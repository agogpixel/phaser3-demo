{"version":3,"file":"js/8799.9dedb21a40e32a3be12e.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/mask/BitmapMask.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/mask/GeometryMask.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/POST_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/PRE_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/RESIZE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GameEvents = require('../../core/events');\r\nvar RenderEvents = require('../../renderer/events');\r\n\r\n/**\r\n * @classdesc\r\n * A Bitmap Mask combines the alpha (opacity) of a masked pixel with the alpha of another pixel.\r\n * Unlike the Geometry Mask, which is a clipping path, a Bitmap Mask behaves like an alpha mask,\r\n * not a clipping path. It is only available when using the WebGL Renderer.\r\n *\r\n * A Bitmap Mask can use any Game Object to determine the alpha of each pixel of the masked Game Object(s).\r\n * For any given point of a masked Game Object's texture, the pixel's alpha will be multiplied by the alpha\r\n * of the pixel at the same position in the Bitmap Mask's Game Object. The color of the pixel from the\r\n * Bitmap Mask doesn't matter.\r\n *\r\n * For example, if a pure blue pixel with an alpha of 0.95 is masked with a pure red pixel with an\r\n * alpha of 0.5, the resulting pixel will be pure blue with an alpha of 0.475. Naturally, this means\r\n * that a pixel in the mask with an alpha of 0 will hide the corresponding pixel in all masked Game Objects\r\n *  A pixel with an alpha of 1 in the masked Game Object will receive the same alpha as the\r\n * corresponding pixel in the mask.\r\n *\r\n * Note: You cannot combine Bitmap Masks and Blend Modes on the same Game Object. You can, however,\r\n * combine Geometry Masks and Blend Modes together.\r\n *\r\n * The Bitmap Mask's location matches the location of its Game Object, not the location of the\r\n * masked objects. Moving or transforming the underlying Game Object will change the mask\r\n * (and affect the visibility of any masked objects), whereas moving or transforming a masked object\r\n * will not affect the mask.\r\n *\r\n * The Bitmap Mask will not render its Game Object by itself. If the Game Object is not in a\r\n * Scene's display list, it will only be used for the mask and its full texture will not be directly\r\n * visible. Adding the underlying Game Object to a Scene will not cause any problems - it will\r\n * render as a normal Game Object and will also serve as a mask.\r\n *\r\n * @class BitmapMask\r\n * @memberof Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene which this Bitmap Mask will be used in.\r\n * @param {Phaser.GameObjects.GameObject} renderable - A renderable Game Object that uses a texture, such as a Sprite.\r\n */\r\nvar BitmapMask = new Class({\r\n\r\n    initialize:\r\n\r\n    function BitmapMask (scene, renderable)\r\n    {\r\n        var renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that this Mask is using.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.11.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * A renderable Game Object that uses a texture, such as a Sprite.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#bitmapMask\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.bitmapMask = renderable;\r\n\r\n        /**\r\n         * The texture used for the masks framebuffer.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#maskTexture\r\n         * @type {WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.maskTexture = null;\r\n\r\n        /**\r\n         * The texture used for the main framebuffer.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#mainTexture\r\n         * @type {WebGLTexture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.mainTexture = null;\r\n\r\n        /**\r\n         * Whether the Bitmap Mask is dirty and needs to be updated.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#dirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = true;\r\n\r\n        /**\r\n         * The framebuffer to which a masked Game Object is rendered.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#mainFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @since 3.0.0\r\n         */\r\n        this.mainFramebuffer = null;\r\n\r\n        /**\r\n         * The framebuffer to which the Bitmap Mask's masking Game Object is rendered.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#maskFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @since 3.0.0\r\n         */\r\n        this.maskFramebuffer = null;\r\n\r\n        /**\r\n         * Whether to invert the masks alpha.\r\n         *\r\n         * If `true`, the alpha of the masking pixel will be inverted before it's multiplied with the masked pixel.\r\n         * Essentially, this means that a masked area will be visible only if the corresponding area in the mask is invisible.\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#invertAlpha\r\n         * @type {boolean}\r\n         * @since 3.1.2\r\n         */\r\n        this.invertAlpha = false;\r\n\r\n        /**\r\n         * Is this mask a stencil mask?\r\n         *\r\n         * @name Phaser.Display.Masks.BitmapMask#isStencil\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.isStencil = false;\r\n\r\n        this.createMask();\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, this.createMask, this);\r\n\r\n        if (renderer)\r\n        {\r\n            renderer.on(RenderEvents.RESIZE, this.createMask, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates the WebGL Texture2D objects and Framebuffers required for this\r\n     * mask. If this mask has already been created, then `clearMask` is called first.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#createMask\r\n     * @since 3.50.0\r\n     */\r\n    createMask: function ()\r\n    {\r\n        var renderer = this.renderer;\r\n\r\n        if (!renderer || !renderer.gl)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.mainTexture)\r\n        {\r\n            this.clearMask();\r\n        }\r\n\r\n        var width = renderer.width;\r\n        var height = renderer.height;\r\n        var pot = ((width & (width - 1)) === 0 && (height & (height - 1)) === 0);\r\n        var gl = renderer.gl;\r\n        var wrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;\r\n        var filter = gl.LINEAR;\r\n\r\n        this.mainTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);\r\n        this.maskTexture = renderer.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);\r\n        this.mainFramebuffer = renderer.createFramebuffer(width, height, this.mainTexture, true);\r\n        this.maskFramebuffer = renderer.createFramebuffer(width, height, this.maskTexture, true);\r\n    },\r\n\r\n    /**\r\n     * Deletes the `mainTexture` and `maskTexture` WebGL Textures and deletes\r\n     * the `mainFramebuffer` and `maskFramebuffer` too, nulling all references.\r\n     *\r\n     * This is called when this mask is destroyed, or if you try to creat a new\r\n     * mask from this object when one is already set.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#clearMask\r\n     * @since 3.50.0\r\n     */\r\n    clearMask: function ()\r\n    {\r\n        var renderer = this.renderer;\r\n\r\n        if (!renderer || !renderer.gl || !this.mainTexture)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer.deleteTexture(this.mainTexture);\r\n        renderer.deleteTexture(this.maskTexture);\r\n        renderer.deleteFramebuffer(this.mainFramebuffer);\r\n        renderer.deleteFramebuffer(this.maskFramebuffer);\r\n\r\n        this.mainTexture = null;\r\n        this.maskTexture = null;\r\n        this.mainFramebuffer = null;\r\n        this.maskFramebuffer = null;\r\n    },\r\n\r\n    /**\r\n     * Sets a new masking Game Object for the Bitmap Mask.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#setBitmap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} renderable - A renderable Game Object that uses a texture, such as a Sprite.\r\n     */\r\n    setBitmap: function (renderable)\r\n    {\r\n        this.bitmapMask = renderable;\r\n    },\r\n\r\n    /**\r\n     * Prepares the WebGL Renderer to render a Game Object with this mask applied.\r\n     *\r\n     * This renders the masking Game Object to the mask framebuffer and switches to the main framebuffer so that the masked Game Object will be rendered to it instead of being rendered directly to the frame.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#preRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The WebGL Renderer to prepare.\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - The masked Game Object which will be drawn.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.\r\n     */\r\n    preRenderWebGL: function (renderer, maskedObject, camera)\r\n    {\r\n        renderer.pipelines.BITMAPMASK_PIPELINE.beginMask(this, maskedObject, camera);\r\n    },\r\n\r\n    /**\r\n     * Finalizes rendering of a masked Game Object.\r\n     *\r\n     * This resets the previously bound framebuffer and switches the WebGL Renderer to the Bitmap Mask Pipeline, which uses a special fragment shader to apply the masking effect.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#postRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The WebGL Renderer to clean up.\r\n     */\r\n    postRenderWebGL: function (renderer, camera)\r\n    {\r\n        renderer.pipelines.BITMAPMASK_PIPELINE.endMask(this, camera);\r\n    },\r\n\r\n    /**\r\n     * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#preRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Canvas Renderer which would be rendered to.\r\n     * @param {Phaser.GameObjects.GameObject} mask - The masked Game Object which would be rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to render to.\r\n     */\r\n    preRenderCanvas: function ()\r\n    {\r\n        // NOOP\r\n    },\r\n\r\n    /**\r\n     * This is a NOOP method. Bitmap Masks are not supported by the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#postRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Canvas Renderer which would be rendered to.\r\n     */\r\n    postRenderCanvas: function ()\r\n    {\r\n        // NOOP\r\n    },\r\n\r\n    /**\r\n     * Destroys this BitmapMask and nulls any references it holds.\r\n     *\r\n     * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,\r\n     * so be sure to call `clearMask` on any Game Object using it, before destroying it.\r\n     *\r\n     * @method Phaser.Display.Masks.BitmapMask#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.clearMask();\r\n\r\n        if (this.renderer)\r\n        {\r\n            this.renderer.off(RenderEvents.RESIZE, this.createMask, this);\r\n        }\r\n        \r\n        this.bitmapMask = null;\r\n        this.prevFramebuffer = null;\r\n        this.renderer = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BitmapMask;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect\r\n * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only\r\n * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).\r\n *\r\n * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)\r\n * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed\r\n * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and\r\n * alpha of the pixel from the Geometry Mask do not matter.\r\n *\r\n * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.\r\n * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility\r\n * of any masked objects), whereas moving or transforming a masked object will not affect the mask.\r\n * You can think of the Geometry Mask (or rather, of its Graphics object) as an invisible curtain placed\r\n * in front of all masked objects which has its own visual properties and, naturally, respects the camera's\r\n * visual properties, but isn't affected by and doesn't follow the masked objects by itself.\r\n *\r\n * @class GeometryMask\r\n * @memberof Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - This parameter is not used.\r\n * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.\r\n */\r\nvar GeometryMask = new Class({\r\n\r\n    initialize:\r\n\r\n    function GeometryMask (scene, graphicsGeometry)\r\n    {\r\n        /**\r\n         * The Graphics object which describes the Geometry Mask.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#geometryMask\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.geometryMask = graphicsGeometry;\r\n\r\n        /**\r\n         * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels\r\n         * drawn to the Geometry Mask.\r\n         *\r\n         * This is a WebGL only feature.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#invertAlpha\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.invertAlpha = false;\r\n\r\n        /**\r\n         * Is this mask a stencil mask?\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#isStencil\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.isStencil = true;\r\n\r\n        /**\r\n         * The current stencil level.\r\n         *\r\n         * @name Phaser.Display.Masks.GeometryMask#level\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.level = 0;\r\n    },\r\n\r\n    /**\r\n     * Sets a new Graphics object for the Geometry Mask.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#setShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics object which will be used for the Geometry Mask.\r\n     *\r\n     * @return {this} This Geometry Mask\r\n     */\r\n    setShape: function (graphicsGeometry)\r\n    {\r\n        this.geometryMask = graphicsGeometry;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `invertAlpha` property of this Geometry Mask.\r\n     *\r\n     * Inverting the alpha essentially flips the way the mask works.\r\n     *\r\n     * This is a WebGL only feature.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#setInvertAlpha\r\n     * @since 3.17.0\r\n     *\r\n     * @param {boolean} [value=true] - Invert the alpha of this mask?\r\n     *\r\n     * @return {this} This Geometry Mask\r\n     */\r\n    setInvertAlpha: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.invertAlpha = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     */\r\n    preRenderWebGL: function (renderer, child, camera)\r\n    {\r\n        var gl = renderer.gl;\r\n\r\n        //  Force flushing before drawing to stencil buffer\r\n        renderer.flush();\r\n\r\n        if (renderer.maskStack.length === 0)\r\n        {\r\n            gl.enable(gl.STENCIL_TEST);\r\n            gl.clear(gl.STENCIL_BUFFER_BIT);\r\n\r\n            renderer.maskCount = 0;\r\n        }\r\n\r\n        if (renderer.currentCameraMask.mask !== this)\r\n        {\r\n            renderer.currentMask.mask = this;\r\n        }\r\n\r\n        renderer.maskStack.push({ mask: this, camera: camera });\r\n\r\n        this.applyStencil(renderer, camera, true);\r\n\r\n        renderer.maskCount++;\r\n    },\r\n\r\n    /**\r\n     * Applies the current stencil mask to the renderer.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#applyStencil\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     * @param {boolean} inc - Is this an INCR stencil or a DECR stencil?\r\n     */\r\n    applyStencil: function (renderer, camera, inc)\r\n    {\r\n        var gl = renderer.gl;\r\n        var geometryMask = this.geometryMask;\r\n        var level = renderer.maskCount;\r\n\r\n        gl.colorMask(false, false, false, false);\r\n\r\n        if (inc)\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level, 0xFF);\r\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\r\n        }\r\n        else\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\r\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\r\n        }\r\n\r\n        //  Write stencil buffer\r\n        geometryMask.renderWebGL(renderer, geometryMask, camera);\r\n\r\n        renderer.flush();\r\n\r\n        gl.colorMask(true, true, true, true);\r\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\r\n\r\n        if (inc)\r\n        {\r\n            if (this.invertAlpha)\r\n            {\r\n                gl.stencilFunc(gl.NOTEQUAL, level + 1, 0xFF);\r\n            }\r\n            else\r\n            {\r\n                gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\r\n            }\r\n        }\r\n        else if (this.invertAlpha)\r\n        {\r\n            gl.stencilFunc(gl.NOTEQUAL, level, 0xFF);\r\n        }\r\n        else\r\n        {\r\n            gl.stencilFunc(gl.EQUAL, level, 0xFF);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw flush.\r\n     */\r\n    postRenderWebGL: function (renderer)\r\n    {\r\n        var gl = renderer.gl;\r\n\r\n        renderer.maskStack.pop();\r\n\r\n        renderer.maskCount--;\r\n\r\n        //  Force flush before disabling stencil test\r\n        renderer.flush();\r\n\r\n        var current = renderer.currentMask;\r\n\r\n        if (renderer.maskStack.length === 0)\r\n        {\r\n            //  If this is the only mask in the stack, flush and disable\r\n            current.mask = null;\r\n\r\n            gl.disable(gl.STENCIL_TEST);\r\n        }\r\n        else\r\n        {\r\n            var prev = renderer.maskStack[renderer.maskStack.length - 1];\r\n\r\n            prev.mask.applyStencil(renderer, prev.camera, false);\r\n\r\n            if (renderer.currentCameraMask.mask !== prev.mask)\r\n            {\r\n                current.mask = prev.mask;\r\n                current.camera = prev.camera;\r\n            }\r\n            else\r\n            {\r\n                current.mask = null;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance to set the clipping path on.\r\n     * @param {Phaser.GameObjects.GameObject} mask - The Game Object being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n     */\r\n    preRenderCanvas: function (renderer, mask, camera)\r\n    {\r\n        var geometryMask = this.geometryMask;\r\n\r\n        renderer.currentContext.save();\r\n\r\n        geometryMask.renderCanvas(renderer, geometryMask, camera, null, null, true);\r\n\r\n        renderer.currentContext.clip();\r\n    },\r\n\r\n    /**\r\n     * Restore the canvas context's previous clipping path, thus turning off the mask for it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance being restored.\r\n     */\r\n    postRenderCanvas: function (renderer)\r\n    {\r\n        renderer.currentContext.restore();\r\n    },\r\n\r\n    /**\r\n     * Destroys this GeometryMask and nulls any references it holds.\r\n     *\r\n     * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,\r\n     * so be sure to call `clearMask` on any Game Object using it, before destroying it.\r\n     *\r\n     * @method Phaser.Display.Masks.GeometryMask#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.geometryMask = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = GeometryMask;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Post-Render Event.\r\n *\r\n * This event is dispatched by the Renderer when all rendering, for all cameras in all Scenes,\r\n * has completed, but before any pending snap shots have been taken.\r\n *\r\n * @event Phaser.Renderer.Events#POST_RENDER\r\n * @since 3.50.0\r\n */\r\nmodule.exports = 'postrender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Pre-Render Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer. This happens right at the start of the render\r\n * process, after the context has been cleared, the scissors enabled (WebGL only) and everything has been\r\n * reset ready for the render.\r\n *\r\n * @event Phaser.Renderer.Events#PRE_RENDER\r\n * @since 3.50.0\r\n */\r\nmodule.exports = 'prerender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Render Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer for every camera in every Scene.\r\n *\r\n * It is dispatched before any of the children in the Scene have been rendered.\r\n *\r\n * @event Phaser.Renderer.Events#RENDER\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene being rendered.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered.\r\n */\r\nmodule.exports = 'render';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Renderer Resize Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer when it is resized, usually as a result\r\n * of the Scale Manager resizing.\r\n *\r\n * @event Phaser.Renderer.Events#RESIZE\r\n * @since 3.50.0\r\n *\r\n * @param {number} width - The new width of the renderer.\r\n * @param {number} height - The new height of the renderer.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    POST_RENDER: require('./POST_RENDER_EVENT'),\r\n    PRE_RENDER: require('./PRE_RENDER_EVENT'),\r\n    RENDER: require('./RENDER_EVENT'),\r\n    RESIZE: require('./RESIZE_EVENT')\r\n\r\n};\r\n"],"names":["Class","GameEvents","RenderEvents","BitmapMask","initialize","scene","renderable","renderer","sys","this","bitmapMask","maskTexture","mainTexture","dirty","mainFramebuffer","maskFramebuffer","invertAlpha","isStencil","createMask","game","events","on","CONTEXT_RESTORED","RESIZE","gl","clearMask","width","height","pot","wrap","REPEAT","CLAMP_TO_EDGE","filter","LINEAR","createTexture2D","RGBA","createFramebuffer","deleteTexture","deleteFramebuffer","setBitmap","preRenderWebGL","maskedObject","camera","pipelines","BITMAPMASK_PIPELINE","beginMask","postRenderWebGL","endMask","preRenderCanvas","postRenderCanvas","destroy","off","prevFramebuffer","module","exports","GeometryMask","graphicsGeometry","geometryMask","level","setShape","setInvertAlpha","value","undefined","child","flush","maskStack","length","enable","STENCIL_TEST","clear","STENCIL_BUFFER_BIT","maskCount","currentCameraMask","mask","currentMask","push","applyStencil","inc","colorMask","stencilFunc","EQUAL","stencilOp","KEEP","INCR","DECR","renderWebGL","NOTEQUAL","pop","current","disable","prev","currentContext","save","renderCanvas","clip","restore","POST_RENDER","PRE_RENDER","RENDER"],"sourceRoot":""}