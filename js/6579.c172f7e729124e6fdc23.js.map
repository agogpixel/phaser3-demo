{"version":3,"file":"js/6579.c172f7e729124e6fdc23.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/AnimationState.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CustomMap = require('../structs/Map');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar Events = require('./events');\r\nvar Animation = require('./Animation');\r\n\r\n/**\r\n * @classdesc\r\n * The Animation State Component.\r\n *\r\n * This component provides features to apply animations to Game Objects. It is responsible for\r\n * loading, queuing animations for later playback, mixing between animations and setting\r\n * the current animation frame to the Game Object that owns this component.\r\n *\r\n * This component lives as an instance within any Game Object that has it defined, such as Sprites.\r\n *\r\n * You can access its properties and methods via the `anims` property, i.e. `Sprite.anims`.\r\n *\r\n * As well as playing animations stored in the global Animation Manager, this component\r\n * can also create animations that are stored locally within it. See the `create` method\r\n * for more details.\r\n *\r\n * Prior to Phaser 3.50 this component was called just `Animation` and lived in the\r\n * `Phaser.GameObjects.Components` namespace. It was renamed to `AnimationState`\r\n * in 3.50 to help better identify its true purpose when browsing the documentation.\r\n *\r\n * @class AnimationState\r\n * @memberof Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} parent - The Game Object to which this animation component belongs.\r\n */\r\nvar AnimationState = new Class({\r\n\r\n    initialize:\r\n\r\n    function AnimationState (parent)\r\n    {\r\n        /**\r\n         * The Game Object to which this animation component belongs.\r\n         *\r\n         * You can typically access this component from the Game Object\r\n         * via the `this.anims` property.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#parent\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * A reference to the global Animation Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#animationManager\r\n         * @type {Phaser.Animations.AnimationManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.animationManager = parent.scene.sys.anims;\r\n\r\n        this.animationManager.on(Events.REMOVE_ANIMATION, this.globalRemove, this);\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @protected\r\n         * @since 3.50.0\r\n         */\r\n        this.textureManager = this.animationManager.textureManager;\r\n\r\n        /**\r\n         * The Animations stored locally in this Animation component.\r\n         *\r\n         * Do not modify the contents of this Map directly, instead use the\r\n         * `add`, `create` and `remove` methods of this class instead.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#anims\r\n         * @type {Phaser.Structs.Map.<string, Phaser.Animations.Animation>}\r\n         * @protected\r\n         * @since 3.50.0\r\n         */\r\n        this.anims = null;\r\n\r\n        /**\r\n         * Is an animation currently playing or not?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#isPlaying\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isPlaying = false;\r\n\r\n        /**\r\n         * Has the current animation started playing, or is it waiting for a delay to expire?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#hasStarted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.hasStarted = false;\r\n\r\n        /**\r\n         * The current Animation loaded into this Animation component.\r\n         *\r\n         * Will by `null` if no animation is yet loaded.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#currentAnim\r\n         * @type {?Phaser.Animations.Animation}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentAnim = null;\r\n\r\n        /**\r\n         * The current AnimationFrame being displayed by this Animation component.\r\n         *\r\n         * Will by `null` if no animation is yet loaded.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#currentFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentFrame = null;\r\n\r\n        /**\r\n         * The key, instance, or config of the next Animation to be loaded into this Animation component\r\n         * when the current animation completes.\r\n         *\r\n         * Will by `null` if no animation has been queued.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#nextAnim\r\n         * @type {?(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)}\r\n         * @default null\r\n         * @since 3.16.0\r\n         */\r\n        this.nextAnim = null;\r\n\r\n        /**\r\n         * A queue of Animations to be loaded into this Animation component when the current animation completes.\r\n         *\r\n         * Populate this queue via the `chain` method.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#nextAnimsQueue\r\n         * @type {array}\r\n         * @since 3.24.0\r\n         */\r\n        this.nextAnimsQueue = [];\r\n\r\n        /**\r\n         * The Time Scale factor.\r\n         *\r\n         * You can adjust this value to modify the passage of time for the animation that is currently\r\n         * playing. For example, setting it to 2 will make the animation play twice as fast. Or setting\r\n         * it to 0.5 will slow the animation down.\r\n         *\r\n         * You can change this value at run-time, or set it via the `PlayAnimationConfig`.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_timeScale`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * The frame rate of playback, of the current animation, in frames per second.\r\n         *\r\n         * This value is set when a new animation is loaded into this component and should\r\n         * be treated as read-only, as changing it once playback has started will not alter\r\n         * the animation. To change the frame rate, provide a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#frameRate\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.frameRate = 0;\r\n\r\n        /**\r\n         * The duration of the current animation, in milliseconds.\r\n         *\r\n         * This value is set when a new animation is loaded into this component and should\r\n         * be treated as read-only, as changing it once playback has started will not alter\r\n         * the animation. To change the duration, provide a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The number of milliseconds per frame, not including frame specific modifiers that may be present in the\r\n         * Animation data.\r\n         *\r\n         * This value is calculated when a new animation is loaded into this component and should\r\n         * be treated as read-only. Changing it will not alter playback speed.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#msPerFrame\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.msPerFrame = 0;\r\n\r\n        /**\r\n         * Skip frames if the time lags, or always advanced anyway?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#skipMissedFrames\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.skipMissedFrames = true;\r\n\r\n        /**\r\n         * The delay before starting playback of the current animation, in milliseconds.\r\n         *\r\n         * This value is set when a new animation is loaded into this component and should\r\n         * be treated as read-only, as changing it once playback has started will not alter\r\n         * the animation. To change the delay, provide a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_delay`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#delay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.50.0\r\n         */\r\n        this.delay = 0;\r\n\r\n        /**\r\n         * The number of times to repeat playback of the current animation.\r\n         *\r\n         * If -1, it means the animation will repeat forever.\r\n         *\r\n         * This value is set when a new animation is loaded into this component and should\r\n         * be treated as read-only, as changing it once playback has started will not alter\r\n         * the animation. To change the number of repeats, provide a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_repeat`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#repeat\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.50.0\r\n         */\r\n        this.repeat = 0;\r\n\r\n        /**\r\n         * The number of milliseconds to wait before starting the repeat playback of the current animation.\r\n         *\r\n         * This value is set when a new animation is loaded into this component, but can also be modified\r\n         * at run-time.\r\n         *\r\n         * You can change the repeat delay by providing a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_repeatDelay`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#repeatDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeatDelay = 0;\r\n\r\n        /**\r\n         * Should the current animation yoyo? An animation that yoyos will play in reverse, from the end\r\n         * to the start, before then repeating or completing. An animation that does not yoyo will just\r\n         * play from the start to the end.\r\n         *\r\n         * This value is set when a new animation is loaded into this component, but can also be modified\r\n         * at run-time.\r\n         *\r\n         * You can change the yoyo by providing a new value in the `PlayAnimationConfig` object.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_yoyo`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#yoyo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.yoyo = false;\r\n\r\n        /**\r\n         * Should the GameObject's `visible` property be set to `true` when the animation starts to play?\r\n         *\r\n         * This will happen _after_ any delay that may have been set.\r\n         *\r\n         * This value is set when a new animation is loaded into this component, but can also be modified\r\n         * at run-time, assuming the animation is currently delayed.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#showOnStart\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.showOnStart = false;\r\n\r\n        /**\r\n         * Should the GameObject's `visible` property be set to `false` when the animation completes?\r\n         *\r\n         * This value is set when a new animation is loaded into this component, but can also be modified\r\n         * at run-time, assuming the animation is still actively playing.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#hideOnComplete\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.hideOnComplete = false;\r\n\r\n        /**\r\n         * Is the playhead moving forwards (`true`) or in reverse (`false`) ?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#forward\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.forward = true;\r\n\r\n        /**\r\n         * An internal trigger that tells the component if it should plays the animation\r\n         * in reverse mode ('true') or not ('false'). This is used because `forward` can\r\n         * be changed by the `yoyo` feature.\r\n         *\r\n         * Prior to Phaser 3.50 this property was private and called `_reverse`.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#inReverse\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.inReverse = false;\r\n\r\n        /**\r\n         * Internal time overflow accumulator.\r\n         *\r\n         * This has the `delta` time added to it as part of the `update` step.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#accumulator\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accumulator = 0;\r\n\r\n        /**\r\n         * The time point at which the next animation frame will change.\r\n         *\r\n         * This value is compared against the `accumulator` as part of the `update` step.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#nextTick\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.nextTick = 0;\r\n\r\n        /**\r\n         * A counter keeping track of how much delay time, in milliseconds, is left before playback begins.\r\n         *\r\n         * This is set via the `playAfterDelay` method, although it can be modified at run-time\r\n         * if required, as long as the animation has not already started playing.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#delayCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.50.0\r\n         */\r\n        this.delayCounter = 0;\r\n\r\n        /**\r\n         * A counter that keeps track of how many repeats are left to run.\r\n         *\r\n         * This value is set when a new animation is loaded into this component, but can also be modified\r\n         * at run-time.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#repeatCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeatCounter = 0;\r\n\r\n        /**\r\n         * An internal flag keeping track of pending repeats.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#pendingRepeat\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.pendingRepeat = false;\r\n\r\n        /**\r\n         * Is the Animation paused?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#_paused\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._paused = false;\r\n\r\n        /**\r\n         * Was the animation previously playing before being paused?\r\n         *\r\n         * @name Phaser.Animations.AnimationState#_wasPlaying\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._wasPlaying = false;\r\n\r\n        /**\r\n         * Internal property tracking if this Animation is waiting to stop.\r\n         *\r\n         * 0 = No\r\n         * 1 = Waiting for ms to pass\r\n         * 2 = Waiting for repeat\r\n         * 3 = Waiting for specific frame\r\n         *\r\n         * @name Phaser.Animations.AnimationState#_pendingStop\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._pendingStop = 0;\r\n\r\n        /**\r\n         * Internal property used by _pendingStop.\r\n         *\r\n         * @name Phaser.Animations.AnimationState#_pendingStopValue\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._pendingStopValue;\r\n    },\r\n\r\n    /**\r\n     * Sets an animation, or an array of animations, to be played in the future, after the current one completes or stops.\r\n     *\r\n     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,\r\n     * or have one of the `stop` methods called.\r\n     *\r\n     * An animation set to repeat forever will never enter a completed state unless stopped.\r\n     *\r\n     * You can chain a new animation at any point, including before the current one starts playing, during it, or when it ends (via its `animationcomplete` event).\r\n     *\r\n     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained animations without impacting the global animation they're playing.\r\n     *\r\n     * Call this method with no arguments to reset all currently chained animations.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#chain\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig|string[]|Phaser.Animations.Animation[]|Phaser.Types.Animations.PlayAnimationConfig[])} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    chain: function (key)\r\n    {\r\n        var parent = this.parent;\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.nextAnimsQueue.length = 0;\r\n            this.nextAnim = null;\r\n\r\n            return parent;\r\n        }\r\n\r\n        if (!Array.isArray(key))\r\n        {\r\n            key = [ key ];\r\n        }\r\n\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            var anim = key[i];\r\n\r\n            if (this.nextAnim === null)\r\n            {\r\n                this.nextAnim = anim;\r\n            }\r\n            else\r\n            {\r\n                this.nextAnimsQueue.push(anim);\r\n            }\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Returns the key of the animation currently loaded into this component.\r\n     *\r\n     * Prior to Phaser 3.50 this method was called `getCurrentKey`.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#getName\r\n     * @since 3.50.0\r\n     *\r\n     * @return {string} The key of the Animation currently loaded into this component, or an empty string if none loaded.\r\n     */\r\n    getName: function ()\r\n    {\r\n        return (this.currentAnim) ? this.currentAnim.key : '';\r\n    },\r\n\r\n    /**\r\n     * Returns the key of the animation frame currently displayed by this component.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#getFrameName\r\n     * @since 3.50.0\r\n     *\r\n     * @return {string} The key of the Animation Frame currently displayed by this component, or an empty string if no animation has been loaded.\r\n     */\r\n    getFrameName: function ()\r\n    {\r\n        return (this.currentFrame) ? this.currentFrame.textureFrame : '';\r\n    },\r\n\r\n    /**\r\n     * Internal method used to load an animation into this component.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#load\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or a `PlayAnimationConfig` object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    load: function (key)\r\n    {\r\n        if (this.isPlaying)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        var manager = this.animationManager;\r\n        var animKey = (typeof key === 'string') ? key : GetFastValue(key, 'key', null);\r\n\r\n        //  Get the animation, first from the local map and, if not found, from the Animation Manager\r\n        var anim = (this.exists(animKey)) ? this.get(animKey) : manager.get(animKey);\r\n\r\n        if (!anim)\r\n        {\r\n            console.warn('Missing animation: ' + animKey);\r\n        }\r\n        else\r\n        {\r\n            this.currentAnim = anim;\r\n\r\n            //  And now override the animation values, if set in the config.\r\n\r\n            var totalFrames = anim.getTotalFrames();\r\n            var frameRate = GetFastValue(key, 'frameRate', anim.frameRate);\r\n            var duration = GetFastValue(key, 'duration', anim.duration);\r\n\r\n            anim.calculateDuration(this, totalFrames, duration, frameRate);\r\n\r\n            this.delay = GetFastValue(key, 'delay', anim.delay);\r\n            this.repeat = GetFastValue(key, 'repeat', anim.repeat);\r\n            this.repeatDelay = GetFastValue(key, 'repeatDelay', anim.repeatDelay);\r\n            this.yoyo = GetFastValue(key, 'yoyo', anim.yoyo);\r\n            this.showOnStart = GetFastValue(key, 'showOnStart', anim.showOnStart);\r\n            this.hideOnComplete = GetFastValue(key, 'hideOnComplete', anim.hideOnComplete);\r\n            this.skipMissedFrames = GetFastValue(key, 'skipMissedFrames', anim.skipMissedFrames);\r\n\r\n            this.timeScale = GetFastValue(key, 'timeScale', this.timeScale);\r\n\r\n            var startFrame = GetFastValue(key, 'startFrame', 0);\r\n\r\n            if (startFrame > anim.getTotalFrames())\r\n            {\r\n                startFrame = 0;\r\n            }\r\n\r\n            var frame = anim.frames[startFrame];\r\n\r\n            if (startFrame === 0 && !this.forward)\r\n            {\r\n                frame = anim.getLastFrame();\r\n            }\r\n\r\n            this.currentFrame = frame;\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Pause the current animation and set the `isPlaying` property to `false`.\r\n     * You can optionally pause it at a specific frame.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} [atFrame] - An optional frame to set after pausing the animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    pause: function (atFrame)\r\n    {\r\n        if (!this._paused)\r\n        {\r\n            this._paused = true;\r\n            this._wasPlaying = this.isPlaying;\r\n            this.isPlaying = false;\r\n        }\r\n\r\n        if (atFrame !== undefined)\r\n        {\r\n            this.setCurrentFrame(atFrame);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Resumes playback of a paused animation and sets the `isPlaying` property to `true`.\r\n     * You can optionally tell it to start playback from a specific frame.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} [fromFrame] - An optional frame to set before restarting playback.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    resume: function (fromFrame)\r\n    {\r\n        if (this._paused)\r\n        {\r\n            this._paused = false;\r\n            this.isPlaying = this._wasPlaying;\r\n        }\r\n\r\n        if (fromFrame !== undefined)\r\n        {\r\n            this.setCurrentFrame(fromFrame);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.\r\n     *\r\n     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.\r\n     *\r\n     * If an animation is already running and a new animation is given to this method, it will wait for\r\n     * the given delay before starting the new animation.\r\n     *\r\n     * If no animation is currently running, the given one begins after the delay.\r\n     *\r\n     * Prior to Phaser 3.50 this method was called 'delayedPlay' and the parameters were in the reverse order.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#playAfterDelay\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {number} delay - The delay, in milliseconds, to wait before starting the animation playing.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    playAfterDelay: function (key, delay)\r\n    {\r\n        if (!this.isPlaying)\r\n        {\r\n            this.delayCounter = delay;\r\n\r\n            this.play(key, true);\r\n        }\r\n        else\r\n        {\r\n            //  If we've got a nextAnim, move it to the queue\r\n            var nextAnim = this.nextAnim;\r\n            var queue = this.nextAnimsQueue;\r\n\r\n            if (nextAnim)\r\n            {\r\n                queue.unshift(nextAnim);\r\n            }\r\n\r\n            this.nextAnim = key;\r\n\r\n            this._pendingStop = 1;\r\n            this._pendingStopValue = delay;\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback\r\n     * of the given animation.\r\n     *\r\n     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an\r\n     * idle animation to a walking animation, by making them blend smoothly into each other.\r\n     *\r\n     * If no animation is currently running, the given one will start immediately.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#playAfterRepeat\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before the next one starts?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    playAfterRepeat: function (key, repeatCount)\r\n    {\r\n        if (repeatCount === undefined) { repeatCount = 1; }\r\n\r\n        if (!this.isPlaying)\r\n        {\r\n            this.play(key);\r\n        }\r\n        else\r\n        {\r\n            //  If we've got a nextAnim, move it to the queue\r\n            var nextAnim = this.nextAnim;\r\n            var queue = this.nextAnimsQueue;\r\n\r\n            if (nextAnim)\r\n            {\r\n                queue.unshift(nextAnim);\r\n            }\r\n\r\n            if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter)\r\n            {\r\n                repeatCount = this.repeatCounter;\r\n            }\r\n\r\n            this.nextAnim = key;\r\n\r\n            this._pendingStop = 2;\r\n            this._pendingStopValue = repeatCount;\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation on this Sprite.\r\n     *\r\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\r\n     *\r\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\r\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\r\n     *\r\n     * The following code shows how to create a global repeating animation. The animation will be created\r\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\r\n     *\r\n     * ```javascript\r\n     * var config = {\r\n     *     key: 'run',\r\n     *     frames: 'muybridge',\r\n     *     frameRate: 15,\r\n     *     repeat: -1\r\n     * };\r\n     *\r\n     * //  This code should be run from within a Scene:\r\n     * this.anims.create(config);\r\n     * ```\r\n     *\r\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\r\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\r\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\r\n     *\r\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).play('run');\r\n     * ```\r\n     *\r\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\r\n     * object instead:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });\r\n     * ```\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\r\n     * have conflicting keys.\r\n     *\r\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\r\n     *\r\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#play\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    play: function (key, ignoreIfPlaying)\r\n    {\r\n        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }\r\n\r\n        var currentAnim = this.currentAnim;\r\n        var parent = this.parent;\r\n\r\n        //  Must be either an Animation instance, or a PlayAnimationConfig object\r\n        var animKey = (typeof key === 'string') ? key : key.key;\r\n\r\n        if (ignoreIfPlaying && this.isPlaying && currentAnim.key === animKey)\r\n        {\r\n            return parent;\r\n        }\r\n\r\n        //  Are we mixing?\r\n        if (currentAnim && this.isPlaying)\r\n        {\r\n            var mix = this.animationManager.getMix(currentAnim.key, key);\r\n\r\n            if (mix > 0)\r\n            {\r\n                return this.playAfterDelay(key, mix);\r\n            }\r\n        }\r\n\r\n        this.forward = true;\r\n        this.inReverse = false;\r\n\r\n        this._paused = false;\r\n        this._wasPlaying = true;\r\n\r\n        return this.startAnimation(key);\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation on this Sprite, in reverse.\r\n     *\r\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\r\n     *\r\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\r\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\r\n     *\r\n     * The following code shows how to create a global repeating animation. The animation will be created\r\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\r\n     *\r\n     * ```javascript\r\n     * var config = {\r\n     *     key: 'run',\r\n     *     frames: 'muybridge',\r\n     *     frameRate: 15,\r\n     *     repeat: -1\r\n     * };\r\n     *\r\n     * //  This code should be run from within a Scene:\r\n     * this.anims.create(config);\r\n     * ```\r\n     *\r\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\r\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\r\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\r\n     *\r\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).playReverse('run');\r\n     * ```\r\n     *\r\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\r\n     * object instead:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });\r\n     * ```\r\n     *\r\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\r\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\r\n     * search the global Animation Manager and look for it there.\r\n     *\r\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\r\n     * have conflicting keys.\r\n     *\r\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\r\n     *\r\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#playReverse\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.12.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    playReverse: function (key, ignoreIfPlaying)\r\n    {\r\n        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }\r\n\r\n        //  Must be either an Animation instance, or a PlayAnimationConfig object\r\n        var animKey = (typeof key === 'string') ? key : key.key;\r\n\r\n        if (ignoreIfPlaying && this.isPlaying && this.currentAnim.key === animKey)\r\n        {\r\n            return this.parent;\r\n        }\r\n\r\n        this.forward = false;\r\n        this.inReverse = true;\r\n\r\n        this._paused = false;\r\n        this._wasPlaying = true;\r\n\r\n        return this.startAnimation(key);\r\n    },\r\n\r\n    /**\r\n     * Load the animation based on the key and set-up all of the internal values\r\n     * needed for playback to start. If there is no delay, it will also fire the start events.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#startAnimation\r\n     * @fires Phaser.Animations.Events#ANIMATION_START\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or a `PlayAnimationConfig` object.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    startAnimation: function (key)\r\n    {\r\n        this.load(key);\r\n\r\n        var anim = this.currentAnim;\r\n        var gameObject = this.parent;\r\n\r\n        if (!anim)\r\n        {\r\n            return gameObject;\r\n        }\r\n\r\n        //  Should give us 9,007,199,254,740,991 safe repeats\r\n        this.repeatCounter = (this.repeat === -1) ? Number.MAX_VALUE : this.repeat;\r\n\r\n        anim.getFirstTick(this);\r\n\r\n        this.isPlaying = true;\r\n        this.pendingRepeat = false;\r\n        this.hasStarted = false;\r\n\r\n        this._pendingStop = 0;\r\n        this._pendingStopValue = 0;\r\n        this._paused = false;\r\n\r\n        //  Add any delay the animation itself may have had as well\r\n        this.delayCounter += this.delay;\r\n\r\n        if (this.delayCounter === 0)\r\n        {\r\n            this.handleStart();\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Handles the start of an animation playback.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#handleStart\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    handleStart: function ()\r\n    {\r\n        if (this.showOnStart)\r\n        {\r\n            this.parent.setVisible(true);\r\n        }\r\n\r\n        this.setCurrentFrame(this.currentFrame);\r\n\r\n        this.hasStarted = true;\r\n\r\n        this.emitEvents(Events.ANIMATION_START);\r\n    },\r\n\r\n    /**\r\n     * Handles the repeat of an animation.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#handleRepeat\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    handleRepeat: function ()\r\n    {\r\n        this.pendingRepeat = false;\r\n\r\n        this.emitEvents(Events.ANIMATION_REPEAT);\r\n    },\r\n\r\n    /**\r\n     * Handles the stop of an animation playback.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#handleStop\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    handleStop: function ()\r\n    {\r\n        this._pendingStop = 0;\r\n\r\n        this.isPlaying = false;\r\n\r\n        this.emitEvents(Events.ANIMATION_STOP);\r\n    },\r\n\r\n    /**\r\n     * Handles the completion of an animation playback.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#handleComplete\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    handleComplete: function ()\r\n    {\r\n        this._pendingStop = 0;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.hideOnComplete)\r\n        {\r\n            this.parent.setVisible(false);\r\n        }\r\n\r\n        this.emitEvents(Events.ANIMATION_COMPLETE, Events.ANIMATION_COMPLETE_KEY);\r\n    },\r\n\r\n    /**\r\n     * Fires the given animation event.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#emitEvents\r\n     * @private\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} event - The Animation Event to dispatch.\r\n     */\r\n    emitEvents: function (event, keyEvent)\r\n    {\r\n        var anim = this.currentAnim;\r\n        var frame = this.currentFrame;\r\n        var gameObject = this.parent;\r\n\r\n        var frameKey = frame.textureFrame;\r\n\r\n        gameObject.emit(event, anim, frame, gameObject, frameKey);\r\n\r\n        if (keyEvent)\r\n        {\r\n            gameObject.emit(keyEvent + anim.key, anim, frame, gameObject, frameKey);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reverse the Animation that is already playing on the Game Object.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#reverse\r\n     * @since 3.12.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    reverse: function ()\r\n    {\r\n        if (this.isPlaying)\r\n        {\r\n            this.inReverse = !this.inReverse;\r\n\r\n            this.forward = !this.forward;\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Returns a value between 0 and 1 indicating how far this animation is through, ignoring repeats and yoyos.\r\n     *\r\n     * The value is based on the current frame and how far that is in the animation, it is not based on\r\n     * the duration of the animation.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#getProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The progress of the current animation in frames, between 0 and 1.\r\n     */\r\n    getProgress: function ()\r\n    {\r\n        var frame = this.currentFrame;\r\n\r\n        if (!frame)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        var p = frame.progress;\r\n\r\n        if (this.inReverse)\r\n        {\r\n            p *= -1;\r\n        }\r\n\r\n        return p;\r\n    },\r\n\r\n    /**\r\n     * Takes a value between 0 and 1 and uses it to set how far this animation is through playback.\r\n     *\r\n     * Does not factor in repeats or yoyos, but does handle playing forwards or backwards.\r\n     *\r\n     * The value is based on the current frame and how far that is in the animation, it is not based on\r\n     * the duration of the animation.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#setProgress\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [value=0] - The progress value, between 0 and 1.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    setProgress: function (value)\r\n    {\r\n        if (!this.forward)\r\n        {\r\n            value = 1 - value;\r\n        }\r\n\r\n        this.setCurrentFrame(this.currentAnim.getFrameByProgress(value));\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of times that the animation should repeat after its first play through.\r\n     * For example, if repeat is 1, the animation will play a total of twice: the initial play plus 1 repeat.\r\n     *\r\n     * To repeat indefinitely, use -1.\r\n     * The value should always be an integer.\r\n     *\r\n     * Calling this method only works if the animation is already running. Otherwise, any\r\n     * value specified here will be overwritten when the next animation loads in. To avoid this,\r\n     * use the `repeat` property of the `PlayAnimationConfig` object instead.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#setRepeat\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} value - The number of times that the animation should repeat.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    setRepeat: function (value)\r\n    {\r\n        this.repeatCounter = (value === -1) ? Number.MAX_VALUE : value;\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Handle the removal of an animation from the Animation Manager.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#globalRemove\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} [key] - The key of the removed Animation.\r\n     * @param {Phaser.Animations.Animation} [animation] - The removed Animation.\r\n     */\r\n    globalRemove: function (key, animation)\r\n    {\r\n        if (animation === undefined) { animation = this.currentAnim; }\r\n\r\n        if (this.isPlaying && animation.key === this.currentAnim.key)\r\n        {\r\n            this.stop();\r\n\r\n            this.setCurrentFrame(this.currentAnim.frames[0]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Restarts the current animation from its beginning.\r\n     *\r\n     * You can optionally reset the delay and repeat counters as well.\r\n     *\r\n     * Calling this will fire the `ANIMATION_RESTART` event immediately.\r\n     *\r\n     * If you `includeDelay` then it will also fire the `ANIMATION_START` event once\r\n     * the delay has expired, otherwise, playback will just begin immediately.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#restart\r\n     * @fires Phaser.Animations.Events#ANIMATION_RESTART\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [includeDelay=false] - Whether to include the delay value of the animation when restarting.\r\n     * @param {boolean} [resetRepeats=false] - Whether to reset the repeat counter or not?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    restart: function (includeDelay, resetRepeats)\r\n    {\r\n        if (includeDelay === undefined) { includeDelay = false; }\r\n        if (resetRepeats === undefined) { resetRepeats = false; }\r\n\r\n        var anim = this.currentAnim;\r\n        var gameObject = this.parent;\r\n\r\n        if (!anim)\r\n        {\r\n            return gameObject;\r\n        }\r\n\r\n        if (resetRepeats)\r\n        {\r\n            this.repeatCounter = (this.repeat === -1) ? Number.MAX_VALUE : this.repeat;\r\n        }\r\n\r\n        anim.getFirstTick(this);\r\n\r\n        this.emitEvents(Events.ANIMATION_RESTART);\r\n\r\n        this.isPlaying = true;\r\n        this.pendingRepeat = false;\r\n\r\n        //  Set this to `true` if there is no delay to include, so it skips the `hasStarted` check in `update`.\r\n        this.hasStarted = !includeDelay;\r\n\r\n        this._pendingStop = 0;\r\n        this._pendingStopValue = 0;\r\n        this._paused = false;\r\n\r\n        this.setCurrentFrame(anim.frames[0]);\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * The current animation has completed. This dispatches the `ANIMATION_COMPLETE` event.\r\n     *\r\n     * This method is called by the Animation instance and should not usually be invoked directly.\r\n     *\r\n     * If no animation is loaded, no events will be dispatched.\r\n     *\r\n     * If another animation has been queued for playback, it will be started after the events fire.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#complete\r\n     * @fires Phaser.Animations.Events#ANIMATION_COMPLETE\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    complete: function ()\r\n    {\r\n        this._pendingStop = 0;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.currentAnim)\r\n        {\r\n            this.handleComplete();\r\n        }\r\n\r\n        if (this.nextAnim)\r\n        {\r\n            var key = this.nextAnim;\r\n\r\n            this.nextAnim = (this.nextAnimsQueue.length > 0) ? this.nextAnimsQueue.shift() : null;\r\n\r\n            this.play(key);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#stop\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this._pendingStop = 0;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.currentAnim)\r\n        {\r\n            this.handleStop();\r\n        }\r\n\r\n        if (this.nextAnim)\r\n        {\r\n            var key = this.nextAnim;\r\n\r\n            this.nextAnim = this.nextAnimsQueue.shift();\r\n\r\n            this.play(key);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#stopAfterDelay\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} delay - The number of milliseconds to wait before stopping this animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    stopAfterDelay: function (delay)\r\n    {\r\n        this._pendingStop = 1;\r\n        this._pendingStopValue = delay;\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing when it next repeats.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * Prior to Phaser 3.50 this method was called `stopOnRepeat` and had no parameters.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#stopAfterRepeat\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before stopping?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    stopAfterRepeat: function (repeatCount)\r\n    {\r\n        if (repeatCount === undefined) { repeatCount = 1; }\r\n\r\n        if (this.repeatCounter !== -1 && repeatCount > this.repeatCounter)\r\n        {\r\n            repeatCount = this.repeatCounter;\r\n        }\r\n\r\n        this._pendingStop = 2;\r\n        this._pendingStopValue = repeatCount;\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Stops the current animation from playing when it next sets the given frame.\r\n     * If this frame doesn't exist within the animation it will not stop it from playing.\r\n     *\r\n     * It then dispatches the `ANIMATION_STOP` event.\r\n     *\r\n     * If no animation is running, no events will be dispatched.\r\n     *\r\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\r\n     * when the current one stops.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#stopOnFrame\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\r\n     */\r\n    stopOnFrame: function (frame)\r\n    {\r\n        this._pendingStop = 3;\r\n        this._pendingStopValue = frame;\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of frames in this animation, or returns zero if no\r\n     * animation has been loaded.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#getTotalFrames\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The total number of frames in the current animation, or zero if no animation has been loaded.\r\n     */\r\n    getTotalFrames: function ()\r\n    {\r\n        return (this.currentAnim) ? this.currentAnim.getTotalFrames() : 0;\r\n    },\r\n\r\n    /**\r\n     * The internal update loop for the AnimationState Component.\r\n     *\r\n     * This is called automatically by the `Sprite.preUpdate` method.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        var anim = this.currentAnim;\r\n\r\n        if (!this.isPlaying || !anim || anim.paused)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.accumulator += delta * this.timeScale;\r\n\r\n        if (this._pendingStop === 1)\r\n        {\r\n            this._pendingStopValue -= delta;\r\n\r\n            if (this._pendingStopValue <= 0)\r\n            {\r\n                return this.stop();\r\n            }\r\n        }\r\n\r\n        if (!this.hasStarted)\r\n        {\r\n            if (this.accumulator >= this.delayCounter)\r\n            {\r\n                this.accumulator -= this.delayCounter;\r\n\r\n                this.handleStart();\r\n            }\r\n        }\r\n        else if (this.accumulator >= this.nextTick)\r\n        {\r\n            //  Process one frame advance as standard\r\n\r\n            if (this.forward)\r\n            {\r\n                anim.nextFrame(this);\r\n            }\r\n            else\r\n            {\r\n                anim.previousFrame(this);\r\n            }\r\n\r\n            //  And only do more if we're skipping frames and have time left\r\n            if (this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick)\r\n            {\r\n                var safetyNet = 0;\r\n\r\n                do\r\n                {\r\n                    if (this.forward)\r\n                    {\r\n                        anim.nextFrame(this);\r\n                    }\r\n                    else\r\n                    {\r\n                        anim.previousFrame(this);\r\n                    }\r\n\r\n                    safetyNet++;\r\n\r\n                } while (this.isPlaying && this.accumulator > this.nextTick && safetyNet < 60);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the given Animation Frame as being the current frame\r\n     * and applies it to the parent Game Object, adjusting size and origin as needed.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#setCurrentFrame\r\n     * @fires Phaser.Animations.Events#ANIMATION_UPDATE\r\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Animations.AnimationFrame} animationFrame - The animation frame to change to.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.\r\n     */\r\n    setCurrentFrame: function (animationFrame)\r\n    {\r\n        var gameObject = this.parent;\r\n\r\n        this.currentFrame = animationFrame;\r\n\r\n        gameObject.texture = animationFrame.frame.texture;\r\n        gameObject.frame = animationFrame.frame;\r\n\r\n        if (gameObject.isCropped)\r\n        {\r\n            gameObject.frame.updateCropUVs(gameObject._crop, gameObject.flipX, gameObject.flipY);\r\n        }\r\n\r\n        if (animationFrame.setAlpha)\r\n        {\r\n            gameObject.alpha = animationFrame.alpha;\r\n        }\r\n\r\n        gameObject.setSizeToFrame();\r\n\r\n        if (gameObject._originComponent)\r\n        {\r\n            if (animationFrame.frame.customPivot)\r\n            {\r\n                gameObject.setOrigin(animationFrame.frame.pivotX, animationFrame.frame.pivotY);\r\n            }\r\n            else\r\n            {\r\n                gameObject.updateDisplayOrigin();\r\n            }\r\n        }\r\n\r\n        if (this.isPlaying && this.hasStarted)\r\n        {\r\n            this.emitEvents(Events.ANIMATION_UPDATE);\r\n\r\n            if (this._pendingStop === 3 && this._pendingStopValue === animationFrame)\r\n            {\r\n                this.stop();\r\n            }\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Advances the animation to the next frame, regardless of the time or animation state.\r\n     * If the animation is set to repeat, or yoyo, this will still take effect.\r\n     *\r\n     * Calling this does not change the direction of the animation. I.e. if it was currently\r\n     * playing in reverse, calling this method doesn't then change the direction to forwards.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#nextFrame\r\n     * @since 3.16.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.\r\n     */\r\n    nextFrame: function ()\r\n    {\r\n        if (this.currentAnim)\r\n        {\r\n            this.currentAnim.nextFrame(this);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Advances the animation to the previous frame, regardless of the time or animation state.\r\n     * If the animation is set to repeat, or yoyo, this will still take effect.\r\n     *\r\n     * Calling this does not change the direction of the animation. I.e. if it was currently\r\n     * playing in forwards, calling this method doesn't then change the direction to backwards.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#previousFrame\r\n     * @since 3.16.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object this Animation Component belongs to.\r\n     */\r\n    previousFrame: function ()\r\n    {\r\n        if (this.currentAnim)\r\n        {\r\n            this.currentAnim.previousFrame(this);\r\n        }\r\n\r\n        return this.parent;\r\n    },\r\n\r\n    /**\r\n     * Get an Animation instance that has been created locally on this Sprite.\r\n     *\r\n     * See the `create` method for more details.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#get\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the Animation to retrieve.\r\n     *\r\n     * @return {Phaser.Animations.Animation} The Animation, or `null` if the key is invalid.\r\n     */\r\n    get: function (key)\r\n    {\r\n        return (this.anims) ? this.anims.get(key) : null;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given key is already used locally within the animations stored on this Sprite.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#exists\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the Animation to check.\r\n     *\r\n     * @return {boolean} `true` if the Animation exists locally, or `false` if the key is available, or there are no local animations.\r\n     */\r\n    exists: function (key)\r\n    {\r\n        return (this.anims) ? this.anims.has(key) : false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Animation that is local specifically to this Sprite.\r\n     *\r\n     * When a Sprite owns an animation, it is kept out of the global Animation Manager, which means\r\n     * you're free to use keys that may be already defined there. Unless you specifically need a Sprite\r\n     * to have a unique animation, you should favor using global animations instead, as they allow for\r\n     * the same animation to be used across multiple Sprites, saving on memory. However, if this Sprite\r\n     * is the only one to use this animation, it's sensible to create it here.\r\n     *\r\n     * If an invalid key is given this method will return `false`.\r\n     *\r\n     * If you pass the key of an animation that already exists locally, that animation will be returned.\r\n     *\r\n     * A brand new animation is only created if the key is valid and not already in use by this Sprite.\r\n     *\r\n     * If you wish to re-use an existing key, call the `remove` method first, then this method.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#create\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Animations.Animation} config - The configuration settings for the Animation.\r\n     *\r\n     * @return {(Phaser.Animations.Animation|false)} The Animation that was created, or `false` if the key is already in use.\r\n     */\r\n    create: function (config)\r\n    {\r\n        var key = config.key;\r\n\r\n        var anim = false;\r\n\r\n        if (key)\r\n        {\r\n            anim = this.get(key);\r\n\r\n            if (!anim)\r\n            {\r\n                anim = new Animation(this, key, config);\r\n\r\n                if (!this.anims)\r\n                {\r\n                    this.anims = new CustomMap();\r\n                }\r\n\r\n                this.anims.set(key, anim);\r\n            }\r\n        }\r\n\r\n        return anim;\r\n    },\r\n\r\n    /**\r\n     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.\r\n     *\r\n     * Generates objects with string based frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNames}.\r\n     *\r\n     * It's a helper method, designed to make it easier for you to extract all of the frame names from texture atlases.\r\n     * If you're working with a sprite sheet, see the `generateFrameNumbers` method instead.\r\n     *\r\n     * Example:\r\n     *\r\n     * If you have a texture atlases loaded called `gems` and it contains 6 frames called `ruby_0001`, `ruby_0002`, and so on,\r\n     * then you can call this method using: `this.anims.generateFrameNames('gems', { prefix: 'ruby_', end: 6, zeroPad: 4 })`.\r\n     *\r\n     * The `end` value tells it to look for 6 frames, incrementally numbered, all starting with the prefix `ruby_`. The `zeroPad`\r\n     * value tells it how many zeroes pad out the numbers. To create an animation using this method, you can do:\r\n     *\r\n     * ```javascript\r\n     * this.anims.create({\r\n     *   key: 'ruby',\r\n     *   repeat: -1,\r\n     *   frames: this.anims.generateFrameNames('gems', {\r\n     *     prefix: 'ruby_',\r\n     *     end: 6,\r\n     *     zeroPad: 4\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     * Please see the animation examples for further details.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#generateFrameNames\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key for the texture containing the animation frames.\r\n     * @param {Phaser.Types.Animations.GenerateFrameNames} [config] - The configuration object for the animation frame names.\r\n     *\r\n     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.\r\n     */\r\n    generateFrameNames: function (key, config)\r\n    {\r\n        return this.animationManager.generateFrameNames(key, config);\r\n    },\r\n\r\n    /**\r\n     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.\r\n     *\r\n     * Generates objects with numbered frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNumbers}.\r\n     *\r\n     * If you're working with a texture atlas, see the `generateFrameNames` method instead.\r\n     *\r\n     * It's a helper method, designed to make it easier for you to extract frames from sprite sheets.\r\n     * If you're working with a texture atlas, see the `generateFrameNames` method instead.\r\n     *\r\n     * Example:\r\n     *\r\n     * If you have a sprite sheet loaded called `explosion` and it contains 12 frames, then you can call this method using:\r\n     * `this.anims.generateFrameNumbers('explosion', { start: 0, end: 12 })`.\r\n     *\r\n     * The `end` value tells it to stop after 12 frames. To create an animation using this method, you can do:\r\n     *\r\n     * ```javascript\r\n     * this.anims.create({\r\n     *   key: 'boom',\r\n     *   frames: this.anims.generateFrameNames('explosion', {\r\n     *     start: 0,\r\n     *     end: 12\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     * Note that `start` is optional and you don't need to include it if the animation starts from frame 0.\r\n     *\r\n     * To specify an animation in reverse, swap the `start` and `end` values.\r\n     *\r\n     * If the frames are not sequential, you may pass an array of frame numbers instead, for example:\r\n     *\r\n     * `this.anims.generateFrameNumbers('explosion', { frames: [ 0, 1, 2, 1, 2, 3, 4, 0, 1, 2 ] })`\r\n     *\r\n     * Please see the animation examples and `GenerateFrameNumbers` config docs for further details.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#generateFrameNumbers\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key for the texture containing the animation frames.\r\n     * @param {Phaser.Types.Animations.GenerateFrameNumbers} config - The configuration object for the animation frames.\r\n     *\r\n     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.\r\n     */\r\n    generateFrameNumbers: function (key, config)\r\n    {\r\n        return this.animationManager.generateFrameNumbers(key, config);\r\n    },\r\n\r\n    /**\r\n     * Removes a locally created Animation from this Sprite, based on the given key.\r\n     *\r\n     * Once an Animation has been removed, this Sprite cannot play it again without re-creating it.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#remove\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the animation to remove.\r\n     *\r\n     * @return {Phaser.Animations.Animation} The Animation instance that was removed from this Sprite, if the key was valid.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        var anim = this.get(key);\r\n\r\n        if (anim)\r\n        {\r\n            if (this.currentAnim === anim)\r\n            {\r\n                this.stop();\r\n            }\r\n\r\n            this.anims.delete(key);\r\n        }\r\n\r\n        return anim;\r\n    },\r\n\r\n    /**\r\n     * Destroy this Animation component.\r\n     *\r\n     * Unregisters event listeners and cleans up its references.\r\n     *\r\n     * @method Phaser.Animations.AnimationState#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.animationManager.off(Events.REMOVE_ANIMATION, this.globalRemove, this);\r\n\r\n        if (this.anims)\r\n        {\r\n            this.anims.clear();\r\n        }\r\n\r\n        this.animationManager = null;\r\n        this.parent = null;\r\n        this.nextAnim = null;\r\n        this.nextAnimsQueue.length = 0;\r\n\r\n        this.currentAnim = null;\r\n        this.currentFrame = null;\r\n    },\r\n\r\n    /**\r\n     * `true` if the current animation is paused, otherwise `false`.\r\n     *\r\n     * @name Phaser.Animations.AnimationState#isPaused\r\n     * @readonly\r\n     * @type {boolean}\r\n     * @since 3.4.0\r\n     */\r\n    isPaused: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._paused;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = AnimationState;\r\n"],"names":["Class","CustomMap","GetFastValue","Events","Animation","AnimationState","initialize","parent","this","animationManager","scene","sys","anims","on","REMOVE_ANIMATION","globalRemove","textureManager","isPlaying","hasStarted","currentAnim","currentFrame","nextAnim","nextAnimsQueue","timeScale","frameRate","duration","msPerFrame","skipMissedFrames","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","forward","inReverse","accumulator","nextTick","delayCounter","repeatCounter","pendingRepeat","_paused","_wasPlaying","_pendingStop","_pendingStopValue","chain","key","undefined","length","Array","isArray","i","anim","push","getName","getFrameName","textureFrame","load","stop","manager","animKey","exists","get","totalFrames","getTotalFrames","calculateDuration","startFrame","frame","frames","getLastFrame","console","warn","pause","atFrame","setCurrentFrame","resume","fromFrame","playAfterDelay","queue","unshift","play","playAfterRepeat","repeatCount","ignoreIfPlaying","mix","getMix","startAnimation","playReverse","gameObject","Number","MAX_VALUE","getFirstTick","handleStart","setVisible","emitEvents","ANIMATION_START","handleRepeat","ANIMATION_REPEAT","handleStop","ANIMATION_STOP","handleComplete","ANIMATION_COMPLETE","ANIMATION_COMPLETE_KEY","event","keyEvent","frameKey","emit","reverse","getProgress","p","progress","setProgress","value","getFrameByProgress","setRepeat","animation","restart","includeDelay","resetRepeats","ANIMATION_RESTART","complete","shift","stopAfterDelay","stopAfterRepeat","stopOnFrame","update","time","delta","paused","nextFrame","previousFrame","safetyNet","animationFrame","texture","isCropped","updateCropUVs","_crop","flipX","flipY","setAlpha","alpha","setSizeToFrame","_originComponent","customPivot","setOrigin","pivotX","pivotY","updateDisplayOrigin","ANIMATION_UPDATE","has","create","config","set","generateFrameNames","generateFrameNumbers","remove","delete","destroy","off","clear","isPaused","module","exports"],"sourceRoot":""}