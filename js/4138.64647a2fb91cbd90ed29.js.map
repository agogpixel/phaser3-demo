{"version":3,"file":"js/4138.64647a2fb91cbd90ed29.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/create/GenerateTexture.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/create/palettes/Arne16.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/CanvasTexture.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/Texture.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/TextureManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/TextureSource.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/AtlasXML.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/Canvas.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/Image.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/JSONArray.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/JSONHash.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/SpriteSheet.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/SpriteSheetFromAtlas.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/UnityYAML.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/parsers/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Arne16 = require('./palettes/Arne16');\r\nvar CanvasPool = require('../display/canvas/CanvasPool');\r\nvar GetValue = require('../utils/object/GetValue');\r\n\r\n/**\r\n * Generates a texture based on the given Create configuration object.\r\n * \r\n * The texture is drawn using a fixed-size indexed palette of 16 colors, where the hex value in the\r\n * data cells map to a single color. For example, if the texture config looked like this:\r\n *\r\n * ```javascript\r\n * var star = [\r\n *   '.....828.....',\r\n *   '....72227....',\r\n *   '....82228....',\r\n *   '...7222227...',\r\n *   '2222222222222',\r\n *   '8222222222228',\r\n *   '.72222222227.',\r\n *   '..787777787..',\r\n *   '..877777778..',\r\n *   '.78778887787.',\r\n *   '.27887.78872.',\r\n *   '.787.....787.'\r\n * ];\r\n * \r\n * this.textures.generate('star', { data: star, pixelWidth: 4 });\r\n * ```\r\n * \r\n * Then it would generate a texture that is 52 x 48 pixels in size, because each cell of the data array\r\n * represents 1 pixel multiplied by the `pixelWidth` value. The cell values, such as `8`, maps to color\r\n * number 8 in the palette. If a cell contains a period character `.` then it is transparent.\r\n * \r\n * The default palette is Arne16, but you can specify your own using the `palette` property.\r\n *\r\n * @function Phaser.Create.GenerateTexture\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Create.GenerateTextureConfig} config - The Generate Texture Configuration object.\r\n *\r\n * @return {HTMLCanvasElement} An HTMLCanvasElement which contains the generated texture drawn to it.\r\n */\r\nvar GenerateTexture = function (config)\r\n{\r\n    var data = GetValue(config, 'data', []);\r\n    var canvas = GetValue(config, 'canvas', null);\r\n    var palette = GetValue(config, 'palette', Arne16);\r\n    var pixelWidth = GetValue(config, 'pixelWidth', 1);\r\n    var pixelHeight = GetValue(config, 'pixelHeight', pixelWidth);\r\n    var resizeCanvas = GetValue(config, 'resizeCanvas', true);\r\n    var clearCanvas = GetValue(config, 'clearCanvas', true);\r\n    var preRender = GetValue(config, 'preRender', null);\r\n    var postRender = GetValue(config, 'postRender', null);\r\n\r\n    var width = Math.floor(Math.abs(data[0].length * pixelWidth));\r\n    var height = Math.floor(Math.abs(data.length * pixelHeight));\r\n\r\n    if (!canvas)\r\n    {\r\n        canvas = CanvasPool.create2D(this, width, height);\r\n        resizeCanvas = false;\r\n        clearCanvas = false;\r\n    }\r\n\r\n    if (resizeCanvas)\r\n    {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n    }\r\n\r\n    var ctx = canvas.getContext('2d');\r\n\r\n    if (clearCanvas)\r\n    {\r\n        ctx.clearRect(0, 0, width, height);\r\n    }\r\n\r\n    //  preRender Callback?\r\n    if (preRender)\r\n    {\r\n        preRender(canvas, ctx);\r\n    }\r\n\r\n    //  Draw it\r\n    for (var y = 0; y < data.length; y++)\r\n    {\r\n        var row = data[y];\r\n\r\n        for (var x = 0; x < row.length; x++)\r\n        {\r\n            var d = row[x];\r\n\r\n            if (d !== '.' && d !== ' ')\r\n            {\r\n                ctx.fillStyle = palette[d];\r\n                ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);\r\n            }\r\n        }\r\n    }\r\n\r\n    //  postRender Callback?\r\n    if (postRender)\r\n    {\r\n        postRender(canvas, ctx);\r\n    }\r\n\r\n    return canvas;\r\n};\r\n\r\nmodule.exports = GenerateTexture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)\r\n *\r\n * @name Phaser.Create.Palettes.ARNE16\r\n * @since 3.0.0\r\n *\r\n * @type {Phaser.Types.Create.Palette}\r\n */\r\nmodule.exports = {\r\n    0: '#000',\r\n    1: '#9D9D9D',\r\n    2: '#FFF',\r\n    3: '#BE2633',\r\n    4: '#E06F8B',\r\n    5: '#493C2B',\r\n    6: '#A46422',\r\n    7: '#EB8931',\r\n    8: '#F7E26B',\r\n    9: '#2F484E',\r\n    A: '#44891A',\r\n    B: '#A3CE27',\r\n    C: '#1B2632',\r\n    D: '#005784',\r\n    E: '#31A2F2',\r\n    F: '#B2DCEF'\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Clamp = require('../math/Clamp');\r\nvar Color = require('../display/color/Color');\r\nvar CONST = require('../const');\r\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\r\nvar Texture = require('./Texture');\r\n\r\n/**\r\n * @classdesc\r\n * A Canvas Texture is a special kind of Texture that is backed by an HTML Canvas Element as its source.\r\n *\r\n * You can use the properties of this texture to draw to the canvas element directly, using all of the standard\r\n * canvas operations available in the browser. Any Game Object can be given this texture and will render with it.\r\n *\r\n * Note: When running under WebGL the Canvas Texture needs to re-generate its base WebGLTexture and reupload it to\r\n * the GPU every time you modify it, otherwise the changes you make to this texture will not be visible. To do this\r\n * you should call `CanvasTexture.refresh()` once you are finished with your changes to the canvas. Try and keep\r\n * this to a minimum, especially on large canvas sizes, or you may inadvertently thrash the GPU by constantly uploading\r\n * texture data to it. This restriction does not apply if using the Canvas Renderer.\r\n *\r\n * It starts with only one frame that covers the whole of the canvas. You can add further frames, that specify\r\n * sections of the canvas using the `add` method.\r\n *\r\n * Should you need to resize the canvas use the `setSize` method so that it accurately updates all of the underlying\r\n * texture data as well. Forgetting to do this (i.e. by changing the canvas size directly from your code) could cause\r\n * graphical errors.\r\n *\r\n * @class CanvasTexture\r\n * @extends Phaser.Textures.Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {HTMLCanvasElement} source - The canvas element that is used as the base of this texture.\r\n * @param {number} width - The width of the canvas.\r\n * @param {number} height - The height of the canvas.\r\n */\r\nvar CanvasTexture = new Class({\r\n\r\n    Extends: Texture,\r\n\r\n    initialize:\r\n\r\n    function CanvasTexture (manager, key, source, width, height)\r\n    {\r\n        Texture.call(this, manager, key, source, width, height);\r\n\r\n        this.add('__BASE', 0, 0, 0, width, height);\r\n\r\n        /**\r\n         * A reference to the Texture Source of this Canvas.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#_source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._source = this.frames['__BASE'].source;\r\n\r\n        /**\r\n         * The source Canvas Element.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#canvas\r\n         * @readonly\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.7.0\r\n         */\r\n        this.canvas = this._source.image;\r\n\r\n        /**\r\n         * The 2D Canvas Rendering Context.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#context\r\n         * @readonly\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.7.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The width of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#width\r\n         * @readonly\r\n         * @type {number}\r\n         * @since 3.7.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Canvas.\r\n         * This property is read-only, if you wish to change it use the `setSize` method.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#height\r\n         * @readonly\r\n         * @type {number}\r\n         * @since 3.7.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The context image data.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#imageData\r\n         * @type {ImageData}\r\n         * @since 3.13.0\r\n         */\r\n        this.imageData = this.context.getImageData(0, 0, width, height);\r\n\r\n        /**\r\n         * A Uint8ClampedArray view into the `buffer`.\r\n         * Use the `update` method to populate this when the canvas changes.\r\n         * Note that this is unavailable in some browsers, such as Epic Browser, due to their security restrictions.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#data\r\n         * @type {Uint8ClampedArray}\r\n         * @since 3.13.0\r\n         */\r\n        this.data = null;\r\n\r\n        if (this.imageData)\r\n        {\r\n            this.data = this.imageData.data;\r\n        }\r\n\r\n        /**\r\n         * An Uint32Array view into the `buffer`.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#pixels\r\n         * @type {Uint32Array}\r\n         * @since 3.13.0\r\n         */\r\n        this.pixels = null;\r\n\r\n        /**\r\n         * An ArrayBuffer the same size as the context ImageData.\r\n         *\r\n         * @name Phaser.Textures.CanvasTexture#buffer\r\n         * @type {ArrayBuffer}\r\n         * @since 3.13.0\r\n         */\r\n        this.buffer;\r\n\r\n        if (this.data)\r\n        {\r\n            if (this.imageData.data.buffer)\r\n            {\r\n                this.buffer = this.imageData.data.buffer;\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else if (window.ArrayBuffer)\r\n            {\r\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n                this.pixels = new Uint32Array(this.buffer);\r\n            }\r\n            else\r\n            {\r\n                this.pixels = this.imageData.data;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This re-creates the `imageData` from the current context.\r\n     * It then re-builds the ArrayBuffer, the `data` Uint8ClampedArray reference and the `pixels` Int32Array.\r\n     *\r\n     * Warning: This is a very expensive operation, so use it sparingly.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#update\r\n     * @since 3.13.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    update: function ()\r\n    {\r\n        this.imageData = this.context.getImageData(0, 0, this.width, this.height);\r\n\r\n        this.data = this.imageData.data;\r\n\r\n        if (this.imageData.data.buffer)\r\n        {\r\n            this.buffer = this.imageData.data.buffer;\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else if (window.ArrayBuffer)\r\n        {\r\n            this.buffer = new ArrayBuffer(this.imageData.data.length);\r\n            this.pixels = new Uint32Array(this.buffer);\r\n        }\r\n        else\r\n        {\r\n            this.pixels = this.imageData.data;\r\n        }\r\n\r\n        if (this.manager.game.config.renderType === CONST.WEBGL)\r\n        {\r\n            this.refresh();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given Image or Canvas element to this CanvasTexture, then updates the internal\r\n     * ImageData buffer and arrays.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#draw\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} x - The x coordinate to draw the source at.\r\n     * @param {number} y - The y coordinate to draw the source at.\r\n     * @param {(HTMLImageElement|HTMLCanvasElement)} source - The element to draw to this canvas.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    draw: function (x, y, source)\r\n    {\r\n        this.context.drawImage(source, x, y);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Draws the given texture frame to this CanvasTexture, then updates the internal\r\n     * ImageData buffer and arrays.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#drawFrame\r\n     * @since 3.16.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     * @param {number} [x=0] - The x coordinate to draw the source at.\r\n     * @param {number} [y=0] - The y coordinate to draw the source at.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    drawFrame: function (key, frame, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        var textureFrame = this.manager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            var cd = textureFrame.canvasData;\r\n\r\n            var width = textureFrame.cutWidth;\r\n            var height = textureFrame.cutHeight;\r\n            var res = textureFrame.source.resolution;\r\n\r\n            this.context.drawImage(\r\n                textureFrame.source.image,\r\n                cd.x, cd.y,\r\n                width,\r\n                height,\r\n                x, y,\r\n                width / res,\r\n                height / res\r\n            );\r\n\r\n            return this.update();\r\n        }\r\n        else\r\n        {\r\n            return this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a pixel in the CanvasTexture to the given color and alpha values.\r\n     *\r\n     * This is an expensive operation to run in large quantities, so use sparingly.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#setPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} red - The red color value. A number between 0 and 255.\r\n     * @param {number} green - The green color value. A number between 0 and 255.\r\n     * @param {number} blue - The blue color value. A number between 0 and 255.\r\n     * @param {number} [alpha=255] - The alpha value. A number between 0 and 255.\r\n     *\r\n     * @return {this} This CanvasTexture.\r\n     */\r\n    setPixel: function (x, y, red, green, blue, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 255; }\r\n\r\n        x = Math.abs(Math.floor(x));\r\n        y = Math.abs(Math.floor(y));\r\n\r\n        var index = this.getIndex(x, y);\r\n\r\n        if (index > -1)\r\n        {\r\n            var imageData = this.context.getImageData(x, y, 1, 1);\r\n\r\n            imageData.data[0] = red;\r\n            imageData.data[1] = green;\r\n            imageData.data[2] = blue;\r\n            imageData.data[3] = alpha;\r\n\r\n            this.context.putImageData(imageData, x, y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the ImageData into the context of this CanvasTexture at the given coordinates.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#putData\r\n     * @since 3.16.0\r\n     *\r\n     * @param {ImageData} imageData - The ImageData to put at the given location.\r\n     * @param {number} x - The x coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} y - The y coordinate to put the imageData. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} [dirtyX=0] - Horizontal position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n     * @param {number} [dirtyY=0] - Vertical position (x coordinate) of the top-left corner from which the image data will be extracted.\r\n     * @param {number} [dirtyWidth] - Width of the rectangle to be painted. Defaults to the width of the image data.\r\n     * @param {number} [dirtyHeight] - Height of the rectangle to be painted. Defaults to the height of the image data.\r\n     *\r\n     * @return {this} This CanvasTexture.\r\n     */\r\n    putData: function (imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)\r\n    {\r\n        if (dirtyX === undefined) { dirtyX = 0; }\r\n        if (dirtyY === undefined) { dirtyY = 0; }\r\n        if (dirtyWidth === undefined) { dirtyWidth = imageData.width; }\r\n        if (dirtyHeight === undefined) { dirtyHeight = imageData.height; }\r\n\r\n        this.context.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets an ImageData region from this CanvasTexture from the position and size specified.\r\n     * You can write this back using `CanvasTexture.putData`, or manipulate it.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getData\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} y - The y coordinate of the top-left of the area to get the ImageData from. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} width - The width of the rectangle from which the ImageData will be extracted. Positive values are to the right, and negative to the left.\r\n     * @param {number} height - The height of the rectangle from which the ImageData will be extracted. Positive values are down, and negative are up.\r\n     *\r\n     * @return {ImageData} The ImageData extracted from this CanvasTexture.\r\n     */\r\n    getData: function (x, y, width, height)\r\n    {\r\n        x = Clamp(Math.floor(x), 0, this.width - 1);\r\n        y = Clamp(Math.floor(y), 0, this.height - 1);\r\n        width = Clamp(width, 1, this.width - x);\r\n        height = Clamp(height, 1, this.height - y);\r\n\r\n        var imageData = this.context.getImageData(x, y, width, height);\r\n\r\n        return imageData;\r\n    },\r\n\r\n    /**\r\n     * Get the color of a specific pixel from this texture and store it in a Color object.\r\n     *\r\n     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getPixel\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {Phaser.Display.Color} [out] - A Color object to store the pixel values in. If not provided a new Color object will be created.\r\n     *\r\n     * @return {Phaser.Display.Color} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\r\n     */\r\n    getPixel: function (x, y, out)\r\n    {\r\n        if (!out)\r\n        {\r\n            out = new Color();\r\n        }\r\n\r\n        var index = this.getIndex(x, y);\r\n\r\n        if (index > -1)\r\n        {\r\n            var data = this.data;\r\n\r\n            var r = data[index + 0];\r\n            var g = data[index + 1];\r\n            var b = data[index + 2];\r\n            var a = data[index + 3];\r\n\r\n            out.setTo(r, g, b, a);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all of the pixels in the given region.\r\n     *\r\n     * If the requested region extends outside the bounds of this CanvasTexture,\r\n     * the region is truncated to fit.\r\n     *\r\n     * If you have drawn anything to this CanvasTexture since it was created you must call `CanvasTexture.update` to refresh the array buffer,\r\n     * otherwise this may return out of date color values, or worse - throw a run-time error as it tries to access an array element that doesn't exist.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getPixels\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} [y=0] - The y coordinate of the top-left of the region. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} [width] - The width of the region to get. Must be an integer. Defaults to the canvas width if not given.\r\n     * @param {number} [height] - The height of the region to get. Must be an integer. If not given will be set to the `width`.\r\n     *\r\n     * @return {Phaser.Types.Textures.PixelConfig[][]} A 2d array of Pixel objects.\r\n     */\r\n    getPixels: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = width; }\r\n\r\n        x = Math.abs(Math.round(x));\r\n        y = Math.abs(Math.round(y));\r\n\r\n        var left = Clamp(x, 0, this.width);\r\n        var right = Clamp(x + width, 0, this.width);\r\n        var top = Clamp(y, 0, this.height);\r\n        var bottom = Clamp(y + height, 0, this.height);\r\n\r\n        var pixel = new Color();\r\n\r\n        var out = [];\r\n\r\n        for (var py = top; py < bottom; py++)\r\n        {\r\n            var row = [];\r\n\r\n            for (var px = left; px < right; px++)\r\n            {\r\n                pixel = this.getPixel(px, py, pixel);\r\n\r\n                row.push({ x: px, y: py, color: pixel.color, alpha: pixel.alphaGL });\r\n            }\r\n\r\n            out.push(row);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns the Image Data index for the given pixel in this CanvasTexture.\r\n     *\r\n     * The index can be used to read directly from the `this.data` array.\r\n     *\r\n     * The index points to the red value in the array. The subsequent 3 indexes\r\n     * point to green, blue and alpha respectively.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getIndex\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     * @param {number} y - The y coordinate of the pixel to get. Must lay within the dimensions of this CanvasTexture and be an integer.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getIndex: function (x, y)\r\n    {\r\n        x = Math.abs(Math.round(x));\r\n        y = Math.abs(Math.round(y));\r\n\r\n        if (x < this.width && y < this.height)\r\n        {\r\n            return (x + y * this.width) * 4;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This should be called manually if you are running under WebGL.\r\n     * It will refresh the WebGLTexture from the Canvas source. Only call this if you know that the\r\n     * canvas has changed, as there is a significant GPU texture allocation cost involved in doing so.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#refresh\r\n     * @since 3.7.0\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} This CanvasTexture.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        this._source.update();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the Canvas Element.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getCanvas\r\n     * @since 3.7.0\r\n     *\r\n     * @return {HTMLCanvasElement} The Canvas DOM element this texture is using.\r\n     */\r\n    getCanvas: function ()\r\n    {\r\n        return this.canvas;\r\n    },\r\n\r\n    /**\r\n     * Gets the 2D Canvas Rendering Context.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#getContext\r\n     * @since 3.7.0\r\n     *\r\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context this texture is using.\r\n     */\r\n    getContext: function ()\r\n    {\r\n        return this.context;\r\n    },\r\n\r\n    /**\r\n     * Clears the given region of this Canvas Texture, resetting it back to transparent.\r\n     * If no region is given, the whole Canvas Texture is cleared.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#clear\r\n     * @since 3.7.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of the top-left of the region to clear.\r\n     * @param {number} [y=0] - The y coordinate of the top-left of the region to clear.\r\n     * @param {number} [width] - The width of the region.\r\n     * @param {number} [height] - The height of the region.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    clear: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        this.context.clearRect(x, y, width, height);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Changes the size of this Canvas Texture.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#setSize\r\n     * @since 3.7.0\r\n     *\r\n     * @param {number} width - The new width of the Canvas.\r\n     * @param {number} [height] - The new height of the Canvas. If not given it will use the width as the height.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Canvas Texture.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            //  Update the Canvas\r\n            this.canvas.width = width;\r\n            this.canvas.height = height;\r\n\r\n            //  Update the Texture Source\r\n            this._source.width = width;\r\n            this._source.height = height;\r\n            this._source.isPowerOf2 = IsSizePowerOfTwo(width, height);\r\n\r\n            //  Update the Frame\r\n            this.frames['__BASE'].setSize(width, height, 0, 0);\r\n\r\n            //  Update this\r\n            this.width = width;\r\n            this.height = height;\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Texture and releases references to its sources and frames.\r\n     *\r\n     * @method Phaser.Textures.CanvasTexture#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        Texture.prototype.destroy.call(this);\r\n\r\n        this._source = null;\r\n        this.canvas = null;\r\n        this.context = null;\r\n        this.imageData = null;\r\n        this.data = null;\r\n        this.pixels = null;\r\n        this.buffer = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasTexture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const');\r\nvar Class = require('../utils/Class');\r\nvar Frame = require('./Frame');\r\nvar TextureSource = require('./TextureSource');\r\n\r\nvar TEXTURE_MISSING_ERROR = 'Texture.frame missing: ';\r\n\r\n/**\r\n * @classdesc\r\n * A Texture consists of a source, usually an Image from the Cache, and a collection of Frames.\r\n * The Frames represent the different areas of the Texture. For example a texture atlas\r\n * may have many Frames, one for each element within the atlas. Where-as a single image would have\r\n * just one frame, that encompasses the whole image.\r\n *\r\n * Every Texture, no matter where it comes from, always has at least 1 frame called the `__BASE` frame.\r\n * This frame represents the entirety of the source image.\r\n *\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * @class Texture\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} manager - A reference to the Texture Manager this Texture belongs to.\r\n * @param {string} key - The unique string-based key of this Texture.\r\n * @param {(HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[])} source - An array of sources that are used to create the texture. Usually Images, but can also be a Canvas.\r\n * @param {number} [width] - The width of the Texture. This is optional and automatically derived from the source images.\r\n * @param {number} [height] - The height of the Texture. This is optional and automatically derived from the source images.\r\n */\r\nvar Texture = new Class({\r\n\r\n    initialize:\r\n\r\n    function Texture (manager, key, source, width, height)\r\n    {\r\n        if (!Array.isArray(source))\r\n        {\r\n            source = [ source ];\r\n        }\r\n\r\n        /**\r\n         * A reference to the Texture Manager this Texture belongs to.\r\n         *\r\n         * @name Phaser.Textures.Texture#manager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * The unique string-based key of this Texture.\r\n         *\r\n         * @name Phaser.Textures.Texture#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * An array of TextureSource instances.\r\n         * These are unique to this Texture and contain the actual Image (or Canvas) data.\r\n         *\r\n         * @name Phaser.Textures.Texture#source\r\n         * @type {Phaser.Textures.TextureSource[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = [];\r\n\r\n        /**\r\n         * An array of TextureSource data instances.\r\n         * Used to store additional data images, such as normal maps or specular maps.\r\n         *\r\n         * @name Phaser.Textures.Texture#dataSource\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.dataSource = [];\r\n\r\n        /**\r\n         * A key-value object pair associating the unique Frame keys with the Frames objects.\r\n         *\r\n         * @name Phaser.Textures.Texture#frames\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.frames = {};\r\n\r\n        /**\r\n         * Any additional data that was set in the source JSON (if any),\r\n         * or any extra data you'd like to store relating to this texture\r\n         *\r\n         * @name Phaser.Textures.Texture#customData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.customData = {};\r\n\r\n        /**\r\n         * The name of the first frame of the Texture.\r\n         *\r\n         * @name Phaser.Textures.Texture#firstFrame\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstFrame = '__BASE';\r\n\r\n        /**\r\n         * The total number of Frames in this Texture, including the `__BASE` frame.\r\n         *\r\n         * A Texture will always contain at least 1 frame because every Texture contains a `__BASE` frame by default,\r\n         * in addition to any extra frames that have been added to it, such as when parsing a Sprite Sheet or Texture Atlas.\r\n         *\r\n         * @name Phaser.Textures.Texture#frameTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.frameTotal = 0;\r\n\r\n        //  Load the Sources\r\n        for (var i = 0; i < source.length; i++)\r\n        {\r\n            this.source.push(new TextureSource(this, source[i], width, height));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a new Frame to this Texture.\r\n     *\r\n     * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.\r\n     *\r\n     * The name given must be unique within this Texture. If it already exists, this method will return `null`.\r\n     *\r\n     * @method Phaser.Textures.Texture#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|string)} name - The name of this Frame. The name is unique within the Texture.\r\n     * @param {number} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n     * @param {number} x - The x coordinate of the top-left of this Frame.\r\n     * @param {number} y - The y coordinate of the top-left of this Frame.\r\n     * @param {number} width - The width of this Frame.\r\n     * @param {number} height - The height of this Frame.\r\n     *\r\n     * @return {?Phaser.Textures.Frame} The Frame that was added to this Texture, or `null` if the given name already exists.\r\n     */\r\n    add: function (name, sourceIndex, x, y, width, height)\r\n    {\r\n        if (this.has(name))\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var frame = new Frame(this, name, sourceIndex, x, y, width, height);\r\n\r\n        this.frames[name] = frame;\r\n\r\n        //  Set the first frame of the Texture (other than __BASE)\r\n        //  This is used to ensure we don't spam the display with entire\r\n        //  atlases of sprite sheets, but instead just the first frame of them\r\n        //  should the dev incorrectly specify the frame index\r\n        if (this.firstFrame === '__BASE')\r\n        {\r\n            this.firstFrame = name;\r\n        }\r\n\r\n        this.frameTotal++;\r\n\r\n        return frame;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Frame from this Texture. The Frame is destroyed immediately.\r\n     *\r\n     * Any Game Objects using this Frame should stop using it _before_ you remove it,\r\n     * as it does not happen automatically.\r\n     *\r\n     * @method Phaser.Textures.Texture#remove\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} name - The key of the Frame to remove.\r\n     *\r\n     * @return {boolean} True if a Frame with the matching key was removed from this Texture.\r\n     */\r\n    remove: function (name)\r\n    {\r\n        if (this.has(name))\r\n        {\r\n            var frame = this.get(name);\r\n\r\n            frame.destroy();\r\n\r\n            delete this.frames[name];\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a Frame matching the given key exists within this Texture.\r\n     *\r\n     * @method Phaser.Textures.Texture#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The key of the Frame to check for.\r\n     *\r\n     * @return {boolean} True if a Frame with the matching key exists in this Texture.\r\n     */\r\n    has: function (name)\r\n    {\r\n        return (this.frames[name]);\r\n    },\r\n\r\n    /**\r\n     * Gets a Frame from this Texture based on either the key or the index of the Frame.\r\n     *\r\n     * In a Texture Atlas Frames are typically referenced by a key.\r\n     * In a Sprite Sheet Frames are referenced by an index.\r\n     * Passing no value for the name returns the base texture.\r\n     *\r\n     * @method Phaser.Textures.Texture#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n     *\r\n     * @return {Phaser.Textures.Frame} The Texture Frame.\r\n     */\r\n    get: function (name)\r\n    {\r\n        //  null, undefined, empty string, zero\r\n        if (!name)\r\n        {\r\n            name = this.firstFrame;\r\n        }\r\n\r\n        var frame = this.frames[name];\r\n\r\n        if (!frame)\r\n        {\r\n            console.warn(TEXTURE_MISSING_ERROR + name);\r\n\r\n            frame = this.frames[this.firstFrame];\r\n        }\r\n\r\n        return frame;\r\n    },\r\n\r\n    /**\r\n     * Takes the given TextureSource and returns the index of it within this Texture.\r\n     * If it's not in this Texture, it returns -1.\r\n     * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this\r\n     * method will always return zero or -1.\r\n     *\r\n     * @method Phaser.Textures.Texture#getTextureSourceIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.TextureSource} source - The TextureSource to check.\r\n     *\r\n     * @return {number} The index of the TextureSource within this Texture, or -1 if not in this Texture.\r\n     */\r\n    getTextureSourceIndex: function (source)\r\n    {\r\n        for (var i = 0; i < this.source.length; i++)\r\n        {\r\n            if (this.source[i] === source)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all the Frames in the given TextureSource.\r\n     *\r\n     * @method Phaser.Textures.Texture#getFramesFromTextureSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} sourceIndex - The index of the TextureSource to get the Frames from.\r\n     * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?\r\n     *\r\n     * @return {Phaser.Textures.Frame[]} An array of Texture Frames.\r\n     */\r\n    getFramesFromTextureSource: function (sourceIndex, includeBase)\r\n    {\r\n        if (includeBase === undefined) { includeBase = false; }\r\n\r\n        var out = [];\r\n\r\n        for (var frameName in this.frames)\r\n        {\r\n            if (frameName === '__BASE' && !includeBase)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var frame = this.frames[frameName];\r\n\r\n            if (frame.sourceIndex === sourceIndex)\r\n            {\r\n                out.push(frame);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array with all of the names of the Frames in this Texture.\r\n     *\r\n     * Useful if you want to randomly assign a Frame to a Game Object, as you can\r\n     * pick a random element from the returned array.\r\n     *\r\n     * @method Phaser.Textures.Texture#getFrameNames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [includeBase=false] - Include the `__BASE` Frame in the output array?\r\n     *\r\n     * @return {string[]} An array of all Frame names in this Texture.\r\n     */\r\n    getFrameNames: function (includeBase)\r\n    {\r\n        if (includeBase === undefined) { includeBase = false; }\r\n\r\n        var out = Object.keys(this.frames);\r\n\r\n        if (!includeBase)\r\n        {\r\n            var idx = out.indexOf('__BASE');\r\n\r\n            if (idx !== -1)\r\n            {\r\n                out.splice(idx, 1);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Given a Frame name, return the source image it uses to render with.\r\n     *\r\n     * This will return the actual DOM Image or Canvas element.\r\n     *\r\n     * @method Phaser.Textures.Texture#getSourceImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n     *\r\n     * @return {(HTMLImageElement|HTMLCanvasElement|Phaser.GameObjects.RenderTexture)} The DOM Image, Canvas Element or Render Texture.\r\n     */\r\n    getSourceImage: function (name)\r\n    {\r\n        if (name === undefined || name === null || this.frameTotal === 1)\r\n        {\r\n            name = '__BASE';\r\n        }\r\n\r\n        var frame = this.frames[name];\r\n\r\n        if (frame)\r\n        {\r\n            return frame.source.image;\r\n        }\r\n        else\r\n        {\r\n            console.warn(TEXTURE_MISSING_ERROR + name);\r\n\r\n            return this.frames['__BASE'].source.image;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Given a Frame name, return the data source image it uses to render with.\r\n     * You can use this to get the normal map for an image for example.\r\n     *\r\n     * This will return the actual DOM Image.\r\n     *\r\n     * @method Phaser.Textures.Texture#getDataSourceImage\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|number)} [name] - The string-based name, or integer based index, of the Frame to get from this Texture.\r\n     *\r\n     * @return {(HTMLImageElement|HTMLCanvasElement)} The DOM Image or Canvas Element.\r\n     */\r\n    getDataSourceImage: function (name)\r\n    {\r\n        if (name === undefined || name === null || this.frameTotal === 1)\r\n        {\r\n            name = '__BASE';\r\n        }\r\n\r\n        var frame = this.frames[name];\r\n        var idx;\r\n\r\n        if (!frame)\r\n        {\r\n            console.warn(TEXTURE_MISSING_ERROR + name);\r\n\r\n            idx = this.frames['__BASE'].sourceIndex;\r\n        }\r\n        else\r\n        {\r\n            idx = frame.sourceIndex;\r\n        }\r\n\r\n        return this.dataSource[idx].image;\r\n    },\r\n\r\n    /**\r\n     * Adds a data source image to this Texture.\r\n     *\r\n     * An example of a data source image would be a normal map, where all of the Frames for this Texture\r\n     * equally apply to the normal map.\r\n     *\r\n     * @method Phaser.Textures.Texture#setDataSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[])} data - The source image.\r\n     */\r\n    setDataSource: function (data)\r\n    {\r\n        if (!Array.isArray(data))\r\n        {\r\n            data = [ data ];\r\n        }\r\n\r\n        for (var i = 0; i < data.length; i++)\r\n        {\r\n            var source = this.source[i];\r\n\r\n            this.dataSource.push(new TextureSource(this, data[i], source.width, source.height));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the Filter Mode for this Texture.\r\n     *\r\n     * The mode can be either Linear, the default, or Nearest.\r\n     *\r\n     * For pixel-art you should use Nearest.\r\n     *\r\n     * The mode applies to the entire Texture, not just a specific Frame of it.\r\n     *\r\n     * @method Phaser.Textures.Texture#setFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.\r\n     */\r\n    setFilter: function (filterMode)\r\n    {\r\n        var i;\r\n\r\n        for (i = 0; i < this.source.length; i++)\r\n        {\r\n            this.source[i].setFilter(filterMode);\r\n        }\r\n\r\n        for (i = 0; i < this.dataSource.length; i++)\r\n        {\r\n            this.dataSource[i].setFilter(filterMode);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Texture and releases references to its sources and frames.\r\n     *\r\n     * @method Phaser.Textures.Texture#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        var i;\r\n\r\n        for (i = 0; i < this.source.length; i++)\r\n        {\r\n            this.source[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this.dataSource.length; i++)\r\n        {\r\n            this.dataSource[i].destroy();\r\n        }\r\n\r\n        for (var frameName in this.frames)\r\n        {\r\n            var frame = this.frames[frameName];\r\n\r\n            frame.destroy();\r\n        }\r\n\r\n        this.source = [];\r\n        this.dataSource = [];\r\n        this.frames = {};\r\n\r\n        this.manager.removeKey(this.key);\r\n\r\n        var renderer = this.manager.game.renderer;\r\n\r\n        if (renderer && renderer.type === CONST.WEBGL)\r\n        {\r\n            renderer.resetTextures(true);\r\n        }\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Texture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../display/canvas/CanvasPool');\r\nvar CanvasTexture = require('./CanvasTexture');\r\nvar Class = require('../utils/Class');\r\nvar Color = require('../display/color/Color');\r\nvar CONST = require('../const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GenerateTexture = require('../create/GenerateTexture');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar Parser = require('./parsers');\r\nvar Texture = require('./Texture');\r\n\r\n/**\r\n * @callback EachTextureCallback\r\n *\r\n * @param {Phaser.Textures.Texture} texture - Each texture in Texture Manager.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Textures are managed by the global TextureManager. This is a singleton class that is\r\n * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.\r\n *\r\n * Sprites and other Game Objects get the texture data they need from the TextureManager.\r\n *\r\n * Access it via `scene.textures`.\r\n *\r\n * @class TextureManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Texture Manager belongs to.\r\n */\r\nvar TextureManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function TextureManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Game that this TextureManager belongs to.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * The name of this manager.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = 'TextureManager';\r\n\r\n        /**\r\n         * An object that has all of textures that Texture Manager creates.\r\n         * Textures are assigned to keys so we can access to any texture that this object has directly by key value without iteration.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#list\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = {};\r\n\r\n        /**\r\n         * The temporary canvas element to save an pixel data of an arbitrary texture in getPixel() and getPixelAlpha() method.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempCanvas = CanvasPool.create2D(this, 1, 1);\r\n\r\n        /**\r\n         * The context of the temporary canvas element made to save an pixel data in getPixel() and getPixelAlpha() method.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_tempContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempContext = this._tempCanvas.getContext('2d');\r\n\r\n        /**\r\n         * An counting value used for emitting 'ready' event after all of managers in game is loaded.\r\n         *\r\n         * @name Phaser.Textures.TextureManager#_pending\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = 0;\r\n\r\n        game.events.once(GameEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot Handler called by Phaser.Game when it first starts up.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this._pending = 3;\r\n\r\n        this.on(Events.LOAD, this.updatePending, this);\r\n        this.on(Events.ERROR, this.updatePending, this);\r\n\r\n        var config = this.game.config;\r\n\r\n        this.addBase64('__DEFAULT', config.defaultImage);\r\n        this.addBase64('__MISSING', config.missingImage);\r\n        this.addBase64('__WHITE', config.whiteImage);\r\n\r\n        this.game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * After 'onload' or 'onerror' invoked twice, emit 'ready' event.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#updatePending\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    updatePending: function ()\r\n    {\r\n        this._pending--;\r\n\r\n        if (this._pending === 0)\r\n        {\r\n            this.off(Events.LOAD);\r\n            this.off(Events.ERROR);\r\n\r\n            this.emit(Events.READY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks the given texture key and throws a console.warn if the key is already in use, then returns false.\r\n     * If you wish to avoid the console.warn then use `TextureManager.exists` instead.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#checkKey\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} key - The texture key to check.\r\n     *\r\n     * @return {boolean} `true` if it's safe to use the texture key, otherwise `false`.\r\n     */\r\n    checkKey: function (key)\r\n    {\r\n        if (this.exists(key))\r\n        {\r\n            // eslint-disable-next-line no-console\r\n            console.error('Texture key already in use: ' + key);\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Removes a Texture from the Texture Manager and destroys it. This will immediately\r\n     * clear all references to it from the Texture Manager, and if it has one, destroy its\r\n     * WebGLTexture. This will emit a `removetexture` event.\r\n     *\r\n     * Note: If you have any Game Objects still using this texture they will start throwing\r\n     * errors the next time they try to render. Make sure that removing the texture is the final\r\n     * step when clearing down to avoid this.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#remove\r\n     * @fires Phaser.Textures.Events#REMOVE\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|Phaser.Textures.Texture)} key - The key of the Texture to remove, or a reference to it.\r\n     *\r\n     * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.exists(key))\r\n            {\r\n                key = this.get(key);\r\n            }\r\n            else\r\n            {\r\n                console.warn('No texture found matching key: ' + key);\r\n                return this;\r\n            }\r\n        }\r\n\r\n        //  By this point key should be a Texture, if not, the following fails anyway\r\n        if (this.list.hasOwnProperty(key.key))\r\n        {\r\n            key.destroy();\r\n\r\n            this.emit(Events.REMOVE, key.key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a key from the Texture Manager but does not destroy the Texture that was using the key.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#removeKey\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key to remove from the texture list.\r\n     *\r\n     * @return {Phaser.Textures.TextureManager} The Texture Manager.\r\n     */\r\n    removeKey: function (key)\r\n    {\r\n        if (this.list.hasOwnProperty(key))\r\n        {\r\n            delete this.list[key];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.\r\n     *\r\n     * It works by creating an `Image` DOM object, then setting the `src` attribute to\r\n     * the given base64 encoded data. As a result, the process is asynchronous by its nature,\r\n     * so be sure to listen for the events this method dispatches before using the texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addBase64\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @fires Phaser.Textures.Events#ERROR\r\n     * @fires Phaser.Textures.Events#LOAD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {*} data - The Base64 encoded data.\r\n     *\r\n     * @return {this} This Texture Manager instance.\r\n     */\r\n    addBase64: function (key, data)\r\n    {\r\n        if (this.checkKey(key))\r\n        {\r\n            var _this = this;\r\n\r\n            var image = new Image();\r\n\r\n            image.onerror = function ()\r\n            {\r\n                _this.emit(Events.ERROR, key);\r\n            };\r\n\r\n            image.onload = function ()\r\n            {\r\n                var texture = _this.create(key, image);\r\n\r\n                Parser.Image(texture, 0);\r\n\r\n                _this.emit(Events.ADD, key, texture);\r\n\r\n                _this.emit(Events.LOAD, key, texture);\r\n            };\r\n\r\n            image.src = data;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets an existing texture frame and converts it into a base64 encoded image and returns the base64 data.\r\n     *\r\n     * You can also provide the image type and encoder options.\r\n     *\r\n     * This will only work with bitmap based texture frames, such as those created from Texture Atlases.\r\n     * It will not work with GL Texture objects, such as Shaders, or Render Textures. For those please\r\n     * see the WebGL Snapshot function instead.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getBase64\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     * @param {string} [type='image/png'] - A DOMString indicating the image format. The default format type is image/png.\r\n     * @param {number} [encoderOptions=0.92] - A Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp. If this argument is anything else, the default value for image quality is used. The default value is 0.92. Other arguments are ignored.\r\n     *\r\n     * @return {string} The base64 encoded data, or an empty string if the texture frame could not be found.\r\n     */\r\n    getBase64: function (key, frame, type, encoderOptions)\r\n    {\r\n        if (type === undefined) { type = 'image/png'; }\r\n        if (encoderOptions === undefined) { encoderOptions = 0.92; }\r\n\r\n        var data = '';\r\n\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame && (textureFrame.source.isRenderTexture || textureFrame.source.isGLTexture))\r\n        {\r\n            console.warn('Cannot getBase64 from WebGL Texture');\r\n        }\r\n        else if (textureFrame)\r\n        {\r\n            var cd = textureFrame.canvasData;\r\n\r\n            var canvas = CanvasPool.create2D(this, cd.width, cd.height);\r\n            var ctx = canvas.getContext('2d');\r\n\r\n            ctx.drawImage(\r\n                textureFrame.source.image,\r\n                cd.x,\r\n                cd.y,\r\n                cd.width,\r\n                cd.height,\r\n                0,\r\n                0,\r\n                cd.width,\r\n                cd.height\r\n            );\r\n\r\n            data = canvas.toDataURL(type, encoderOptions);\r\n\r\n            CanvasPool.remove(canvas);\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture to the Texture Manager created from the given Image element.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addImage\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {HTMLImageElement|HTMLCanvasElement} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addImage: function (key, source, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            Parser.Image(texture, 0);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Takes a WebGL Texture and creates a Phaser Texture from it, which is added to the Texture Manager using the given key.\r\n     *\r\n     * This allows you to then use the Texture as a normal texture for texture based Game Objects like Sprites.\r\n     *\r\n     * If the `width` and `height` arguments are omitted, but the WebGL Texture was created by Phaser's WebGL Renderer\r\n     * and has `glTexture.width` and `glTexture.height` properties, these values will be used instead.\r\n     *\r\n     * This is a WebGL only feature.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addGLTexture\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {WebGLTexture} glTexture - The source Render Texture.\r\n     * @param {number} [width] - The new width of the Texture. Read from `glTexture.width` if omitted.\r\n     * @param {number} [height] - The new height of the Texture. Read from `glTexture.height` if omitted.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addGLTexture: function (key, glTexture, width, height)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            if (width === undefined) { width = glTexture.width; }\r\n            if (height === undefined) { height = glTexture.height; }\r\n\r\n            texture = this.create(key, glTexture, width, height);\r\n\r\n            texture.add('__BASE', 0, 0, 0, width, height);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Render Texture to the Texture Manager using the given key.\r\n     * This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addRenderTexture\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {Phaser.GameObjects.RenderTexture} renderTexture - The source Render Texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addRenderTexture: function (key, renderTexture)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, renderTexture);\r\n\r\n            texture.add('__BASE', 0, 0, 0, renderTexture.width, renderTexture.height);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using the given config values.\r\n     *\r\n     * Generated textures consist of a Canvas element to which the texture data is drawn.\r\n     *\r\n     * Generates a texture based on the given Create configuration object.\r\n     *\r\n     * The texture is drawn using a fixed-size indexed palette of 16 colors, where the hex value in the\r\n     * data cells map to a single color. For example, if the texture config looked like this:\r\n     *\r\n     * ```javascript\r\n     * var star = [\r\n     *   '.....828.....',\r\n     *   '....72227....',\r\n     *   '....82228....',\r\n     *   '...7222227...',\r\n     *   '2222222222222',\r\n     *   '8222222222228',\r\n     *   '.72222222227.',\r\n     *   '..787777787..',\r\n     *   '..877777778..',\r\n     *   '.78778887787.',\r\n     *   '.27887.78872.',\r\n     *   '.787.....787.'\r\n     * ];\r\n     *\r\n     * this.textures.generate('star', { data: star, pixelWidth: 4 });\r\n     * ```\r\n     *\r\n     * Then it would generate a texture that is 52 x 48 pixels in size, because each cell of the data array\r\n     * represents 1 pixel multiplied by the `pixelWidth` value. The cell values, such as `8`, maps to color\r\n     * number 8 in the palette. If a cell contains a period character `.` then it is transparent.\r\n     *\r\n     * The default palette is Arne16, but you can specify your own using the `palette` property.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#generate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {Phaser.Types.Create.GenerateTextureConfig} config - The configuration object needed to generate the texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    generate: function (key, config)\r\n    {\r\n        if (this.checkKey(key))\r\n        {\r\n            var canvas = CanvasPool.create(this, 1, 1);\r\n\r\n            config.canvas = canvas;\r\n\r\n            GenerateTexture(config);\r\n\r\n            return this.addCanvas(key, canvas);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using a blank Canvas element of the size given.\r\n     *\r\n     * Canvas elements are automatically pooled and calling this method will\r\n     * extract a free canvas from the CanvasPool, or create one if none are available.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#createCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {number} [width=256] - The width of the Canvas element.\r\n     * @param {number} [height=256] - The height of the Canvas element.\r\n     *\r\n     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    createCanvas: function (key, width, height)\r\n    {\r\n        if (width === undefined) { width = 256; }\r\n        if (height === undefined) { height = 256; }\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            var canvas = CanvasPool.create(this, width, height, CONST.CANVAS, true);\r\n\r\n            return this.addCanvas(key, canvas);\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Canvas Texture object from an existing Canvas element\r\n     * and adds it to this Texture Manager, unless `skipCache` is true.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addCanvas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLCanvasElement} source - The Canvas element to form the base of the new Texture.\r\n     * @param {boolean} [skipCache=false] - Skip adding this Texture into the Cache?\r\n     *\r\n     * @return {?Phaser.Textures.CanvasTexture} The Canvas Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addCanvas: function (key, source, skipCache)\r\n    {\r\n        if (skipCache === undefined) { skipCache = false; }\r\n\r\n        var texture = null;\r\n\r\n        if (skipCache)\r\n        {\r\n            texture = new CanvasTexture(this, key, source, source.width, source.height);\r\n        }\r\n        else if (this.checkKey(key))\r\n        {\r\n            texture = new CanvasTexture(this, key, source, source.width, source.height);\r\n\r\n            this.list[key] = texture;\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Texture Atlas to this Texture Manager.\r\n     * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlas: function (key, source, data, dataSource)\r\n    {\r\n        //  New Texture Packer format?\r\n        if (Array.isArray(data.textures) || Array.isArray(data.frames))\r\n        {\r\n            return this.addAtlasJSONArray(key, source, data, dataSource);\r\n        }\r\n        else\r\n        {\r\n            return this.addAtlasJSONHash(key, source, data, dataSource);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Array within the JSON.\r\n     * This is known as a JSON Array in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONArray\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(HTMLImageElement|HTMLImageElement[])} source - The source Image element/s.\r\n     * @param {(object|object[])} data - The Texture Atlas data/s.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasJSONArray: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            //  Multi-Atlas?\r\n            if (Array.isArray(data))\r\n            {\r\n                var singleAtlasFile = (data.length === 1); // multi-pack with one atlas file for all images\r\n\r\n                //  !! Assumes the textures are in the same order in the source array as in the json data !!\r\n                for (var i = 0; i < texture.source.length; i++)\r\n                {\r\n                    var atlasData = singleAtlasFile ? data[0] : data[i];\r\n\r\n                    Parser.JSONArray(texture, i, atlasData);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                Parser.JSONArray(texture, 0, data);\r\n            }\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager.\r\n     * The frame data of the atlas must be stored in an Object within the JSON.\r\n     * This is known as a JSON Hash in software such as Texture Packer.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasJSONHash\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasJSONHash: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            if (Array.isArray(data))\r\n            {\r\n                for (var i = 0; i < data.length; i++)\r\n                {\r\n                    Parser.JSONHash(texture, i, data[i]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                Parser.JSONHash(texture, 0, data);\r\n            }\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Atlas to this Texture Manager, where the atlas data is given\r\n     * in the XML format.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addAtlasXML\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas XML data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addAtlasXML: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            Parser.AtlasXML(texture, 0, data);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Unity Texture Atlas to this Texture Manager.\r\n     * The data must be in the form of a Unity YAML file.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addUnityAtlas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {object} data - The Texture Atlas data.\r\n     * @param {HTMLImageElement|HTMLCanvasElement|HTMLImageElement[]|HTMLCanvasElement[]} [dataSource] - An optional data Image element.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addUnityAtlas: function (key, source, data, dataSource)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            Parser.UnityYAML(texture, 0, data);\r\n\r\n            if (dataSource)\r\n            {\r\n                texture.setDataSource(dataSource);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Sprite Sheet to this Texture Manager.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheet\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {Phaser.Types.Textures.SpriteSheetConfig} config - The configuration object for this Sprite Sheet.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addSpriteSheet: function (key, source, config)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = this.create(key, source);\r\n\r\n            var width = texture.source[0].width;\r\n            var height = texture.source[0].height;\r\n\r\n            Parser.SpriteSheet(texture, 0, 0, 0, width, height, config);\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.\r\n     *\r\n     * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n     * same size and cannot be trimmed or rotated.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#addSpriteSheetFromAtlas\r\n     * @fires Phaser.Textures.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {Phaser.Types.Textures.SpriteSheetFromAtlasConfig} config - The configuration object for this Sprite Sheet.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    addSpriteSheetFromAtlas: function (key, config)\r\n    {\r\n        if (!this.checkKey(key))\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var atlasKey = GetValue(config, 'atlas', null);\r\n        var atlasFrame = GetValue(config, 'frame', null);\r\n\r\n        if (!atlasKey || !atlasFrame)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var atlas = this.get(atlasKey);\r\n        var sheet = atlas.get(atlasFrame);\r\n\r\n        if (sheet)\r\n        {\r\n            var texture = this.create(key, sheet.source.image);\r\n\r\n            if (sheet.trimmed)\r\n            {\r\n                //  If trimmed we need to help the parser adjust\r\n                Parser.SpriteSheetFromAtlas(texture, sheet, config);\r\n            }\r\n            else\r\n            {\r\n                Parser.SpriteSheet(texture, 0, sheet.cutX, sheet.cutY, sheet.cutWidth, sheet.cutHeight, config);\r\n            }\r\n\r\n            this.emit(Events.ADD, key, texture);\r\n\r\n            return texture;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new Texture using the given source and dimensions.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {HTMLImageElement} source - The source Image element.\r\n     * @param {number} width - The width of the Texture.\r\n     * @param {number} height - The height of the Texture.\r\n     *\r\n     * @return {?Phaser.Textures.Texture} The Texture that was created, or `null` if the key is already in use.\r\n     */\r\n    create: function (key, source, width, height)\r\n    {\r\n        var texture = null;\r\n\r\n        if (this.checkKey(key))\r\n        {\r\n            texture = new Texture(this, key, source, width, height);\r\n\r\n            this.list[key] = texture;\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Checks the given key to see if a Texture using it exists within this Texture Manager.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#exists\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     *\r\n     * @return {boolean} Returns `true` if a Texture matching the given key exists in this Texture Manager.\r\n     */\r\n    exists: function (key)\r\n    {\r\n        return (this.list.hasOwnProperty(key));\r\n    },\r\n\r\n    /**\r\n     * Returns a Texture from the Texture Manager that matches the given key.\r\n     *\r\n     * If the key is `undefined` it will return the `__DEFAULT` Texture.\r\n     *\r\n     * If the key is an instance of a Texture, it will return the key directly.\r\n     *\r\n     * Finally. if the key is given, but not found and not a Texture instance, it will return the `__MISSING` Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Textures.Texture)} key - The unique string-based key of the Texture, or a Texture instance.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was created.\r\n     */\r\n    get: function (key)\r\n    {\r\n        if (key === undefined) { key = '__DEFAULT'; }\r\n\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key];\r\n        }\r\n        else if (key instanceof Texture)\r\n        {\r\n            return key;\r\n        }\r\n        else\r\n        {\r\n            return this.list['__MISSING'];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Texture key and Frame name and returns a clone of that Frame if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#cloneFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} frame - The string or index of the Frame to be cloned.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Clone of the given Frame.\r\n     */\r\n    cloneFrame: function (key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key].get(frame).clone();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Texture key and Frame name and returns a reference to that Frame, if found.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string-based name, or integer based index, of the Frame to get from the Texture.\r\n     *\r\n     * @return {Phaser.Textures.Frame} A Texture Frame object.\r\n     */\r\n    getFrame: function (key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            return this.list[key].get(frame);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array with all of the keys of all Textures in this Texture Manager.\r\n     * The output array will exclude the `__DEFAULT` and `__MISSING` keys.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getTextureKeys\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string[]} An array containing all of the Texture keys stored in this Texture Manager.\r\n     */\r\n    getTextureKeys: function ()\r\n    {\r\n        var output = [];\r\n\r\n        for (var key in this.list)\r\n        {\r\n            if (key !== '__DEFAULT' && key !== '__MISSING')\r\n            {\r\n                output.push(key);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Given a Texture and an `x` and `y` coordinate this method will return a new\r\n     * Color object that has been populated with the color and alpha values of the pixel\r\n     * at that location in the Texture.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getPixel\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel within the Texture.\r\n     * @param {number} y - The y coordinate of the pixel within the Texture.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {?Phaser.Display.Color} A Color object populated with the color values of the requested pixel,\r\n     * or `null` if the coordinates were out of bounds.\r\n     */\r\n    getPixel: function (x, y, key, frame)\r\n    {\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            //  Adjust for trim (if not trimmed x and y are just zero)\r\n            x -= textureFrame.x;\r\n            y -= textureFrame.y;\r\n\r\n            var data = textureFrame.data.cut;\r\n\r\n            x += data.x;\r\n            y += data.y;\r\n\r\n            if (x >= data.x && x < data.r && y >= data.y && y < data.b)\r\n            {\r\n                var ctx = this._tempContext;\r\n\r\n                ctx.clearRect(0, 0, 1, 1);\r\n                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\r\n\r\n                var rgb = ctx.getImageData(0, 0, 1, 1);\r\n\r\n                return new Color(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Given a Texture and an `x` and `y` coordinate this method will return a value between 0 and 255\r\n     * corresponding to the alpha value of the pixel at that location in the Texture. If the coordinate\r\n     * is out of bounds it will return null.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#getPixelAlpha\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel within the Texture.\r\n     * @param {number} y - The y coordinate of the pixel within the Texture.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {number} A value between 0 and 255, or `null` if the coordinates were out of bounds.\r\n     */\r\n    getPixelAlpha: function (x, y, key, frame)\r\n    {\r\n        var textureFrame = this.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            //  Adjust for trim (if not trimmed x and y are just zero)\r\n            x -= textureFrame.x;\r\n            y -= textureFrame.y;\r\n\r\n            var data = textureFrame.data.cut;\r\n\r\n            x += data.x;\r\n            y += data.y;\r\n\r\n            if (x >= data.x && x < data.r && y >= data.y && y < data.b)\r\n            {\r\n                var ctx = this._tempContext;\r\n\r\n                ctx.clearRect(0, 0, 1, 1);\r\n                ctx.drawImage(textureFrame.source.image, x, y, 1, 1, 0, 0, 1, 1);\r\n\r\n                var rgb = ctx.getImageData(0, 0, 1, 1);\r\n\r\n                return rgb.data[3];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Sets the given Game Objects `texture` and `frame` properties so that it uses\r\n     * the Texture and Frame specified in the `key` and `frame` arguments to this method.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the texture would be set on.\r\n     * @param {string} key - The unique string-based key of the Texture.\r\n     * @param {(string|number)} [frame] - The string or index of the Frame.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object the texture was set on.\r\n     */\r\n    setTexture: function (gameObject, key, frame)\r\n    {\r\n        if (this.list[key])\r\n        {\r\n            gameObject.texture = this.list[key];\r\n            gameObject.frame = gameObject.texture.get(frame);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Changes the key being used by a Texture to the new key provided.\r\n     *\r\n     * The old key is removed, allowing it to be re-used.\r\n     *\r\n     * Game Objects are linked to Textures by a reference to the Texture object, so\r\n     * all existing references will be retained.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#renameTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} currentKey - The current string-based key of the Texture you wish to rename.\r\n     * @param {string} newKey - The new unique string-based key to use for the Texture.\r\n     *\r\n     * @return {boolean} `true` if the Texture key was successfully renamed, otherwise `false`.\r\n     */\r\n    renameTexture: function (currentKey, newKey)\r\n    {\r\n        var texture = this.get(currentKey);\r\n\r\n        if (texture && currentKey !== newKey)\r\n        {\r\n            texture.key = newKey;\r\n\r\n            this.list[newKey] = texture;\r\n\r\n            delete this.list[currentKey];\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Passes all Textures to the given callback.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#each\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTextureCallback} callback - The callback function to be sent the Textures.\r\n     * @param {object} scope - The value to use as `this` when executing the callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n    each: function (callback, scope)\r\n    {\r\n        var args = [ null ];\r\n\r\n        for (var i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (var texture in this.list)\r\n        {\r\n            args[0] = this.list[texture];\r\n\r\n            callback.apply(scope, args);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the Texture Manager and all Textures stored within it.\r\n     *\r\n     * @method Phaser.Textures.TextureManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var texture in this.list)\r\n        {\r\n            this.list[texture].destroy();\r\n        }\r\n\r\n        this.list = {};\r\n\r\n        this.game = null;\r\n\r\n        CanvasPool.remove(this._tempCanvas);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TextureManager;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CanvasPool = require('../display/canvas/CanvasPool');\nvar Class = require('../utils/Class');\nvar IsSizePowerOfTwo = require('../math/pow2/IsSizePowerOfTwo');\nvar ScaleModes = require('../renderer/ScaleModes');\n\n/**\n * @classdesc\n * A Texture Source is the encapsulation of the actual source data for a Texture.\n *\n * This is typically an Image Element, loaded from the file system or network, a Canvas Element or a Video Element.\n *\n * A Texture can contain multiple Texture Sources, which only happens when a multi-atlas is loaded.\n *\n * @class TextureSource\n * @memberof Phaser.Textures\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Textures.Texture} texture - The Texture this TextureSource belongs to.\n * @param {(HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|Phaser.GameObjects.RenderTexture|WebGLTexture)} source - The source image data.\n * @param {number} [width] - Optional width of the source image. If not given it's derived from the source itself.\n * @param {number} [height] - Optional height of the source image. If not given it's derived from the source itself.\n * @param {boolean} [flipY=false] - Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.\n */\nvar TextureSource = new Class({\n\n    initialize:\n\n    function TextureSource (texture, source, width, height, flipY)\n    {\n        if (flipY === undefined) { flipY = false; }\n\n        var game = texture.manager.game;\n\n        /**\n         * The Texture this TextureSource belongs to.\n         *\n         * @name Phaser.Textures.TextureSource#renderer\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\n         * @since 3.7.0\n         */\n        this.renderer = game.renderer;\n\n        /**\n         * The Texture this TextureSource belongs to.\n         *\n         * @name Phaser.Textures.TextureSource#texture\n         * @type {Phaser.Textures.Texture}\n         * @since 3.0.0\n         */\n        this.texture = texture;\n\n        /**\n         * The source of the image data.\n         *\n         * This is either an Image Element, a Canvas Element, a Video Element, a RenderTexture or a WebGLTexture.\n         *\n         * @name Phaser.Textures.TextureSource#source\n         * @type {(HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|Phaser.GameObjects.RenderTexture|WebGLTexture)}\n         * @since 3.12.0\n         */\n        this.source = source;\n\n        /**\n         * The image data.\n         *\n         * This is either an Image element, Canvas element or a Video Element.\n         *\n         * @name Phaser.Textures.TextureSource#image\n         * @type {(HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)}\n         * @since 3.0.0\n         */\n        this.image = source;\n\n        /**\n         * Currently un-used.\n         *\n         * @name Phaser.Textures.TextureSource#compressionAlgorithm\n         * @type {number}\n         * @default null\n         * @since 3.0.0\n         */\n        this.compressionAlgorithm = null;\n\n        /**\n         * The resolution of the source image.\n         *\n         * @name Phaser.Textures.TextureSource#resolution\n         * @type {number}\n         * @default 1\n         * @since 3.0.0\n         */\n        this.resolution = 1;\n\n        /**\n         * The width of the source image. If not specified in the constructor it will check\n         * the `naturalWidth` and then `width` properties of the source image.\n         *\n         * @name Phaser.Textures.TextureSource#width\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.width = width || source.naturalWidth || source.videoWidth || source.width || 0;\n\n        /**\n         * The height of the source image. If not specified in the constructor it will check\n         * the `naturalHeight` and then `height` properties of the source image.\n         *\n         * @name Phaser.Textures.TextureSource#height\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.height = height || source.naturalHeight || source.videoHeight || source.height || 0;\n\n        /**\n         * The Scale Mode the image will use when rendering.\n         * Either Linear or Nearest.\n         *\n         * @name Phaser.Textures.TextureSource#scaleMode\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.scaleMode = ScaleModes.DEFAULT;\n\n        /**\n         * Is the source image a Canvas Element?\n         *\n         * @name Phaser.Textures.TextureSource#isCanvas\n         * @type {boolean}\n         * @since 3.0.0\n         */\n        this.isCanvas = (source instanceof HTMLCanvasElement);\n\n        /**\n         * Is the source image a Video Element?\n         *\n         * @name Phaser.Textures.TextureSource#isVideo\n         * @type {boolean}\n         * @since 3.20.0\n         */\n        this.isVideo = (window.hasOwnProperty('HTMLVideoElement') && source instanceof HTMLVideoElement);\n\n        /**\n         * Is the source image a Render Texture?\n         *\n         * @name Phaser.Textures.TextureSource#isRenderTexture\n         * @type {boolean}\n         * @since 3.12.0\n         */\n        this.isRenderTexture = (source.type === 'RenderTexture');\n\n        /**\n         * Is the source image a WebGLTexture?\n         *\n         * @name Phaser.Textures.TextureSource#isGLTexture\n         * @type {boolean}\n         * @since 3.19.0\n         */\n        this.isGLTexture = (window.hasOwnProperty('WebGLTexture') && source instanceof WebGLTexture);\n\n        /**\n         * Are the source image dimensions a power of two?\n         *\n         * @name Phaser.Textures.TextureSource#isPowerOf2\n         * @type {boolean}\n         * @since 3.0.0\n         */\n        this.isPowerOf2 = IsSizePowerOfTwo(this.width, this.height);\n\n        /**\n         * The WebGL Texture of the source image. If this TextureSource is driven from a WebGLTexture\n         * already, then this is a reference to that WebGLTexture.\n         *\n         * @name Phaser.Textures.TextureSource#glTexture\n         * @type {?WebGLTexture}\n         * @default null\n         * @since 3.0.0\n         */\n        this.glTexture = null;\n\n        /**\n         * The current texture unit index as assigned by the WebGL Renderer.\n         * Un-used in canvas. Should be treated as read-only.\n         *\n         * @name Phaser.Textures.TextureSource#glIndex\n         * @type {number}\n         * @default 0\n         * @since 3.50.0\n         */\n        this.glIndex = 0;\n\n        /**\n         * The counter value when this texture was last assigned an index by the WebGL Renderer.\n         * Un-used in canvas. Should be treated as read-only.\n         *\n         * @name Phaser.Textures.TextureSource#glIndexCounter\n         * @type {number}\n         * @default -1\n         * @since 3.50.0\n         */\n        this.glIndexCounter = -1;\n\n        /**\n         * Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.\n         *\n         * @name Phaser.Textures.TextureSource#flipY\n         * @type {boolean}\n         * @since 3.20.0\n         */\n        this.flipY = flipY;\n\n        this.init(game);\n    },\n\n    /**\n     * Creates a WebGL Texture, if required, and sets the Texture filter mode.\n     *\n     * @method Phaser.Textures.TextureSource#init\n     * @since 3.0.0\n     *\n     * @param {Phaser.Game} game - A reference to the Phaser Game instance.\n     */\n    init: function (game)\n    {\n        var renderer = this.renderer;\n\n        if (renderer)\n        {\n            if (renderer.gl)\n            {\n                if (this.isCanvas)\n                {\n                    this.glTexture = renderer.createCanvasTexture(this.image, false, this.flipY);\n                }\n                else if (this.isVideo)\n                {\n                    this.glTexture = renderer.createVideoTexture(this.image, false, this.flipY);\n                }\n                else if (this.isRenderTexture)\n                {\n                    this.image = this.source.canvas;\n\n                    this.glTexture = renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode);\n                }\n                else if (this.isGLTexture)\n                {\n                    this.glTexture = this.source;\n                }\n                else\n                {\n                    this.glTexture = renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode);\n                }\n            }\n            else if (this.isRenderTexture)\n            {\n                this.image = this.source.canvas;\n            }\n        }\n\n        if (!game.config.antialias)\n        {\n            this.setFilter(1);\n        }\n    },\n\n    /**\n     * Sets the Filter Mode for this Texture.\n     *\n     * The mode can be either Linear, the default, or Nearest.\n     *\n     * For pixel-art you should use Nearest.\n     *\n     * @method Phaser.Textures.TextureSource#setFilter\n     * @since 3.0.0\n     *\n     * @param {Phaser.Textures.FilterMode} filterMode - The Filter Mode.\n     */\n    setFilter: function (filterMode)\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.setTextureFilter(this.glTexture, filterMode);\n        }\n\n        this.scaleMode = filterMode;\n    },\n\n    /**\n     * Sets the `UNPACK_FLIP_Y_WEBGL` flag for the WebGL Texture during texture upload.\n     *\n     * @method Phaser.Textures.TextureSource#setFlipY\n     * @since 3.20.0\n     *\n     * @param {boolean} [value=true] - Should the WebGL Texture be flipped on the Y axis on texture upload or not?\n     */\n    setFlipY: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.flipY = value;\n\n        return this;\n    },\n\n    /**\n     * If this TextureSource is backed by a Canvas and is running under WebGL,\n     * it updates the WebGLTexture using the canvas data.\n     *\n     * @method Phaser.Textures.TextureSource#update\n     * @since 3.7.0\n     */\n    update: function ()\n    {\n        var gl = this.renderer.gl;\n\n        if (gl && this.isCanvas)\n        {\n            this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY);\n        }\n        else if (gl && this.isVideo)\n        {\n            this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY);\n        }\n    },\n\n    /**\n     * Destroys this Texture Source and nulls the references.\n     *\n     * @method Phaser.Textures.TextureSource#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        if (this.glTexture)\n        {\n            this.renderer.deleteTexture(this.glTexture, true);\n        }\n\n        if (this.isCanvas)\n        {\n            CanvasPool.remove(this.image);\n        }\n\n        this.renderer = null;\n        this.texture = null;\n        this.source = null;\n        this.image = null;\n        this.glTexture = null;\n    }\n\n});\n\nmodule.exports = TextureSource;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Parses an XML Texture Atlas object and adds all the Frames into a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.AtlasXML\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n * @param {*} xml - The XML data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar AtlasXML = function (texture, sourceIndex, xml)\r\n{\r\n    //  Malformed?\r\n    if (!xml.getElementsByTagName('TextureAtlas'))\r\n    {\r\n        console.warn('Invalid Texture Atlas XML given');\r\n        return;\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    //  By this stage frames is a fully parsed array\r\n    var frames = xml.getElementsByTagName('SubTexture');\r\n\r\n    var newFrame;\r\n\r\n    for (var i = 0; i < frames.length; i++)\r\n    {\r\n        var frame = frames[i].attributes;\r\n\r\n        var name = frame.name.value;\r\n        var x = parseInt(frame.x.value, 10);\r\n        var y = parseInt(frame.y.value, 10);\r\n        var width = parseInt(frame.width.value, 10);\r\n        var height = parseInt(frame.height.value, 10);\r\n\r\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n        newFrame = texture.add(name, sourceIndex, x, y, width, height);\r\n\r\n        //  These are the original (non-trimmed) sprite values\r\n        if (frame.frameX)\r\n        {\r\n            var frameX = Math.abs(parseInt(frame.frameX.value, 10));\r\n            var frameY = Math.abs(parseInt(frame.frameY.value, 10));\r\n            var frameWidth = parseInt(frame.frameWidth.value, 10);\r\n            var frameHeight = parseInt(frame.frameHeight.value, 10);\r\n\r\n            newFrame.setTrim(\r\n                width,\r\n                height,\r\n                frameX,\r\n                frameY,\r\n                frameWidth,\r\n                frameHeight\r\n            );\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = AtlasXML;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Adds a Canvas Element to a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.Canvas\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar Canvas = function (texture, sourceIndex)\r\n{\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = Canvas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Adds an Image Element to a Texture.\r\n *\r\n * @function Phaser.Textures.Parsers.Image\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar Image = function (texture, sourceIndex)\r\n{\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = Image;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clone = require('../../utils/object/Clone');\r\n\r\n/**\r\n * Parses a Texture Atlas JSON Array and adds the Frames to the Texture.\r\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an array of Frames.\r\n *\r\n * @function Phaser.Textures.Parsers.JSONArray\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n * @param {object} json - The JSON data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar JSONArray = function (texture, sourceIndex, json)\r\n{\r\n    //  Malformed?\r\n    if (!json['frames'] && !json['textures'])\r\n    {\r\n        console.warn('Invalid Texture Atlas JSON Array');\r\n        return;\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    //  By this stage frames is a fully parsed array\r\n    var frames = (Array.isArray(json.textures)) ? json.textures[sourceIndex].frames : json.frames;\r\n\r\n    var newFrame;\r\n\r\n    for (var i = 0; i < frames.length; i++)\r\n    {\r\n        var src = frames[i];\r\n\r\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n        newFrame = texture.add(src.filename, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\r\n\r\n        //  These are the original (non-trimmed) sprite values\r\n        if (src.trimmed)\r\n        {\r\n            newFrame.setTrim(\r\n                src.sourceSize.w,\r\n                src.sourceSize.h,\r\n                src.spriteSourceSize.x,\r\n                src.spriteSourceSize.y,\r\n                src.spriteSourceSize.w,\r\n                src.spriteSourceSize.h\r\n            );\r\n        }\r\n\r\n        if (src.rotated)\r\n        {\r\n            newFrame.rotated = true;\r\n            newFrame.updateUVsInverted();\r\n        }\r\n\r\n        var pivot = src.anchor || src.pivot;\r\n\r\n        if (pivot)\r\n        {\r\n            newFrame.customPivot = true;\r\n            newFrame.pivotX = pivot.x;\r\n            newFrame.pivotY = pivot.y;\r\n        }\r\n\r\n        //  Copy over any extra data\r\n        newFrame.customData = Clone(src);\r\n    }\r\n\r\n    //  Copy over any additional data that was in the JSON to Texture.customData\r\n    for (var dataKey in json)\r\n    {\r\n        if (dataKey === 'frames')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (Array.isArray(json[dataKey]))\r\n        {\r\n            texture.customData[dataKey] = json[dataKey].slice(0);\r\n        }\r\n        else\r\n        {\r\n            texture.customData[dataKey] = json[dataKey];\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = JSONArray;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Clone = require('../../utils/object/Clone');\n\n/**\n * Parses a Texture Atlas JSON Hash and adds the Frames to the Texture.\n * JSON format expected to match that defined by Texture Packer, with the frames property containing an object of Frames.\n *\n * @function Phaser.Textures.Parsers.JSONHash\n * @memberof Phaser.Textures.Parsers\n * @private\n * @since 3.0.0\n *\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\n * @param {number} sourceIndex - The index of the TextureSource.\n * @param {object} json - The JSON data.\n *\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\n */\nvar JSONHash = function (texture, sourceIndex, json)\n{\n    //  Malformed?\n    if (!json['frames'])\n    {\n        console.warn('Invalid Texture Atlas JSON Hash given, missing \\'frames\\' Object');\n        return;\n    }\n\n    //  Add in a __BASE entry (for the entire atlas)\n    var source = texture.source[sourceIndex];\n\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\n\n    //  By this stage frames is a fully parsed Object\n    var frames = json.frames;\n    var newFrame;\n\n    for (var key in frames)\n    {\n        if (!frames.hasOwnProperty(key))\n        {\n            continue;\n        }\n\n        var src = frames[key];\n\n        //  The frame values are the exact coordinates to cut the frame out of the atlas from\n        newFrame = texture.add(key, sourceIndex, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\n\n        //  These are the original (non-trimmed) sprite values\n        if (src.trimmed)\n        {\n            newFrame.setTrim(\n                src.sourceSize.w,\n                src.sourceSize.h,\n                src.spriteSourceSize.x,\n                src.spriteSourceSize.y,\n                src.spriteSourceSize.w,\n                src.spriteSourceSize.h\n            );\n        }\n\n        if (src.rotated)\n        {\n            newFrame.rotated = true;\n            newFrame.updateUVsInverted();\n        }\n\n        var pivot = src.anchor || src.pivot;\n\n        if (pivot)\n        {\n            newFrame.customPivot = true;\n            newFrame.pivotX = pivot.x;\n            newFrame.pivotY = pivot.y;\n        }\n\n        //  Copy over any extra data\n        newFrame.customData = Clone(src);\n    }\n\n    //  Copy over any additional data that was in the JSON to Texture.customData\n    for (var dataKey in json)\n    {\n        if (dataKey === 'frames')\n        {\n            continue;\n        }\n\n        if (Array.isArray(json[dataKey]))\n        {\n            texture.customData[dataKey] = json[dataKey].slice(0);\n        }\n        else\n        {\n            texture.customData[dataKey] = json[dataKey];\n        }\n    }\n\n    return texture;\n};\n\nmodule.exports = JSONHash;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Parses a Sprite Sheet and adds the Frames to the Texture.\r\n *\r\n * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n * same size and cannot be trimmed or rotated.\r\n *\r\n * @function Phaser.Textures.Parsers.SpriteSheet\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n * @param {number} x - The top-left coordinate of the Sprite Sheet. Defaults to zero. Used when extracting sheets from atlases.\r\n * @param {number} y - The top-left coordinate of the Sprite Sheet. Defaults to zero. Used when extracting sheets from atlases.\r\n * @param {number} width - The width of the source image.\r\n * @param {number} height - The height of the source image.\r\n * @param {object} config - An object describing how to parse the Sprite Sheet.\r\n * @param {number} config.frameWidth - Width in pixels of a single frame in the sprite sheet.\r\n * @param {number} [config.frameHeight] - Height in pixels of a single frame in the sprite sheet. Defaults to frameWidth if not provided.\r\n * @param {number} [config.startFrame=0] - The frame to start extracting from. Defaults to zero.\r\n * @param {number} [config.endFrame=-1] - The frame to finish extracting at. Defaults to -1, which means 'all frames'.\r\n * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar SpriteSheet = function (texture, sourceIndex, x, y, width, height, config)\r\n{\r\n    var frameWidth = GetFastValue(config, 'frameWidth', null);\r\n    var frameHeight = GetFastValue(config, 'frameHeight', frameWidth);\r\n\r\n    //  If missing we can't proceed\r\n    if (frameWidth === null)\r\n    {\r\n        throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.');\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    var startFrame = GetFastValue(config, 'startFrame', 0);\r\n    var endFrame = GetFastValue(config, 'endFrame', -1);\r\n    var margin = GetFastValue(config, 'margin', 0);\r\n    var spacing = GetFastValue(config, 'spacing', 0);\r\n\r\n    var row = Math.floor((width - margin + spacing) / (frameWidth + spacing));\r\n    var column = Math.floor((height - margin + spacing) / (frameHeight + spacing));\r\n    var total = row * column;\r\n\r\n    if (total === 0)\r\n    {\r\n        console.warn('SpriteSheet frame dimensions will result in zero frames for texture:', texture.key);\r\n    }\r\n\r\n    if (startFrame > total || startFrame < -total)\r\n    {\r\n        startFrame = 0;\r\n    }\r\n\r\n    if (startFrame < 0)\r\n    {\r\n        //  Allow negative skipframes.\r\n        startFrame = total + startFrame;\r\n    }\r\n\r\n    if (endFrame !== -1)\r\n    {\r\n        total = startFrame + (endFrame + 1);\r\n    }\r\n\r\n    var fx = margin;\r\n    var fy = margin;\r\n    var ax = 0;\r\n    var ay = 0;\r\n\r\n    for (var i = 0; i < total; i++)\r\n    {\r\n        ax = 0;\r\n        ay = 0;\r\n\r\n        var w = fx + frameWidth;\r\n        var h = fy + frameHeight;\r\n\r\n        if (w > width)\r\n        {\r\n            ax = w - width;\r\n        }\r\n\r\n        if (h > height)\r\n        {\r\n            ay = h - height;\r\n        }\r\n\r\n        texture.add(i, sourceIndex, x + fx, y + fy, frameWidth - ax, frameHeight - ay);\r\n\r\n        fx += frameWidth + spacing;\r\n\r\n        if (fx + frameWidth > width)\r\n        {\r\n            fx = margin;\r\n            fy += frameHeight + spacing;\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = SpriteSheet;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Parses a Sprite Sheet and adds the Frames to the Texture, where the Sprite Sheet is stored as a frame within an Atlas.\r\n *\r\n * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact\r\n * same size and cannot be trimmed or rotated.\r\n *\r\n * @function Phaser.Textures.Parsers.SpriteSheetFromAtlas\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {Phaser.Textures.Frame} frame - The Frame that contains the Sprite Sheet.\r\n * @param {object} config - An object describing how to parse the Sprite Sheet.\r\n * @param {number} config.frameWidth - Width in pixels of a single frame in the sprite sheet.\r\n * @param {number} [config.frameHeight] - Height in pixels of a single frame in the sprite sheet. Defaults to frameWidth if not provided.\r\n * @param {number} [config.startFrame=0] - Index of the start frame in the sprite sheet\r\n * @param {number} [config.endFrame=-1] - Index of the end frame in the sprite sheet. -1 mean all the rest of the frames\r\n * @param {number} [config.margin=0] - If the frames have been drawn with a margin, specify the amount here.\r\n * @param {number} [config.spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar SpriteSheetFromAtlas = function (texture, frame, config)\r\n{\r\n    var frameWidth = GetFastValue(config, 'frameWidth', null);\r\n    var frameHeight = GetFastValue(config, 'frameHeight', frameWidth);\r\n\r\n    //  If missing we can't proceed\r\n    if (!frameWidth)\r\n    {\r\n        throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.');\r\n    }\r\n\r\n    //  Add in a __BASE entry (for the entire atlas frame)\r\n    var source = texture.source[0];\r\n    texture.add('__BASE', 0, 0, 0, source.width, source.height);\r\n\r\n    var startFrame = GetFastValue(config, 'startFrame', 0);\r\n    var endFrame = GetFastValue(config, 'endFrame', -1);\r\n    var margin = GetFastValue(config, 'margin', 0);\r\n    var spacing = GetFastValue(config, 'spacing', 0);\r\n\r\n    var x = frame.cutX;\r\n    var y = frame.cutY;\r\n\r\n    var cutWidth = frame.cutWidth;\r\n    var cutHeight = frame.cutHeight;\r\n    var sheetWidth = frame.realWidth;\r\n    var sheetHeight = frame.realHeight;\r\n\r\n    var row = Math.floor((sheetWidth - margin + spacing) / (frameWidth + spacing));\r\n    var column = Math.floor((sheetHeight - margin + spacing) / (frameHeight + spacing));\r\n    var total = row * column;\r\n\r\n    //  trim offsets\r\n\r\n    var leftPad = frame.x;\r\n    var leftWidth = frameWidth - leftPad;\r\n\r\n    var rightWidth = frameWidth - ((sheetWidth - cutWidth) - leftPad);\r\n\r\n    var topPad = frame.y;\r\n    var topHeight = frameHeight - topPad;\r\n\r\n    var bottomHeight = frameHeight - ((sheetHeight - cutHeight) - topPad);\r\n\r\n    if (startFrame > total || startFrame < -total)\r\n    {\r\n        startFrame = 0;\r\n    }\r\n\r\n    if (startFrame < 0)\r\n    {\r\n        //  Allow negative skipframes.\r\n        startFrame = total + startFrame;\r\n    }\r\n\r\n    if (endFrame !== -1)\r\n    {\r\n        total = startFrame + (endFrame + 1);\r\n    }\r\n\r\n    var sheetFrame;\r\n    var frameX = margin;\r\n    var frameY = margin;\r\n    var frameIndex = 0;\r\n    var sourceIndex = frame.sourceIndex;\r\n\r\n    for (var sheetY = 0; sheetY < column; sheetY++)\r\n    {\r\n        var topRow = (sheetY === 0);\r\n        var bottomRow = (sheetY === column - 1);\r\n\r\n        for (var sheetX = 0; sheetX < row; sheetX++)\r\n        {\r\n            var leftRow = (sheetX === 0);\r\n            var rightRow = (sheetX === row - 1);\r\n\r\n            sheetFrame = texture.add(frameIndex, sourceIndex, x + frameX, y + frameY, frameWidth, frameHeight);\r\n\r\n            if (leftRow || topRow || rightRow || bottomRow)\r\n            {\r\n                var destX = (leftRow) ? leftPad : 0;\r\n                var destY = (topRow) ? topPad : 0;\r\n\r\n                var trimWidth = 0;\r\n                var trimHeight = 0;\r\n\r\n                if (leftRow)\r\n                {\r\n                    trimWidth += (frameWidth - leftWidth);\r\n                }\r\n\r\n                if (rightRow)\r\n                {\r\n                    trimWidth += (frameWidth - rightWidth);\r\n                }\r\n\r\n                if (topRow)\r\n                {\r\n                    trimHeight += (frameHeight - topHeight);\r\n                }\r\n\r\n                if (bottomRow)\r\n                {\r\n                    trimHeight += (frameHeight - bottomHeight);\r\n                }\r\n\r\n                var destWidth = frameWidth - trimWidth;\r\n                var destHeight = frameHeight - trimHeight;\r\n\r\n                sheetFrame.cutWidth = destWidth;\r\n                sheetFrame.cutHeight = destHeight;\r\n\r\n                sheetFrame.setTrim(frameWidth, frameHeight, destX, destY, destWidth, destHeight);\r\n            }\r\n\r\n            frameX += spacing;\r\n\r\n            if (leftRow)\r\n            {\r\n                frameX += leftWidth;\r\n            }\r\n            else if (rightRow)\r\n            {\r\n                frameX += rightWidth;\r\n            }\r\n            else\r\n            {\r\n                frameX += frameWidth;\r\n            }\r\n\r\n            frameIndex++;\r\n        }\r\n\r\n        frameX = margin;\r\n        frameY += spacing;\r\n\r\n        if (topRow)\r\n        {\r\n            frameY += topHeight;\r\n        }\r\n        else if (bottomRow)\r\n        {\r\n            frameY += bottomHeight;\r\n        }\r\n        else\r\n        {\r\n            frameY += frameHeight;\r\n        }\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = SpriteSheetFromAtlas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar imageHeight = 0;\r\n\r\n/**\r\n * @function addFrame\r\n * @private\r\n * @since 3.0.0\r\n */\r\nvar addFrame = function (texture, sourceIndex, name, frame)\r\n{\r\n    //  The frame values are the exact coordinates to cut the frame out of the atlas from\r\n\r\n    var y = imageHeight - frame.y - frame.height;\r\n\r\n    texture.add(name, sourceIndex, frame.x, y, frame.width, frame.height);\r\n\r\n    //  These are the original (non-trimmed) sprite values\r\n    /*\r\n    if (src.trimmed)\r\n    {\r\n        newFrame.setTrim(\r\n            src.sourceSize.w,\r\n            src.sourceSize.h,\r\n            src.spriteSourceSize.x,\r\n            src.spriteSourceSize.y,\r\n            src.spriteSourceSize.w,\r\n            src.spriteSourceSize.h\r\n        );\r\n    }\r\n    */\r\n};\r\n\r\n/**\r\n * Parses a Unity YAML File and creates Frames in the Texture.\r\n * For more details about Sprite Meta Data see https://docs.unity3d.com/ScriptReference/SpriteMetaData.html\r\n *\r\n * @function Phaser.Textures.Parsers.UnityYAML\r\n * @memberof Phaser.Textures.Parsers\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture to add the Frames to.\r\n * @param {number} sourceIndex - The index of the TextureSource.\r\n * @param {object} yaml - The YAML data.\r\n *\r\n * @return {Phaser.Textures.Texture} The Texture modified by this parser.\r\n */\r\nvar UnityYAML = function (texture, sourceIndex, yaml)\r\n{\r\n    //  Add in a __BASE entry (for the entire atlas)\r\n    var source = texture.source[sourceIndex];\r\n\r\n    texture.add('__BASE', sourceIndex, 0, 0, source.width, source.height);\r\n\r\n    imageHeight = source.height;\r\n\r\n    var data = yaml.split('\\n');\r\n\r\n    var lineRegExp = /^[ ]*(- )*(\\w+)+[: ]+(.*)/;\r\n\r\n    var prevSprite = '';\r\n    var currentSprite = '';\r\n    var rect = { x: 0, y: 0, width: 0, height: 0 };\r\n\r\n    // var pivot = { x: 0, y: 0 };\r\n    // var border = { x: 0, y: 0, z: 0, w: 0 };\r\n\r\n    for (var i = 0; i < data.length; i++)\r\n    {\r\n        var results = data[i].match(lineRegExp);\r\n\r\n        if (!results)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var isList = (results[1] === '- ');\r\n        var key = results[2];\r\n        var value = results[3];\r\n\r\n        if (isList)\r\n        {\r\n            if (currentSprite !== prevSprite)\r\n            {\r\n                addFrame(texture, sourceIndex, currentSprite, rect);\r\n\r\n                prevSprite = currentSprite;\r\n            }\r\n\r\n            rect = { x: 0, y: 0, width: 0, height: 0 };\r\n        }\r\n\r\n        if (key === 'name')\r\n        {\r\n            //  Start new list\r\n            currentSprite = value;\r\n            continue;\r\n        }\r\n\r\n        switch (key)\r\n        {\r\n            case 'x':\r\n            case 'y':\r\n            case 'width':\r\n            case 'height':\r\n                rect[key] = parseInt(value, 10);\r\n                break;\r\n\r\n            // case 'pivot':\r\n            //     pivot = eval('var obj = ' + value);\r\n            //     break;\r\n\r\n            // case 'border':\r\n            //     border = eval('var obj = ' + value);\r\n            //     break;\r\n        }\r\n    }\r\n\r\n    if (currentSprite !== prevSprite)\r\n    {\r\n        addFrame(texture, sourceIndex, currentSprite, rect);\r\n    }\r\n\r\n    return texture;\r\n};\r\n\r\nmodule.exports = UnityYAML;\r\n\r\n/*\r\nExample data:\r\n\r\nTextureImporter:\r\n  spritePivot: {x: .5, y: .5}\r\n  spriteBorder: {x: 0, y: 0, z: 0, w: 0}\r\n  spritePixelsToUnits: 100\r\n  spriteSheet:\r\n    sprites:\r\n    - name: asteroids_0\r\n      rect:\r\n        serializedVersion: 2\r\n        x: 5\r\n        y: 328\r\n        width: 65\r\n        height: 82\r\n      alignment: 0\r\n      pivot: {x: 0, y: 0}\r\n      border: {x: 0, y: 0, z: 0, w: 0}\r\n    - name: asteroids_1\r\n      rect:\r\n        serializedVersion: 2\r\n        x: 80\r\n        y: 322\r\n        width: 53\r\n        height: 88\r\n      alignment: 0\r\n      pivot: {x: 0, y: 0}\r\n      border: {x: 0, y: 0, z: 0, w: 0}\r\n  spritePackingTag: Asteroids\r\n*/\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Textures.Parsers\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AtlasXML: require('./AtlasXML'),\r\n    Canvas: require('./Canvas'),\r\n    Image: require('./Image'),\r\n    JSONArray: require('./JSONArray'),\r\n    JSONHash: require('./JSONHash'),\r\n    SpriteSheet: require('./SpriteSheet'),\r\n    SpriteSheetFromAtlas: require('./SpriteSheetFromAtlas'),\r\n    UnityYAML: require('./UnityYAML')\r\n\r\n};\r\n"],"names":["Arne16","CanvasPool","GetValue","module","exports","config","data","canvas","palette","pixelWidth","pixelHeight","resizeCanvas","clearCanvas","preRender","postRender","width","Math","floor","abs","length","height","create2D","this","ctx","getContext","clearRect","y","row","x","d","fillStyle","fillRect","A","B","C","D","E","F","Class","Clamp","Color","CONST","IsSizePowerOfTwo","Texture","CanvasTexture","Extends","initialize","manager","key","source","call","add","_source","frames","image","context","imageData","getImageData","pixels","buffer","Uint32Array","window","ArrayBuffer","update","game","renderType","WEBGL","refresh","draw","drawImage","drawFrame","frame","undefined","textureFrame","getFrame","cd","canvasData","cutWidth","cutHeight","res","resolution","setPixel","red","green","blue","alpha","getIndex","putImageData","putData","dirtyX","dirtyY","dirtyWidth","dirtyHeight","getData","getPixel","out","index","r","g","b","a","setTo","getPixels","round","left","right","top","bottom","pixel","py","px","push","color","alphaGL","getCanvas","clear","setSize","isPowerOf2","destroy","prototype","Frame","TextureSource","TEXTURE_MISSING_ERROR","Array","isArray","dataSource","customData","firstFrame","frameTotal","i","name","sourceIndex","has","remove","get","console","warn","getTextureSourceIndex","getFramesFromTextureSource","includeBase","frameName","getFrameNames","Object","keys","idx","indexOf","splice","getSourceImage","getDataSourceImage","setDataSource","setFilter","filterMode","removeKey","renderer","type","resetTextures","EventEmitter","Events","GameEvents","GenerateTexture","Parser","TextureManager","list","_tempCanvas","_tempContext","_pending","events","once","BOOT","boot","on","LOAD","updatePending","ERROR","addBase64","defaultImage","missingImage","whiteImage","DESTROY","off","emit","READY","checkKey","exists","error","hasOwnProperty","REMOVE","_this","Image","onerror","onload","texture","create","ADD","src","getBase64","encoderOptions","isRenderTexture","isGLTexture","toDataURL","addImage","addGLTexture","glTexture","addRenderTexture","renderTexture","generate","addCanvas","createCanvas","CANVAS","skipCache","addAtlas","textures","addAtlasJSONArray","addAtlasJSONHash","singleAtlasFile","atlasData","JSONArray","JSONHash","addAtlasXML","AtlasXML","addUnityAtlas","UnityYAML","addSpriteSheet","SpriteSheet","addSpriteSheetFromAtlas","atlasKey","atlasFrame","sheet","trimmed","SpriteSheetFromAtlas","cutX","cutY","cloneFrame","clone","getTextureKeys","output","cut","rgb","getPixelAlpha","setTexture","gameObject","renameTexture","currentKey","newKey","each","callback","scope","args","arguments","apply","ScaleModes","flipY","compressionAlgorithm","naturalWidth","videoWidth","naturalHeight","videoHeight","scaleMode","DEFAULT","isCanvas","HTMLCanvasElement","isVideo","HTMLVideoElement","WebGLTexture","glIndex","glIndexCounter","init","gl","createCanvasTexture","createVideoTexture","createTextureFromSource","antialias","setTextureFilter","setFlipY","value","updateCanvasTexture","updateVideoTexture","deleteTexture","xml","getElementsByTagName","newFrame","attributes","parseInt","frameX","frameY","frameWidth","frameHeight","setTrim","Clone","json","filename","w","h","sourceSize","spriteSourceSize","rotated","updateUVsInverted","pivot","anchor","customPivot","pivotX","pivotY","dataKey","slice","GetFastValue","Error","startFrame","endFrame","margin","spacing","total","fx","fy","ax","ay","sheetFrame","sheetWidth","realWidth","sheetHeight","realHeight","column","leftPad","leftWidth","rightWidth","topPad","topHeight","bottomHeight","frameIndex","sheetY","topRow","bottomRow","sheetX","leftRow","rightRow","destX","destY","trimWidth","trimHeight","destWidth","destHeight","imageHeight","addFrame","yaml","split","lineRegExp","prevSprite","currentSprite","rect","results","match","isList","Canvas"],"sourceRoot":""}