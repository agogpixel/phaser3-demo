{"version":3,"file":"js/phaser-time.d69f82a4056b11b99b09.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/time/Clock.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/time/TimerEvent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/time/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/Class.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Remove.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/SpliceOne.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetFastValue.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\nvar TimerEvent = require('./TimerEvent');\r\nvar Remove = require('../utils/array/Remove');\r\n\r\n/**\r\n * @classdesc\r\n * The Clock is a Scene plugin which creates and updates Timer Events for its Scene.\r\n *\r\n * @class Clock\r\n * @memberof Phaser.Time\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene which owns this Clock.\r\n */\r\nvar Clock = new Class({\r\n\r\n    initialize:\r\n\r\n    function Clock (scene)\r\n    {\r\n        /**\r\n         * The Scene which owns this Clock.\r\n         *\r\n         * @name Phaser.Time.Clock#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene Systems object of the Scene which owns this Clock.\r\n         *\r\n         * @name Phaser.Time.Clock#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The current time of the Clock, in milliseconds.\r\n         *\r\n         * If accessed externally, this is equivalent to the `time` parameter normally passed to a Scene's `update` method.\r\n         *\r\n         * @name Phaser.Time.Clock#now\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.now = 0;\r\n\r\n        /**\r\n         * The scale of the Clock's time delta.\r\n         *\r\n         * The time delta is the time elapsed between two consecutive frames and influences the speed of time for this Clock and anything which uses it, such as its Timer Events. Values higher than 1 increase the speed of time, while values smaller than 1 decrease it. A value of 0 freezes time and is effectively equivalent to pausing the Clock.\r\n         *\r\n         * @name Phaser.Time.Clock#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * Whether the Clock is paused (`true`) or active (`false`).\r\n         *\r\n         * When paused, the Clock will not update any of its Timer Events, thus freezing time.\r\n         *\r\n         * @name Phaser.Time.Clock#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * An array of all Timer Events whose delays haven't expired - these are actively updating Timer Events.\r\n         *\r\n         * @name Phaser.Time.Clock#_active\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._active = [];\r\n\r\n        /**\r\n         * An array of all Timer Events which will be added to the Clock at the start of the next frame.\r\n         *\r\n         * @name Phaser.Time.Clock#_pendingInsertion\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * An array of all Timer Events which will be removed from the Clock at the start of the next frame.\r\n         *\r\n         * @name Phaser.Time.Clock#_pendingRemoval\r\n         * @type {Phaser.Time.TimerEvent[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Time.Clock#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        //  Sync with the TimeStep\r\n        this.now = this.systems.game.loop.time;\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Time.Clock#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.on(SceneEvents.UPDATE, this.update, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Creates a Timer Event and adds it to this Clock at the start of the next frame.\r\n     *\r\n     * You can pass in either a `TimerEventConfig` object, from with a new `TimerEvent` will\r\n     * be created, or you can pass in a `TimerEvent` instance.\r\n     *\r\n     * If passing an instance please make sure that this instance hasn't been used before.\r\n     * If it has ever entered a 'completed' state then it will no longer be suitable to\r\n     * run again.\r\n     *\r\n     * Also, if the `TimerEvent` instance is being used by _another_ Clock (in another Scene)\r\n     * it will still be updated by that Clock as well, so be careful when using this feature.\r\n     *\r\n     * @method Phaser.Time.Clock#addEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Time.TimerEvent | Phaser.Types.Time.TimerEventConfig)} config - The configuration for the Timer Event, or an existing Timer Event object.\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} The Timer Event which was created, or passed in.\r\n     */\r\n    addEvent: function (config)\r\n    {\r\n        var event;\r\n\r\n        if (config instanceof TimerEvent)\r\n        {\r\n            event = config;\r\n\r\n            this.removeEvent(event);\r\n\r\n            event.elapsed = event.startAt;\r\n            event.hasDispatched = false;\r\n            event.repeatCount = (event.repeat === -1 || event.loop) ? 999999999999 : event.repeat;\r\n        }\r\n        else\r\n        {\r\n            event = new TimerEvent(config);\r\n        }\r\n\r\n        this._pendingInsertion.push(event);\r\n\r\n        return event;\r\n    },\r\n\r\n    /**\r\n     * Creates a Timer Event and adds it to the Clock at the start of the frame.\r\n     *\r\n     * This is a shortcut for {@link #addEvent} which can be shorter and is compatible with the syntax of the GreenSock Animation Platform (GSAP).\r\n     *\r\n     * @method Phaser.Time.Clock#delayedCall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delay - The delay of the function call, in milliseconds.\r\n     * @param {function} callback - The function to call after the delay expires.\r\n     * @param {Array.<*>} [args] - The arguments to call the function with.\r\n     * @param {*} [callbackScope] - The scope (`this` object) to call the function with.\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} The Timer Event which was created.\r\n     */\r\n    delayedCall: function (delay, callback, args, callbackScope)\r\n    {\r\n        return this.addEvent({ delay: delay, callback: callback, args: args, callbackScope: callbackScope });\r\n    },\r\n\r\n    /**\r\n     * Clears and recreates the array of pending Timer Events.\r\n     *\r\n     * @method Phaser.Time.Clock#clearPendingEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} - This Clock instance.\r\n     */\r\n    clearPendingEvents: function ()\r\n    {\r\n        this._pendingInsertion = [];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Timer Event, or an array of Timer Events, from this Clock.\r\n     *\r\n     * The events are removed from all internal lists (active, pending and removal),\r\n     * freeing the event up to be re-used.\r\n     *\r\n     * @method Phaser.Time.Clock#removeEvent\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.Time.TimerEvent | Phaser.Time.TimerEvent[])} events - The Timer Event, or an array of Timer Events, to remove from this Clock.\r\n     *\r\n     * @return {this} - This Clock instance.\r\n     */\r\n    removeEvent: function (events)\r\n    {\r\n        if (!Array.isArray(events))\r\n        {\r\n            events = [ events ];\r\n        }\r\n\r\n        for (var i = 0; i < events.length; i++)\r\n        {\r\n            var event = events[i];\r\n\r\n            Remove(this._pendingRemoval, event);\r\n            Remove(this._pendingInsertion, event);\r\n            Remove(this._active, event);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules all active Timer Events for removal at the start of the frame.\r\n     *\r\n     * @method Phaser.Time.Clock#removeAllEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} - This Clock instance.\r\n     */\r\n    removeAllEvents: function ()\r\n    {\r\n        this._pendingRemoval = this._pendingRemoval.concat(this._active);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the arrays of active and pending Timer Events. Called at the start of the frame.\r\n     *\r\n     * @method Phaser.Time.Clock#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var toRemove = this._pendingRemoval.length;\r\n        var toInsert = this._pendingInsertion.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var event;\r\n\r\n        //  Delete old events\r\n        for (i = 0; i < toRemove; i++)\r\n        {\r\n            event = this._pendingRemoval[i];\r\n\r\n            var index = this._active.indexOf(event);\r\n\r\n            if (index > -1)\r\n            {\r\n                this._active.splice(index, 1);\r\n            }\r\n\r\n            //  Pool them?\r\n            event.destroy();\r\n        }\r\n\r\n        for (i = 0; i < toInsert; i++)\r\n        {\r\n            event = this._pendingInsertion[i];\r\n\r\n            this._active.push(event);\r\n        }\r\n\r\n        //  Clear the lists\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Updates the Clock's internal time and all of its Timer Events.\r\n     *\r\n     * @method Phaser.Time.Clock#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        this.now = time;\r\n\r\n        if (this.paused)\r\n        {\r\n            return;\r\n        }\r\n\r\n        delta *= this.timeScale;\r\n\r\n        for (var i = 0; i < this._active.length; i++)\r\n        {\r\n            var event = this._active[i];\r\n\r\n            if (event.paused)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  Use delta time to increase elapsed.\r\n            //  Avoids needing to adjust for pause / resume.\r\n            //  Automatically smoothed by TimeStep class.\r\n            //  In testing accurate to +- 1ms!\r\n            event.elapsed += delta * event.timeScale;\r\n\r\n            if (event.elapsed >= event.delay)\r\n            {\r\n                var remainder = event.elapsed - event.delay;\r\n\r\n                //  Limit it, in case it's checked in the callback\r\n                event.elapsed = event.delay;\r\n\r\n                //  Process the event\r\n                if (!event.hasDispatched && event.callback)\r\n                {\r\n                    event.hasDispatched = true;\r\n                    event.callback.apply(event.callbackScope, event.args);\r\n                }\r\n\r\n                if (event.repeatCount > 0)\r\n                {\r\n                    event.repeatCount--;\r\n\r\n                    event.elapsed = remainder;\r\n                    event.hasDispatched = false;\r\n                }\r\n                else\r\n                {\r\n                    this._pendingRemoval.push(event);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Time.Clock#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var i;\r\n\r\n        for (i = 0; i < this._pendingInsertion.length; i++)\r\n        {\r\n            this._pendingInsertion[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this._active.length; i++)\r\n        {\r\n            this._active[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this._pendingRemoval.length; i++)\r\n        {\r\n            this._pendingRemoval[i].destroy();\r\n        }\r\n\r\n        this._active.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.off(SceneEvents.UPDATE, this.update, this);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Time.Clock#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('Clock', Clock, 'time');\r\n\r\nmodule.exports = Clock;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A Timer Event represents a delayed function call. It's managed by a Scene's {@link Clock} and will call its function after a set amount of time has passed. The Timer Event can optionally repeat - i.e. call its function multiple times before finishing, or loop indefinitely.\r\n *\r\n * Because it's managed by a Clock, a Timer Event is based on game time, will be affected by its Clock's time scale, and will pause if its Clock pauses.\r\n *\r\n * @class TimerEvent\r\n * @memberof Phaser.Time\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Time.TimerEventConfig} config - The configuration for the Timer Event, including its delay and callback.\r\n */\r\nvar TimerEvent = new Class({\r\n\r\n    initialize:\r\n\r\n    function TimerEvent (config)\r\n    {\r\n        /**\r\n         * The delay in ms at which this TimerEvent fires.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#delay\r\n         * @type {number}\r\n         * @default 0\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.delay = 0;\r\n\r\n        /**\r\n         * The total number of times this TimerEvent will repeat before finishing.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#repeat\r\n         * @type {number}\r\n         * @default 0\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.repeat = 0;\r\n\r\n        /**\r\n         * If repeating this contains the current repeat count.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#repeatCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeatCount = 0;\r\n\r\n        /**\r\n         * True if this TimerEvent loops, otherwise false.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#loop\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.loop = false;\r\n\r\n        /**\r\n         * The callback that will be called when the TimerEvent occurs.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#callback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.callback;\r\n\r\n        /**\r\n         * The scope in which the callback will be called.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#callbackScope\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.callbackScope;\r\n\r\n        /**\r\n         * Additional arguments to be passed to the callback.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#args\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.args;\r\n\r\n        /**\r\n         * Scale the time causing this TimerEvent to update.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)\r\n         *\r\n         * @name Phaser.Time.TimerEvent#startAt\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.startAt = 0;\r\n\r\n        /**\r\n         * The time in milliseconds which has elapsed since the Timer Event's creation.\r\n         *\r\n         * This value is local for the Timer Event and is relative to its Clock. As such, it's influenced by the Clock's time scale and paused state, the Timer Event's initial {@link #startAt} property, and the Timer Event's {@link #timeScale} and {@link #paused} state.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.elapsed = 0;\r\n\r\n        /**\r\n         * Whether or not this timer is paused.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * Whether the Timer Event's function has been called.\r\n         *\r\n         * When the Timer Event fires, this property will be set to `true` before the callback function is invoked and will be reset immediately afterward if the Timer Event should repeat. The value of this property does not directly influence whether the Timer Event will be removed from its Clock, but can prevent it from firing.\r\n         *\r\n         * @name Phaser.Time.TimerEvent#hasDispatched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.hasDispatched = false;\r\n\r\n        this.reset(config);\r\n    },\r\n\r\n    /**\r\n     * Completely reinitializes the Timer Event, regardless of its current state, according to a configuration object.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Time.TimerEventConfig} config - The new state for the Timer Event.\r\n     *\r\n     * @return {Phaser.Time.TimerEvent} This TimerEvent object.\r\n     */\r\n    reset: function (config)\r\n    {\r\n        this.delay = GetFastValue(config, 'delay', 0);\r\n\r\n        //  Can also be set to -1 for an infinite loop (same as setting loop: true)\r\n        this.repeat = GetFastValue(config, 'repeat', 0);\r\n\r\n        this.loop = GetFastValue(config, 'loop', false);\r\n\r\n        this.callback = GetFastValue(config, 'callback', undefined);\r\n\r\n        this.callbackScope = GetFastValue(config, 'callbackScope', this.callback);\r\n\r\n        this.args = GetFastValue(config, 'args', []);\r\n\r\n        this.timeScale = GetFastValue(config, 'timeScale', 1);\r\n\r\n        this.startAt = GetFastValue(config, 'startAt', 0);\r\n\r\n        this.paused = GetFastValue(config, 'paused', false);\r\n\r\n        this.elapsed = this.startAt;\r\n        this.hasDispatched = false;\r\n        this.repeatCount = (this.repeat === -1 || this.loop) ? 999999999999 : this.repeat;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the progress of the current iteration, not factoring in repeats.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A number between 0 and 1 representing the current progress.\r\n     */\r\n    getProgress: function ()\r\n    {\r\n        return (this.elapsed / this.delay);\r\n    },\r\n\r\n    /**\r\n     * Gets the progress of the timer overall, factoring in repeats.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getOverallProgress\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The overall progress of the Timer Event, between 0 and 1.\r\n     */\r\n    getOverallProgress: function ()\r\n    {\r\n        if (this.repeat > 0)\r\n        {\r\n            var totalDuration = this.delay + (this.delay * this.repeat);\r\n            var totalElapsed = this.elapsed + (this.delay * (this.repeat - this.repeatCount));\r\n\r\n            return (totalElapsed / totalDuration);\r\n        }\r\n        else\r\n        {\r\n            return this.getProgress();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the number of times this Timer Event will repeat before finishing.\r\n     *\r\n     * This should not be confused with the number of times the Timer Event will fire before finishing. A return value of 0 doesn't indicate that the Timer Event has finished running - it indicates that it will not repeat after the next time it fires.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getRepeatCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} How many times the Timer Event will repeat.\r\n     */\r\n    getRepeatCount: function ()\r\n    {\r\n        return this.repeatCount;\r\n    },\r\n\r\n    /**\r\n     * Returns the local elapsed time for the current iteration of the Timer Event.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getElapsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The local elapsed time in milliseconds.\r\n     */\r\n    getElapsed: function ()\r\n    {\r\n        return this.elapsed;\r\n    },\r\n\r\n    /**\r\n     * Returns the local elapsed time for the current iteration of the Timer Event in seconds.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getElapsedSeconds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The local elapsed time in seconds.\r\n     */\r\n    getElapsedSeconds: function ()\r\n    {\r\n        return this.elapsed * 0.001;\r\n    },\r\n\r\n    /**\r\n     * Returns the time interval until the next iteration of the Timer Event.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getRemaining\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The time interval in milliseconds.\r\n     */\r\n    getRemaining: function ()\r\n    {\r\n        return this.delay - this.elapsed;\r\n    },\r\n\r\n    /**\r\n     * Returns the time interval until the next iteration of the Timer Event in seconds.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getRemainingSeconds\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The time interval in seconds.\r\n     */\r\n    getRemainingSeconds: function ()\r\n    {\r\n        return this.getRemaining() * 0.001;\r\n    },\r\n\r\n    /**\r\n     * Returns the time interval until the last iteration of the Timer Event.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getOverallRemaining\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The time interval in milliseconds.\r\n     */\r\n    getOverallRemaining: function ()\r\n    {\r\n        return this.delay * (1 + this.repeatCount) - this.elapsed;\r\n    },\r\n\r\n    /**\r\n     * Returns the time interval until the last iteration of the Timer Event in seconds.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#getOverallRemainingSeconds\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The time interval in seconds.\r\n     */\r\n    getOverallRemainingSeconds: function ()\r\n    {\r\n        return this.getOverallRemaining() * 0.001;\r\n    },\r\n\r\n    /**\r\n     * Forces the Timer Event to immediately expire, thus scheduling its removal in the next frame.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [dispatchCallback=false] - If `true`, the function of the Timer Event will be called before its removal.\r\n     */\r\n    remove: function (dispatchCallback)\r\n    {\r\n        if (dispatchCallback === undefined) { dispatchCallback = false; }\r\n\r\n        this.elapsed = this.delay;\r\n\r\n        this.hasDispatched = !dispatchCallback;\r\n\r\n        this.repeatCount = 0;\r\n    },\r\n\r\n    /**\r\n     * Destroys all object references in the Timer Event, i.e. its callback, scope, and arguments.\r\n     *\r\n     * Normally, this method is only called by the Clock when it shuts down. As such, it doesn't stop the Timer Event. If called manually, the Timer Event will still be updated by the Clock, but it won't do anything when it fires.\r\n     *\r\n     * @method Phaser.Time.TimerEvent#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.callback = undefined;\r\n        this.callbackScope = undefined;\r\n        this.args = [];\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TimerEvent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Time\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Clock: require('./Clock'),\r\n    TimerEvent: require('./TimerEvent')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @ignore\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @ignore\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SpliceOne = require('./SpliceOne');\r\n\r\n/**\r\n * Removes the given item, or array of items, from the array.\r\n *\r\n * The array is modified in-place.\r\n *\r\n * You can optionally specify a callback to be invoked for each item successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.Remove\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.\r\n */\r\nvar Remove = function (array, item, callback, context)\r\n{\r\n    if (context === undefined) { context = array; }\r\n\r\n    var index;\r\n\r\n    //  Fast path to avoid array mutation and iteration\r\n    if (!Array.isArray(item))\r\n    {\r\n        index = array.indexOf(item);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, item);\r\n            }\r\n\r\n            return item;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    //  If we got this far, we have an array of items to remove\r\n\r\n    var itemLength = item.length - 1;\r\n    var removed = [];\r\n\r\n    while (itemLength >= 0)\r\n    {\r\n        var entry = item[itemLength];\r\n\r\n        index = array.indexOf(entry);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            removed.push(entry);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, entry);\r\n            }\r\n        }\r\n\r\n        itemLength--;\r\n    }\r\n\r\n    return removed;\r\n};\r\n\r\nmodule.exports = Remove;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Removes a single item from an array and returns it without creating gc, like the native splice does.\r\n * Based on code by Mike Reinstein.\r\n *\r\n * @function Phaser.Utils.Array.SpliceOne\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to splice from.\r\n * @param {number} index - The index of the item which should be spliced.\r\n *\r\n * @return {*} The item which was spliced (removed).\r\n */\r\nvar SpliceOne = function (array, index)\r\n{\r\n    if (index >= array.length)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var len = array.length - 1;\r\n\r\n    var item = array[index];\r\n\r\n    for (var i = index; i < len; i++)\r\n    {\r\n        array[i] = array[i + 1];\r\n    }\r\n\r\n    array.length = len;\r\n\r\n    return item;\r\n};\r\n\r\nmodule.exports = SpliceOne;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n"],"names":["corePlugins","customPlugins","PluginCache","key","plugin","mapping","custom","undefined","data","hasOwnProperty","module","exports","Class","SceneEvents","TimerEvent","Remove","Clock","initialize","scene","this","systems","sys","now","timeScale","paused","_active","_pendingInsertion","_pendingRemoval","events","once","BOOT","boot","on","START","start","game","loop","time","DESTROY","destroy","eventEmitter","PRE_UPDATE","preUpdate","UPDATE","update","SHUTDOWN","shutdown","addEvent","config","event","removeEvent","elapsed","startAt","hasDispatched","repeatCount","repeat","push","delayedCall","delay","callback","args","callbackScope","clearPendingEvents","Array","isArray","i","length","removeAllEvents","concat","toRemove","toInsert","index","indexOf","splice","delta","remainder","apply","off","register","GetFastValue","reset","getProgress","getOverallProgress","totalDuration","getRepeatCount","getElapsed","getElapsedSeconds","getRemaining","getRemainingSeconds","getOverallRemaining","getOverallRemainingSeconds","remove","dispatchCallback","getProperty","definition","k","isClassDescriptor","def","Object","getOwnPropertyDescriptor","value","get","set","hasGetterOrSetter","enumerable","configurable","hasNonConfigurable","obj","prop","extend","ctor","prototype","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Extends","base","arguments","create","constructor","Mixins","SpliceOne","array","item","context","call","itemLength","removed","entry","len","source","defaultValue","t"],"sourceRoot":""}