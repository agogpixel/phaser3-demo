{"version":3,"file":"js/6236.5cc3502e11ded07a4746.js","mappings":";gHAuBAA,EAAOC,QAAU,W,UCFjBD,EAAOC,QAAU,Y,SCCjBD,EAAOC,QAAU,gB,UCyBjBD,EAAOC,QAAU,iB,UC7BjBD,EAAOC,QAAU,a,UCCjBD,EAAOC,QAAU,Q,SCCjBD,EAAOC,QAAU,gB,UCEjBD,EAAOC,QAAU,e,UCJjBD,EAAOC,QAAU,Y,UCEjBD,EAAOC,QAAU,S,aCVjBD,EAAOC,QAAU,CAEbC,IAAK,EAAQ,OACbC,SAAU,EAAQ,OAClBC,cAAe,EAAQ,MACvBC,kBAAmB,EAAQ,OAC3BC,gBAAiB,EAAQ,OACzBC,UAAW,EAAQ,OACnBC,cAAe,EAAQ,MACvBC,aAAc,EAAQ,OACtBC,SAAU,EAAQ,OAClBC,MAAO,EAAQ,S,gBCfnB,IAAIC,EAAQ,EAAQ,OAChBC,EAAQ,EAAQ,MAChBC,EAAS,EAAQ,OACjBC,EAAa,EAAQ,OACrBC,EAAW,EAAQ,OACnBC,EAAe,EAAQ,IACvBC,EAAO,EAAQ,OACfC,EAAQ,EAAQ,OAChBC,EAAU,EAAQ,OAwBlBC,EAAe,IAAIT,EAAM,CAEzBU,WAEA,SAAuBC,EAAMC,GAsGzB,GA7FAC,KAAKF,KAAOA,EASZE,KAAKC,KAAO,GASZD,KAAKE,OAAS,GAUdF,KAAKG,SAAW,GAUhBH,KAAKI,OAAS,GAUdJ,KAAKK,OAAS,GAUdL,KAAKM,MAAQ,GAWbN,KAAKO,cAAe,EAWpBP,KAAKQ,UAAW,EAWhBR,KAAKS,gBAAkB,EAEnBV,EACJ,CACSW,MAAMC,QAAQZ,KAEfA,EAAc,CAAEA,IAGpB,IAAK,IAAIa,EAAI,EAAGA,EAAIb,EAAYc,OAAQD,IAGpCZ,KAAKG,SAASW,KAAK,CACfC,IAAK,UACLC,MAAOjB,EAAYa,GACnBK,UAAkB,IAANL,EACZM,KAAM,KAKlBpB,EAAKqB,OAAOC,KAAK9B,EAAW+B,MAAOrB,KAAKsB,UAAWtB,OAUvDsB,UAAW,WAEP,IAAItB,KAAKQ,SAAT,CAKA,IAAII,EACAW,EACAR,EACAhB,EAEJ,IAAKa,EAAI,EAAGA,EAAIZ,KAAKG,SAASU,OAAQD,IACtC,CAMI,IAAIY,EAHJT,GAFAQ,EAAQvB,KAAKG,SAASS,IAEVG,KACZhB,EAAcwB,EAAMP,iBAIOtB,EAEvB8B,EAAWxB,KAAKyB,wBAAwBV,EAAKhB,GAEjB,iBAAhBA,EAEZyB,EAAWxB,KAAK0B,sBAAsBX,EAAKhB,GAEf,mBAAhBA,IAEZyB,EAAWxB,KAAK2B,wBAAwBZ,EAAKhB,IAIjDgB,EAAMS,EAASI,IAAIC,SAASd,IAE5Bf,KAAKC,KAAKc,GAAOS,EAEjBxB,KAAKE,OAAOY,KAAKU,GAGbxB,KAAKM,MAAMS,KAEXS,EAASI,IAAIC,SAASX,KAAOlB,KAAKM,MAAMS,GAAKG,KAEzClB,KAAKM,MAAMS,GAAKE,YAEhBM,EAAMN,WAAY,KAItBM,EAAMN,WAAaO,EAASI,IAAIC,SAASC,SAEzC9B,KAAKI,OAAOU,KAAKC,GAYzB,IAPAf,KAAKG,SAASU,OAAS,EAEvBb,KAAKM,MAAQ,GAEbN,KAAKQ,UAAW,EAGXI,EAAI,EAAGA,EAAIZ,KAAKI,OAAOS,OAAQD,IAEhCW,EAAQvB,KAAKI,OAAOQ,GAEpBZ,KAAK+B,MAAMR,GAGfvB,KAAKI,OAAOS,OAAS,IASzBmB,aAAc,WAEV,IAAIC,EAAgBjC,KAAKG,SAASU,OAC9BqB,EAAclC,KAAKK,OAAOQ,OAE9B,GAAsB,IAAlBoB,GAAuC,IAAhBC,EAA3B,CAKA,IAAItB,EACAW,EAEJ,GAAIU,EACJ,CACI,IAAKrB,EAAI,EAAGA,EAAIqB,EAAerB,IAE3BW,EAAQvB,KAAKG,SAASS,GAEtBZ,KAAKmC,IAAIZ,EAAMR,IAAKQ,EAAMP,MAAOO,EAAMN,UAAWM,EAAML,MAI5D,IAAKN,EAAI,EAAGA,EAAIZ,KAAKI,OAAOS,OAAQD,IAEhCW,EAAQvB,KAAKI,OAAOQ,GAEpBZ,KAAK+B,MAAMR,GAOf,OAHAvB,KAAKI,OAAOS,OAAS,OACrBb,KAAKG,SAASU,OAAS,GAK3B,IAAKD,EAAI,EAAGA,EAAIZ,KAAKK,OAAOQ,OAAQD,IAIhCZ,MAFAuB,EAAQvB,KAAKK,OAAOO,IAETwB,IAAIb,EAAMc,KAAMd,EAAMe,MAGrCtC,KAAKK,OAAOQ,OAAS,IA2BzBsB,IAAK,SAAUpB,EAAKhB,EAAakB,EAAWC,GAMxC,YAJkBqB,IAAdtB,IAA2BA,GAAY,QAC9BsB,IAATrB,IAAsBA,EAAO,IAG7BlB,KAAKO,eAAiBP,KAAKQ,UAE3BR,KAAKG,SAASW,KAAK,CACfC,IAAKA,EACLC,MAAOjB,EACPkB,UAAWA,EACXC,KAAMA,IAGLlB,KAAKQ,WAENR,KAAKM,MAAMS,GAAO,CAAEG,KAAMA,IAGvB,OAGXH,EAAMf,KAAKwC,OAAOzB,EAAKhB,GAInBA,aAAuBL,EAEvB8B,EAAWxB,KAAKyB,wBAAwBV,EAAKhB,GAEjB,iBAAhBA,GAEZA,EAAYgB,IAAMA,EAElBS,EAAWxB,KAAK0B,sBAAsBX,EAAKhB,IAEf,mBAAhBA,IAEZyB,EAAWxB,KAAK2B,wBAAwBZ,EAAKhB,IAIjDyB,EAASI,IAAIC,SAASX,KAAOA,EAG7BH,EAAMS,EAASI,IAAIC,SAASd,IAE5Bf,KAAKC,KAAKc,GAAOS,EAEjBxB,KAAKE,OAAOY,KAAKU,IAEbP,GAAaO,EAASI,IAAIC,SAASC,UAE/B9B,KAAKG,SAASU,OAEdb,KAAKI,OAAOU,KAAKC,GAIjBf,KAAK+B,MAAMhB,IAIZS,GAvCP,IAAIA,GA0DRiB,OAAQ,SAAU1B,GAEd,GAAIf,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,SAAUC,KAAMtB,EAAKuB,KAAM,WAGtD,CACI,IAAII,EAAgB1C,KAAK2C,SAAS5B,GAElC,IAAK2B,GAAiBA,EAAcd,IAAIgB,kBAEpC,OAAO5C,KAGX,IAAI6C,EAAQ7C,KAAKE,OAAO4C,QAAQJ,GAC5BK,EAAWL,EAAcd,IAAIC,SAASd,IAEtC8B,GAAS,WAEF7C,KAAKC,KAAK8C,GACjB/C,KAAKE,OAAO8C,OAAOH,EAAO,GAEtB7C,KAAKI,OAAO0C,QAAQC,IAAa,IAEjCF,EAAQ7C,KAAKI,OAAO0C,QAAQC,GAC5B/C,KAAKI,OAAO4C,OAAOH,EAAO,IAG9BH,EAAcd,IAAIqB,WAI1B,OAAOjD,MAaXkD,UAAW,SAAUlC,GAEjB,IAiBImC,EAjBAvB,EAAMZ,EAAMY,IACZC,EAAWD,EAAIC,SAEnBD,EAAIwB,YAAc3D,EAEduB,EAAMqC,OAENrC,EAAMqC,KAAKC,KAAKtC,EAAOa,EAASX,MAEhCW,EAAS0B,OAASnE,EAAMoE,KAEpB3B,EAAS4B,cAET7B,EAAIT,OAAOuC,KAAKrE,EAAOsE,gBAAiB9B,EAAS+B,eAAgB/B,EAASgC,qBAM9EjC,EAAIkC,OAEJX,EAASvB,EAAIkC,MAENC,QAGPZ,GAAUnC,EAAMgD,SAEhBhD,EAAMgD,QAAQV,KAAKtC,GAGM,IAArBmC,EAAOc,KAAKC,KAEZlE,KAAKmE,OAAOnD,IAIZa,EAAS0B,OAASnE,EAAMgF,QAGxBjB,EAAO/B,KAAK5B,EAAad,SAAUsB,KAAKqE,aAAcrE,MAEtDmD,EAAOpB,UAMX/B,KAAKmE,OAAOnD,IAepBqD,aAAc,SAAUlB,GAEpBnD,KAAKmE,OAAOhB,EAAOnC,QAYvBsD,gBAAiB,SAAUnB,GAEvBnD,KAAKkD,UAAUC,EAAOnC,QAY1BuD,OAAQ,SAAUC,EAAMC,GAEpBzE,KAAKgC,eAELhC,KAAKO,cAAe,EAGpB,IAAK,IAAIK,EAAIZ,KAAKE,OAAOW,OAAS,EAAGD,GAAK,EAAGA,IAC7C,CACI,IAAIgB,EAAM5B,KAAKE,OAAOU,GAAGgB,IAErBA,EAAIC,SAAS0B,OAASnE,EAAMF,OAAS0C,EAAIC,SAAS0B,QAAUnE,EAAMsF,SAElE9C,EAAI+C,KAAKH,EAAMC,KAa3BG,OAAQ,SAAUC,GAGd,IAAK,IAAIjE,EAAI,EAAGA,EAAIZ,KAAKE,OAAOW,OAAQD,IACxC,CACI,IAAIgB,EAAM5B,KAAKE,OAAOU,GAAGgB,IAErBA,EAAIC,SAASiD,SAAWlD,EAAIC,SAAS0B,QAAUnE,EAAMgF,SAAWxC,EAAIC,SAAS0B,OAASnE,EAAM2F,UAE5FnD,EAAIgD,OAAOC,GAInB7E,KAAKO,cAAe,GAcxB4D,OAAQ,SAAUnD,GAEd,IAAIY,EAAMZ,EAAMY,IACZC,EAAWD,EAAIC,SAEfb,EAAMmD,SAENtC,EAAS0B,OAASnE,EAAM4F,SAExBhE,EAAMmD,OAAOb,KAAKtC,EAAOa,EAASX,MAE9BW,EAAS0B,SAAWnE,EAAM6F,aAM9BpD,EAAS4B,cAET7B,EAAIT,OAAOuC,KAAKrE,EAAO6F,iBAAkBrD,EAAS+B,eAAgB/B,EAASgC,oBAI3E7C,EAAMuD,SAEN3C,EAAIwB,YAAcpC,EAAMuD,QAG5B1C,EAAS0B,OAASnE,EAAMsF,QAExB9C,EAAIT,OAAOuC,KAAKrE,EAAO8F,OAAQnE,KAenCW,wBAAyB,SAAUZ,EAAKC,GAEpC,IAAIQ,EAAW,IAAIR,EAEnB,GAAIQ,aAAoB9B,EACxB,CACI,IAAI0F,EAAY5D,EAASI,IAAIC,SAASd,IAOtC,GALkB,KAAdqE,IAEArE,EAAMqE,GAGNpF,KAAKC,KAAKoF,eAAetE,GAEzB,MAAM,IAAIuE,MAAM,0CAA4CvE,GAGhE,OAAOf,KAAKyB,wBAAwBV,EAAKS,GAUzC,OANAA,EAASI,IAAM,IAAIjC,EAAQ6B,GAE3BA,EAASI,IAAIC,SAASd,IAAMA,EAE5BS,EAASI,IAAIyB,KAAKrD,KAAKF,MAEhB0B,GAgBfC,wBAAyB,SAAUV,EAAKS,GAWpC,MAPkB,KAFFA,EAASI,IAAIC,SAASd,MAIlCS,EAASI,IAAIC,SAASd,IAAMA,GAGhCS,EAASI,IAAIyB,KAAKrD,KAAKF,MAEhB0B,GAeXE,sBAAuB,SAAUX,EAAKhB,GAElC,IAAIyB,EAAW,IAAI9B,EAAMK,GAErBqF,EAAY5D,EAASI,IAAIC,SAASd,IAEpB,KAAdqE,EAEArE,EAAMqE,EAIN5D,EAASI,IAAIC,SAASd,IAAMA,EAGhCS,EAASI,IAAIyB,KAAKrD,KAAKF,MAMvB,IAFA,IAAIyF,EAAW,CAAE,OAAQ,UAAW,SAAU,SAAU,UAE/C3E,EAAI,EAAGA,EAAI2E,EAAS1E,OAAQD,IACrC,CACI,IAAI4E,EAAgBjG,EAASQ,EAAawF,EAAS3E,GAAI,MAEnD4E,IAEAhE,EAAS+D,EAAS3E,IAAM4E,GAkBhC,GAAIzF,EAAYsF,eAAe,UAE3B,IAAK,IAAII,KAAe1F,EAAY2F,OAEhC,GAAK3F,EAAY2F,OAAOL,eAAeI,GAAvC,CAKA,IAAIE,EAAQ5F,EAAY2F,OAAOD,GAEX,SAAhBA,GAA0BjE,EAAS6D,eAAe,SAA4B,iBAAVM,EAGpEnE,EAASN,KAAK0E,MAAMD,GAEC,QAAhBF,IAELjE,EAASiE,GAAeE,GAKpC,OAAOnE,GAeXgB,OAAQ,SAAUzB,EAAKhB,GAInB,GAFKgB,IAAOA,EAAM,WAES,mBAAhBhB,EAEP,OAAOgB,EAaX,GAXShB,aAAuBL,EAE5BqB,EAAMhB,EAAY6B,IAAIC,SAASd,IAEH,iBAAhBhB,GAA4BA,EAAYsF,eAAe,SAEnEtE,EAAMhB,EAAYgB,KAKlBf,KAAKC,KAAKoF,eAAetE,GAEzB,MAAM,IAAIuE,MAAM,0CAA4CvE,GAI5D,OAAOA,GAkBf8E,UAAW,SAAUC,EAAUC,QAEVxD,IAAbuD,IAA0BA,GAAW,QACvBvD,IAAdwD,IAA2BA,GAAY,GAK3C,IAHA,IAAIC,EAAM,GACN9F,EAASF,KAAKE,OAETU,EAAI,EAAGA,EAAIV,EAAOW,OAAQD,IACnC,CACI,IAAII,EAAQd,EAAOU,GAEfI,KAAW8E,GAAaA,GAAY9E,EAAMY,IAAIkE,aAE9CE,EAAIlF,KAAKE,GAIjB,OAAO,EAAcgF,EAAIC,UAAYD,GAazCrD,SAAU,SAAU5B,GAEhB,GAAmB,iBAARA,GAEP,GAAIf,KAAKC,KAAKc,GAEV,OAAOf,KAAKC,KAAKc,QAKrB,IAAK,IAAIH,EAAI,EAAGA,EAAIZ,KAAKE,OAAOW,OAAQD,IAEpC,GAAIG,IAAQf,KAAKE,OAAOU,GAEpB,OAAOG,EAKnB,OAAO,MAaX+E,SAAU,SAAU/E,GAEhB,IAAIC,EAAQhB,KAAK2C,SAAS5B,GAE1B,OAAIC,EAEOA,EAAMY,IAAIkE,WAGd,MAaXI,SAAU,SAAUnF,GAEhB,IAAIC,EAAQhB,KAAK2C,SAAS5B,GAE1B,OAAIC,EAEOA,EAAMY,IAAIsE,WAGd,MAaXC,UAAW,SAAUpF,GAEjB,IAAIC,EAAQhB,KAAK2C,SAAS5B,GAE1B,OAAIC,EAEOA,EAAMY,IAAIuE,YAGd,MAaXC,WAAY,SAAUrF,GAElB,IAAIC,EAAQhB,KAAK2C,SAAS5B,GAE1B,OAAIC,EAEOA,EAAMY,IAAIwE,aAGd,MAcXC,MAAO,SAAUtF,EAAKG,GAElB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAO1B,OALIC,GAEAA,EAAMY,IAAIyE,MAAMnF,GAGblB,MAcXsG,OAAQ,SAAUvF,EAAKG,GAEnB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAO1B,OALIC,GAEAA,EAAMY,IAAI0E,OAAOpF,GAGdlB,MAcXuG,MAAO,SAAUxF,EAAKG,GAElB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAO1B,OALIC,IAAUA,EAAMY,IAAIgB,mBAEpB5B,EAAMY,IAAI2E,MAAMrF,GAGblB,MAcXwG,KAAM,SAAUzF,EAAKG,GAEjB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAO1B,OALIC,GAEAA,EAAMY,IAAI4E,KAAKtF,GAGZlB,MAoBXyG,IAAK,SAAU1F,EAAKG,GAEhB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAE1B,IAAKC,EACL,CACI,IAAK,IAAIJ,EAAI,EAAGA,EAAIZ,KAAKG,SAASU,OAAQD,IAEtC,GAAIZ,KAAKG,SAASS,GAAGG,MAAQA,EAC7B,CACIf,KAAK0G,QAAQ,QAAS3F,EAAKG,GAC3B,MAGR,OAAOlB,KAGPgB,EAAMY,IAAIwE,aAGVpF,EAAMY,IAAI4E,KAAKtF,GAEVF,EAAMY,IAAIsE,WAGflF,EAAMY,IAAI0E,OAAOpF,GAKjBlB,KAAK+B,MAAMhB,EAAKG,IAexBa,MAAO,SAAUhB,EAAKG,GAGlB,IAAKlB,KAAKQ,SAON,OALAR,KAAKM,MAAMS,GAAO,CACdE,WAAW,EACXC,KAAMA,GAGHlB,KAGX,IAAIgB,EAAQhB,KAAK2C,SAAS5B,GAE1B,GAAIC,EACJ,CACI,IAkBQmC,EAlBJvB,EAAMZ,EAAMY,IAIhB,GAAIA,EAAIkE,YAAclE,EAAIsE,WAEtBtE,EAAI+E,WAEJ/E,EAAIwB,YAAc3D,EAElBmC,EAAIG,MAAMb,QAgBV,GAZAU,EAAIwB,YAAc3D,EAElBmC,EAAIG,MAAMb,GAINU,EAAIkC,OAEJX,EAASvB,EAAIkC,MAIbX,GAAUvB,EAAIC,SAASwD,eAAe,UAEtClC,EAAOY,QAEHZ,EAAOyD,QAAQ,CAAEC,QAASjF,EAAIC,SAASiF,QAQvC,OANAlF,EAAIC,SAAS0B,OAASnE,EAAMgF,QAE5BjB,EAAO/B,KAAK5B,EAAad,SAAUsB,KAAKsE,gBAAiBtE,MAEzDmD,EAAOpB,QAEA/B,KAKnBA,KAAKkD,UAAUlC,GAGnB,OAAOhB,MAcX+G,KAAM,SAAUhG,EAAKG,GAEjB,IAAIF,EAAQhB,KAAK2C,SAAS5B,GAO1B,OALIC,IAAUA,EAAMY,IAAIgB,mBAEpB5B,EAAMY,IAAI+E,SAASzF,GAGhBlB,MAcXgH,OAAQ,SAAUC,EAAMC,GAEpB,IAAIC,EAASnH,KAAK2C,SAASsE,GACvBG,EAASpH,KAAK2C,SAASuE,GAgB3B,OAdIC,GAAUC,GAAUD,IAAWC,IAE/BpH,KAAKuG,MAAMU,GAEPjH,KAAKoG,WAAWc,GAEhBlH,KAAKwG,KAAKU,GAIVlH,KAAK+B,MAAMmF,IAIZlH,MAaXqH,MAAO,SAAUxE,GAEb,OAAO7C,KAAKE,OAAO2C,IAavByE,SAAU,SAAUvG,GAEhB,IAAIC,EAAQhB,KAAK2C,SAAS5B,GAE1B,OAAOf,KAAKE,OAAO4C,QAAQ9B,IAe/BuG,WAAY,SAAUxG,GAElB,GAAIf,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,aAAcC,KAAMtB,EAAKuB,KAAM,WAG1D,CACI,IAAIO,EAAQ7C,KAAKsH,SAASvG,GAE1B,IAAe,IAAX8B,GAAgBA,EAAQ7C,KAAKE,OAAOW,OACxC,CACI,IAAIG,EAAQhB,KAAK2C,SAAS5B,GAE1Bf,KAAKE,OAAO8C,OAAOH,EAAO,GAC1B7C,KAAKE,OAAOY,KAAKE,IAIzB,OAAOhB,MAeXwH,WAAY,SAAUzG,GAElB,GAAIf,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,aAAcC,KAAMtB,EAAKuB,KAAM,WAG1D,CACI,IAAIO,EAAQ7C,KAAKsH,SAASvG,GAE1B,IAAe,IAAX8B,GAAgBA,EAAQ,EAC5B,CACI,IAAI7B,EAAQhB,KAAK2C,SAAS5B,GAE1Bf,KAAKE,OAAO8C,OAAOH,EAAO,GAC1B7C,KAAKE,OAAOuH,QAAQzG,IAI5B,OAAOhB,MAaX0H,SAAU,SAAU3G,GAEhB,GAAIf,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,WAAYC,KAAMtB,EAAKuB,KAAM,WAGxD,CACI,IAAIqF,EAAS3H,KAAKsH,SAASvG,GAE3B,GAAI4G,EAAS,EACb,CACI,IAAIC,EAASD,EAAS,EAClBR,EAASnH,KAAK2C,SAAS5B,GACvBqG,EAASpH,KAAKqH,MAAMO,GAExB5H,KAAKE,OAAOyH,GAAUP,EACtBpH,KAAKE,OAAO0H,GAAUT,GAI9B,OAAOnH,MAaX6H,OAAQ,SAAU9G,GAEd,GAAIf,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,SAAUC,KAAMtB,EAAKuB,KAAM,WAGtD,CACI,IAAIqF,EAAS3H,KAAKsH,SAASvG,GAE3B,GAAI4G,EAAS3H,KAAKE,OAAOW,OAAS,EAClC,CACI,IAAI+G,EAASD,EAAS,EAClBR,EAASnH,KAAK2C,SAAS5B,GACvBqG,EAASpH,KAAKqH,MAAMO,GAExB5H,KAAKE,OAAOyH,GAAUP,EACtBpH,KAAKE,OAAO0H,GAAUT,GAI9B,OAAOnH,MAgBX8H,UAAW,SAAUzF,EAAMC,GAEvB,GAAID,IAASC,EAET,OAAOtC,KAGX,GAAIA,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,YAAaC,KAAMA,EAAMC,KAAMA,QAG1D,CACI,IAAIqF,EAAS3H,KAAKsH,SAASjF,GACvBuF,EAAS5H,KAAKsH,SAAShF,GAE3B,IAAgB,IAAZqF,IAA6B,IAAZC,EACrB,CACI,IAAIG,EAAY/H,KAAKqH,MAAMO,GAG3B5H,KAAKE,OAAO8C,OAAO4E,EAAQ,GAG3B5H,KAAKE,OAAO8C,OAAO2E,EAAS,EAAG,EAAGI,IAI1C,OAAO/H,MAgBXgI,UAAW,SAAU3F,EAAMC,GAEvB,GAAID,IAASC,EAET,OAAOtC,KAGX,GAAIA,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,YAAaC,KAAMA,EAAMC,KAAMA,QAG1D,CACI,IAAIqF,EAAS3H,KAAKsH,SAASjF,GACvBuF,EAAS5H,KAAKsH,SAAShF,GAE3B,IAAgB,IAAZqF,IAA6B,IAAZC,EACrB,CACI,IAAIG,EAAY/H,KAAKqH,MAAMO,GAG3B5H,KAAKE,OAAO8C,OAAO4E,EAAQ,GAEZ,IAAXD,EAEA3H,KAAKE,OAAOuH,QAAQM,GAKpB/H,KAAKE,OAAO8C,OAAO2E,EAAQ,EAAGI,IAK1C,OAAO/H,MAgBX0G,QAAS,SAAUtE,EAAIC,EAAMC,GAIzB,OAFAtC,KAAKK,OAAOS,KAAK,CAAEsB,GAAIA,EAAIC,KAAMA,EAAMC,KAAMA,IAEtCtC,MAcXiI,aAAc,SAAU5F,EAAMC,GAE1B,GAAID,IAASC,EAET,OAAOtC,KAGX,GAAIA,KAAKO,aAELP,KAAKK,OAAOS,KAAK,CAAEsB,GAAI,eAAgBC,KAAMA,EAAMC,KAAMA,QAG7D,CACI,IAAIqF,EAAS3H,KAAKsH,SAASjF,GACvBuF,EAAS5H,KAAKsH,SAAShF,GAE3B,GAAIqF,IAAWC,IAAsB,IAAZD,IAA6B,IAAZC,EAC1C,CACI,IAAIG,EAAY/H,KAAKqH,MAAMM,GAE3B3H,KAAKE,OAAOyH,GAAU3H,KAAKE,OAAO0H,GAClC5H,KAAKE,OAAO0H,GAAUG,GAI9B,OAAO/H,MASXkI,KAAM,WAKF,IAHA,IAAIlC,EAAM,GACNmC,EAAM,CAAE,UAAW,OAAQ,QAAS,UAAW,WAAY,UAAW,SAAU,WAAY,WAAY,aAEnGvH,EAAI,EAAGA,EAAIZ,KAAKE,OAAOW,OAAQD,IACxC,CACI,IAAIgB,EAAM5B,KAAKE,OAAOU,GAAGgB,IAErBb,GAAOa,EAAIC,SAASiD,SAAYlD,EAAIC,SAAS0B,SAAWnE,EAAMsF,SAAW9C,EAAIC,SAAS0B,SAAWnE,EAAMgJ,OAAoB,OAAT,OACtHrH,GAAOa,EAAIC,SAASd,IAAM,KAAOoH,EAAIvG,EAAIC,SAAS0B,QAAU,IAE5DyC,EAAIlF,KAAKC,GAGbsH,QAAQC,IAAItC,EAAIuC,KAAK,QAazBtF,QAAS,WAEL,IAAK,IAAIrC,EAAI,EAAGA,EAAIZ,KAAKE,OAAOW,OAAQD,IAE1BZ,KAAKE,OAAOU,GAAGgB,IAErBqB,UAGRjD,KAAKuE,OAAS9E,EAEdO,KAAKE,OAAS,GAEdF,KAAKG,SAAW,GAChBH,KAAKI,OAAS,GACdJ,KAAKK,OAAS,GAEdL,KAAKF,KAAO,QAKpBvB,EAAOC,QAAUoB,M","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_LOAD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_PROGRESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/POST_PROCESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/PROGRESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/SceneManager.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Add File Event.\r\n * \r\n * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('addfile', listener)`.\r\n * \r\n * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.\r\n *\r\n * @event Phaser.Loader.Events#ADD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The unique key of the file that was added to the Loader.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.\r\n */\r\nmodule.exports = 'addfile';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Complete Event.\r\n * \r\n * This event is dispatched when the Loader has fully processed everything in the load queue.\r\n * By this point every loaded file will now be in its associated cache and ready for use.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('complete', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {number} totalComplete - The total number of files that successfully loaded.\r\n * @param {number} totalFailed - The total number of files that failed to load.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.\r\n * \r\n * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * It uses a special dynamic event name constructed from the key and type of the file.\r\n * \r\n * For example, if you have loaded an `image` with a key of `monster`, you can listen for it\r\n * using the following:\r\n *\r\n * ```javascript\r\n * this.load.on('filecomplete-image-monster', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n *\r\n * Or, if you have loaded a texture `atlas` with a key of `Level1`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Error Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file fails to load.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD_ERROR\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n */\r\nmodule.exports = 'loaderror';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file finishes loading,\r\n * but _before_ it is processed and added to the internal Phaser caches.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('load', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.\r\n */\r\nmodule.exports = 'load';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Progress Event.\r\n * \r\n * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\r\n * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.\r\n */\r\nmodule.exports = 'fileprogress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Post Process Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\r\n * It is dispatched before the internal lists are cleared and each File is destroyed.\r\n * \r\n * Use this hook to perform any last minute processing of files that can only happen once the\r\n * Loader has completed, but prior to it emitting the `complete` event.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#POST_PROCESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'postprocess';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Progress Event.\r\n * \r\n * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('progress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {number} progress - The current progress of the load. A value between 0 and 1.\r\n */\r\nmodule.exports = 'progress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Start Event.\r\n * \r\n * This event is dispatched when the Loader starts running. At this point load progress is zero.\r\n * \r\n * This event is dispatched even if there aren't any files in the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('start', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD: require('./ADD_EVENT'),\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    FILE_COMPLETE: require('./FILE_COMPLETE_EVENT'),\r\n    FILE_KEY_COMPLETE: require('./FILE_KEY_COMPLETE_EVENT'),\r\n    FILE_LOAD_ERROR: require('./FILE_LOAD_ERROR_EVENT'),\r\n    FILE_LOAD: require('./FILE_LOAD_EVENT'),\r\n    FILE_PROGRESS: require('./FILE_PROGRESS_EVENT'),\r\n    POST_PROCESS: require('./POST_PROCESS_EVENT'),\r\n    PROGRESS: require('./PROGRESS_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar LoaderEvents = require('../loader/events');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Scene = require('./Scene');\r\nvar Systems = require('./Systems');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n * You should not usually interact directly with the Scene Manager at all. Instead, you should use\r\n * the Scene Plugin, which is available from every Scene in your game via the `this.scene` property.\r\n *\r\n * Using methods in this Scene Manager directly will break queued operations and can cause runtime\r\n * errors. Instead, go via the Scene Plugin. Every feature this Scene Manager provides is also\r\n * available via the Scene Plugin.\r\n *\r\n * @class SceneManager\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\r\nvar SceneManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function SceneManager (game, sceneConfig)\r\n    {\r\n        /**\r\n         * The Game that this SceneManager belongs to.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#keys\r\n         * @type {Record<string, Phaser.Scene>}\r\n         * @since 3.0.0\r\n         */\r\n        this.keys = {};\r\n\r\n        /**\r\n         * The array in which all of the scenes are kept.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#scenes\r\n         * @type {Phaser.Scene[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenes = [];\r\n\r\n        /**\r\n         * Scenes pending to be added are stored in here until the manager has time to add it.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = [];\r\n\r\n        /**\r\n         * An array of scenes waiting to be started once the game has booted.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_start\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._start = [];\r\n\r\n        /**\r\n         * An operations queue, because we don't manipulate the scenes array during processing.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_queue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._queue = [];\r\n\r\n        /**\r\n         * Boot time data to merge.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._data = {};\r\n\r\n        /**\r\n         * Is the Scene Manager actively processing the Scenes list?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isProcessing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.isProcessing = false;\r\n\r\n        /**\r\n         * Has the Scene Manager properly started?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isBooted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.4.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        /**\r\n         * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n         * If not we can skip scissor tests.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#customViewports\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.12.0\r\n         */\r\n        this.customViewports = 0;\r\n\r\n        if (sceneConfig)\r\n        {\r\n            if (!Array.isArray(sceneConfig))\r\n            {\r\n                sceneConfig = [ sceneConfig ];\r\n            }\r\n\r\n            for (var i = 0; i < sceneConfig.length; i++)\r\n            {\r\n                //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\r\n                this._pending.push({\r\n                    key: 'default',\r\n                    scene: sceneConfig[i],\r\n                    autoStart: (i === 0),\r\n                    data: {}\r\n                });\r\n            }\r\n        }\r\n\r\n        game.events.once(GameEvents.READY, this.bootQueue, this);\r\n    },\r\n\r\n    /**\r\n     * Internal first-time Scene boot handler.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootQueue\r\n     * @private\r\n     * @since 3.2.0\r\n     */\r\n    bootQueue: function ()\r\n    {\r\n        if (this.isBooted)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n        var key;\r\n        var sceneConfig;\r\n\r\n        for (i = 0; i < this._pending.length; i++)\r\n        {\r\n            entry = this._pending[i];\r\n\r\n            key = entry.key;\r\n            sceneConfig = entry.scene;\r\n\r\n            var newScene;\r\n\r\n            if (sceneConfig instanceof Scene)\r\n            {\r\n                newScene = this.createSceneFromInstance(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'object')\r\n            {\r\n                newScene = this.createSceneFromObject(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'function')\r\n            {\r\n                newScene = this.createSceneFromFunction(key, sceneConfig);\r\n            }\r\n\r\n            //  Replace key in case the scene changed it\r\n            key = newScene.sys.settings.key;\r\n\r\n            this.keys[key] = newScene;\r\n\r\n            this.scenes.push(newScene);\r\n\r\n            //  Any data to inject?\r\n            if (this._data[key])\r\n            {\r\n                newScene.sys.settings.data = this._data[key].data;\r\n\r\n                if (this._data[key].autoStart)\r\n                {\r\n                    entry.autoStart = true;\r\n                }\r\n            }\r\n\r\n            if (entry.autoStart || newScene.sys.settings.active)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n        }\r\n\r\n        //  Clear the pending lists\r\n        this._pending.length = 0;\r\n\r\n        this._data = {};\r\n\r\n        this.isBooted = true;\r\n\r\n        //  _start might have been populated by the above\r\n        for (i = 0; i < this._start.length; i++)\r\n        {\r\n            entry = this._start[i];\r\n\r\n            this.start(entry);\r\n        }\r\n\r\n        this._start.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Process the Scene operations queue.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#processQueue\r\n     * @since 3.0.0\r\n     */\r\n    processQueue: function ()\r\n    {\r\n        var pendingLength = this._pending.length;\r\n        var queueLength = this._queue.length;\r\n\r\n        if (pendingLength === 0 && queueLength === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n\r\n        if (pendingLength)\r\n        {\r\n            for (i = 0; i < pendingLength; i++)\r\n            {\r\n                entry = this._pending[i];\r\n\r\n                this.add(entry.key, entry.scene, entry.autoStart, entry.data);\r\n            }\r\n\r\n            //  _start might have been populated by this.add\r\n            for (i = 0; i < this._start.length; i++)\r\n            {\r\n                entry = this._start[i];\r\n\r\n                this.start(entry);\r\n            }\r\n\r\n            //  Clear the pending lists\r\n            this._start.length = 0;\r\n            this._pending.length = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < this._queue.length; i++)\r\n        {\r\n            entry = this._queue[i];\r\n\r\n            this[entry.op](entry.keyA, entry.keyB);\r\n        }\r\n\r\n        this._queue.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Scene into the SceneManager.\r\n     * You must give each Scene a unique key by which you'll identify it.\r\n     *\r\n     * The `sceneConfig` can be:\r\n     *\r\n     * * A `Phaser.Scene` object, or an object that extends it.\r\n     * * A plain JavaScript object\r\n     * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n     * * A JavaScript ES5 prototype based Class\r\n     * * A JavaScript function\r\n     *\r\n     * If a function is given then a new Scene will be created by calling it.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as `Scene.settings.data` and passed to `Scene.init`, and `Scene.create`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        if (autoStart === undefined) { autoStart = false; }\r\n        if (data === undefined) { data = {}; }\r\n\r\n        //  If processing or not booted then put scene into a holding pattern\r\n        if (this.isProcessing || !this.isBooted)\r\n        {\r\n            this._pending.push({\r\n                key: key,\r\n                scene: sceneConfig,\r\n                autoStart: autoStart,\r\n                data: data\r\n            });\r\n\r\n            if (!this.isBooted)\r\n            {\r\n                this._data[key] = { data: data };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        key = this.getKey(key, sceneConfig);\r\n\r\n        var newScene;\r\n\r\n        if (sceneConfig instanceof Scene)\r\n        {\r\n            newScene = this.createSceneFromInstance(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'object')\r\n        {\r\n            sceneConfig.key = key;\r\n\r\n            newScene = this.createSceneFromObject(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'function')\r\n        {\r\n            newScene = this.createSceneFromFunction(key, sceneConfig);\r\n        }\r\n\r\n        //  Any data to inject?\r\n        newScene.sys.settings.data = data;\r\n\r\n        //  Replace key in case the scene changed it\r\n        key = newScene.sys.settings.key;\r\n\r\n        this.keys[key] = newScene;\r\n\r\n        this.scenes.push(newScene);\r\n\r\n        if (autoStart || newScene.sys.settings.active)\r\n        {\r\n            if (this._pending.length)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n            else\r\n            {\r\n                this.start(key);\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'remove', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var sceneToRemove = this.getScene(key);\r\n\r\n            if (!sceneToRemove || sceneToRemove.sys.isTransitioning())\r\n            {\r\n                return this;\r\n            }\r\n\r\n            var index = this.scenes.indexOf(sceneToRemove);\r\n            var sceneKey = sceneToRemove.sys.settings.key;\r\n\r\n            if (index > -1)\r\n            {\r\n                delete this.keys[sceneKey];\r\n                this.scenes.splice(index, 1);\r\n\r\n                if (this._start.indexOf(sceneKey) > -1)\r\n                {\r\n                    index = this._start.indexOf(sceneKey);\r\n                    this._start.splice(index, 1);\r\n                }\r\n\r\n                sceneToRemove.sys.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Boot the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootScene\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to boot.\r\n     */\r\n    bootScene: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        sys.sceneUpdate = NOOP;\r\n\r\n        if (scene.init)\r\n        {\r\n            scene.init.call(scene, settings.data);\r\n\r\n            settings.status = CONST.INIT;\r\n\r\n            if (settings.isTransition)\r\n            {\r\n                sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);\r\n            }\r\n        }\r\n\r\n        var loader;\r\n\r\n        if (sys.load)\r\n        {\r\n            loader = sys.load;\r\n\r\n            loader.reset();\r\n        }\r\n\r\n        if (loader && scene.preload)\r\n        {\r\n            scene.preload.call(scene);\r\n\r\n            //  Is the loader empty?\r\n            if (loader.list.size === 0)\r\n            {\r\n                this.create(scene);\r\n            }\r\n            else\r\n            {\r\n                settings.status = CONST.LOADING;\r\n\r\n                //  Start the loader going as we have something in the queue\r\n                loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);\r\n\r\n                loader.start();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  No preload? Then there was nothing to load either\r\n            this.create(scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles load completion for a Scene's Loader.\r\n     *\r\n     * Starts the Scene that the Loader belongs to.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#loadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n     */\r\n    loadComplete: function (loader)\r\n    {\r\n        this.create(loader.scene);\r\n    },\r\n\r\n    /**\r\n     * Handle payload completion for a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#payloadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n     */\r\n    payloadComplete: function (loader)\r\n    {\r\n        this.bootScene(loader.scene);\r\n    },\r\n\r\n    /**\r\n     * Updates the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - Time elapsed.\r\n     * @param {number} delta - Delta time from the last update.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        this.processQueue();\r\n\r\n        this.isProcessing = true;\r\n\r\n        //  Loop through the active scenes in reverse order\r\n        for (var i = this.scenes.length - 1; i >= 0; i--)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING)\r\n            {\r\n                sys.step(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        //  Loop through the scenes in forward order\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING)\r\n            {\r\n                sys.render(renderer);\r\n            }\r\n        }\r\n\r\n        this.isProcessing = false;\r\n    },\r\n\r\n    /**\r\n     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#create\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#CREATE\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to create.\r\n     */\r\n    create: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.create)\r\n        {\r\n            settings.status = CONST.CREATING;\r\n\r\n            scene.create.call(scene, settings.data);\r\n\r\n            if (settings.status === CONST.DESTROYED)\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (settings.isTransition)\r\n        {\r\n            sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);\r\n        }\r\n\r\n        //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\r\n        if (scene.update)\r\n        {\r\n            sys.sceneUpdate = scene.update;\r\n        }\r\n\r\n        settings.status = CONST.RUNNING;\r\n\r\n        sys.events.emit(Events.CREATE, scene);\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from a function.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {function} scene - The function to create the Scene from.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromFunction: function (key, scene)\r\n    {\r\n        var newScene = new scene();\r\n\r\n        if (newScene instanceof Scene)\r\n        {\r\n            var configKey = newScene.sys.settings.key;\r\n\r\n            if (configKey !== '')\r\n            {\r\n                key = configKey;\r\n            }\r\n\r\n            if (this.keys.hasOwnProperty(key))\r\n            {\r\n                throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n            }\r\n\r\n            return this.createSceneFromInstance(key, newScene);\r\n        }\r\n        else\r\n        {\r\n            newScene.sys = new Systems(newScene);\r\n\r\n            newScene.sys.settings.key = key;\r\n\r\n            newScene.sys.init(this.game);\r\n\r\n            return newScene;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene instance.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {Phaser.Scene} newScene - The Scene instance.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromInstance: function (key, newScene)\r\n    {\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey === '')\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from an Object definition.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {(string|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromObject: function (key, sceneConfig)\r\n    {\r\n        var newScene = new Scene(sceneConfig);\r\n\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        //  Extract callbacks\r\n\r\n        var defaults = [ 'init', 'preload', 'create', 'update', 'render' ];\r\n\r\n        for (var i = 0; i < defaults.length; i++)\r\n        {\r\n            var sceneCallback = GetValue(sceneConfig, defaults[i], null);\r\n\r\n            if (sceneCallback)\r\n            {\r\n                newScene[defaults[i]] = sceneCallback;\r\n            }\r\n        }\r\n\r\n        //  Now let's move across any other functions or properties that may exist in the extend object:\r\n\r\n        /*\r\n        scene: {\r\n            preload: preload,\r\n            create: create,\r\n            extend: {\r\n                hello: 1,\r\n                test: 'atari',\r\n                addImage: addImage\r\n            }\r\n        }\r\n        */\r\n\r\n        if (sceneConfig.hasOwnProperty('extend'))\r\n        {\r\n            for (var propertyKey in sceneConfig.extend)\r\n            {\r\n                if (!sceneConfig.extend.hasOwnProperty(propertyKey))\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var value = sceneConfig.extend[propertyKey];\r\n\r\n                if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object')\r\n                {\r\n                    //  Populate the DataManager\r\n                    newScene.data.merge(value);\r\n                }\r\n                else if (propertyKey !== 'sys')\r\n                {\r\n                    newScene[propertyKey] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the key of a Scene from a Scene config.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getKey\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check in the Scene config.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|function)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {string} The Scene key.\r\n     */\r\n    getKey: function (key, sceneConfig)\r\n    {\r\n        if (!key) { key = 'default'; }\r\n\r\n        if (typeof sceneConfig === 'function')\r\n        {\r\n            return key;\r\n        }\r\n        else if (sceneConfig instanceof Scene)\r\n        {\r\n            key = sceneConfig.sys.settings.key;\r\n        }\r\n        else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))\r\n        {\r\n            key = sceneConfig.key;\r\n        }\r\n\r\n        //  By this point it's either 'default' or extracted from the Scene\r\n\r\n        if (this.keys.hasOwnProperty(key))\r\n        {\r\n            throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n        }\r\n        else\r\n        {\r\n            return key;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all the current Scenes being managed by this Scene Manager.\r\n     *\r\n     * You can filter the output by the active state of the Scene and choose to have\r\n     * the array returned in normal or reversed order.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScenes\r\n     * @since 3.16.0\r\n     *\r\n     * @param {boolean} [isActive=true] - Only include Scene's that are currently active?\r\n     * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?\r\n     *\r\n     * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.\r\n     */\r\n    getScenes: function (isActive, inReverse)\r\n    {\r\n        if (isActive === undefined) { isActive = true; }\r\n        if (inReverse === undefined) { inReverse = false; }\r\n\r\n        var out = [];\r\n        var scenes = this.scenes;\r\n\r\n        for (var i = 0; i < scenes.length; i++)\r\n        {\r\n            var scene = scenes[i];\r\n\r\n            if (scene && (!isActive || (isActive && scene.sys.isActive())))\r\n            {\r\n                out.push(scene);\r\n            }\r\n        }\r\n\r\n        return (inReverse) ? out.reverse() : out;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to retrieve.\r\n     *\r\n     * @return {?Phaser.Scene} The Scene.\r\n     */\r\n    getScene: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.keys[key])\r\n            {\r\n                return this.keys[key];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < this.scenes.length; i++)\r\n            {\r\n                if (key === this.scenes[i])\r\n                {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is running.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is running, or `null` if no matching Scene was found.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isActive();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is paused.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isPaused\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is paused, or `null` if no matching Scene was found.\r\n     */\r\n    isPaused: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isPaused();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is visible.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible, or `null` if no matching Scene was found.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isVisible();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is sleeping.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping, or `null` if no matching Scene was found.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isSleeping();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Pauses the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.pause(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.resume(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the given Scene to sleep.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.sleep(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Awakens the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.wake(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (!scene)\r\n        {\r\n            for (var i = 0; i < this._pending.length; i++)\r\n            {\r\n                if (this._pending[i].key === key)\r\n                {\r\n                    this.queueOp('start', key, data);\r\n                    break;\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (scene.sys.isSleeping())\r\n        {\r\n            //  Sleeping?\r\n            scene.sys.wake(data);\r\n        }\r\n        else if (scene.sys.isPaused())\r\n        {\r\n            //  Paused?\r\n            scene.sys.resume(data);\r\n        }\r\n        else\r\n        {\r\n            //  Not actually running?\r\n            this.start(key, data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Starts the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to start.\r\n     * @param {object} [data] - Optional data object to pass to `Scene.Settings` and `Scene.init`, and `Scene.create`.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        //  If the Scene Manager is not running, then put the Scene into a holding pattern\r\n        if (!this.isBooted)\r\n        {\r\n            this._data[key] = {\r\n                autoStart: true,\r\n                data: data\r\n            };\r\n\r\n            return this;\r\n        }\r\n\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            var sys = scene.sys;\r\n\r\n            //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\r\n            //  then we close it down before starting it again.\r\n            if (sys.isActive() || sys.isPaused())\r\n            {\r\n                sys.shutdown();\r\n\r\n                sys.sceneUpdate = NOOP;\r\n\r\n                sys.start(data);\r\n            }\r\n            else\r\n            {\r\n                sys.sceneUpdate = NOOP;\r\n\r\n                sys.start(data);\r\n\r\n                var loader;\r\n\r\n                if (sys.load)\r\n                {\r\n                    loader = sys.load;\r\n                }\r\n\r\n                //  Files payload?\r\n                if (loader && sys.settings.hasOwnProperty('pack'))\r\n                {\r\n                    loader.reset();\r\n\r\n                    if (loader.addPack({ payload: sys.settings.pack }))\r\n                    {\r\n                        sys.settings.status = CONST.LOADING;\r\n\r\n                        loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);\r\n\r\n                        loader.start();\r\n\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.bootScene(scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to stop.\r\n     * @param {object} [data] - Optional data object to pass to Scene.shutdown.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    stop: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.shutdown(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sleeps one one Scene and starts the other.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} from - The Scene to sleep.\r\n     * @param {(string|Phaser.Scene)} to - The Scene to start.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    switch: function (from, to)\r\n    {\r\n        var sceneA = this.getScene(from);\r\n        var sceneB = this.getScene(to);\r\n\r\n        if (sceneA && sceneB && sceneA !== sceneB)\r\n        {\r\n            this.sleep(from);\r\n\r\n            if (this.isSleeping(to))\r\n            {\r\n                this.wake(to);\r\n            }\r\n            else\r\n            {\r\n                this.start(to);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene by numeric index.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The index of the Scene to retrieve.\r\n     *\r\n     * @return {(Phaser.Scene|undefined)} The Scene.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.scenes[index];\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n     *\r\n     * @return {number} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        return this.scenes.indexOf(scene);\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'bringToTop', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index < this.scenes.length)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.push(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'sendToBack', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index > 0)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.unshift(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveDown', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA > 0)\r\n            {\r\n                var indexB = indexA - 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveUp', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA < this.scenes.length - 1)\r\n            {\r\n                var indexB = indexA + 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n     *\r\n     * This means it will render over the top of the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveAbove', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                //  Add in new location\r\n                this.scenes.splice(indexA + 1, 0, tempScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n     *\r\n     * This means it will render behind the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveBelow', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                if (indexA === 0)\r\n                {\r\n                    this.scenes.unshift(tempScene);\r\n                }\r\n                else\r\n                {\r\n                    //  Add in new location\r\n                    this.scenes.splice(indexA, 0, tempScene);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queue a Scene operation for the next update.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#queueOp\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} op - The operation to perform.\r\n     * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n     * @param {(any|string|Phaser.Scene)} [keyB] - Scene B, or a data object.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    queueOp: function (op, keyA, keyB)\r\n    {\r\n        this._queue.push({ op: op, keyA: keyA, keyB: keyB });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the positions of two Scenes in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#swapPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n     *\r\n     * @return {this} This Scene Manager instance.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'swapPosition', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== indexB && indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexA);\r\n\r\n                this.scenes[indexA] = this.scenes[indexB];\r\n                this.scenes[indexB] = tempScene;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps debug information about each Scene to the developer console.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#dump\r\n     * @since 3.2.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var out = [];\r\n        var map = [ 'pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed' ];\r\n\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            var key = (sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED)) ? '[*] ' : '[-] ';\r\n            key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\r\n\r\n            out.push(key);\r\n        }\r\n\r\n        console.log(out.join('\\n'));\r\n    },\r\n\r\n    /**\r\n     * Destroy this Scene Manager and all of its systems.\r\n     *\r\n     * This process cannot be reversed.\r\n     *\r\n     * This method is called automatically when a Phaser Game instance is destroyed.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            sys.destroy();\r\n        }\r\n\r\n        this.update = NOOP;\r\n\r\n        this.scenes = [];\r\n\r\n        this._pending = [];\r\n        this._start = [];\r\n        this._queue = [];\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SceneManager;\r\n"],"names":["module","exports","ADD","COMPLETE","FILE_COMPLETE","FILE_KEY_COMPLETE","FILE_LOAD_ERROR","FILE_LOAD","FILE_PROGRESS","POST_PROCESS","PROGRESS","START","Class","CONST","Events","GameEvents","GetValue","LoaderEvents","NOOP","Scene","Systems","SceneManager","initialize","game","sceneConfig","this","keys","scenes","_pending","_start","_queue","_data","isProcessing","isBooted","customViewports","Array","isArray","i","length","push","key","scene","autoStart","data","events","once","READY","bootQueue","entry","newScene","createSceneFromInstance","createSceneFromObject","createSceneFromFunction","sys","settings","active","start","processQueue","pendingLength","queueLength","add","op","keyA","keyB","undefined","getKey","remove","sceneToRemove","getScene","isTransitioning","index","indexOf","sceneKey","splice","destroy","bootScene","loader","sceneUpdate","init","call","status","INIT","isTransition","emit","TRANSITION_INIT","transitionFrom","transitionDuration","load","reset","preload","list","size","create","LOADING","loadComplete","payloadComplete","update","time","delta","RUNNING","step","render","renderer","visible","SLEEPING","CREATING","DESTROYED","TRANSITION_START","CREATE","configKey","hasOwnProperty","Error","defaults","sceneCallback","propertyKey","extend","value","merge","getScenes","isActive","inReverse","out","reverse","isPaused","isVisible","isSleeping","pause","resume","sleep","wake","run","queueOp","shutdown","addPack","payload","pack","stop","switch","from","to","sceneA","sceneB","getAt","getIndex","bringToTop","sendToBack","unshift","moveDown","indexA","indexB","moveUp","moveAbove","tempScene","moveBelow","swapPosition","dump","map","PAUSED","console","log","join"],"sourceRoot":""}