{"version":3,"file":"js/2063.fdd8954a406ea1c1baa0.js","mappings":";gHAmBAA,EAAOC,QAAU,gB,UCDjBD,EAAOC,QAAU,Q,UCIjBD,EAAOC,QAAU,U,UCFjBD,EAAOC,QAAU,W,UCAjBD,EAAOC,QAAU,S,UCWjBD,EAAOC,QAAU,c,UCAjBD,EAAOC,QAAU,a,UCAjBD,EAAOC,QAAU,a,UCVjBD,EAAOC,QAAU,S,QCFjBD,EAAOC,QAAU,oB,UCYjBD,EAAOC,QAAU,U,UCXjBD,EAAOC,QAAU,U,UCGjBD,EAAOC,QAAU,Y,UCHjBD,EAAOC,QAAU,S,UCFjBD,EAAOC,QAAU,S,UCWjBD,EAAOC,QAAU,sB,UCCjBD,EAAOC,QAAU,kB,UCHjBD,EAAOC,QAAU,iB,UCMjBD,EAAOC,QAAU,mB,UCLjBD,EAAOC,QAAU,kB,SCGjBD,EAAOC,QAAU,U,SCXjBD,EAAOC,QAAU,Q,gBCVjBD,EAAOC,QAAU,CAEbC,eAAgB,EAAQ,OACxBC,KAAM,EAAQ,OACdC,OAAQ,EAAQ,OAChBC,QAAS,EAAQ,OACjBC,MAAO,EAAQ,OACfC,YAAa,EAAQ,OACrBC,WAAY,EAAQ,OACpBC,WAAY,EAAQ,OACpBC,MAAO,EAAQ,OACfC,mBAAoB,EAAQ,KAC5BC,OAAQ,EAAQ,OAChBC,OAAQ,EAAQ,OAChBC,SAAU,EAAQ,OAClBC,MAAO,EAAQ,OACfC,MAAO,EAAQ,OACfC,oBAAqB,EAAQ,OAC7BC,gBAAiB,EAAQ,OACzBC,eAAgB,EAAQ,OACxBC,iBAAkB,EAAQ,OAC1BC,gBAAiB,EAAQ,OACzBC,OAAQ,EAAQ,MAChBC,KAAM,EAAQ,W","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/ADDED_TO_SCENE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/BOOT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/CREATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/DESTROY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/PAUSE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/POST_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/PRE_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/PRE_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/READY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/REMOVED_FROM_SCENE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/RESUME_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/SHUTDOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/SLEEP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/TRANSITION_INIT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/TRANSITION_OUT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/TRANSITION_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/WAKE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/events/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Object Added to Scene Event.\r\n *\r\n * This event is dispatched when a Game Object is added to a Scene.\r\n *\r\n * Listen for it from a Scene using `this.events.on('addedtoscene', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#ADDED_TO_SCENE\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the Scene.\r\n * @param {Phaser.Scene} scene - The Scene to which the Game Object was added.\r\n */\r\nmodule.exports = 'addedtoscene';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Boot Event.\r\n *\r\n * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\r\n *\r\n * Listen to it from a Scene using `this.events.on('boot', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#BOOT\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'boot';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Create Event.\r\n *\r\n * This event is dispatched by a Scene after it has been created by the Scene Manager.\r\n *\r\n * If a Scene has a `create` method then this event is emitted _after_ that has run.\r\n *\r\n * If there is a transition, this event will be fired after the `TRANSITION_START` event.\r\n *\r\n * Listen to it from a Scene using `this.events.on('create', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#CREATE\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that emitted this event.\r\n */\r\nmodule.exports = 'create';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Destroy Event.\r\n *\r\n * This event is dispatched by a Scene during the Scene Systems destroy process.\r\n *\r\n * Listen to it from a Scene using `this.events.on('destroy', listener)`.\r\n *\r\n * You should destroy any resources that may be in use by your Scene in this event handler.\r\n *\r\n * @event Phaser.Scenes.Events#DESTROY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pause Event.\r\n *\r\n * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\r\n * action from another Scene.\r\n *\r\n * Listen to it from a Scene using `this.events.on('pause', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#PAUSE\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was paused.\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Post Update Event.\r\n *\r\n * This event is dispatched by a Scene during the main game loop step.\r\n *\r\n * The event flow for a single step of a Scene is as follows:\r\n *\r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\r\n * 6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n *\r\n * Listen to it from a Scene using `this.events.on('postupdate', listener)`.\r\n *\r\n * A Scene will only run its step if it is active.\r\n *\r\n * @event Phaser.Scenes.Events#POST_UPDATE\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'postupdate';\r\n","/**\r\n * @author       samme\r\n * @copyright    2021 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pre-Render Event.\r\n *\r\n * This event is dispatched by a Scene during the main game loop step.\r\n *\r\n * The event flow for a single step of a Scene is as follows:\r\n *\r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\r\n * 6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n *\r\n * Listen to this event from a Scene using `this.events.on('prerender', listener)`.\r\n *\r\n * A Scene will only render if it is visible.\r\n *\r\n * This event is dispatched after the Scene Display List is sorted and before the Scene is rendered.\r\n *\r\n * @event Phaser.Scenes.Events#PRE_RENDER\r\n * @since 3.53.0\r\n *\r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.\r\n */\r\nmodule.exports = 'prerender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Pre Update Event.\r\n *\r\n * This event is dispatched by a Scene during the main game loop step.\r\n *\r\n * The event flow for a single step of a Scene is as follows:\r\n *\r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\r\n * 6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n *\r\n * Listen to it from a Scene using `this.events.on('preupdate', listener)`.\r\n *\r\n * A Scene will only run its step if it is active.\r\n *\r\n * @event Phaser.Scenes.Events#PRE_UPDATE\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'preupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Ready Event.\r\n *\r\n * This event is dispatched by a Scene during the Scene Systems start process.\r\n * By this point in the process the Scene is now fully active and rendering.\r\n * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\r\n *\r\n * Listen to it from a Scene using `this.events.on('ready', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#READY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was started.\r\n */\r\nmodule.exports = 'ready';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Object Removed from Scene Event.\r\n *\r\n * This event is dispatched when a Game Object is removed from a Scene.\r\n *\r\n * Listen for it from a Scene using `this.events.on('removedfromscene', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the Scene.\r\n * @param {Phaser.Scene} scene - The Scene from which the Game Object was removed.\r\n */\r\nmodule.exports = 'removedfromscene';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Render Event.\r\n *\r\n * This event is dispatched by a Scene during the main game loop step.\r\n *\r\n * The event flow for a single step of a Scene is as follows:\r\n *\r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\r\n * 6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n *\r\n * Listen to it from a Scene using `this.events.on('render', listener)`.\r\n *\r\n * A Scene will only render if it is visible.\r\n *\r\n * By the time this event is dispatched, the Scene will have already been rendered.\r\n *\r\n * @event Phaser.Scenes.Events#RENDER\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.\r\n */\r\nmodule.exports = 'render';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Resume Event.\r\n *\r\n * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\r\n * or as an action from another Scene.\r\n *\r\n * Listen to it from a Scene using `this.events.on('resume', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#RESUME\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was resumed.\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Shutdown Event.\r\n *\r\n * This event is dispatched by a Scene during the Scene Systems shutdown process.\r\n *\r\n * Listen to it from a Scene using `this.events.on('shutdown', listener)`.\r\n *\r\n * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding\r\n * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\r\n * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.\r\n *\r\n * @event Phaser.Scenes.Events#SHUTDOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was shutdown.\r\n */\r\nmodule.exports = 'shutdown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Sleep Event.\r\n *\r\n * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\r\n * or as an action from another Scene.\r\n *\r\n * Listen to it from a Scene using `this.events.on('sleep', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#SLEEP\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was sent to sleep.\r\n */\r\nmodule.exports = 'sleep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Start Event.\r\n *\r\n * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\r\n *\r\n * Listen to it from a Scene using `this.events.on('start', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#START\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Complete Event.\r\n *\r\n * This event is dispatched by the Target Scene of a transition.\r\n *\r\n * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\r\n * of the transition.\r\n *\r\n * Listen to it from a Scene using `this.events.on('transitioncomplete', listener)`.\r\n *\r\n * The Scene Transition event flow is as follows:\r\n *\r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n *\r\n * @event Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Scene} scene -The Scene on which the transitioned completed.\r\n */\r\nmodule.exports = 'transitioncomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Init Event.\r\n *\r\n * This event is dispatched by the Target Scene of a transition.\r\n *\r\n * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\r\n * this event is not dispatched.\r\n *\r\n * Listen to it from a Scene using `this.events.on('transitioninit', listener)`.\r\n *\r\n * The Scene Transition event flow is as follows:\r\n *\r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n *\r\n * @event Phaser.Scenes.Events#TRANSITION_INIT\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitioninit';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Out Event.\r\n *\r\n * This event is dispatched by a Scene when it initiates a transition to another Scene.\r\n *\r\n * Listen to it from a Scene using `this.events.on('transitionout', listener)`.\r\n *\r\n * The Scene Transition event flow is as follows:\r\n *\r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n *\r\n * @event Phaser.Scenes.Events#TRANSITION_OUT\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Scene} target - A reference to the Scene that is being transitioned to.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionout';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Start Event.\r\n *\r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\r\n *\r\n * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\r\n * this event is dispatched anyway.\r\n *\r\n * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\r\n * dispatched instead of this event.\r\n *\r\n * Listen to it from a Scene using `this.events.on('transitionstart', listener)`.\r\n *\r\n * The Scene Transition event flow is as follows:\r\n *\r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n *\r\n * @event Phaser.Scenes.Events#TRANSITION_START\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Transition Wake Event.\r\n *\r\n * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\r\n * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\r\n *\r\n * Listen to it from a Scene using `this.events.on('transitionwake', listener)`.\r\n *\r\n * The Scene Transition event flow is as follows:\r\n *\r\n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\r\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\r\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\r\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\r\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\r\n *\r\n * @event Phaser.Scenes.Events#TRANSITION_WAKE\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\r\n * @param {number} duration - The duration of the transition in ms.\r\n */\r\nmodule.exports = 'transitionwake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Update Event.\r\n *\r\n * This event is dispatched by a Scene during the main game loop step.\r\n *\r\n * The event flow for a single step of a Scene is as follows:\r\n *\r\n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\r\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\r\n * 3. The `Scene.update` method is called, if it exists\r\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\r\n * 5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\r\n * 6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\r\n *\r\n * Listen to it from a Scene using `this.events.on('update', listener)`.\r\n *\r\n * A Scene will only run its step if it is active.\r\n *\r\n * @event Phaser.Scenes.Events#UPDATE\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'update';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scene Systems Wake Event.\r\n *\r\n * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\r\n * or as an action from another Scene.\r\n *\r\n * Listen to it from a Scene using `this.events.on('wake', listener)`.\r\n *\r\n * @event Phaser.Scenes.Events#WAKE\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\r\n * @param {any} [data] - An optional data object that was passed to this Scene when it was woken up.\r\n */\r\nmodule.exports = 'wake';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Scenes.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADDED_TO_SCENE: require('./ADDED_TO_SCENE_EVENT'),\r\n    BOOT: require('./BOOT_EVENT'),\r\n    CREATE: require('./CREATE_EVENT'),\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    POST_UPDATE: require('./POST_UPDATE_EVENT'),\r\n    PRE_RENDER: require('./PRE_RENDER_EVENT'),\r\n    PRE_UPDATE: require('./PRE_UPDATE_EVENT'),\r\n    READY: require('./READY_EVENT'),\r\n    REMOVED_FROM_SCENE: require('./REMOVED_FROM_SCENE_EVENT'),\r\n    RENDER: require('./RENDER_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    SHUTDOWN: require('./SHUTDOWN_EVENT'),\r\n    SLEEP: require('./SLEEP_EVENT'),\r\n    START: require('./START_EVENT'),\r\n    TRANSITION_COMPLETE: require('./TRANSITION_COMPLETE_EVENT'),\r\n    TRANSITION_INIT: require('./TRANSITION_INIT_EVENT'),\r\n    TRANSITION_OUT: require('./TRANSITION_OUT_EVENT'),\r\n    TRANSITION_START: require('./TRANSITION_START_EVENT'),\r\n    TRANSITION_WAKE: require('./TRANSITION_WAKE_EVENT'),\r\n    UPDATE: require('./UPDATE_EVENT'),\r\n    WAKE: require('./WAKE_EVENT')\r\n\r\n};\r\n"],"names":["module","exports","ADDED_TO_SCENE","BOOT","CREATE","DESTROY","PAUSE","POST_UPDATE","PRE_RENDER","PRE_UPDATE","READY","REMOVED_FROM_SCENE","RENDER","RESUME","SHUTDOWN","SLEEP","START","TRANSITION_COMPLETE","TRANSITION_INIT","TRANSITION_OUT","TRANSITION_START","TRANSITION_WAKE","UPDATE","WAKE"],"sourceRoot":""}