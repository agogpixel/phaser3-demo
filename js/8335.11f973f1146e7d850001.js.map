{"version":3,"file":"js/8335.11f973f1146e7d850001.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Area.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/ContainsPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/ContainsRect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/GetBounds.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Offset.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/OffsetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Area.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/ContainsPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/ContainsRect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/GetBounds.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Offset.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/OffsetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/CircleToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetCircleToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetCircleToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetLineToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetLineToLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetLineToPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetLineToPolygon.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetLineToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetRaysFromPointToPolygon.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetRectangleIntersection.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetRectangleToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetRectangleToTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetTriangleToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetTriangleToLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/GetTriangleToTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/LineToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/LineToLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/LineToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/PointToLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/PointToLineSegment.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/RectangleToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/RectangleToTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/RectangleToValues.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/TriangleToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/TriangleToLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/TriangleToTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Angle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/CenterOn.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Extend.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/GetEasedPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/GetMidPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/GetNearestPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/GetNormal.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/GetShortestDistance.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Height.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/NormalAngle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/NormalX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/NormalY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Offset.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/PerpSlope.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/ReflectAngle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Rotate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/RotateAroundPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/RotateAroundXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/SetToAngle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Slope.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/Width.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/line/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/GenerateGridVerts.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/ParseObj.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/ParseObjMaterial.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/RotateFace.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Ceil.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Floor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/GetCentroid.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/GetMagnitude.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/GetMagnitudeSq.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/GetRectangleFromPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Interpolate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Invert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Negative.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/Project.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/ProjectUnit.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/SetMagnitude.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/point/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/ContainsPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/GetNumberArray.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Reverse.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Simplify.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Translate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Area.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Ceil.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/CeilAll.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/CenterOn.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/ContainsPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/ContainsRect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Decompose.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FitInside.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FitOutside.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Floor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FloorAll.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FromPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FromXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/GetAspectRatio.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/GetCenter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/GetSize.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Inflate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Intersection.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/MergePoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/MergeRect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/MergeXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Offset.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/OffsetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Overlaps.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/PerimeterPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/RandomOutside.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/SameDimensions.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Scale.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Area.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/BuildEquilateral.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/BuildFromPolygon.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/BuildRight.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/CenterOn.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Centroid.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/CircumCenter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/CircumCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/ContainsArray.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/ContainsPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/CopyFrom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Decompose.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Equals.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/InCenter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Offset.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Perimeter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Rotate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/RotateAroundPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/RotateAroundXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Between.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FromPercent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Vector4.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetweenPoints.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the area of the circle.\r\n *\r\n * @function Phaser.Geom.Circle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the area of.\r\n *\r\n * @return {number} The area of the Circle.\r\n */\r\nvar Area = function (circle)\r\n{\r\n    return (circle.radius > 0) ? Math.PI * circle.radius * circle.radius : 0;\r\n};\r\n\r\nmodule.exports = Area;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('./Circle');\r\n\r\n/**\r\n * Creates a new Circle instance based on the values contained in the given source.\r\n *\r\n * @function Phaser.Geom.Circle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|object)} source - The Circle to be cloned. Can be an instance of a Circle or a circle-like object, with x, y and radius properties.\r\n *\r\n * @return {Phaser.Geom.Circle} A clone of the source Circle.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Circle(source.x, source.y, source.radius);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Check to see if the Circle contains the given Point object.\r\n *\r\n * @function Phaser.Geom.Circle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if the Point coordinates are within the circle, otherwise false.\r\n */\r\nvar ContainsPoint = function (circle, point)\r\n{\r\n    return Contains(circle, point.x, point.y);\r\n};\r\n\r\nmodule.exports = ContainsPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Check to see if the Circle contains all four points of the given Rectangle object.\r\n *\r\n * @function Phaser.Geom.Circle.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if all of the Rectangle coordinates are within the circle, otherwise false.\r\n */\r\nvar ContainsRect = function (circle, rect)\r\n{\r\n    return (\r\n        Contains(circle, rect.x, rect.y) &&\r\n        Contains(circle, rect.right, rect.y) &&\r\n        Contains(circle, rect.x, rect.bottom) &&\r\n        Contains(circle, rect.right, rect.bottom)\r\n    );\r\n};\r\n\r\nmodule.exports = ContainsRect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copies the `x`, `y` and `radius` properties from the `source` Circle\r\n * into the given `dest` Circle, then returns the `dest` Circle.\r\n *\r\n * @function Phaser.Geom.Circle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} source - The source Circle to copy the values from.\r\n * @param {Phaser.Geom.Circle} dest - The destination Circle to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Circle} The destination Circle.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x, source.y, source.radius);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compares the `x`, `y` and `radius` properties of the two given Circles.\r\n * Returns `true` if they all match, otherwise returns `false`.\r\n *\r\n * @function Phaser.Geom.Circle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The first Circle to compare.\r\n * @param {Phaser.Geom.Circle} toCompare - The second Circle to compare.\r\n *\r\n * @return {boolean} `true` if the two Circles equal each other, otherwise `false`.\r\n */\r\nvar Equals = function (circle, toCompare)\r\n{\r\n    return (\r\n        circle.x === toCompare.x &&\r\n        circle.y === toCompare.y &&\r\n        circle.radius === toCompare.radius\r\n    );\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../rectangle/Rectangle');\r\n\r\n/**\r\n * Returns the bounds of the Circle object.\r\n *\r\n * @function Phaser.Geom.Circle.GetBounds\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the bounds from.\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - A Rectangle, or rectangle-like object, to store the circle bounds in. If not given a new Rectangle will be created.\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} The Rectangle object containing the Circles bounds.\r\n */\r\nvar GetBounds = function (circle, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    out.x = circle.left;\r\n    out.y = circle.top;\r\n    out.width = circle.diameter;\r\n    out.height = circle.diameter;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Offsets the Circle by the values given.\r\n *\r\n * @function Phaser.Geom.Circle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [circle,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to be offset (translated.)\r\n * @param {number} x - The amount to horizontally offset the Circle by.\r\n * @param {number} y - The amount to vertically offset the Circle by.\r\n *\r\n * @return {Phaser.Geom.Circle} The Circle that was offset.\r\n */\r\nvar Offset = function (circle, x, y)\r\n{\r\n    circle.x += x;\r\n    circle.y += y;\r\n\r\n    return circle;\r\n};\r\n\r\nmodule.exports = Offset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Offsets the Circle by the values given in the `x` and `y` properties of the Point object.\r\n *\r\n * @function Phaser.Geom.Circle.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [circle,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to be offset (translated.)\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object containing the values to offset the Circle by.\r\n *\r\n * @return {Phaser.Geom.Circle} The Circle that was offset.\r\n */\r\nvar OffsetPoint = function (circle, point)\r\n{\r\n    circle.x += point.x;\r\n    circle.y += point.y;\r\n\r\n    return circle;\r\n};\r\n\r\nmodule.exports = OffsetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('./Circle');\r\n\r\nCircle.Area = require('./Area');\r\nCircle.Circumference = require('./Circumference');\r\nCircle.CircumferencePoint = require('./CircumferencePoint');\r\nCircle.Clone = require('./Clone');\r\nCircle.Contains = require('./Contains');\r\nCircle.ContainsPoint = require('./ContainsPoint');\r\nCircle.ContainsRect = require('./ContainsRect');\r\nCircle.CopyFrom = require('./CopyFrom');\r\nCircle.Equals = require('./Equals');\r\nCircle.GetBounds = require('./GetBounds');\r\nCircle.GetPoint = require('./GetPoint');\r\nCircle.GetPoints = require('./GetPoints');\r\nCircle.Offset = require('./Offset');\r\nCircle.OffsetPoint = require('./OffsetPoint');\r\nCircle.Random = require('./Random');\r\n\r\nmodule.exports = Circle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the area of the Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the area of.\r\n *\r\n * @return {number} The area of the Ellipse.\r\n */\r\nvar Area = function (ellipse)\r\n{\r\n    if (ellipse.isEmpty())\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    //  units squared\r\n    return (ellipse.getMajorRadius() * ellipse.getMinorRadius() * Math.PI);\r\n};\r\n\r\nmodule.exports = Area;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Ellipse = require('./Ellipse');\r\n\r\n/**\r\n * Creates a new Ellipse instance based on the values contained in the given source.\r\n *\r\n * @function Phaser.Geom.Ellipse.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} source - The Ellipse to be cloned. Can be an instance of an Ellipse or a ellipse-like object, with x, y, width and height properties.\r\n *\r\n * @return {Phaser.Geom.Ellipse} A clone of the source Ellipse.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Ellipse(source.x, source.y, source.width, source.height);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Check to see if the Ellipse contains the given Point object.\r\n *\r\n * @function Phaser.Geom.Ellipse.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to check.\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object to check if it's within the Circle or not.\r\n *\r\n * @return {boolean} True if the Point coordinates are within the circle, otherwise false.\r\n */\r\nvar ContainsPoint = function (ellipse, point)\r\n{\r\n    return Contains(ellipse, point.x, point.y);\r\n};\r\n\r\nmodule.exports = ContainsPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Check to see if the Ellipse contains all four points of the given Rectangle object.\r\n *\r\n * @function Phaser.Geom.Ellipse.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to check.\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle object to check if it's within the Ellipse or not.\r\n *\r\n * @return {boolean} True if all of the Rectangle coordinates are within the ellipse, otherwise false.\r\n */\r\nvar ContainsRect = function (ellipse, rect)\r\n{\r\n    return (\r\n        Contains(ellipse, rect.x, rect.y) &&\r\n        Contains(ellipse, rect.right, rect.y) &&\r\n        Contains(ellipse, rect.x, rect.bottom) &&\r\n        Contains(ellipse, rect.right, rect.bottom)\r\n    );\r\n};\r\n\r\nmodule.exports = ContainsRect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copies the `x`, `y`, `width` and `height` properties from the `source` Ellipse\r\n * into the given `dest` Ellipse, then returns the `dest` Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} source - The source Ellipse to copy the values from.\r\n * @param {Phaser.Geom.Ellipse} dest - The destination Ellipse to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The destination Ellipse.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x, source.y, source.width, source.height);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compares the `x`, `y`, `width` and `height` properties of the two given Ellipses.\r\n * Returns `true` if they all match, otherwise returns `false`.\r\n *\r\n * @function Phaser.Geom.Ellipse.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The first Ellipse to compare.\r\n * @param {Phaser.Geom.Ellipse} toCompare - The second Ellipse to compare.\r\n *\r\n * @return {boolean} `true` if the two Ellipse equal each other, otherwise `false`.\r\n */\r\nvar Equals = function (ellipse, toCompare)\r\n{\r\n    return (\r\n        ellipse.x === toCompare.x &&\r\n        ellipse.y === toCompare.y &&\r\n        ellipse.width === toCompare.width &&\r\n        ellipse.height === toCompare.height\r\n    );\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../rectangle/Rectangle');\r\n\r\n/**\r\n * Returns the bounds of the Ellipse object.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetBounds\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the bounds from.\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - A Rectangle, or rectangle-like object, to store the ellipse bounds in. If not given a new Rectangle will be created.\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} The Rectangle object containing the Ellipse bounds.\r\n */\r\nvar GetBounds = function (ellipse, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    out.x = ellipse.left;\r\n    out.y = ellipse.top;\r\n    out.width = ellipse.width;\r\n    out.height = ellipse.height;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Offsets the Ellipse by the values given.\r\n *\r\n * @function Phaser.Geom.Ellipse.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [ellipse,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to be offset (translated.)\r\n * @param {number} x - The amount to horizontally offset the Ellipse by.\r\n * @param {number} y - The amount to vertically offset the Ellipse by.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The Ellipse that was offset.\r\n */\r\nvar Offset = function (ellipse, x, y)\r\n{\r\n    ellipse.x += x;\r\n    ellipse.y += y;\r\n\r\n    return ellipse;\r\n};\r\n\r\nmodule.exports = Offset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Offsets the Ellipse by the values given in the `x` and `y` properties of the Point object.\r\n *\r\n * @function Phaser.Geom.Ellipse.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Ellipse} O - [ellipse,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to be offset (translated.)\r\n * @param {(Phaser.Geom.Point|object)} point - The Point object containing the values to offset the Ellipse by.\r\n *\r\n * @return {Phaser.Geom.Ellipse} The Ellipse that was offset.\r\n */\r\nvar OffsetPoint = function (ellipse, point)\r\n{\r\n    ellipse.x += point.x;\r\n    ellipse.y += point.y;\r\n\r\n    return ellipse;\r\n};\r\n\r\nmodule.exports = OffsetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Ellipse = require('./Ellipse');\r\n\r\nEllipse.Area = require('./Area');\r\nEllipse.Circumference = require('./Circumference');\r\nEllipse.CircumferencePoint = require('./CircumferencePoint');\r\nEllipse.Clone = require('./Clone');\r\nEllipse.Contains = require('./Contains');\r\nEllipse.ContainsPoint = require('./ContainsPoint');\r\nEllipse.ContainsRect = require('./ContainsRect');\r\nEllipse.CopyFrom = require('./CopyFrom');\r\nEllipse.Equals = require('./Equals');\r\nEllipse.GetBounds = require('./GetBounds');\r\nEllipse.GetPoint = require('./GetPoint');\r\nEllipse.GetPoints = require('./GetPoints');\r\nEllipse.Offset = require('./Offset');\r\nEllipse.OffsetPoint = require('./OffsetPoint');\r\nEllipse.Random = require('./Random');\r\n\r\nmodule.exports = Ellipse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Geom\r\n */\r\n\r\nvar Geom = {\r\n\r\n    Circle: require('./circle'),\r\n    Ellipse: require('./ellipse'),\r\n    Intersects: require('./intersects'),\r\n    Line: require('./line'),\r\n    Mesh: require('./mesh'),\r\n    Point: require('./point'),\r\n    Polygon: require('./polygon'),\r\n    Rectangle: require('./rectangle'),\r\n    Triangle: require('./triangle')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nGeom = Extend(false, Geom, CONST);\r\n\r\nmodule.exports = Geom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\n\r\n/**\r\n * Checks if two Circles intersect.\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the two Circles intersect, otherwise `false`.\r\n */\r\nvar CircleToCircle = function (circleA, circleB)\r\n{\r\n    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));\r\n};\r\n\r\nmodule.exports = CircleToCircle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar CircleToCircle = require('./CircleToCircle');\r\n\r\n/**\r\n * Checks if two Circles intersect and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetCircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetCircleToCircle = function (circleA, circleB, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (CircleToCircle(circleA, circleB))\r\n    {\r\n        var x0 = circleA.x;\r\n        var y0 = circleA.y;\r\n        var r0 = circleA.radius;\r\n\r\n        var x1 = circleB.x;\r\n        var y1 = circleB.y;\r\n        var r1 = circleB.radius;\r\n\r\n        var coefficientA, coefficientB, coefficientC, lambda, x;\r\n\r\n        if (y0 === y1)\r\n        {\r\n            x = ((r1 * r1) - (r0 * r0) - (x1 * x1) + (x0 * x0)) / (2 * (x0 - x1));\r\n\r\n            coefficientA = 1;\r\n            coefficientB = -2 * y1;\r\n            coefficientC = (x1 * x1) + (x * x) - (2 * x1 * x) + (y1 * y1) - (r1 * r1);\r\n\r\n            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);\r\n\r\n            if (lambda === 0)\r\n            {\r\n                out.push(new Point(x, (-coefficientB / (2 * coefficientA))));\r\n            }\r\n            else if (lambda > 0)\r\n            {\r\n                out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));\r\n                out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var v1 = (x0 - x1) / (y0 - y1);\r\n            var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));\r\n\r\n            coefficientA = (v1 * v1) + 1;\r\n            coefficientB = (2 * y0 * v1) - (2 * n * v1) - (2 * x0);\r\n            coefficientC = (x0 * x0) + (y0 * y0) + (n * n) - (r0 * r0) - (2 * y0 * n);\r\n\r\n            lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);\r\n\r\n            if (lambda === 0)\r\n            {\r\n                x = (-coefficientB / (2 * coefficientA));\r\n                out.push(new Point(x, (n - (x * v1))));\r\n            }\r\n            else if (lambda > 0)\r\n            {\r\n                x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);\r\n                out.push(new Point(x, (n - (x * v1))));\r\n                x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);\r\n                out.push(new Point(x, (n - (x * v1))));\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetCircleToCircle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetLineToCircle = require('./GetLineToCircle');\r\nvar CircleToRectangle = require('./CircleToRectangle');\r\n\r\n/**\r\n * Checks for intersection between a circle and a rectangle,\r\n * and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetCircleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The circle to be checked.\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to be checked.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetCircleToRectangle = function (circle, rect, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (CircleToRectangle(circle, rect))\r\n    {\r\n        var lineA = rect.getLineA();\r\n        var lineB = rect.getLineB();\r\n        var lineC = rect.getLineC();\r\n        var lineD = rect.getLineD();\r\n\r\n        GetLineToCircle(lineA, circle, out);\r\n        GetLineToCircle(lineB, circle, out);\r\n        GetLineToCircle(lineC, circle, out);\r\n        GetLineToCircle(lineD, circle, out);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetCircleToRectangle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar LineToCircle = require('./LineToCircle');\r\n\r\n/**\r\n * Checks for intersection between the line segment and circle,\r\n * and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetLineToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line segment to check.\r\n * @param {Phaser.Geom.Circle} circle - The circle to check against the line.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetLineToCircle = function (line, circle, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (LineToCircle(line, circle))\r\n    {\r\n        var lx1 = line.x1;\r\n        var ly1 = line.y1;\r\n\r\n        var lx2 = line.x2;\r\n        var ly2 = line.y2;\r\n\r\n        var cx = circle.x;\r\n        var cy = circle.y;\r\n        var cr = circle.radius;\r\n\r\n        var lDirX = lx2 - lx1;\r\n        var lDirY = ly2 - ly1;\r\n        var oDirX = lx1 - cx;\r\n        var oDirY = ly1 - cy;\r\n\r\n        var coefficientA = lDirX * lDirX + lDirY * lDirY;\r\n        var coefficientB = 2 * (lDirX * oDirX + lDirY * oDirY);\r\n        var coefficientC = oDirX * oDirX + oDirY * oDirY - cr * cr;\r\n\r\n        var lambda = (coefficientB * coefficientB) - (4 * coefficientA * coefficientC);\r\n\r\n        var x, y;\r\n\r\n        if (lambda === 0)\r\n        {\r\n            var root = -coefficientB / (2 * coefficientA);\r\n            x = lx1 + root * lDirX;\r\n            y = ly1 + root * lDirY;\r\n            if (root >= 0 && root <= 1)\r\n            {\r\n                out.push(new Point(x, y));\r\n            }\r\n        }\r\n        else if (lambda > 0)\r\n        {\r\n            var root1 = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);\r\n            x = lx1 + root1 * lDirX;\r\n            y = ly1 + root1 * lDirY;\r\n            if (root1 >= 0 && root1 <= 1)\r\n            {\r\n                out.push(new Point(x, y));\r\n            }\r\n\r\n            var root2 = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);\r\n            x = lx1 + root2 * lDirX;\r\n            y = ly1 + root2 * lDirY;\r\n            if (root2 >= 0 && root2 <= 1)\r\n            {\r\n                out.push(new Point(x, y));\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetLineToCircle;\r\n","/**\r\n * @author       Richard Davey\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector3 = require('../../math/Vector3');\r\n\r\n/**\r\n * Checks for intersection between the two line segments and returns the intersection point as a Vector3,\r\n * or `null` if the lines are parallel, or do not intersect.\r\n *\r\n * The `z` property of the Vector3 contains the intersection distance, which can be used to find\r\n * the closest intersecting point from a group of line segments.\r\n *\r\n * @function Phaser.Geom.Intersects.GetLineToLine\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Geom.Line} line1 - The first line segment to check.\r\n * @param {Phaser.Geom.Line} line2 - The second line segment to check.\r\n * @param {Phaser.Math.Vector3} [out] - A Vector3 to store the intersection results in.\r\n *\r\n * @return {Phaser.Math.Vector3} A Vector3 containing the intersection results, or `null`.\r\n */\r\nvar GetLineToLine = function (line1, line2, out)\r\n{\r\n    var x1 = line1.x1;\r\n    var y1 = line1.y1;\r\n    var x2 = line1.x2;\r\n    var y2 = line1.y2;\r\n\r\n    var x3 = line2.x1;\r\n    var y3 = line2.y1;\r\n    var x4 = line2.x2;\r\n    var y4 = line2.y2;\r\n\r\n    var dx1 = x2 - x1;\r\n    var dy1 = y2 - y1;\r\n\r\n    var dx2 = x4 - x3;\r\n    var dy2 = y4 - y3;\r\n\r\n    var denom = dy2 * dx1 - dx2 * dy1;\r\n\r\n    //  Make sure there is not a division by zero - this also indicates that the lines are parallel.\r\n    //  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).\r\n    //  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).\r\n\r\n    if (dx1 === 0 || denom === 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var T2 = (dx1 * (y3 - y1) + dy1 * (x1 - x3)) / (dx2 * dy1 - dy2 * dx1);\r\n    var T1 = (x3 + dx2 * T2 - x1) / dx1;\r\n\r\n    //  Intersects?\r\n    if (T1 < 0 || T2 < 0 || T2 > 1)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    if (out === undefined)\r\n    {\r\n        out = new Vector3();\r\n    }\r\n\r\n    return out.set(\r\n        x1 + dx1 * T1,\r\n        y1 + dy1 * T1,\r\n        T1\r\n    );\r\n};\r\n\r\nmodule.exports = GetLineToLine;\r\n","/**\r\n * @author       Richard Davey\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector3 = require('../../math/Vector3');\r\nvar GetLineToLine = require('./GetLineToLine');\r\nvar Line = require('../line/Line');\r\n\r\n//  Temp calculation segment\r\nvar segment = new Line();\r\n\r\n//  Temp vec3\r\nvar tempIntersect = new Vector3();\r\n\r\n/**\r\n * Checks for the closest point of intersection between a line segment and an array of points, where each pair\r\n * of points are converted to line segments for the intersection tests.\r\n *\r\n * If no intersection is found, this function returns `null`.\r\n *\r\n * If intersection was found, a Vector3 is returned with the following properties:\r\n *\r\n * The `x` and `y` components contain the point of the intersection.\r\n * The `z` component contains the closest distance.\r\n *\r\n * @function Phaser.Geom.Intersects.GetLineToPoints\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line segment to check.\r\n * @param {Phaser.Math.Vector2[] | Phaser.Geom.Point[]} points - An array of points to check.\r\n * @param {Phaser.Math.Vector3} [out] - A Vector3 to store the intersection results in.\r\n *\r\n * @return {Phaser.Math.Vector3} A Vector3 containing the intersection results, or `null`.\r\n */\r\nvar GetLineToPoints = function (line, points, out)\r\n{\r\n    if (out === undefined) { out = new Vector3(); }\r\n\r\n    var closestIntersect = false;\r\n\r\n    //  Reset our vec3s\r\n    out.set();\r\n    tempIntersect.set();\r\n\r\n    var prev = points[0];\r\n\r\n    for (var i = 1; i < points.length; i++)\r\n    {\r\n        var current = points[i];\r\n\r\n        segment.setTo(prev.x, prev.y, current.x, current.y);\r\n\r\n        prev = current;\r\n\r\n        if (GetLineToLine(line, segment, tempIntersect))\r\n        {\r\n            if (!closestIntersect || tempIntersect.z < out.z)\r\n            {\r\n                out.copy(tempIntersect);\r\n\r\n                closestIntersect = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return (closestIntersect) ? out : null;\r\n};\r\n\r\nmodule.exports = GetLineToPoints;\r\n","/**\r\n * @author       Richard Davey\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector3 = require('../../math/Vector3');\r\nvar Vector4 = require('../../math/Vector4');\r\nvar GetLineToPoints = require('./GetLineToPoints');\r\n\r\n//  Temp vec3\r\nvar tempIntersect = new Vector3();\r\n\r\n/**\r\n * Checks for the closest point of intersection between a line segment and an array of polygons.\r\n *\r\n * If no intersection is found, this function returns `null`.\r\n *\r\n * If intersection was found, a Vector4 is returned with the following properties:\r\n *\r\n * The `x` and `y` components contain the point of the intersection.\r\n * The `z` component contains the closest distance.\r\n * The `w` component contains the index of the polygon, in the given array, that triggered the intersection.\r\n *\r\n * @function Phaser.Geom.Intersects.GetLineToPolygon\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line segment to check.\r\n * @param {Phaser.Geom.Polygon | Phaser.Geom.Polygon[]} polygons - A single polygon, or array of polygons, to check.\r\n * @param {Phaser.Math.Vector4} [out] - A Vector4 to store the intersection results in.\r\n *\r\n * @return {Phaser.Math.Vector4} A Vector4 containing the intersection results, or `null`.\r\n */\r\nvar GetLineToPolygon = function (line, polygons, out)\r\n{\r\n    if (out === undefined) { out = new Vector4(); }\r\n\r\n    if (!Array.isArray(polygons))\r\n    {\r\n        polygons = [ polygons ];\r\n    }\r\n\r\n    var closestIntersect = false;\r\n\r\n    //  Reset our vec4s\r\n    out.set();\r\n    tempIntersect.set();\r\n\r\n    for (var i = 0; i < polygons.length; i++)\r\n    {\r\n        if (GetLineToPoints(line, polygons[i].points, tempIntersect))\r\n        {\r\n            if (!closestIntersect || tempIntersect.z < out.z)\r\n            {\r\n                out.set(tempIntersect.x, tempIntersect.y, tempIntersect.z, i);\r\n\r\n                closestIntersect = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return (closestIntersect) ? out : null;\r\n};\r\n\r\nmodule.exports = GetLineToPolygon;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar LineToLine = require('./LineToLine');\r\nvar LineToRectangle = require('./LineToRectangle');\r\n\r\n/**\r\n * Checks for intersection between the Line and a Rectangle shape,\r\n * and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetLineToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The Line to check for intersection.\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetLineToRectangle = function (line, rect, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (LineToRectangle(line, rect))\r\n    {\r\n        var lineA = rect.getLineA();\r\n        var lineB = rect.getLineB();\r\n        var lineC = rect.getLineC();\r\n        var lineD = rect.getLineD();\r\n\r\n        var output = [ new Point(), new Point(), new Point(), new Point() ];\r\n\r\n        var result = [\r\n            LineToLine(lineA, line, output[0]),\r\n            LineToLine(lineB, line, output[1]),\r\n            LineToLine(lineC, line, output[2]),\r\n            LineToLine(lineD, line, output[3])\r\n        ];\r\n\r\n        for (var i = 0; i < 4; i++)\r\n        {\r\n            if (result[i]) { out.push(output[i]); }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetLineToRectangle;\r\n","/**\r\n * @author       Richard Davey\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector4 = require('../../math/Vector4');\r\nvar GetLineToPolygon = require('./GetLineToPolygon');\r\nvar Line = require('../line/Line');\r\n\r\n//  Temp calculation segment\r\nvar segment = new Line();\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction CheckIntersects (angle, x, y, polygons, intersects)\r\n{\r\n    var dx = Math.cos(angle);\r\n    var dy = Math.sin(angle);\r\n\r\n    segment.setTo(x, y, x + dx, y + dy);\r\n\r\n    var closestIntersect = GetLineToPolygon(segment, polygons);\r\n\r\n    if (closestIntersect)\r\n    {\r\n        intersects.push(new Vector4(closestIntersect.x, closestIntersect.y, angle, closestIntersect.w));\r\n    }\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction SortIntersects (a, b)\r\n{\r\n    return a.z - b.z;\r\n}\r\n\r\n/**\r\n * Projects rays out from the given point to each line segment of the polygons.\r\n *\r\n * If the rays intersect with the polygons, the points of intersection are returned in an array.\r\n *\r\n * If no intersections are found, the returned array will be empty.\r\n *\r\n * Each Vector4 intersection result has the following properties:\r\n *\r\n * The `x` and `y` components contain the point of the intersection.\r\n * The `z` component contains the angle of intersection.\r\n * The `w` component contains the index of the polygon, in the given array, that triggered the intersection.\r\n *\r\n * @function Phaser.Geom.Intersects.GetRaysFromPointToPolygon\r\n * @since 3.50.0\r\n *\r\n * @param {number} x - The x coordinate to project the rays from.\r\n * @param {number} y - The y coordinate to project the rays from.\r\n * @param {Phaser.Geom.Polygon | Phaser.Geom.Polygon[]} polygons - A single polygon, or array of polygons, to check against the rays.\r\n *\r\n * @return {Phaser.Math.Vector4[]} An array containing all intersections in Vector4s.\r\n */\r\nvar GetRaysFromPointToPolygon = function (x, y, polygons)\r\n{\r\n    if (!Array.isArray(polygons))\r\n    {\r\n        polygons = [ polygons ];\r\n    }\r\n\r\n    var intersects = [];\r\n    var angles = [];\r\n\r\n    for (var i = 0; i < polygons.length; i++)\r\n    {\r\n        var points = polygons[i].points;\r\n\r\n        for (var p = 0; p < points.length; p++)\r\n        {\r\n            var angle = Math.atan2(points[p].y - y, points[p].x - x);\r\n\r\n            if (angles.indexOf(angle) === -1)\r\n            {\r\n                //  +- 0.00001 rads to catch lines behind segment corners\r\n\r\n                CheckIntersects(angle, x, y, polygons, intersects);\r\n                CheckIntersects(angle - 0.00001, x, y, polygons, intersects);\r\n                CheckIntersects(angle + 0.00001, x, y, polygons, intersects);\r\n\r\n                angles.push(angle);\r\n            }\r\n        }\r\n    }\r\n\r\n    return intersects.sort(SortIntersects);\r\n};\r\n\r\nmodule.exports = GetRaysFromPointToPolygon;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../rectangle/Rectangle');\r\nvar RectangleToRectangle = require('./RectangleToRectangle');\r\n\r\n/**\r\n * Checks if two Rectangle shapes intersect and returns the area of this intersection as Rectangle object.\r\n * \r\n * If optional `output` parameter is omitted, new Rectangle object is created and returned. If there is intersection, it will contain intersection area. If there is no intersection, it wil be empty Rectangle (all values set to zero).\r\n * \r\n * If Rectangle object is passed as `output` and there is intersection, then intersection area data will be loaded into it and it will be returned. If there is no intersection, it will be returned without any change.\r\n *\r\n * @function Phaser.Geom.Intersects.GetRectangleIntersection\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle object.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle object.\r\n * @param {Phaser.Geom.Rectangle} [output] - Optional Rectangle object. If given, the intersection data will be loaded into it (in case of no intersection, it will be left unchanged). Otherwise, new Rectangle object will be created and returned with either intersection data or empty (all values set to zero), if there is no intersection.\r\n *\r\n * @return {Phaser.Geom.Rectangle} A rectangle object with intersection data.\r\n */\r\nvar GetRectangleIntersection = function (rectA, rectB, output)\r\n{\r\n    if (output === undefined) { output = new Rectangle(); }\r\n\r\n    if (RectangleToRectangle(rectA, rectB))\r\n    {\r\n        output.x = Math.max(rectA.x, rectB.x);\r\n        output.y = Math.max(rectA.y, rectB.y);\r\n        output.width = Math.min(rectA.right, rectB.right) - output.x;\r\n        output.height = Math.min(rectA.bottom, rectB.bottom) - output.y;\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = GetRectangleIntersection;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetLineToRectangle = require('./GetLineToRectangle');\r\nvar RectangleToRectangle = require('./RectangleToRectangle');\r\n\r\n/**\r\n * Checks if two Rectangles intersect and returns the intersection points as a Point object array.\r\n *\r\n * A Rectangle intersects another Rectangle if any part of its bounds is within the other Rectangle's bounds. As such, the two Rectangles are considered \"solid\". A Rectangle with no width or no height will never intersect another Rectangle.\r\n *\r\n * @function Phaser.Geom.Intersects.GetRectangleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle to check for intersection.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetRectangleToRectangle = function (rectA, rectB, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (RectangleToRectangle(rectA, rectB))\r\n    {\r\n        var lineA = rectA.getLineA();\r\n        var lineB = rectA.getLineB();\r\n        var lineC = rectA.getLineC();\r\n        var lineD = rectA.getLineD();\r\n\r\n        GetLineToRectangle(lineA, rectB, out);\r\n        GetLineToRectangle(lineB, rectB, out);\r\n        GetLineToRectangle(lineC, rectB, out);\r\n        GetLineToRectangle(lineD, rectB, out);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetRectangleToRectangle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RectangleToTriangle = require('./RectangleToTriangle');\r\nvar GetLineToRectangle = require('./GetLineToRectangle');\r\n\r\n/**\r\n * Checks for intersection between Rectangle shape and Triangle shape,\r\n * and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetRectangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - Rectangle object to test.\r\n * @param {Phaser.Geom.Triangle} triangle - Triangle object to test.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetRectangleToTriangle = function (rect, triangle, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (RectangleToTriangle(rect, triangle))\r\n    {\r\n        var lineA = triangle.getLineA();\r\n        var lineB = triangle.getLineB();\r\n        var lineC = triangle.getLineC();\r\n\r\n        GetLineToRectangle(lineA, rect, out);\r\n        GetLineToRectangle(lineB, rect, out);\r\n        GetLineToRectangle(lineC, rect, out);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetRectangleToTriangle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetLineToCircle = require('./GetLineToCircle');\r\nvar TriangleToCircle = require('./TriangleToCircle');\r\n\r\n/**\r\n * Checks if a Triangle and a Circle intersect, and returns the intersection points as a Point object array.\r\n *\r\n * A Circle intersects a Triangle if its center is located within it or if any of the Triangle's sides intersect the Circle. As such, the Triangle and the Circle are considered \"solid\" for the intersection.\r\n *\r\n * @function Phaser.Geom.Intersects.GetTriangleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetTriangleToCircle = function (triangle, circle, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (TriangleToCircle(triangle, circle))\r\n    {\r\n        var lineA = triangle.getLineA();\r\n        var lineB = triangle.getLineB();\r\n        var lineC = triangle.getLineC();\r\n\r\n        GetLineToCircle(lineA, circle, out);\r\n        GetLineToCircle(lineB, circle, out);\r\n        GetLineToCircle(lineC, circle, out);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetTriangleToCircle;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar TriangleToLine = require('./TriangleToLine');\r\nvar LineToLine = require('./LineToLine');\r\n\r\n/**\r\n * Checks if a Triangle and a Line intersect, and returns the intersection points as a Point object array.\r\n *\r\n * The Line intersects the Triangle if it starts inside of it, ends inside of it, or crosses any of the Triangle's sides. Thus, the Triangle is considered \"solid\".\r\n *\r\n * @function Phaser.Geom.Intersects.GetTriangleToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to check with.\r\n * @param {Phaser.Geom.Line} line - The Line to check with.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetTriangleToLine = function (triangle, line, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (TriangleToLine(triangle, line))\r\n    {\r\n        var lineA = triangle.getLineA();\r\n        var lineB = triangle.getLineB();\r\n        var lineC = triangle.getLineC();\r\n\r\n        var output = [ new Point(), new Point(), new Point() ];\r\n\r\n        var result = [\r\n            LineToLine(lineA, line, output[0]),\r\n            LineToLine(lineB, line, output[1]),\r\n            LineToLine(lineC, line, output[2])\r\n        ];\r\n\r\n        for (var i = 0; i < 3; i++)\r\n        {\r\n            if (result[i]) { out.push(output[i]); }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetTriangleToLine;\r\n","/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TriangleToTriangle = require('./TriangleToTriangle');\r\nvar GetTriangleToLine = require('./GetTriangleToLine');\r\n\r\n/**\r\n * Checks if two Triangles intersect, and returns the intersection points as a Point object array.\r\n *\r\n * A Triangle intersects another Triangle if any pair of their lines intersects or if any point of one Triangle is within the other Triangle. Thus, the Triangles are considered \"solid\".\r\n *\r\n * @function Phaser.Geom.Intersects.GetTriangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangleA - The first Triangle to check for intersection.\r\n * @param {Phaser.Geom.Triangle} triangleB - The second Triangle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\r\nvar GetTriangleToTriangle = function (triangleA, triangleB, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    if (TriangleToTriangle(triangleA, triangleB))\r\n    {\r\n        var lineA = triangleB.getLineA();\r\n        var lineB = triangleB.getLineB();\r\n        var lineC = triangleB.getLineC();\r\n\r\n        GetTriangleToLine(triangleA, lineA, out);\r\n        GetTriangleToLine(triangleA, lineB, out);\r\n        GetTriangleToLine(triangleA, lineC, out);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetTriangleToTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('../circle/Contains');\r\nvar Point = require('../point/Point');\r\n\r\nvar tmp = new Point();\r\n\r\n/**\r\n * Checks for intersection between the line segment and circle.\r\n *\r\n * Based on code by [Matt DesLauriers](https://github.com/mattdesl/line-circle-collision/blob/master/LICENSE.md).\r\n *\r\n * @function Phaser.Geom.Intersects.LineToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line segment to check.\r\n * @param {Phaser.Geom.Circle} circle - The circle to check against the line.\r\n * @param {(Phaser.Geom.Point|any)} [nearest] - An optional Point-like object. If given the closest point on the Line where the circle intersects will be stored in this object.\r\n *\r\n * @return {boolean} `true` if the two objects intersect, otherwise `false`.\r\n */\r\nvar LineToCircle = function (line, circle, nearest)\r\n{\r\n    if (nearest === undefined) { nearest = tmp; }\r\n\r\n    if (Contains(circle, line.x1, line.y1))\r\n    {\r\n        nearest.x = line.x1;\r\n        nearest.y = line.y1;\r\n\r\n        return true;\r\n    }\r\n\r\n    if (Contains(circle, line.x2, line.y2))\r\n    {\r\n        nearest.x = line.x2;\r\n        nearest.y = line.y2;\r\n\r\n        return true;\r\n    }\r\n\r\n    var dx = line.x2 - line.x1;\r\n    var dy = line.y2 - line.y1;\r\n\r\n    var lcx = circle.x - line.x1;\r\n    var lcy = circle.y - line.y1;\r\n\r\n    //  project lc onto d, resulting in vector p\r\n    var dLen2 = (dx * dx) + (dy * dy);\r\n    var px = dx;\r\n    var py = dy;\r\n\r\n    if (dLen2 > 0)\r\n    {\r\n        var dp = ((lcx * dx) + (lcy * dy)) / dLen2;\r\n\r\n        px *= dp;\r\n        py *= dp;\r\n    }\r\n\r\n    nearest.x = line.x1 + px;\r\n    nearest.y = line.y1 + py;\r\n    \r\n    //  len2 of p\r\n    var pLen2 = (px * px) + (py * py);\r\n    \r\n    return (\r\n        pLen2 <= dLen2 &&\r\n        ((px * dx) + (py * dy)) >= 0 &&\r\n        Contains(circle, nearest.x, nearest.y)\r\n    );\r\n};\r\n\r\nmodule.exports = LineToCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n//  This is based off an explanation and expanded math presented by Paul Bourke:\r\n//  See http:'local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/\r\n\r\n/**\r\n * Checks if two Lines intersect. If the Lines are identical, they will be treated as parallel and thus non-intersecting.\r\n *\r\n * @function Phaser.Geom.Intersects.LineToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line1 - The first Line to check.\r\n * @param {Phaser.Geom.Line} line2 - The second Line to check.\r\n * @param {Phaser.Geom.Point} [out] - A Point in which to optionally store the point of intersection.\r\n *\r\n * @return {boolean} `true` if the two Lines intersect, and the `out` object will be populated, if given. Otherwise, `false`.\r\n */\r\nvar LineToLine = function (line1, line2, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var x1 = line1.x1;\r\n    var y1 = line1.y1;\r\n    var x2 = line1.x2;\r\n    var y2 = line1.y2;\r\n\r\n    var x3 = line2.x1;\r\n    var y3 = line2.y1;\r\n    var x4 = line2.x2;\r\n    var y4 = line2.y2;\r\n\r\n    var numA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\r\n    var numB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\r\n    var deNom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\r\n\r\n    //  Make sure there is not a division by zero - this also indicates that the lines are parallel.\r\n    //  If numA and numB were both equal to zero the lines would be on top of each other (coincidental).\r\n    //  This check is not done because it is not necessary for this implementation (the parallel check accounts for this).\r\n\r\n    if (deNom === 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    //  Calculate the intermediate fractional point that the lines potentially intersect.\r\n\r\n    var uA = numA / deNom;\r\n    var uB = numB / deNom;\r\n\r\n    //  The fractional point will be between 0 and 1 inclusive if the lines intersect.\r\n    //  If the fractional calculation is larger than 1 or smaller than 0 the lines would need to be longer to intersect.\r\n\r\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1)\r\n    {\r\n        out.x = x1 + (uA * (x2 - x1));\r\n        out.y = y1 + (uA * (y2 - y1));\r\n\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = LineToLine;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks for intersection between the Line and a Rectangle shape, or a rectangle-like\r\n * object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.\r\n *\r\n * An intersection is considered valid if:\r\n *\r\n * The line starts within, or ends within, the Rectangle.\r\n * The line segment intersects one of the 4 rectangle edges.\r\n *\r\n * The for the purposes of this function rectangles are considered 'solid'.\r\n *\r\n * @function Phaser.Geom.Intersects.LineToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The Line to check for intersection.\r\n * @param {(Phaser.Geom.Rectangle|object)} rect - The Rectangle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the Line and the Rectangle intersect, `false` otherwise.\r\n */\r\nvar LineToRectangle = function (line, rect)\r\n{\r\n    var x1 = line.x1;\r\n    var y1 = line.y1;\r\n\r\n    var x2 = line.x2;\r\n    var y2 = line.y2;\r\n\r\n    var bx1 = rect.x;\r\n    var by1 = rect.y;\r\n    var bx2 = rect.right;\r\n    var by2 = rect.bottom;\r\n\r\n    var t = 0;\r\n\r\n    //  If the start or end of the line is inside the rect then we assume\r\n    //  collision, as rects are solid for our use-case.\r\n\r\n    if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) ||\r\n        (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (x1 < bx1 && x2 >= bx1)\r\n    {\r\n        //  Left edge\r\n        t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1);\r\n\r\n        if (t > by1 && t <= by2)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    else if (x1 > bx2 && x2 <= bx2)\r\n    {\r\n        //  Right edge\r\n        t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1);\r\n\r\n        if (t >= by1 && t <= by2)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    if (y1 < by1 && y2 >= by1)\r\n    {\r\n        //  Top edge\r\n        t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1);\r\n\r\n        if (t >= bx1 && t <= bx2)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    else if (y1 > by2 && y2 <= by2)\r\n    {\r\n        //  Bottom edge\r\n        t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1);\r\n\r\n        if (t >= bx1 && t <= bx2)\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = LineToRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Florian Mertens\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the a Point falls between the two end-points of a Line, based on the given line thickness.\r\n * \r\n * Assumes that the line end points are circular, not square.\r\n *\r\n * @function Phaser.Geom.Intersects.PointToLine\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|any)} point - The point, or point-like object to check.\r\n * @param {Phaser.Geom.Line} line - The line segment to test for intersection on.\r\n * @param {number} [lineThickness=1] - The line thickness. Assumes that the line end points are circular.\r\n *\r\n * @return {boolean} `true` if the Point falls on the Line, otherwise `false`.\r\n */\r\nvar PointToLine = function (point, line, lineThickness)\r\n{\r\n    if (lineThickness === undefined) { lineThickness = 1; }\r\n\r\n    var x1 = line.x1;\r\n    var y1 = line.y1;\r\n\r\n    var x2 = line.x2;\r\n    var y2 = line.y2;\r\n\r\n    var px = point.x;\r\n    var py = point.y;\r\n\r\n    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\r\n\r\n    if (L2 === 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var r = (((px - x1) * (x2 - x1)) + ((py - y1) * (y2 - y1))) / L2;\r\n\r\n    //  Assume line thickness is circular\r\n    if (r < 0)\r\n    {\r\n        //  Outside line1\r\n        return (Math.sqrt(((x1 - px) * (x1 - px)) + ((y1 - py) * (y1 - py))) <= lineThickness);\r\n    }\r\n    else if ((r >= 0) && (r <= 1))\r\n    {\r\n        //  On the line segment\r\n        var s = (((y1 - py) * (x2 - x1)) - ((x1 - px) * (y2 - y1))) / L2;\r\n\r\n        return (Math.abs(s) * Math.sqrt(L2) <= lineThickness);\r\n    }\r\n    else\r\n    {\r\n        //  Outside line2\r\n        return (Math.sqrt(((x2 - px) * (x2 - px)) + ((y2 - py) * (y2 - py))) <= lineThickness);\r\n    }\r\n};\r\n\r\nmodule.exports = PointToLine;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PointToLine = require('./PointToLine');\r\n\r\n/**\r\n * Checks if a Point is located on the given line segment.\r\n *\r\n * @function Phaser.Geom.Intersects.PointToLineSegment\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to check for intersection.\r\n * @param {Phaser.Geom.Line} line - The line segment to check for intersection.\r\n *\r\n * @return {boolean} `true` if the Point is on the given line segment, otherwise `false`.\r\n */\r\nvar PointToLineSegment = function (point, line)\r\n{\r\n    if (!PointToLine(point, line))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var xMin = Math.min(line.x1, line.x2);\r\n    var xMax = Math.max(line.x1, line.x2);\r\n    var yMin = Math.min(line.y1, line.y2);\r\n    var yMax = Math.max(line.y1, line.y2);\r\n\r\n    return ((point.x >= xMin && point.x <= xMax) && (point.y >= yMin && point.y <= yMax));\r\n};\r\n\r\nmodule.exports = PointToLineSegment;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if two Rectangles intersect.\r\n *\r\n * A Rectangle intersects another Rectangle if any part of its bounds is within the other Rectangle's bounds.\r\n * As such, the two Rectangles are considered \"solid\".\r\n * A Rectangle with no width or no height will never intersect another Rectangle.\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle to check for intersection.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the two Rectangles intersect, otherwise `false`.\r\n */\r\nvar RectangleToRectangle = function (rectA, rectB)\r\n{\r\n    if (rectA.width <= 0 || rectA.height <= 0 || rectB.width <= 0 || rectB.height <= 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return !(rectA.right < rectB.x || rectA.bottom < rectB.y || rectA.x > rectB.right || rectA.y > rectB.bottom);\r\n};\r\n\r\nmodule.exports = RectangleToRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LineToLine = require('./LineToLine');\r\nvar Contains = require('../rectangle/Contains');\r\nvar ContainsArray = require('../triangle/ContainsArray');\r\nvar Decompose = require('../rectangle/Decompose');\r\n\r\n/**\r\n * Checks for intersection between Rectangle shape and Triangle shape.\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - Rectangle object to test.\r\n * @param {Phaser.Geom.Triangle} triangle - Triangle object to test.\r\n *\r\n * @return {boolean} A value of `true` if objects intersect; otherwise `false`.\r\n */\r\nvar RectangleToTriangle = function (rect, triangle)\r\n{\r\n    //  First the cheapest ones:\r\n\r\n    if (\r\n        triangle.left > rect.right ||\r\n        triangle.right < rect.left ||\r\n        triangle.top > rect.bottom ||\r\n        triangle.bottom < rect.top)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var triA = triangle.getLineA();\r\n    var triB = triangle.getLineB();\r\n    var triC = triangle.getLineC();\r\n\r\n    //  Are any of the triangle points within the rectangle?\r\n\r\n    if (Contains(rect, triA.x1, triA.y1) || Contains(rect, triA.x2, triA.y2))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (Contains(rect, triB.x1, triB.y1) || Contains(rect, triB.x2, triB.y2))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (Contains(rect, triC.x1, triC.y1) || Contains(rect, triC.x2, triC.y2))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Cheap tests over, now to see if any of the lines intersect ...\r\n\r\n    var rectA = rect.getLineA();\r\n    var rectB = rect.getLineB();\r\n    var rectC = rect.getLineC();\r\n    var rectD = rect.getLineD();\r\n\r\n    if (LineToLine(triA, rectA) || LineToLine(triA, rectB) || LineToLine(triA, rectC) || LineToLine(triA, rectD))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(triB, rectA) || LineToLine(triB, rectB) || LineToLine(triB, rectC) || LineToLine(triB, rectD))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(triC, rectA) || LineToLine(triC, rectB) || LineToLine(triC, rectC) || LineToLine(triC, rectD))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  None of the lines intersect, so are any rectangle points within the triangle?\r\n\r\n    var points = Decompose(rect);\r\n    var within = ContainsArray(triangle, points, true);\r\n\r\n    return (within.length > 0);\r\n};\r\n\r\nmodule.exports = RectangleToTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if rectangle intersects with values.\r\n *\r\n * @function Phaser.Geom.Intersects.RectangleToValues\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle object\r\n * @param {number} left - The x coordinate of the left of the Rectangle.\r\n * @param {number} right - The x coordinate of the right of the Rectangle.\r\n * @param {number} top - The y coordinate of the top of the Rectangle.\r\n * @param {number} bottom - The y coordinate of the bottom of the Rectangle.\r\n * @param {number} [tolerance=0] - Tolerance allowed in the calculation, expressed in pixels.\r\n *\r\n * @return {boolean} Returns true if there is an intersection.\r\n */\r\nvar RectangleToValues = function (rect, left, right, top, bottom, tolerance)\r\n{\r\n    if (tolerance === undefined) { tolerance = 0; }\r\n\r\n    return !(\r\n        left > rect.right + tolerance ||\r\n        right < rect.left - tolerance ||\r\n        top > rect.bottom + tolerance ||\r\n        bottom < rect.top - tolerance\r\n    );\r\n};\r\n\r\nmodule.exports = RectangleToValues;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LineToCircle = require('./LineToCircle');\r\nvar Contains = require('../triangle/Contains');\r\n\r\n/**\r\n * Checks if a Triangle and a Circle intersect.\r\n *\r\n * A Circle intersects a Triangle if its center is located within it or if any of the Triangle's sides intersect the Circle. As such, the Triangle and the Circle are considered \"solid\" for the intersection.\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the Triangle and the `Circle` intersect, otherwise `false`.\r\n */\r\nvar TriangleToCircle = function (triangle, circle)\r\n{\r\n    //  First the cheapest ones:\r\n\r\n    if (\r\n        triangle.left > circle.right ||\r\n        triangle.right < circle.left ||\r\n        triangle.top > circle.bottom ||\r\n        triangle.bottom < circle.top)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (Contains(triangle, circle.x, circle.y))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToCircle(triangle.getLineA(), circle))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToCircle(triangle.getLineB(), circle))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToCircle(triangle.getLineC(), circle))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = TriangleToCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LineToLine = require('./LineToLine');\r\n\r\n/**\r\n * Checks if a Triangle and a Line intersect.\r\n *\r\n * The Line intersects the Triangle if it starts inside of it, ends inside of it, or crosses any of the Triangle's sides. Thus, the Triangle is considered \"solid\".\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToLine\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to check with.\r\n * @param {Phaser.Geom.Line} line - The Line to check with.\r\n *\r\n * @return {boolean} `true` if the Triangle and the Line intersect, otherwise `false`.\r\n */\r\nvar TriangleToLine = function (triangle, line)\r\n{\r\n    //  If the Triangle contains either the start or end point of the line, it intersects\r\n    if (triangle.contains(line.x1, line.y1) || triangle.contains(line.x2, line.y2))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Now check the line against each line of the Triangle\r\n    if (LineToLine(triangle.getLineA(), line))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(triangle.getLineB(), line))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(triangle.getLineC(), line))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = TriangleToLine;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ContainsArray = require('../triangle/ContainsArray');\r\nvar Decompose = require('../triangle/Decompose');\r\nvar LineToLine = require('./LineToLine');\r\n\r\n/**\r\n * Checks if two Triangles intersect.\r\n *\r\n * A Triangle intersects another Triangle if any pair of their lines intersects or if any point of one Triangle is within the other Triangle. Thus, the Triangles are considered \"solid\".\r\n *\r\n * @function Phaser.Geom.Intersects.TriangleToTriangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangleA - The first Triangle to check for intersection.\r\n * @param {Phaser.Geom.Triangle} triangleB - The second Triangle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the Triangles intersect, otherwise `false`.\r\n */\r\nvar TriangleToTriangle = function (triangleA, triangleB)\r\n{\r\n    //  First the cheapest ones:\r\n\r\n    if (\r\n        triangleA.left > triangleB.right ||\r\n        triangleA.right < triangleB.left ||\r\n        triangleA.top > triangleB.bottom ||\r\n        triangleA.bottom < triangleB.top)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var lineAA = triangleA.getLineA();\r\n    var lineAB = triangleA.getLineB();\r\n    var lineAC = triangleA.getLineC();\r\n\r\n    var lineBA = triangleB.getLineA();\r\n    var lineBB = triangleB.getLineB();\r\n    var lineBC = triangleB.getLineC();\r\n\r\n    //  Now check the lines against each line of TriangleB\r\n    if (LineToLine(lineAA, lineBA) || LineToLine(lineAA, lineBB) || LineToLine(lineAA, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(lineAB, lineBA) || LineToLine(lineAB, lineBB) || LineToLine(lineAB, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (LineToLine(lineAC, lineBA) || LineToLine(lineAC, lineBB) || LineToLine(lineAC, lineBC))\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Nope, so check to see if any of the points of triangleA are within triangleB\r\n\r\n    var points = Decompose(triangleA);\r\n    var within = ContainsArray(triangleB, points, true);\r\n\r\n    if (within.length > 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    //  Finally check to see if any of the points of triangleB are within triangleA\r\n\r\n    points = Decompose(triangleB);\r\n    within = ContainsArray(triangleA, points, true);\r\n\r\n    if (within.length > 0)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nmodule.exports = TriangleToTriangle;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Geom.Intersects\n */\n\nmodule.exports = {\n\n    CircleToCircle: require('./CircleToCircle'),\n    CircleToRectangle: require('./CircleToRectangle'),\n    GetCircleToCircle: require('./GetCircleToCircle'),\n    GetCircleToRectangle: require('./GetCircleToRectangle'),\n    GetLineToCircle: require('./GetLineToCircle'),\n    GetLineToLine: require('./GetLineToLine'),\n    GetLineToPoints: require('./GetLineToPoints'),\n    GetLineToPolygon: require('./GetLineToPolygon'),\n    GetLineToRectangle: require('./GetLineToRectangle'),\n    GetRaysFromPointToPolygon: require('./GetRaysFromPointToPolygon'),\n    GetRectangleIntersection: require('./GetRectangleIntersection'),\n    GetRectangleToRectangle: require('./GetRectangleToRectangle'),\n    GetRectangleToTriangle: require('./GetRectangleToTriangle'),\n    GetTriangleToCircle: require('./GetTriangleToCircle'),\n    GetTriangleToLine: require('./GetTriangleToLine'),\n    GetTriangleToTriangle: require('./GetTriangleToTriangle'),\n    LineToCircle: require('./LineToCircle'),\n    LineToLine: require('./LineToLine'),\n    LineToRectangle: require('./LineToRectangle'),\n    PointToLine: require('./PointToLine'),\n    PointToLineSegment: require('./PointToLineSegment'),\n    RectangleToRectangle: require('./RectangleToRectangle'),\n    RectangleToTriangle: require('./RectangleToTriangle'),\n    RectangleToValues: require('./RectangleToValues'),\n    TriangleToCircle: require('./TriangleToCircle'),\n    TriangleToLine: require('./TriangleToLine'),\n    TriangleToTriangle: require('./TriangleToTriangle')\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the angle of the line in radians.\r\n *\r\n * @function Phaser.Geom.Line.Angle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the angle of.\r\n *\r\n * @return {number} The angle of the line, in radians.\r\n */\r\nvar Angle = function (line)\r\n{\r\n    return Math.atan2(line.y2 - line.y1, line.x2 - line.x1);\r\n};\r\n\r\nmodule.exports = Angle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n\r\n/**\r\n * Center a line on the given coordinates.\r\n *\r\n * @function Phaser.Geom.Line.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to center.\r\n * @param {number} x - The horizontal coordinate to center the line on.\r\n * @param {number} y - The vertical coordinate to center the line on.\r\n *\r\n * @return {Phaser.Geom.Line} The centered line.\r\n */\r\nvar CenterOn = function (line, x, y)\r\n{\r\n    var tx = x - ((line.x1 + line.x2) / 2);\r\n    var ty = y - ((line.y1 + line.y2) / 2);\r\n\r\n    line.x1 += tx;\r\n    line.y1 += ty;\r\n\r\n    line.x2 += tx;\r\n    line.y2 += ty;\r\n\r\n    return line;\r\n};\r\n\r\nmodule.exports = CenterOn;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Line = require('./Line');\r\n\r\n/**\r\n * Clone the given line.\r\n *\r\n * @function Phaser.Geom.Line.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} source - The source line to clone.\r\n *\r\n * @return {Phaser.Geom.Line} The cloned line.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Line(source.x1, source.y1, source.x2, source.y2);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copy the values of one line to a destination line.\r\n *\r\n * @function Phaser.Geom.Line.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Line} source - The source line to copy the values from.\r\n * @param {Phaser.Geom.Line} dest - The destination line to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Line} The destination line.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x1, source.y1, source.x2, source.y2);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compare two lines for strict equality.\r\n *\r\n * @function Phaser.Geom.Line.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The first line to compare.\r\n * @param {Phaser.Geom.Line} toCompare - The second line to compare.\r\n *\r\n * @return {boolean} Whether the two lines are equal.\r\n */\r\nvar Equals = function (line, toCompare)\r\n{\r\n    return (\r\n        line.x1 === toCompare.x1 &&\r\n        line.y1 === toCompare.y1 &&\r\n        line.x2 === toCompare.x2 &&\r\n        line.y2 === toCompare.y2\r\n    );\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('./Length');\r\n\r\n/**\r\n * Extends the start and end points of a Line by the given amounts.\r\n *\r\n * The amounts can be positive or negative. Positive points will increase the length of the line,\r\n * while negative ones will decrease it.\r\n *\r\n * If no `right` value is provided it will extend the length of the line equally in both directions.\r\n *\r\n * Pass a value of zero to leave the start or end point unchanged.\r\n *\r\n * @function Phaser.Geom.Line.Extend\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line instance to extend.\r\n * @param {number} left - The amount to extend the start of the line by.\r\n * @param {number} [right] - The amount to extend the end of the line by. If not given it will be set to the `left` value.\r\n *\r\n * @return {Phaser.Geom.Line} The modified Line instance.\r\n */\r\nvar Extend = function (line, left, right)\r\n{\r\n    if (right === undefined) { right = left; }\r\n\r\n    var length = Length(line);\r\n\r\n    var slopX = line.x2 - line.x1;\r\n    var slopY = line.y2 - line.y1;\r\n\r\n    if (left)\r\n    {\r\n        line.x1 = line.x1 - slopX / length * left;\r\n        line.y1 = line.y1 - slopY / length * left;\r\n    }\r\n\r\n    if (right)\r\n    {\r\n        line.x2 = line.x2 + slopX / length * right;\r\n        line.y2 = line.y2 + slopY / length * right;\r\n    }\r\n\r\n    return line;\r\n};\r\n\r\nmodule.exports = Extend;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DistanceBetweenPoints = require('../../math/distance/DistanceBetweenPoints');\r\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns an array of `quantity` Points where each point is taken from the given Line,\r\n * spaced out according to the ease function specified.\r\n * \r\n * ```javascript\r\n * const line = new Phaser.Geom.Line(100, 300, 700, 300);\r\n * const points = Phaser.Geom.Line.GetEasedPoints(line, 'sine.out', 32)\r\n * ```\r\n * \r\n * In the above example, the `points` array will contain 32 points spread-out across\r\n * the length of `line`, where the position of each point is determined by the `Sine.out`\r\n * ease function.\r\n * \r\n * You can optionally provide a collinear threshold. In this case, the resulting points\r\n * are checked against each other, and if they are `< collinearThreshold` distance apart,\r\n * they are dropped from the results. This can help avoid lots of clustered points at\r\n * far ends of the line with tightly-packed eases such as Quartic. Leave the value set\r\n * to zero to skip this check.\r\n * \r\n * Note that if you provide a collinear threshold, the resulting array may not always\r\n * contain `quantity` points.\r\n *\r\n * @function Phaser.Geom.Line.GetEasedPoints\r\n * @since 3.23.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The Line object.\r\n * @param {(string|function)} ease - The ease to use. This can be either a string from the EaseMap, or a custom function.\r\n * @param {number} quantity - The number of points to return. Note that if you provide a `collinearThreshold`, the resulting array may not always contain this number of points.\r\n * @param {number} [collinearThreshold=0] - An optional threshold. The final array is reduced so that each point is spaced out at least this distance apart. This helps reduce clustering in noisey eases.\r\n * @param {number[]} [easeParams] - An optional array of ease parameters to go with the ease.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Geom.Points containing the coordinates of the points on the line.\r\n */\r\nvar GetEasedPoints = function (line, ease, quantity, collinearThreshold, easeParams)\r\n{\r\n    if (collinearThreshold === undefined) { collinearThreshold = 0; }\r\n    if (easeParams === undefined) { easeParams = []; }\r\n\r\n    var results = [];\r\n\r\n    var x1 = line.x1;\r\n    var y1 = line.y1;\r\n\r\n    var spaceX = line.x2 - x1;\r\n    var spaceY = line.y2 - y1;\r\n\r\n    var easeFunc = GetEaseFunction(ease, easeParams);\r\n\r\n    var i;\r\n    var v;\r\n    var q = quantity - 1;\r\n\r\n    for (i = 0; i < q; i++)\r\n    {\r\n        v = easeFunc(i / q);\r\n\r\n        results.push(new Point(x1 + (spaceX * v), y1 + (spaceY * v)));\r\n    }\r\n\r\n    //  Always include the end of the line\r\n    v = easeFunc(1);\r\n\r\n    results.push(new Point(x1 + (spaceX * v), y1 + (spaceY * v)));\r\n\r\n    //  Remove collinear parts\r\n    if (collinearThreshold > 0)\r\n    {\r\n        var prevPoint = results[0];\r\n\r\n        //  Store the new results here\r\n        var sortedResults = [ prevPoint ];\r\n\r\n        for (i = 1; i < results.length - 1; i++)\r\n        {\r\n            var point = results[i];\r\n\r\n            if (DistanceBetweenPoints(prevPoint, point) >= collinearThreshold)\r\n            {\r\n                sortedResults.push(point);\r\n                prevPoint = point;\r\n            }\r\n        }\r\n\r\n        //  Top and tail\r\n        var endPoint = results[results.length - 1];\r\n\r\n        if (DistanceBetweenPoints(prevPoint, endPoint) < collinearThreshold)\r\n        {\r\n            sortedResults.pop();\r\n        }\r\n\r\n        sortedResults.push(endPoint);\r\n\r\n        return sortedResults;\r\n    }\r\n    else\r\n    {\r\n        return results;\r\n    }\r\n};\r\n\r\nmodule.exports = GetEasedPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Get the midpoint of the given line.\r\n *\r\n * @function Phaser.Geom.Line.GetMidPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to get the midpoint of.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An optional point object to store the midpoint in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} The midpoint of the Line.\r\n */\r\nvar GetMidPoint = function (line, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = (line.x1 + line.x2) / 2;\r\n    out.y = (line.y1 + line.y2) / 2;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetMidPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Florian Mertens\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Get the nearest point on a line perpendicular to the given point.\r\n *\r\n * @function Phaser.Geom.Line.GetNearestPoint\r\n * @since 3.16.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to get the nearest point on.\r\n * @param {(Phaser.Geom.Point|object)} point - The point to get the nearest point to.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An optional point, or point-like object, to store the coordinates of the nearest point on the line.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} The nearest point on the line.\r\n */\r\nvar GetNearestPoint = function (line, point, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var x1 = line.x1;\r\n    var y1 = line.y1;\r\n\r\n    var x2 = line.x2;\r\n    var y2 = line.y2;\r\n\r\n    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\r\n\r\n    if (L2 === 0)\r\n    {\r\n        return out;\r\n    }\r\n\r\n    var r = (((point.x - x1) * (x2 - x1)) + ((point.y - y1) * (y2 - y1))) / L2;\r\n\r\n    out.x = x1 + (r * (x2 - x1));\r\n    out.y = y1 + (r * (y2 - y1));\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetNearestPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar Angle = require('./Angle');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Calculate the normal of the given line.\r\n *\r\n * The normal of a line is a vector that points perpendicular from it.\r\n *\r\n * @function Phaser.Geom.Line.GetNormal\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the normal of.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An optional point object to store the normal in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} The normal of the Line.\r\n */\r\nvar GetNormal = function (line, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var a = Angle(line) - MATH_CONST.TAU;\r\n\r\n    out.x = Math.cos(a);\r\n    out.y = Math.sin(a);\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetNormal;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Florian Mertens\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Get the shortest distance from a Line to the given Point.\r\n *\r\n * @function Phaser.Geom.Line.GetShortestDistance\r\n * @since 3.16.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to get the distance from.\r\n * @param {(Phaser.Geom.Point|object)} point - The point to get the shortest distance to.\r\n *\r\n * @return {number} The shortest distance from the line to the point.\r\n */\r\nvar GetShortestDistance = function (line, point)\r\n{\r\n    var x1 = line.x1;\r\n    var y1 = line.y1;\r\n\r\n    var x2 = line.x2;\r\n    var y2 = line.y2;\r\n\r\n    var L2 = (((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\r\n\r\n    if (L2 === 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var s = (((y1 - point.y) * (x2 - x1)) - ((x1 - point.x) * (y2 - y1))) / L2;\r\n\r\n    return Math.abs(s) * Math.sqrt(L2);\r\n};\r\n\r\nmodule.exports = GetShortestDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the height of the given line.\r\n *\r\n * @function Phaser.Geom.Line.Height\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the height of.\r\n *\r\n * @return {number} The height of the line.\r\n */\r\nvar Height = function (line)\r\n{\r\n    return Math.abs(line.y1 - line.y2);\r\n};\r\n\r\nmodule.exports = Height;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar Wrap = require('../../math/Wrap');\r\nvar Angle = require('./Angle');\r\n\r\n/**\r\n * Get the angle of the normal of the given line in radians.\r\n *\r\n * @function Phaser.Geom.Line.NormalAngle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the angle of the normal of.\r\n *\r\n * @return {number} The angle of the normal of the line in radians.\r\n */\r\nvar NormalAngle = function (line)\r\n{\r\n    var angle = Angle(line) - MATH_CONST.TAU;\r\n\r\n    return Wrap(angle, -Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = NormalAngle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar Angle = require('./Angle');\r\n\r\n/**\r\n * Returns the x component of the normal vector of the given line.\r\n *\r\n * @function Phaser.Geom.Line.NormalX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The Line object to get the normal value from.\r\n *\r\n * @return {number} The x component of the normal vector of the line.\r\n */\r\nvar NormalX = function (line)\r\n{\r\n    return Math.cos(Angle(line) - MATH_CONST.TAU);\r\n};\r\n\r\nmodule.exports = NormalX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar Angle = require('./Angle');\r\n\r\n/**\r\n * The Y value of the normal of the given line.\r\n * The normal of a line is a vector that points perpendicular from it.\r\n *\r\n * @function Phaser.Geom.Line.NormalY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the normal of.\r\n *\r\n * @return {number} The Y value of the normal of the Line.\r\n */\r\nvar NormalY = function (line)\r\n{\r\n    return Math.sin(Angle(line) - MATH_CONST.TAU);\r\n};\r\n\r\nmodule.exports = NormalY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Offset a line by the given amount.\r\n *\r\n * @function Phaser.Geom.Line.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to offset.\r\n * @param {number} x - The horizontal offset to add to the line.\r\n * @param {number} y - The vertical offset to add to the line.\r\n *\r\n * @return {Phaser.Geom.Line} The offset line.\r\n */\r\nvar Offset = function (line, x, y)\r\n{\r\n    line.x1 += x;\r\n    line.y1 += y;\r\n\r\n    line.x2 += x;\r\n    line.y2 += y;\r\n\r\n    return line;\r\n};\r\n\r\nmodule.exports = Offset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the perpendicular slope of the given line.\r\n *\r\n * @function Phaser.Geom.Line.PerpSlope\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the perpendicular slope of.\r\n *\r\n * @return {number} The perpendicular slope of the line.\r\n */\r\nvar PerpSlope = function (line)\r\n{\r\n    return -((line.x2 - line.x1) / (line.y2 - line.y1));\r\n};\r\n\r\nmodule.exports = PerpSlope;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Angle = require('./Angle');\r\nvar NormalAngle = require('./NormalAngle');\r\n\r\n/**\r\n * Calculate the reflected angle between two lines.\r\n *\r\n * This is the outgoing angle based on the angle of Line 1 and the normalAngle of Line 2.\r\n *\r\n * @function Phaser.Geom.Line.ReflectAngle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} lineA - The first line.\r\n * @param {Phaser.Geom.Line} lineB - The second line.\r\n *\r\n * @return {number} The reflected angle between each line.\r\n */\r\nvar ReflectAngle = function (lineA, lineB)\r\n{\r\n    return (2 * NormalAngle(lineB) - Math.PI - Angle(lineA));\r\n};\r\n\r\nmodule.exports = ReflectAngle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RotateAroundXY = require('./RotateAroundXY');\r\n\r\n/**\r\n * Rotate a line around its midpoint by the given angle in radians.\r\n *\r\n * @function Phaser.Geom.Line.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to rotate.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Geom.Line} The rotated line.\r\n */\r\nvar Rotate = function (line, angle)\r\n{\r\n    var x = (line.x1 + line.x2) / 2;\r\n    var y = (line.y1 + line.y2) / 2;\r\n\r\n    return RotateAroundXY(line, x, y, angle);\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RotateAroundXY = require('./RotateAroundXY');\r\n\r\n/**\r\n * Rotate a line around a point by the given angle in radians.\r\n *\r\n * @function Phaser.Geom.Line.RotateAroundPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to rotate.\r\n * @param {(Phaser.Geom.Point|object)} point - The point to rotate the line around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Geom.Line} The rotated line.\r\n */\r\nvar RotateAroundPoint = function (line, point, angle)\r\n{\r\n    return RotateAroundXY(line, point.x, point.y, angle);\r\n};\r\n\r\nmodule.exports = RotateAroundPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a line around the given coordinates by the given angle in radians.\r\n *\r\n * @function Phaser.Geom.Line.RotateAroundXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to rotate.\r\n * @param {number} x - The horizontal coordinate to rotate the line around.\r\n * @param {number} y - The vertical coordinate to rotate the line around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Geom.Line} The rotated line.\r\n */\r\nvar RotateAroundXY = function (line, x, y, angle)\r\n{\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var tx = line.x1 - x;\r\n    var ty = line.y1 - y;\r\n\r\n    line.x1 = tx * c - ty * s + x;\r\n    line.y1 = tx * s + ty * c + y;\r\n\r\n    tx = line.x2 - x;\r\n    ty = line.y2 - y;\r\n\r\n    line.x2 = tx * c - ty * s + x;\r\n    line.y2 = tx * s + ty * c + y;\r\n\r\n    return line;\r\n};\r\n\r\nmodule.exports = RotateAroundXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Set a line to a given position, angle and length.\r\n *\r\n * @function Phaser.Geom.Line.SetToAngle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Line} O - [line,$return]\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to set.\r\n * @param {number} x - The horizontal start position of the line.\r\n * @param {number} y - The vertical start position of the line.\r\n * @param {number} angle - The angle of the line in radians.\r\n * @param {number} length - The length of the line.\r\n *\r\n * @return {Phaser.Geom.Line} The updated line.\r\n */\r\nvar SetToAngle = function (line, x, y, angle, length)\r\n{\r\n    line.x1 = x;\r\n    line.y1 = y;\r\n\r\n    line.x2 = x + (Math.cos(angle) * length);\r\n    line.y2 = y + (Math.sin(angle) * length);\r\n\r\n    return line;\r\n};\r\n\r\nmodule.exports = SetToAngle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the slope of the given line.\r\n *\r\n * @function Phaser.Geom.Line.Slope\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the slope of.\r\n *\r\n * @return {number} The slope of the line.\r\n */\r\nvar Slope = function (line)\r\n{\r\n    return (line.y2 - line.y1) / (line.x2 - line.x1);\r\n};\r\n\r\nmodule.exports = Slope;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the width of the given line.\r\n *\r\n * @function Phaser.Geom.Line.Width\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Line} line - The line to calculate the width of.\r\n *\r\n * @return {number} The width of the line.\r\n */\r\nvar Width = function (line)\r\n{\r\n    return Math.abs(line.x1 - line.x2);\r\n};\r\n\r\nmodule.exports = Width;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Line = require('./Line');\r\n\r\nLine.Angle = require('./Angle');\r\nLine.BresenhamPoints = require('./BresenhamPoints');\r\nLine.CenterOn = require('./CenterOn');\r\nLine.Clone = require('./Clone');\r\nLine.CopyFrom = require('./CopyFrom');\r\nLine.Equals = require('./Equals');\r\nLine.Extend = require('./Extend');\r\nLine.GetEasedPoints = require('./GetEasedPoints');\r\nLine.GetMidPoint = require('./GetMidPoint');\r\nLine.GetNearestPoint = require('./GetNearestPoint');\r\nLine.GetNormal = require('./GetNormal');\r\nLine.GetPoint = require('./GetPoint');\r\nLine.GetPoints = require('./GetPoints');\r\nLine.GetShortestDistance = require('./GetShortestDistance');\r\nLine.Height = require('./Height');\r\nLine.Length = require('./Length');\r\nLine.NormalAngle = require('./NormalAngle');\r\nLine.NormalX = require('./NormalX');\r\nLine.NormalY = require('./NormalY');\r\nLine.Offset = require('./Offset');\r\nLine.PerpSlope = require('./PerpSlope');\r\nLine.Random = require('./Random');\r\nLine.ReflectAngle = require('./ReflectAngle');\r\nLine.Rotate = require('./Rotate');\r\nLine.RotateAroundPoint = require('./RotateAroundPoint');\r\nLine.RotateAroundXY = require('./RotateAroundXY');\r\nLine.SetToAngle = require('./SetToAngle');\r\nLine.Slope = require('./Slope');\r\nLine.Width = require('./Width');\r\n\r\nmodule.exports = Line;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Face = require('./Face');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar Vector3 = require('../../math/Vector3');\r\nvar Vertex = require('./Vertex');\r\n\r\nvar tempPosition = new Vector3();\r\nvar tempRotation = new Vector3();\r\nvar tempMatrix = new Matrix4();\r\n\r\n/**\r\n * Creates a grid of vertices based on the given configuration object and optionally adds it to a Mesh.\r\n *\r\n * The size of the grid is given in pixels. An example configuration may be:\r\n *\r\n * `{ width: 256, height: 256, widthSegments: 2, heightSegments: 2, tile: true }`\r\n *\r\n * This will create a grid 256 x 256 pixels in size, split into 2 x 2 segments, with\r\n * the texture tiling across the cells.\r\n *\r\n * You can split the grid into segments both vertically and horizontally. This will\r\n * generate two faces per grid segment as a result.\r\n *\r\n * The `tile` parameter allows you to control if the tile will repeat across the grid\r\n * segments, or be displayed in full.\r\n *\r\n * If adding this grid to a Mesh you can offset the grid via the `x` and `y` properties.\r\n *\r\n * UV coordinates are generated based on the given texture and frame in the config. For\r\n * example, no frame is given, the UVs will be in the range 0 to 1. If a frame is given,\r\n * such as from a texture atlas, the UVs will be generated within the range of that frame.\r\n *\r\n * @function Phaser.Geom.Mesh.GenerateGridVerts\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Geom.Mesh.GenerateGridConfig} config - A Grid configuration object.\r\n *\r\n * @return {Phaser.Types.Geom.Mesh.GenerateGridVertsResult} A Grid Result object, containing the generated vertices and indicies.\r\n */\r\nvar GenerateGridVerts = function (config)\r\n{\r\n    var mesh = GetFastValue(config, 'mesh');\r\n    var texture = GetFastValue(config, 'texture', null);\r\n    var frame = GetFastValue(config, 'frame');\r\n    var width = GetFastValue(config, 'width', 1);\r\n    var height = GetFastValue(config, 'height', width);\r\n    var widthSegments = GetFastValue(config, 'widthSegments', 1);\r\n    var heightSegments = GetFastValue(config, 'heightSegments', widthSegments);\r\n    var posX = GetFastValue(config, 'x', 0);\r\n    var posY = GetFastValue(config, 'y', 0);\r\n    var posZ = GetFastValue(config, 'z', 0);\r\n    var rotateX = GetFastValue(config, 'rotateX', 0);\r\n    var rotateY = GetFastValue(config, 'rotateY', 0);\r\n    var rotateZ = GetFastValue(config, 'rotateZ', 0);\r\n    var zIsUp = GetFastValue(config, 'zIsUp', true);\r\n    var isOrtho = GetFastValue(config, 'isOrtho', (mesh) ? mesh.dirtyCache[11] : false);\r\n    var colors = GetFastValue(config, 'colors', [ 0xffffff ]);\r\n    var alphas = GetFastValue(config, 'alphas', [ 1 ]);\r\n    var tile = GetFastValue(config, 'tile', false);\r\n    var flipY = GetFastValue(config, 'flipY', false);\r\n\r\n    var widthSet = GetFastValue(config, 'width', null);\r\n\r\n    var result = {\r\n        faces: [],\r\n        verts: []\r\n    };\r\n\r\n    tempPosition.set(posX, posY, posZ);\r\n    tempRotation.set(rotateX, rotateY, rotateZ);\r\n    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);\r\n\r\n    if (!texture && mesh)\r\n    {\r\n        texture = mesh.texture;\r\n    }\r\n    else if (mesh && typeof(texture) === 'string')\r\n    {\r\n        texture = mesh.scene.sys.textures.get(texture);\r\n    }\r\n    else\r\n    {\r\n        //  There's nothing more we can do without a texture\r\n        return result;\r\n    }\r\n\r\n    var textureFrame = texture.get(frame);\r\n\r\n    //  If the Mesh is ortho and no width / height is given, we'll default to texture sizes (if set!)\r\n    if (!widthSet && isOrtho && texture && mesh)\r\n    {\r\n        width = textureFrame.width / mesh.height;\r\n        height = textureFrame.height / mesh.height;\r\n    }\r\n\r\n    var halfWidth = width / 2;\r\n    var halfHeight = height / 2;\r\n\r\n    var gridX = Math.floor(widthSegments);\r\n    var gridY = Math.floor(heightSegments);\r\n\r\n    var gridX1 = gridX + 1;\r\n    var gridY1 = gridY + 1;\r\n\r\n    var segmentWidth = width / gridX;\r\n    var segmentHeight = height / gridY;\r\n\r\n    var uvs = [];\r\n    var vertices = [];\r\n\r\n    var ix;\r\n    var iy;\r\n\r\n    var frameU0 = 0;\r\n    var frameU1 = 1;\r\n    var frameV0 = 0;\r\n    var frameV1 = 1;\r\n\r\n    if (textureFrame)\r\n    {\r\n        frameU0 = textureFrame.u0;\r\n        frameU1 = textureFrame.u1;\r\n\r\n        if (!flipY)\r\n        {\r\n            frameV0 = textureFrame.v0;\r\n            frameV1 = textureFrame.v1;\r\n        }\r\n        else\r\n        {\r\n            frameV0 = textureFrame.v1;\r\n            frameV1 = textureFrame.v0;\r\n        }\r\n    }\r\n\r\n    var frameU = frameU1 - frameU0;\r\n    var frameV = frameV1 - frameV0;\r\n\r\n    for (iy = 0; iy < gridY1; iy++)\r\n    {\r\n        var y = iy * segmentHeight - halfHeight;\r\n\r\n        for (ix = 0; ix < gridX1; ix++)\r\n        {\r\n            var x = ix * segmentWidth - halfWidth;\r\n\r\n            vertices.push(x, -y);\r\n\r\n            var tu = frameU0 + frameU * (ix / gridX);\r\n            var tv = frameV0 + frameV * (iy / gridY);\r\n\r\n            uvs.push(tu, tv);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(colors))\r\n    {\r\n        colors = [ colors ];\r\n    }\r\n\r\n    if (!Array.isArray(alphas))\r\n    {\r\n        alphas = [ alphas ];\r\n    }\r\n\r\n    var alphaIndex = 0;\r\n    var colorIndex = 0;\r\n\r\n    for (iy = 0; iy < gridY; iy++)\r\n    {\r\n        for (ix = 0; ix < gridX; ix++)\r\n        {\r\n            var a = (ix + gridX1 * iy) * 2;\r\n            var b = (ix + gridX1 * (iy + 1)) * 2;\r\n            var c = ((ix + 1) + gridX1 * (iy + 1)) * 2;\r\n            var d = ((ix + 1) + gridX1 * iy) * 2;\r\n\r\n            var color = colors[colorIndex];\r\n            var alpha = alphas[alphaIndex];\r\n\r\n            var vert1 = new Vertex(vertices[a], vertices[a + 1], 0, uvs[a], uvs[a + 1], color, alpha).transformMat4(tempMatrix);\r\n            var vert2 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);\r\n            var vert3 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);\r\n            var vert4 = new Vertex(vertices[b], vertices[b + 1], 0, uvs[b], uvs[b + 1], color, alpha).transformMat4(tempMatrix);\r\n            var vert5 = new Vertex(vertices[c], vertices[c + 1], 0, uvs[c], uvs[c + 1], color, alpha).transformMat4(tempMatrix);\r\n            var vert6 = new Vertex(vertices[d], vertices[d + 1], 0, uvs[d], uvs[d + 1], color, alpha).transformMat4(tempMatrix);\r\n\r\n            if (tile)\r\n            {\r\n                vert1.setUVs(frameU0, frameV1);\r\n                vert2.setUVs(frameU0, frameV0);\r\n                vert3.setUVs(frameU1, frameV1);\r\n                vert4.setUVs(frameU0, frameV0);\r\n                vert5.setUVs(frameU1, frameV0);\r\n                vert6.setUVs(frameU1, frameV1);\r\n            }\r\n\r\n            colorIndex++;\r\n\r\n            if (colorIndex === colors.length)\r\n            {\r\n                colorIndex = 0;\r\n            }\r\n\r\n            alphaIndex++;\r\n\r\n            if (alphaIndex === alphas.length)\r\n            {\r\n                alphaIndex = 0;\r\n            }\r\n\r\n            result.verts.push(vert1, vert2, vert3, vert4, vert5, vert6);\r\n\r\n            result.faces.push(\r\n                new Face(vert1, vert2, vert3),\r\n                new Face(vert4, vert5, vert6)\r\n            );\r\n        }\r\n    }\r\n\r\n    if (mesh)\r\n    {\r\n        mesh.faces = mesh.faces.concat(result.faces);\r\n        mesh.vertices = mesh.vertices.concat(result.verts);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nmodule.exports = GenerateGridVerts;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar flip = true;\n\nvar defaultModelName = 'untitled';\nvar currentGroup = '';\nvar currentMaterial = '';\n\n/**\n * @ignore\n */\nfunction stripComments (line)\n{\n    var idx = line.indexOf('#');\n\n    return (idx > -1) ? line.substring(0, idx) : line;\n}\n\n/**\n * @ignore\n */\nfunction currentModel (result)\n{\n    if (result.models.length === 0)\n    {\n        result.models.push({\n            faces: [],\n            name: defaultModelName,\n            textureCoords: [],\n            vertexNormals: [],\n            vertices: []\n        });\n    }\n\n    currentGroup = '';\n\n    return result.models[result.models.length - 1];\n}\n\n/**\n * @ignore\n */\nfunction parseObject (lineItems, result)\n{\n    var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;\n\n    result.models.push({\n        faces: [],\n        name: modelName,\n        textureCoords: [],\n        vertexNormals: [],\n        vertices: []\n    });\n\n    currentGroup = '';\n}\n\n/**\n * @ignore\n */\nfunction parseGroup (lineItems)\n{\n    if (lineItems.length === 2)\n    {\n        currentGroup = lineItems[1];\n    }\n}\n\n/**\n * @ignore\n */\nfunction parseVertexCoords (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    currentModel(result).vertices.push({ x: x, y: y, z: z });\n}\n\n/**\n * @ignore\n */\nfunction parseTextureCoords (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var u = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var v = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var w = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    if (isNaN(u))\n    {\n        u = 0;\n    }\n\n    if (isNaN(v))\n    {\n        v = 0;\n    }\n\n    if (isNaN(w))\n    {\n        w = 0;\n    }\n\n    if (flip)\n    {\n        v = 1 - v;\n    }\n\n    currentModel(result).textureCoords.push({ u: u, v: v, w: w });\n}\n\n/**\n * @ignore\n */\nfunction parseVertexNormal (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    currentModel(result).vertexNormals.push({ x: x, y: y, z: z });\n}\n\n/**\n * @ignore\n */\nfunction parsePolygon (lineItems, result)\n{\n    var totalVertices = lineItems.length - 1;\n\n    if (totalVertices < 3)\n    {\n        return;\n    }\n\n    var face = {\n        group: currentGroup,\n        material: currentMaterial,\n        vertices: []\n    };\n\n    for (var i = 0; i < totalVertices; i++)\n    {\n        var vertexString = lineItems[i + 1];\n        var vertexValues = vertexString.split('/');\n        var vvLen = vertexValues.length;\n\n        if (vvLen < 1 || vvLen > 3)\n        {\n            continue;\n        }\n\n        var vertexIndex = 0;\n        var textureCoordsIndex = 0;\n        var vertexNormalIndex = 0;\n\n        vertexIndex = parseInt(vertexValues[0], 10);\n\n        if (vvLen > 1 && vertexValues[1] !== '')\n        {\n            textureCoordsIndex = parseInt(vertexValues[1], 10);\n        }\n\n        if (vvLen > 2)\n        {\n            vertexNormalIndex = parseInt(vertexValues[2], 10);\n        }\n\n        if (vertexIndex !== 0)\n        {\n            // Negative vertex indices refer to the nth last defined vertex\n            // convert these to postive indices for simplicity\n            if (vertexIndex < 0)\n            {\n                vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;\n            }\n\n            textureCoordsIndex -= 1;\n            vertexIndex -= 1;\n            vertexNormalIndex -= 1;\n\n            face.vertices.push({\n                textureCoordsIndex: textureCoordsIndex,\n                vertexIndex: vertexIndex,\n                vertexNormalIndex: vertexNormalIndex\n            });\n        }\n    }\n\n    currentModel(result).faces.push(face);\n}\n\n/**\n * @ignore\n */\nfunction parseMtlLib (lineItems, result)\n{\n    if (lineItems.length >= 2)\n    {\n        result.materialLibraries.push(lineItems[1]);\n    }\n}\n\n/**\n * @ignore\n */\nfunction parseUseMtl (lineItems)\n{\n    if (lineItems.length >= 2)\n    {\n        currentMaterial = lineItems[1];\n    }\n}\n\n/**\n * Parses a Wavefront OBJ File, extracting the models from it and returning them in an array.\n *\n * The model data *must* be triangulated for a Mesh Game Object to be able to render it.\n *\n * @function Phaser.Geom.Mesh.ParseObj\n * @since 3.50.0\n *\n * @param {string} data - The OBJ File data as a raw string.\n * @param {boolean} [flipUV=true] - Flip the UV coordinates?\n *\n * @return {Phaser.Types.Geom.Mesh.OBJData} The parsed model and material data.\n */\nvar ParseObj = function (data, flipUV)\n{\n    if (flipUV === undefined) { flipUV = true; }\n\n    flip = flipUV;\n\n    //  Store results in here\n    var result = {\n        materials: {},\n        materialLibraries: [],\n        models: []\n    };\n\n    currentGroup = '';\n    currentMaterial = '';\n\n    var lines = data.split('\\n');\n\n    for (var i = 0; i < lines.length; i++)\n    {\n        var line = stripComments(lines[i]);\n\n        var lineItems = line.replace(/\\s\\s+/g, ' ').trim().split(' ');\n\n        switch (lineItems[0].toLowerCase())\n        {\n            case 'o':\n                // Start A New Model\n                parseObject(lineItems, result);\n                break;\n\n            case 'g':\n                // Start a new polygon group\n                parseGroup(lineItems);\n                break;\n\n            case 'v':\n                // Define a vertex for the current model\n                parseVertexCoords(lineItems, result);\n                break;\n\n            case 'vt':\n                // Texture Coords\n                parseTextureCoords(lineItems, result);\n                break;\n\n            case 'vn':\n                // Define a vertex normal for the current model\n                parseVertexNormal(lineItems, result);\n                break;\n\n            case 'f':\n                // Define a Face/Polygon\n                parsePolygon(lineItems, result);\n                break;\n\n            case 'mtllib':\n                // Reference to a material library file (.mtl)\n                parseMtlLib(lineItems, result);\n                break;\n\n            case 'usemtl':\n                // Sets the current material to be applied to polygons defined from this point forward\n                parseUseMtl(lineItems);\n                break;\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = ParseObj;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetColor = require('../../display/color/GetColor');\r\n\r\n/**\r\n * Takes a Wavefront Material file and extracts the diffuse reflectivity of the named\r\n * materials, converts them to integer color values and returns them.\r\n *\r\n * This is used internally by the `addOBJ` and `addModel` methods, but is exposed for\r\n * public consumption as well.\r\n *\r\n * Note this only works with diffuse values, specified in the `Kd r g b` format, where\r\n * `g` and `b` are optional, but `r` is required. It does not support spectral rfl files,\r\n * or any other material statement (such as `Ka` or `Ks`)\r\n *\r\n * @method Phaser.Geom.Mesh.ParseObjMaterial\r\n * @since 3.50.0\r\n *\r\n * @param {string} mtl - The OBJ MTL file as a raw string, i.e. loaded via `this.load.text`.\r\n *\r\n * @return {object} The parsed material colors, where each property of the object matches the material name.\r\n */\r\nvar ParseObjMaterial = function (mtl)\r\n{\r\n    var output = {};\r\n\r\n    var lines = mtl.split('\\n');\r\n\r\n    var currentMaterial = '';\r\n\r\n    for (var i = 0; i < lines.length; i++)\r\n    {\r\n        var line = lines[i].trim();\r\n\r\n        if (line.indexOf('#') === 0 || line === '')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var lineItems = line.replace(/\\s\\s+/g, ' ').trim().split(' ');\r\n\r\n        switch (lineItems[0].toLowerCase())\r\n        {\r\n            case 'newmtl':\r\n            {\r\n                currentMaterial = lineItems[1];\r\n                break;\r\n            }\r\n\r\n            //  The diffuse reflectivity of the current material\r\n            //  Support r, [g], [b] format, where g and b are optional\r\n            case 'kd':\r\n            {\r\n                var r = Math.floor(lineItems[1] * 255);\r\n                var g = (lineItems.length >= 2) ? Math.floor(lineItems[2] * 255) : r;\r\n                var b = (lineItems.length >= 3) ? Math.floor(lineItems[3] * 255) : r;\r\n\r\n                output[currentMaterial] = GetColor(r, g, b);\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = ParseObjMaterial;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotates the vertices of a Face to the given angle.\r\n *\r\n * The actual vertex positions are adjusted, not their transformed positions.\r\n *\r\n * Therefore, this updates the vertex data directly.\r\n *\r\n * @function Phaser.Geom.Mesh.RotateFace\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Geom.Mesh.Face} face - The Face to rotate.\r\n * @param {number} angle - The angle to rotate to, in radians.\r\n * @param {number} [cx] - An optional center of rotation. If not given, the Face in-center is used.\r\n * @param {number} [cy] - An optional center of rotation. If not given, the Face in-center is used.\r\n */\r\nvar RotateFace = function (face, angle, cx, cy)\r\n{\r\n    var x;\r\n    var y;\r\n\r\n    //  No point of rotation? Use the inCenter instead, then.\r\n    if (cx === undefined && cy === undefined)\r\n    {\r\n        var inCenter = face.getInCenter();\r\n\r\n        x = inCenter.x;\r\n        y = inCenter.y;\r\n    }\r\n\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var v1 = face.vertex1;\r\n    var v2 = face.vertex2;\r\n    var v3 = face.vertex3;\r\n\r\n    var tx = v1.x - x;\r\n    var ty = v1.y - y;\r\n\r\n    v1.set(tx * c - ty * s + x, tx * s + ty * c + y);\r\n\r\n    tx = v2.x - x;\r\n    ty = v2.y - y;\r\n\r\n    v2.set(tx * c - ty * s + x, tx * s + ty * c + y);\r\n\r\n    tx = v3.x - x;\r\n    ty = v3.y - y;\r\n\r\n    v3.set(tx * c - ty * s + x, tx * s + ty * c + y);\r\n};\r\n\r\nmodule.exports = RotateFace;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Geom.Mesh\r\n */\r\n\r\nvar Mesh = {\r\n\r\n    Face: require('./Face'),\r\n    GenerateGridVerts: require('./GenerateGridVerts'),\r\n    GenerateObjVerts: require('./GenerateObjVerts'),\r\n    GenerateVerts: require('./GenerateVerts'),\r\n    ParseObj: require('./ParseObj'),\r\n    ParseObjMaterial: require('./ParseObjMaterial'),\r\n    RotateFace: require('./RotateFace'),\r\n    Vertex: require('./Vertex')\r\n\r\n};\r\n\r\nmodule.exports = Mesh;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Apply `Math.ceil()` to each coordinate of the given Point.\r\n *\r\n * @function Phaser.Geom.Point.Ceil\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to ceil.\r\n *\r\n * @return {Phaser.Geom.Point} The Point with `Math.ceil()` applied to its coordinates.\r\n */\r\nvar Ceil = function (point)\r\n{\r\n    return point.setTo(Math.ceil(point.x), Math.ceil(point.y));\r\n};\r\n\r\nmodule.exports = Ceil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\n/**\r\n * Clone the given Point.\r\n *\r\n * @function Phaser.Geom.Point.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} source - The source Point to clone.\r\n *\r\n * @return {Phaser.Geom.Point} The cloned Point.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Point(source.x, source.y);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copy the values of one Point to a destination Point.\r\n *\r\n * @function Phaser.Geom.Point.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Point} source - The source Point to copy the values from.\r\n * @param {Phaser.Geom.Point} dest - The destination Point to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Point} The destination Point.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x, source.y);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A comparison of two `Point` objects to see if they are equal.\r\n *\r\n * @function Phaser.Geom.Point.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - The original `Point` to compare against.\r\n * @param {Phaser.Geom.Point} toCompare - The second `Point` to compare.\r\n *\r\n * @return {boolean} Returns true if the both `Point` objects are equal.\r\n */\r\nvar Equals = function (point, toCompare)\r\n{\r\n    return (point.x === toCompare.x && point.y === toCompare.y);\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Apply `Math.ceil()` to each coordinate of the given Point.\r\n *\r\n * @function Phaser.Geom.Point.Floor\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to floor.\r\n *\r\n * @return {Phaser.Geom.Point} The Point with `Math.floor()` applied to its coordinates.\r\n */\r\nvar Floor = function (point)\r\n{\r\n    return point.setTo(Math.floor(point.x), Math.floor(point.y));\r\n};\r\n\r\nmodule.exports = Floor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\n/**\r\n * Get the centroid or geometric center of a plane figure (the arithmetic mean position of all the points in the figure).\r\n * Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.\r\n *\r\n * @function Phaser.Geom.Point.GetCentroid\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like[]} points - An array of Vector2Like objects to get the geometric center of.\r\n * @param {Phaser.Geom.Point} [out] - A Point object to store the output coordinates in. If not given, a new Point instance is created.\r\n *\r\n * @return {Phaser.Geom.Point} A Point object representing the geometric center of the given points.\r\n */\r\nvar GetCentroid = function (points, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    if (!Array.isArray(points))\r\n    {\r\n        throw new Error('GetCentroid points argument must be an array');\r\n    }\r\n\r\n    var len = points.length;\r\n\r\n    if (len < 1)\r\n    {\r\n        throw new Error('GetCentroid points array must not be empty');\r\n    }\r\n    else if (len === 1)\r\n    {\r\n        out.x = points[0].x;\r\n        out.y = points[0].y;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            out.x += points[i].x;\r\n            out.y += points[i].y;\r\n        }\r\n\r\n        out.x /= len;\r\n        out.y /= len;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetCentroid;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the magnitude of the point, which equivalent to the length of the line from the origin to this point.\r\n *\r\n * @function Phaser.Geom.Point.GetMagnitude\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - The point to calculate the magnitude for\r\n *\r\n * @return {number} The resulting magnitude\r\n */\r\nvar GetMagnitude = function (point)\r\n{\r\n    return Math.sqrt((point.x * point.x) + (point.y * point.y));\r\n};\r\n\r\nmodule.exports = GetMagnitude;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the square of magnitude of given point.(Can be used for fast magnitude calculation of point)\r\n *\r\n * @function Phaser.Geom.Point.GetMagnitudeSq\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Point} point - Returns square of the magnitude/length of given point.\r\n *\r\n * @return {number} Returns square of the magnitude of given point.\r\n */\r\nvar GetMagnitudeSq = function (point)\r\n{\r\n    return (point.x * point.x) + (point.y * point.y);\r\n};\r\n\r\nmodule.exports = GetMagnitudeSq;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../rectangle/Rectangle');\r\n\r\n/**\r\n * Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.\r\n *\r\n * @function Phaser.Geom.Point.GetRectangleFromPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like[]} points - An array of Vector2Like objects to get the AABB from.\r\n * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the results in. If not given, a new Rectangle instance is created.\r\n *\r\n * @return {Phaser.Geom.Rectangle} A Rectangle object holding the AABB values for the given points.\r\n */\r\nvar GetRectangleFromPoints = function (points, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    var xMax = Number.NEGATIVE_INFINITY;\r\n    var xMin = Number.POSITIVE_INFINITY;\r\n    var yMax = Number.NEGATIVE_INFINITY;\r\n    var yMin = Number.POSITIVE_INFINITY;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        var point = points[i];\r\n\r\n        if (point.x > xMax)\r\n        {\r\n            xMax = point.x;\r\n        }\r\n\r\n        if (point.x < xMin)\r\n        {\r\n            xMin = point.x;\r\n        }\r\n\r\n        if (point.y > yMax)\r\n        {\r\n            yMax = point.y;\r\n        }\r\n\r\n        if (point.y < yMin)\r\n        {\r\n            yMin = point.y;\r\n        }\r\n    }\r\n\r\n    out.x = xMin;\r\n    out.y = yMin;\r\n    out.width = xMax - xMin;\r\n    out.height = yMax - yMin;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetRectangleFromPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\n/**\r\n * Returns the linear interpolation point between the two given points, based on `t`.\r\n *\r\n * @function Phaser.Geom.Point.Interpolate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - The starting `Point` for the interpolation.\r\n * @param {Phaser.Geom.Point} pointB - The target `Point` for the interpolation.\r\n * @param {number} [t=0] - The amount to interpolate between the two points. Generally, a value between 0 (returns the starting `Point`) and 1 (returns the target `Point`). If omitted, 0 is used.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An optional `Point` object whose `x` and `y` values will be set to the result of the interpolation (can also be any object with `x` and `y` properties). If omitted, a new `Point` created and returned.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} Either the object from the `out` argument with the properties `x` and `y` set to the result of the interpolation or a newly created `Point` object.\r\n */\r\nvar Interpolate = function (pointA, pointB, t, out)\r\n{\r\n    if (t === undefined) { t = 0; }\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = pointA.x + ((pointB.x - pointA.x) * t);\r\n    out.y = pointA.y + ((pointB.y - pointA.y) * t);\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Interpolate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Swaps the X and the Y coordinate of a point.\r\n *\r\n * @function Phaser.Geom.Point.Invert\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to modify.\r\n *\r\n * @return {Phaser.Geom.Point} The modified `point`.\r\n */\r\nvar Invert = function (point)\r\n{\r\n    return point.setTo(point.y, point.x);\r\n};\r\n\r\nmodule.exports = Invert;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\n/**\r\n * Inverts a Point's coordinates.\r\n *\r\n * @function Phaser.Geom.Point.Negative\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to invert.\r\n * @param {Phaser.Geom.Point} [out] - The Point to return the inverted coordinates in.\r\n *\r\n * @return {Phaser.Geom.Point} The modified `out` Point, or a new Point if none was provided.\r\n */\r\nvar Negative = function (point, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    return out.setTo(-point.x, -point.y);\r\n};\r\n\r\nmodule.exports = Negative;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\nvar GetMagnitudeSq = require('./GetMagnitudeSq');\r\n\r\n/**\r\n * Calculates the vector projection of `pointA` onto the nonzero `pointB`. This is the\r\n * orthogonal projection of `pointA` onto a straight line parallel to `pointB`.\r\n *\r\n * @function Phaser.Geom.Point.Project\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - Point A, to be projected onto Point B.\r\n * @param {Phaser.Geom.Point} pointB - Point B, to have Point A projected upon it.\r\n * @param {Phaser.Geom.Point} [out] - The Point object to store the position in. If not given, a new Point instance is created.\r\n *\r\n * @return {Phaser.Geom.Point} A Point object holding the coordinates of the vector projection of `pointA` onto `pointB`.\r\n */\r\nvar Project = function (pointA, pointB, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var dot = ((pointA.x * pointB.x) + (pointA.y * pointB.y));\r\n    var amt = dot / GetMagnitudeSq(pointB);\r\n\r\n    if (amt !== 0)\r\n    {\r\n        out.x = amt * pointB.x;\r\n        out.y = amt * pointB.y;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Project;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\n/**\r\n * Calculates the vector projection of `pointA` onto the nonzero `pointB`. This is the\r\n * orthogonal projection of `pointA` onto a straight line paralle to `pointB`.\r\n *\r\n * @function Phaser.Geom.Point.ProjectUnit\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Point} pointA - Point A, to be projected onto Point B. Must be a normalized point with a magnitude of 1.\r\n * @param {Phaser.Geom.Point} pointB - Point B, to have Point A projected upon it.\r\n * @param {Phaser.Geom.Point} [out] - The Point object to store the position in. If not given, a new Point instance is created.\r\n *\r\n * @return {Phaser.Geom.Point} A unit Point object holding the coordinates of the vector projection of `pointA` onto `pointB`.\r\n */\r\nvar ProjectUnit = function (pointA, pointB, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var amt = ((pointA.x * pointB.x) + (pointA.y * pointB.y));\r\n\r\n    if (amt !== 0)\r\n    {\r\n        out.x = amt * pointB.x;\r\n        out.y = amt * pointB.y;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ProjectUnit;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetMagnitude = require('./GetMagnitude');\r\n\r\n/**\r\n * Changes the magnitude (length) of a two-dimensional vector without changing its direction.\r\n *\r\n * @function Phaser.Geom.Point.SetMagnitude\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [point,$return]\r\n *\r\n * @param {Phaser.Geom.Point} point - The Point to treat as the end point of the vector.\r\n * @param {number} magnitude - The new magnitude of the vector.\r\n *\r\n * @return {Phaser.Geom.Point} The modified Point.\r\n */\r\nvar SetMagnitude = function (point, magnitude)\r\n{\r\n    if (point.x !== 0 || point.y !== 0)\r\n    {\r\n        var m = GetMagnitude(point);\r\n\r\n        point.x /= m;\r\n        point.y /= m;\r\n    }\r\n\r\n    point.x *= magnitude;\r\n    point.y *= magnitude;\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = SetMagnitude;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('./Point');\r\n\r\nPoint.Ceil = require('./Ceil');\r\nPoint.Clone = require('./Clone');\r\nPoint.CopyFrom = require('./CopyFrom');\r\nPoint.Equals = require('./Equals');\r\nPoint.Floor = require('./Floor');\r\nPoint.GetCentroid = require('./GetCentroid');\r\nPoint.GetMagnitude = require('./GetMagnitude');\r\nPoint.GetMagnitudeSq = require('./GetMagnitudeSq');\r\nPoint.GetRectangleFromPoints = require('./GetRectangleFromPoints');\r\nPoint.Interpolate = require('./Interpolate');\r\nPoint.Invert = require('./Invert');\r\nPoint.Negative = require('./Negative');\r\nPoint.Project = require('./Project');\r\nPoint.ProjectUnit = require('./ProjectUnit');\r\nPoint.SetMagnitude = require('./SetMagnitude');\r\n\r\nmodule.exports = Point;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Polygon = require('./Polygon');\r\n\r\n/**\r\n * Create a new polygon which is a copy of the specified polygon\r\n *\r\n * @function Phaser.Geom.Polygon.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The polygon to create a clone of\r\n *\r\n * @return {Phaser.Geom.Polygon} A new separate Polygon cloned from the specified polygon, based on the same points.\r\n */\r\nvar Clone = function (polygon)\r\n{\r\n    return new Polygon(polygon.points);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Checks the given Point again the Polygon to see if the Point lays within its vertices.\r\n *\r\n * @function Phaser.Geom.Polygon.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to check.\r\n * @param {Phaser.Geom.Point} point - The Point to check if it's within the Polygon.\r\n *\r\n * @return {boolean} `true` if the Point is within the Polygon, otherwise `false`.\r\n */\r\nvar ContainsPoint = function (polygon, point)\r\n{\r\n    return Contains(polygon, point.x, point.y);\r\n};\r\n\r\nmodule.exports = ContainsPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]\r\n\r\n/**\r\n * Stores all of the points of a Polygon into a flat array of numbers following the sequence [ x,y, x,y, x,y ],\r\n * i.e. each point of the Polygon, in the order it's defined, corresponds to two elements of the resultant\r\n * array for the point's X and Y coordinate.\r\n *\r\n * @function Phaser.Geom.Polygon.GetNumberArray\r\n * @since 3.0.0\r\n *\r\n * @generic {number[]} O - [output,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon whose points to export.\r\n * @param {(array|number[])} [output] - An array to which the points' coordinates should be appended.\r\n *\r\n * @return {(array|number[])} The modified `output` array, or a new array if none was given.\r\n */\r\nvar GetNumberArray = function (polygon, output)\r\n{\r\n    if (output === undefined) { output = []; }\r\n\r\n    for (var i = 0; i < polygon.points.length; i++)\r\n    {\r\n        output.push(polygon.points[i].x);\r\n        output.push(polygon.points[i].y);\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = GetNumberArray;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Reverses the order of the points of a Polygon.\r\n *\r\n * @function Phaser.Geom.Polygon.Reverse\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to modify.\r\n *\r\n * @return {Phaser.Geom.Polygon} The modified Polygon.\r\n */\r\nvar Reverse = function (polygon)\r\n{\r\n    polygon.points.reverse();\r\n\r\n    return polygon;\r\n};\r\n\r\nmodule.exports = Reverse;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @author       Vladimir Agafonkin\n * @see          Based on Simplify.js mourner.github.io/simplify-js\n */\n\n/**\n * Copyright (c) 2017, Vladimir Agafonkin\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @ignore\n */\nfunction getSqDist (p1, p2)\n{\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n/**\n * Square distance from a point to a segment\n *\n * @ignore\n */\nfunction getSqSegDist (p, p1, p2)\n{\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0)\n    {\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1)\n        {\n            x = p2.x;\n            y = p2.y;\n        }\n        else if (t > 0)\n        {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n\n/**\n * Basic distance-based simplification\n *\n * @ignore\n */\nfunction simplifyRadialDist (points, sqTolerance)\n{\n    var prevPoint = points[0],\n        newPoints = [ prevPoint ],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++)\n    {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance)\n        {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point)\n    {\n        newPoints.push(point);\n    }\n\n    return newPoints;\n}\n\n/**\n * @ignore\n */\nfunction simplifyDPStep (points, first, last, sqTolerance, simplified)\n{\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++)\n    {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist)\n        {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance)\n    {\n        if (index - first > 1)\n        {\n            simplifyDPStep(points, first, index, sqTolerance, simplified);\n        }\n\n        simplified.push(points[index]);\n\n        if (last - index > 1)\n        {\n            simplifyDPStep(points, index, last, sqTolerance, simplified);\n        }\n    }\n}\n\n/**\n * Simplification using Ramer-Douglas-Peucker algorithm\n *\n * @ignore\n */\nfunction simplifyDouglasPeucker (points, sqTolerance)\n{\n    var last = points.length - 1;\n\n    var simplified = [ points[0] ];\n\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n/**\n * Takes a Polygon object and simplifies the points by running them through a combination of\n * Douglas-Peucker and Radial Distance algorithms. Simplification dramatically reduces the number of\n * points in a polygon while retaining its shape, giving a huge performance boost when processing\n * it and also reducing visual noise.\n *\n * @function Phaser.Geom.Polygon.Simplify\n * @since 3.50.0\n *\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\n *\n * @param {Phaser.Geom.Polygon} polygon - The polygon to be simplified. The polygon will be modified in-place and returned.\n * @param {number} [tolerance=1] - Affects the amount of simplification (in the same metric as the point coordinates).\n * @param {boolean} [highestQuality=false] - Excludes distance-based preprocessing step which leads to highest quality simplification but runs ~10-20 times slower.\n *\n * @return {Phaser.Geom.Polygon} The input polygon.\n */\nvar Simplify = function (polygon, tolerance, highestQuality)\n{\n    if (tolerance === undefined) { tolerance = 1; }\n    if (highestQuality === undefined) { highestQuality = false; }\n\n    var points = polygon.points;\n\n    if (points.length > 2)\n    {\n        var sqTolerance = tolerance * tolerance;\n\n        if (!highestQuality)\n        {\n            points = simplifyRadialDist(points, sqTolerance);\n        }\n\n        polygon.setTo(simplifyDouglasPeucker(points, sqTolerance));\n    }\n\n    return polygon;\n};\n\nmodule.exports = Simplify;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Tranlates the points of the given Polygon.\n *\n * @function Phaser.Geom.Polygon.Translate\n * @since 3.50.0\n *\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\n *\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to modify.\n * @param {number} x - The amount to horizontally translate the points by.\n * @param {number} y - The amount to vertically translate the points by.\n *\n * @return {Phaser.Geom.Polygon} The modified Polygon.\n */\nvar Translate = function (polygon, x, y)\n{\n    var points = polygon.points;\n\n    for (var i = 0; i < points.length; i++)\n    {\n        points[i].x += x;\n        points[i].y += y;\n    }\n\n    return polygon;\n};\n\nmodule.exports = Translate;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Polygon = require('./Polygon');\n\nPolygon.Clone = require('./Clone');\nPolygon.Contains = require('./Contains');\nPolygon.ContainsPoint = require('./ContainsPoint');\nPolygon.Earcut = require('./Earcut');\nPolygon.GetAABB = require('./GetAABB');\nPolygon.GetNumberArray = require('./GetNumberArray');\nPolygon.GetPoints = require('./GetPoints');\nPolygon.Perimeter = require('./Perimeter');\nPolygon.Reverse = require('./Reverse');\nPolygon.Simplify = require('./Simplify');\nPolygon.Smooth = require('./Smooth');\nPolygon.Translate = require('./Translate');\n\nmodule.exports = Polygon;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the area of the given Rectangle object.\r\n *\r\n * @function Phaser.Geom.Rectangle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to calculate the area of.\r\n *\r\n * @return {number} The area of the Rectangle object.\r\n */\r\nvar Area = function (rect)\r\n{\r\n    return rect.width * rect.height;\r\n};\r\n\r\nmodule.exports = Area;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rounds a Rectangle's position up to the smallest integer greater than or equal to each current coordinate.\r\n *\r\n * @function Phaser.Geom.Rectangle.Ceil\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to adjust.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted Rectangle.\r\n */\r\nvar Ceil = function (rect)\r\n{\r\n    rect.x = Math.ceil(rect.x);\r\n    rect.y = Math.ceil(rect.y);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = Ceil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rounds a Rectangle's position and size up to the smallest integer greater than or equal to each respective value.\r\n *\r\n * @function Phaser.Geom.Rectangle.CeilAll\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to modify.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified Rectangle.\r\n */\r\nvar CeilAll = function (rect)\r\n{\r\n    rect.x = Math.ceil(rect.x);\r\n    rect.y = Math.ceil(rect.y);\r\n    rect.width = Math.ceil(rect.width);\r\n    rect.height = Math.ceil(rect.height);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = CeilAll;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// Centers this Rectangle so that the center coordinates match the given x and y values.\r\n\r\n/**\r\n * Moves the top-left corner of a Rectangle so that its center is at the given coordinates.\r\n *\r\n * @function Phaser.Geom.Rectangle.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to be centered.\r\n * @param {number} x - The X coordinate of the Rectangle's center.\r\n * @param {number} y - The Y coordinate of the Rectangle's center.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The centered rectangle.\r\n */\r\nvar CenterOn = function (rect, x, y)\r\n{\r\n    rect.x = x - (rect.width / 2);\r\n    rect.y = y - (rect.height / 2);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = CenterOn;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\n\r\n/**\r\n * Creates a new Rectangle which is identical to the given one.\r\n *\r\n * @function Phaser.Geom.Rectangle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} source - The Rectangle to clone.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The newly created Rectangle, which is separate from the given one.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Rectangle(source.x, source.y, source.width, source.height);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Determines whether the specified point is contained within the rectangular region defined by this Rectangle object.\r\n *\r\n * @function Phaser.Geom.Rectangle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle object.\r\n * @param {Phaser.Geom.Point} point - The point object to be checked. Can be a Phaser Point object or any object with x and y values.\r\n *\r\n * @return {boolean} A value of true if the Rectangle object contains the specified point, otherwise false.\r\n */\r\nvar ContainsPoint = function (rect, point)\r\n{\r\n    return Contains(rect, point.x, point.y);\r\n};\r\n\r\nmodule.exports = ContainsPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tests if one rectangle fully contains another.\r\n *\r\n * @function Phaser.Geom.Rectangle.ContainsRect\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first rectangle.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second rectangle.\r\n *\r\n * @return {boolean} True only if rectA fully contains rectB.\r\n */\r\nvar ContainsRect = function (rectA, rectB)\r\n{\r\n    //  Volume check (if rectB volume > rectA then rectA cannot contain it)\r\n    if ((rectB.width * rectB.height) > (rectA.width * rectA.height))\r\n    {\r\n        return false;\r\n    }\r\n\r\n    return (\r\n        (rectB.x > rectA.x && rectB.x < rectA.right) &&\r\n        (rectB.right > rectA.x && rectB.right < rectA.right) &&\r\n        (rectB.y > rectA.y && rectB.y < rectA.bottom) &&\r\n        (rectB.bottom > rectA.y && rectB.bottom < rectA.bottom)\r\n    );\r\n};\r\n\r\nmodule.exports = ContainsRect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copy the values of one Rectangle to a destination Rectangle.\r\n *\r\n * @function Phaser.Geom.Rectangle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} source - The source Rectangle to copy the values from.\r\n * @param {Phaser.Geom.Rectangle} dest - The destination Rectangle to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The destination Rectangle.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x, source.y, source.width, source.height);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Create an array of points for each corner of a Rectangle\r\n * If an array is specified, each point object will be added to the end of the array, otherwise a new array will be created.\r\n *\r\n * @function Phaser.Geom.Rectangle.Decompose\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle object to be decomposed.\r\n * @param {array} [out] - If provided, each point will be added to this array.\r\n *\r\n * @return {array} Will return the array you specified or a new array containing the points of the Rectangle.\r\n */\r\nvar Decompose = function (rect, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    out.push({ x: rect.x, y: rect.y });\r\n    out.push({ x: rect.right, y: rect.y });\r\n    out.push({ x: rect.right, y: rect.bottom });\r\n    out.push({ x: rect.x, y: rect.bottom });\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Decompose;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compares the `x`, `y`, `width` and `height` properties of two rectangles.\r\n *\r\n * @function Phaser.Geom.Rectangle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - Rectangle A\r\n * @param {Phaser.Geom.Rectangle} toCompare - Rectangle B\r\n *\r\n * @return {boolean} `true` if the rectangles' properties are an exact match, otherwise `false`.\r\n */\r\nvar Equals = function (rect, toCompare)\r\n{\r\n    return (\r\n        rect.x === toCompare.x &&\r\n        rect.y === toCompare.y &&\r\n        rect.width === toCompare.width &&\r\n        rect.height === toCompare.height\r\n    );\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetAspectRatio = require('./GetAspectRatio');\r\n\r\n/**\r\n * Adjusts the target rectangle, changing its width, height and position,\r\n * so that it fits inside the area of the source rectangle, while maintaining its original\r\n * aspect ratio.\r\n * \r\n * Unlike the `FitOutside` function, there may be some space inside the source area not covered.\r\n *\r\n * @function Phaser.Geom.Rectangle.FitInside\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - The target rectangle to adjust.\r\n * @param {Phaser.Geom.Rectangle} source - The source rectangle to envelop the target in.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified target rectangle instance.\r\n */\r\nvar FitInside = function (target, source)\r\n{\r\n    var ratio = GetAspectRatio(target);\r\n\r\n    if (ratio < GetAspectRatio(source))\r\n    {\r\n        //  Taller than Wide\r\n        target.setSize(source.height * ratio, source.height);\r\n    }\r\n    else\r\n    {\r\n        //  Wider than Tall\r\n        target.setSize(source.width, source.width / ratio);\r\n    }\r\n\r\n    return target.setPosition(\r\n        source.centerX - (target.width / 2),\r\n        source.centerY - (target.height / 2)\r\n    );\r\n};\r\n\r\nmodule.exports = FitInside;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetAspectRatio = require('./GetAspectRatio');\r\n\r\n/**\r\n * Adjusts the target rectangle, changing its width, height and position,\r\n * so that it fully covers the area of the source rectangle, while maintaining its original\r\n * aspect ratio.\r\n * \r\n * Unlike the `FitInside` function, the target rectangle may extend further out than the source.\r\n *\r\n * @function Phaser.Geom.Rectangle.FitOutside\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - The target rectangle to adjust.\r\n * @param {Phaser.Geom.Rectangle} source - The source rectangle to envelope the target in.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified target rectangle instance.\r\n */\r\nvar FitOutside = function (target, source)\r\n{\r\n    var ratio = GetAspectRatio(target);\r\n\r\n    if (ratio > GetAspectRatio(source))\r\n    {\r\n        //  Wider than Tall\r\n        target.setSize(source.height * ratio, source.height);\r\n    }\r\n    else\r\n    {\r\n        //  Taller than Wide\r\n        target.setSize(source.width, source.width / ratio);\r\n    }\r\n\r\n    return target.setPosition(\r\n        source.centerX - target.width / 2,\r\n        source.centerY - target.height / 2\r\n    );\r\n};\r\n\r\nmodule.exports = FitOutside;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rounds down (floors) the top left X and Y coordinates of the given Rectangle to the largest integer less than or equal to them\r\n *\r\n * @function Phaser.Geom.Rectangle.Floor\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to floor the top left X and Y coordinates of\r\n *\r\n * @return {Phaser.Geom.Rectangle} The rectangle that was passed to this function with its coordinates floored.\r\n */\r\nvar Floor = function (rect)\r\n{\r\n    rect.x = Math.floor(rect.x);\r\n    rect.y = Math.floor(rect.y);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = Floor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rounds a Rectangle's position and size down to the largest integer less than or equal to each current coordinate or dimension.\r\n *\r\n * @function Phaser.Geom.Rectangle.FloorAll\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to adjust.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted Rectangle.\r\n */\r\nvar FloorAll = function (rect)\r\n{\r\n    rect.x = Math.floor(rect.x);\r\n    rect.y = Math.floor(rect.y);\r\n    rect.width = Math.floor(rect.width);\r\n    rect.height = Math.floor(rect.height);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = FloorAll;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n//  points is an array of Point-like objects,\r\n//  either 2 dimensional arrays, or objects with public x/y properties:\r\n//  var points = [\r\n//      [100, 200],\r\n//      [200, 400],\r\n//      { x: 30, y: 60 }\r\n//  ]\r\n\r\n/**\r\n * Constructs new Rectangle or repositions and resizes an existing Rectangle so that all of the given points are on or within its bounds.\r\n *\r\n * @function Phaser.Geom.Rectangle.FromPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {array} points - An array of points (either arrays with two elements corresponding to the X and Y coordinate or an object with public `x` and `y` properties) which should be surrounded by the Rectangle.\r\n * @param {Phaser.Geom.Rectangle} [out] - Optional Rectangle to adjust.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted `out` Rectangle, or a new Rectangle if none was provided.\r\n */\r\nvar FromPoints = function (points, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    if (points.length === 0)\r\n    {\r\n        return out;\r\n    }\r\n\r\n    var minX = Number.MAX_VALUE;\r\n    var minY = Number.MAX_VALUE;\r\n\r\n    var maxX = MATH_CONST.MIN_SAFE_INTEGER;\r\n    var maxY = MATH_CONST.MIN_SAFE_INTEGER;\r\n\r\n    var p;\r\n    var px;\r\n    var py;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        p = points[i];\r\n\r\n        if (Array.isArray(p))\r\n        {\r\n            px = p[0];\r\n            py = p[1];\r\n        }\r\n        else\r\n        {\r\n            px = p.x;\r\n            py = p.y;\r\n        }\r\n\r\n        minX = Math.min(minX, px);\r\n        minY = Math.min(minY, py);\r\n\r\n        maxX = Math.max(maxX, px);\r\n        maxY = Math.max(maxY, py);\r\n    }\r\n\r\n    out.x = minX;\r\n    out.y = minY;\r\n    out.width = maxX - minX;\r\n    out.height = maxY - minY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = FromPoints;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\n\r\n/**\r\n * Create the smallest Rectangle containing two coordinate pairs.\r\n *\r\n * @function Phaser.Geom.Rectangle.FromXY\r\n * @since 3.23.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {number} x1 - The X coordinate of the first point.\r\n * @param {number} y1 - The Y coordinate of the first point.\r\n * @param {number} x2 - The X coordinate of the second point.\r\n * @param {number} y2 - The Y coordinate of the second point.\r\n * @param {Phaser.Geom.Rectangle} [out] - Optional Rectangle to adjust.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted `out` Rectangle, or a new Rectangle if none was provided.\r\n */\r\nvar FromXY = function (x1, y1, x2, y2, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    return out.setTo(\r\n        Math.min(x1, x2),\r\n        Math.min(y1, y2),\r\n        Math.abs(x1 - x2),\r\n        Math.abs(y1 - y2)\r\n    );\r\n};\r\n\r\nmodule.exports = FromXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the width/height ratio of a rectangle.\r\n *\r\n * @function Phaser.Geom.Rectangle.GetAspectRatio\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle.\r\n *\r\n * @return {number} The width/height ratio of the rectangle.\r\n */\r\nvar GetAspectRatio = function (rect)\r\n{\r\n    return (rect.height === 0) ? NaN : rect.width / rect.height;\r\n};\r\n\r\nmodule.exports = GetAspectRatio;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns the center of a Rectangle as a Point.\r\n *\r\n * @function Phaser.Geom.Rectangle.GetCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to get the center of.\r\n * @param {(Phaser.Geom.Point|object)} [out] - Optional point-like object to update with the center coordinates.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} The modified `out` object, or a new Point if none was provided.\r\n */\r\nvar GetCenter = function (rect, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = rect.centerX;\r\n    out.y = rect.centerY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetCenter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n\r\n/**\r\n * Returns the size of the Rectangle, expressed as a Point object.\r\n * With the value of the `width` as the `x` property and the `height` as the `y` property.\r\n *\r\n * @function Phaser.Geom.Rectangle.GetSize\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to get the size from.\r\n * @param {(Phaser.Geom.Point|object)} [out] - The Point object to store the size in. If not given, a new Point instance is created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object where `x` holds the width and `y` holds the height of the Rectangle.\r\n */\r\nvar GetSize = function (rect, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = rect.width;\r\n    out.y = rect.height;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetSize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CenterOn = require('./CenterOn');\r\n\r\n\r\n/**\r\n * Increases the size of a Rectangle by a specified amount.\r\n *\r\n * The center of the Rectangle stays the same. The amounts are added to each side, so the actual increase in width or height is two times bigger than the respective argument.\r\n *\r\n * @function Phaser.Geom.Rectangle.Inflate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to inflate.\r\n * @param {number} x - How many pixels the left and the right side should be moved by horizontally.\r\n * @param {number} y - How many pixels the top and the bottom side should be moved by vertically.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The inflated Rectangle.\r\n */\r\nvar Inflate = function (rect, x, y)\r\n{\r\n    var cx = rect.centerX;\r\n    var cy = rect.centerY;\r\n\r\n    rect.setSize(rect.width + (x * 2), rect.height + (y * 2));\r\n\r\n    return CenterOn(rect, cx, cy);\r\n};\r\n\r\nmodule.exports = Inflate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\nvar Intersects = require('../intersects/RectangleToRectangle');\r\n\r\n/**\r\n * Takes two Rectangles and first checks to see if they intersect.\r\n * If they intersect it will return the area of intersection in the `out` Rectangle.\r\n * If they do not intersect, the `out` Rectangle will have a width and height of zero.\r\n *\r\n * @function Phaser.Geom.Rectangle.Intersection\r\n * @since 3.11.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle to get the intersection from.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle to get the intersection from.\r\n * @param {Phaser.Geom.Rectangle} [out] - A Rectangle to store the intersection results in.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The intersection result. If the width and height are zero, no intersection occurred.\r\n */\r\nvar Intersection = function (rectA, rectB, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    if (Intersects(rectA, rectB))\r\n    {\r\n        out.x = Math.max(rectA.x, rectB.x);\r\n        out.y = Math.max(rectA.y, rectB.y);\r\n        out.width = Math.min(rectA.right, rectB.right) - out.x;\r\n        out.height = Math.min(rectA.bottom, rectB.bottom) - out.y;\r\n    }\r\n    else\r\n    {\r\n        out.setEmpty();\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Intersection;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Merges a Rectangle with a list of points by repositioning and/or resizing it such that all points are located on or within its bounds.\r\n *\r\n * @function Phaser.Geom.Rectangle.MergePoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - The Rectangle which should be merged.\r\n * @param {Phaser.Geom.Point[]} points - An array of Points (or any object with public `x` and `y` properties) which should be merged with the Rectangle.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified Rectangle.\r\n */\r\nvar MergePoints = function (target, points)\r\n{\r\n    var minX = target.x;\r\n    var maxX = target.right;\r\n    var minY = target.y;\r\n    var maxY = target.bottom;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        minX = Math.min(minX, points[i].x);\r\n        maxX = Math.max(maxX, points[i].x);\r\n        minY = Math.min(minY, points[i].y);\r\n        maxY = Math.max(maxY, points[i].y);\r\n    }\r\n\r\n    target.x = minX;\r\n    target.y = minY;\r\n    target.width = maxX - minX;\r\n    target.height = maxY - minY;\r\n\r\n    return target;\r\n};\r\n\r\nmodule.exports = MergePoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Merges source rectangle into target rectangle and returns target\r\n//  Neither rect should have negative widths or heights\r\n\r\n/**\r\n * Merges the source rectangle into the target rectangle and returns the target.\r\n * Neither rectangle should have a negative width or height.\r\n *\r\n * @function Phaser.Geom.Rectangle.MergeRect\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - Target rectangle. Will be modified to include source rectangle.\r\n * @param {Phaser.Geom.Rectangle} source - Rectangle that will be merged into target rectangle.\r\n *\r\n * @return {Phaser.Geom.Rectangle} Modified target rectangle that contains source rectangle.\r\n */\r\nvar MergeRect = function (target, source)\r\n{\r\n    var minX = Math.min(target.x, source.x);\r\n    var maxX = Math.max(target.right, source.right);\r\n\r\n    target.x = minX;\r\n    target.width = maxX - minX;\r\n\r\n    var minY = Math.min(target.y, source.y);\r\n    var maxY = Math.max(target.bottom, source.bottom);\r\n\r\n    target.y = minY;\r\n    target.height = maxY - minY;\r\n\r\n    return target;\r\n};\r\n\r\nmodule.exports = MergeRect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Merges a Rectangle with a point by repositioning and/or resizing it so that the point is on or within its bounds.\r\n *\r\n * @function Phaser.Geom.Rectangle.MergeXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [target,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} target - The Rectangle which should be merged and modified.\r\n * @param {number} x - The X coordinate of the point which should be merged.\r\n * @param {number} y - The Y coordinate of the point which should be merged.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified `target` Rectangle.\r\n */\r\nvar MergeXY = function (target, x, y)\r\n{\r\n    var minX = Math.min(target.x, x);\r\n    var maxX = Math.max(target.right, x);\r\n\r\n    target.x = minX;\r\n    target.width = maxX - minX;\r\n\r\n    var minY = Math.min(target.y, y);\r\n    var maxY = Math.max(target.bottom, y);\r\n\r\n    target.y = minY;\r\n    target.height = maxY - minY;\r\n\r\n    return target;\r\n};\r\n\r\nmodule.exports = MergeXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Nudges (translates) the top left corner of a Rectangle by a given offset.\r\n *\r\n * @function Phaser.Geom.Rectangle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to adjust.\r\n * @param {number} x - The distance to move the Rectangle horizontally.\r\n * @param {number} y - The distance to move the Rectangle vertically.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted Rectangle.\r\n */\r\nvar Offset = function (rect, x, y)\r\n{\r\n    rect.x += x;\r\n    rect.y += y;\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = Offset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Nudges (translates) the top-left corner of a Rectangle by the coordinates of a point (translation vector).\r\n *\r\n * @function Phaser.Geom.Rectangle.OffsetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to adjust.\r\n * @param {(Phaser.Geom.Point|Phaser.Math.Vector2)} point - The point whose coordinates should be used as an offset.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted Rectangle.\r\n */\r\nvar OffsetPoint = function (rect, point)\r\n{\r\n    rect.x += point.x;\r\n    rect.y += point.y;\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = OffsetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if two Rectangles overlap. If a Rectangle is within another Rectangle, the two will be considered overlapping. Thus, the Rectangles are treated as \"solid\".\r\n *\r\n * @function Phaser.Geom.Rectangle.Overlaps\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle to check.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle to check.\r\n *\r\n * @return {boolean} `true` if the two Rectangles overlap, `false` otherwise.\r\n */\r\nvar Overlaps = function (rectA, rectB)\r\n{\r\n    return (\r\n        rectA.x < rectB.right &&\r\n        rectA.right > rectB.x &&\r\n        rectA.y < rectB.bottom &&\r\n        rectA.bottom > rectB.y\r\n    );\r\n};\r\n\r\nmodule.exports = Overlaps;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar DegToRad = require('../../math/DegToRad');\r\n\r\n/**\r\n * Returns a Point from the perimeter of a Rectangle based on the given angle.\r\n *\r\n * @function Phaser.Geom.Rectangle.PerimeterPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectangle - The Rectangle to get the perimeter point from.\r\n * @param {number} angle - The angle of the point, in degrees.\r\n * @param {Phaser.Geom.Point} [out] - The Point object to store the position in. If not given, a new Point instance is created.\r\n *\r\n * @return {Phaser.Geom.Point} A Point object holding the coordinates of the Rectangle perimeter.\r\n */\r\nvar PerimeterPoint = function (rectangle, angle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    angle = DegToRad(angle);\r\n\r\n    var s = Math.sin(angle);\r\n    var c = Math.cos(angle);\r\n\r\n    var dx = (c > 0) ? rectangle.width / 2 : rectangle.width / -2;\r\n    var dy = (s > 0) ? rectangle.height / 2 : rectangle.height / -2;\r\n\r\n    if (Math.abs(dx * s) < Math.abs(dy * c))\r\n    {\r\n        dy = (dx * s) / c;\r\n    }\r\n    else\r\n    {\r\n        dx = (dy * c) / s;\r\n    }\r\n\r\n    out.x = dx + rectangle.centerX;\r\n    out.y = dy + rectangle.centerY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = PerimeterPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Between = require('../../math/Between');\r\nvar ContainsRect = require('./ContainsRect');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Calculates a random point that lies within the `outer` Rectangle, but outside of the `inner` Rectangle.\r\n * The inner Rectangle must be fully contained within the outer rectangle.\r\n *\r\n * @function Phaser.Geom.Rectangle.RandomOutside\r\n * @since 3.10.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} outer - The outer Rectangle to get the random point within.\r\n * @param {Phaser.Geom.Rectangle} inner - The inner Rectangle to exclude from the returned point.\r\n * @param {Phaser.Geom.Point} [out] - A Point, or Point-like object to store the result in. If not specified, a new Point will be created.\r\n *\r\n * @return {Phaser.Geom.Point} A Point object containing the random values in its `x` and `y` properties.\r\n */\r\nvar RandomOutside = function (outer, inner, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    if (ContainsRect(outer, inner))\r\n    {\r\n        //  Pick a random quadrant\r\n        //\r\n        //  The quadrants don't extend the full widths / heights of the outer rect to give\r\n        //  us a better uniformed distribution, otherwise you get clumping in the corners where\r\n        //  the 4 quads would overlap\r\n\r\n        switch (Between(0, 3))\r\n        {\r\n            case 0: // Top\r\n                out.x = outer.x + (Math.random() * (inner.right - outer.x));\r\n                out.y = outer.y + (Math.random() * (inner.top - outer.y));\r\n                break;\r\n\r\n            case 1: // Bottom\r\n                out.x = inner.x + (Math.random() * (outer.right - inner.x));\r\n                out.y = inner.bottom + (Math.random() * (outer.bottom - inner.bottom));\r\n                break;\r\n\r\n            case 2: // Left\r\n                out.x = outer.x + (Math.random() * (inner.x - outer.x));\r\n                out.y = inner.y + (Math.random() * (outer.bottom - inner.y));\r\n                break;\r\n\r\n            case 3: // Right\r\n                out.x = inner.right + (Math.random() * (outer.right - inner.right));\r\n                out.y = outer.y + (Math.random() * (inner.bottom - outer.y));\r\n                break;\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = RandomOutside;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Determines if the two objects (either Rectangles or Rectangle-like) have the same width and height values under strict equality.\r\n *\r\n * @function Phaser.Geom.Rectangle.SameDimensions\r\n * @since 3.15.0\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The first Rectangle object.\r\n * @param {Phaser.Geom.Rectangle} toCompare - The second Rectangle object.\r\n *\r\n * @return {boolean} `true` if the objects have equivalent values for the `width` and `height` properties, otherwise `false`.\r\n */\r\nvar SameDimensions = function (rect, toCompare)\r\n{\r\n    return (rect.width === toCompare.width && rect.height === toCompare.height);\r\n};\r\n\r\nmodule.exports = SameDimensions;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// Scales the width and height of this Rectangle by the given amounts.\r\n\r\n/**\r\n * Scales the width and height of this Rectangle by the given amounts.\r\n *\r\n * @function Phaser.Geom.Rectangle.Scale\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The `Rectangle` object that will be scaled by the specified amount(s).\r\n * @param {number} x - The factor by which to scale the rectangle horizontally.\r\n * @param {number} y - The amount by which to scale the rectangle vertically. If this is not specified, the rectangle will be scaled by the factor `x` in both directions.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The rectangle object with updated `width` and `height` properties as calculated from the scaling factor(s).\r\n */\r\nvar Scale = function (rect, x, y)\r\n{\r\n    if (y === undefined) { y = x; }\r\n\r\n    rect.width *= x;\r\n    rect.height *= y;\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = Scale;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\n\r\nRectangle.Area = require('./Area');\r\nRectangle.Ceil = require('./Ceil');\r\nRectangle.CeilAll = require('./CeilAll');\r\nRectangle.CenterOn = require('./CenterOn');\r\nRectangle.Clone = require('./Clone');\r\nRectangle.Contains = require('./Contains');\r\nRectangle.ContainsPoint = require('./ContainsPoint');\r\nRectangle.ContainsRect = require('./ContainsRect');\r\nRectangle.CopyFrom = require('./CopyFrom');\r\nRectangle.Decompose = require('./Decompose');\r\nRectangle.Equals = require('./Equals');\r\nRectangle.FitInside = require('./FitInside');\r\nRectangle.FitOutside = require('./FitOutside');\r\nRectangle.Floor = require('./Floor');\r\nRectangle.FloorAll = require('./FloorAll');\r\nRectangle.FromPoints = require('./FromPoints');\r\nRectangle.FromXY = require('./FromXY');\r\nRectangle.GetAspectRatio = require('./GetAspectRatio');\r\nRectangle.GetCenter = require('./GetCenter');\r\nRectangle.GetPoint = require('./GetPoint');\r\nRectangle.GetPoints = require('./GetPoints');\r\nRectangle.GetSize = require('./GetSize');\r\nRectangle.Inflate = require('./Inflate');\r\nRectangle.Intersection = require('./Intersection');\r\nRectangle.MarchingAnts = require('./MarchingAnts');\r\nRectangle.MergePoints = require('./MergePoints');\r\nRectangle.MergeRect = require('./MergeRect');\r\nRectangle.MergeXY = require('./MergeXY');\r\nRectangle.Offset = require('./Offset');\r\nRectangle.OffsetPoint = require('./OffsetPoint');\r\nRectangle.Overlaps = require('./Overlaps');\r\nRectangle.Perimeter = require('./Perimeter');\r\nRectangle.PerimeterPoint = require('./PerimeterPoint');\r\nRectangle.Random = require('./Random');\r\nRectangle.RandomOutside = require('./RandomOutside');\r\nRectangle.SameDimensions = require('./SameDimensions');\r\nRectangle.Scale = require('./Scale');\r\nRectangle.Union = require('./Union');\r\n\r\nmodule.exports = Rectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// The 2D area of a triangle. The area value is always non-negative.\r\n\r\n/**\r\n * Returns the area of a Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.Area\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to use.\r\n *\r\n * @return {number} The area of the Triangle, always non-negative.\r\n */\r\nvar Area = function (triangle)\r\n{\r\n    var x1 = triangle.x1;\r\n    var y1 = triangle.y1;\r\n\r\n    var x2 = triangle.x2;\r\n    var y2 = triangle.y2;\r\n\r\n    var x3 = triangle.x3;\r\n    var y3 = triangle.y3;\r\n\r\n    return Math.abs(((x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)) / 2);\r\n};\r\n\r\nmodule.exports = Area;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Triangle = require('./Triangle');\r\n\r\n/**\r\n * Builds an equilateral triangle. In the equilateral triangle, all the sides are the same length (congruent) and all the angles are the same size (congruent).\r\n * The x/y specifies the top-middle of the triangle (x1/y1) and length is the length of each side.\r\n *\r\n * @function Phaser.Geom.Triangle.BuildEquilateral\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - x coordinate of the top point of the triangle.\r\n * @param {number} y - y coordinate of the top point of the triangle.\r\n * @param {number} length - Length of each side of the triangle.\r\n *\r\n * @return {Phaser.Geom.Triangle} The Triangle object of the given size.\r\n */\r\nvar BuildEquilateral = function (x, y, length)\r\n{\r\n    var height = length * (Math.sqrt(3) / 2);\r\n\r\n    var x1 = x;\r\n    var y1 = y;\r\n\r\n    var x2 = x + (length / 2);\r\n    var y2 = y + height;\r\n\r\n    var x3 = x - (length / 2);\r\n    var y3 = y + height;\r\n\r\n    return new Triangle(x1, y1, x2, y2, x3, y3);\r\n};\r\n\r\nmodule.exports = BuildEquilateral;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar EarCut = require('../polygon/Earcut');\r\nvar Triangle = require('./Triangle');\r\n\r\n/**\r\n * Takes an array of vertex coordinates, and optionally an array of hole indices, then returns an array\r\n * of Triangle instances, where the given vertices have been decomposed into a series of triangles.\r\n *\r\n * @function Phaser.Geom.Triangle.BuildFromPolygon\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle[]} O - [out,$return]\r\n *\r\n * @param {array} data - A flat array of vertex coordinates like [x0,y0, x1,y1, x2,y2, ...]\r\n * @param {array} [holes=null] - An array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean one hole with vertices 5–7 and another with 8–11).\r\n * @param {number} [scaleX=1] - Horizontal scale factor to multiply the resulting points by.\r\n * @param {number} [scaleY=1] - Vertical scale factor to multiply the resulting points by.\r\n * @param {(array|Phaser.Geom.Triangle[])} [out] - An array to store the resulting Triangle instances in. If not provided, a new array is created.\r\n *\r\n * @return {(array|Phaser.Geom.Triangle[])} An array of Triangle instances, where each triangle is based on the decomposed vertices data.\r\n */\r\nvar BuildFromPolygon = function (data, holes, scaleX, scaleY, out)\r\n{\r\n    if (holes === undefined) { holes = null; }\r\n    if (scaleX === undefined) { scaleX = 1; }\r\n    if (scaleY === undefined) { scaleY = 1; }\r\n    if (out === undefined) { out = []; }\r\n\r\n    var tris = EarCut(data, holes);\r\n\r\n    var a;\r\n    var b;\r\n    var c;\r\n\r\n    var x1;\r\n    var y1;\r\n\r\n    var x2;\r\n    var y2;\r\n\r\n    var x3;\r\n    var y3;\r\n\r\n    for (var i = 0; i < tris.length; i += 3)\r\n    {\r\n        a = tris[i];\r\n        b = tris[i + 1];\r\n        c = tris[i + 2];\r\n\r\n        x1 = data[a * 2] * scaleX;\r\n        y1 = data[(a * 2) + 1] * scaleY;\r\n\r\n        x2 = data[b * 2] * scaleX;\r\n        y2 = data[(b * 2) + 1] * scaleY;\r\n\r\n        x3 = data[c * 2] * scaleX;\r\n        y3 = data[(c * 2) + 1] * scaleY;\r\n\r\n        out.push(new Triangle(x1, y1, x2, y2, x3, y3));\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = BuildFromPolygon;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Triangle = require('./Triangle');\r\n\r\n//  Builds a right triangle, with one 90 degree angle and two acute angles\r\n//  The x/y is the coordinate of the 90 degree angle (and will map to x1/y1 in the resulting Triangle)\r\n//  w/h can be positive or negative and represent the length of each side\r\n\r\n/**\r\n * Builds a right triangle, i.e. one which has a 90-degree angle and two acute angles.\r\n *\r\n * @function Phaser.Geom.Triangle.BuildRight\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The X coordinate of the right angle, which will also be the first X coordinate of the constructed Triangle.\r\n * @param {number} y - The Y coordinate of the right angle, which will also be the first Y coordinate of the constructed Triangle.\r\n * @param {number} width - The length of the side which is to the left or to the right of the right angle.\r\n * @param {number} height - The length of the side which is above or below the right angle.\r\n *\r\n * @return {Phaser.Geom.Triangle} The constructed right Triangle.\r\n */\r\nvar BuildRight = function (x, y, width, height)\r\n{\r\n    if (height === undefined) { height = width; }\r\n\r\n    //  90 degree angle\r\n    var x1 = x;\r\n    var y1 = y;\r\n\r\n    var x2 = x;\r\n    var y2 = y - height;\r\n\r\n    var x3 = x + width;\r\n    var y3 = y;\r\n\r\n    return new Triangle(x1, y1, x2, y2, x3, y3);\r\n};\r\n\r\nmodule.exports = BuildRight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Centroid = require('./Centroid');\r\nvar Offset = require('./Offset');\r\n\r\n/**\r\n * @callback CenterFunction\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to return the center coordinates of.\r\n *\r\n * @return {Phaser.Math.Vector2} The center point of the Triangle according to the function.\r\n */\r\n\r\n/**\r\n * Positions the Triangle so that it is centered on the given coordinates.\r\n *\r\n * @function Phaser.Geom.Triangle.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The triangle to be positioned.\r\n * @param {number} x - The horizontal coordinate to center on.\r\n * @param {number} y - The vertical coordinate to center on.\r\n * @param {CenterFunction} [centerFunc] - The function used to center the triangle. Defaults to Centroid centering.\r\n *\r\n * @return {Phaser.Geom.Triangle} The Triangle that was centered.\r\n */\r\nvar CenterOn = function (triangle, x, y, centerFunc)\r\n{\r\n    if (centerFunc === undefined) { centerFunc = Centroid; }\r\n\r\n    //  Get the center of the triangle\r\n    var center = centerFunc(triangle);\r\n\r\n    //  Difference\r\n    var diffX = x - center.x;\r\n    var diffY = y - center.y;\r\n\r\n    return Offset(triangle, diffX, diffY);\r\n};\r\n\r\nmodule.exports = CenterOn;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n//  The three medians (the lines drawn from the vertices to the bisectors of the opposite sides)\r\n//  meet in the centroid or center of mass (center of gravity).\r\n//  The centroid divides each median in a ratio of 2:1\r\n\r\n/**\r\n * Calculates the position of a Triangle's centroid, which is also its center of mass (center of gravity).\r\n *\r\n * The centroid is the point in a Triangle at which its three medians (the lines drawn from the vertices to the bisectors of the opposite sides) meet. It divides each one in a 2:1 ratio.\r\n *\r\n * @function Phaser.Geom.Triangle.Centroid\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to use.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the coordinates in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} The `out` object with modified `x` and `y` properties, or a new Point if none was provided.\r\n */\r\nvar Centroid = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = (triangle.x1 + triangle.x2 + triangle.x3) / 3;\r\n    out.y = (triangle.y1 + triangle.y2 + triangle.y3) / 3;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Centroid;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n//  Adapted from http://bjornharrtell.github.io/jsts/doc/api/jsts_geom_Triangle.js.html\r\n\r\n/**\r\n * Computes the determinant of a 2x2 matrix. Uses standard double-precision arithmetic, so is susceptible to round-off error.\r\n *\r\n * @function det\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {number} m00 - The [0,0] entry of the matrix.\r\n * @param {number} m01 - The [0,1] entry of the matrix.\r\n * @param {number} m10 - The [1,0] entry of the matrix.\r\n * @param {number} m11 - The [1,1] entry of the matrix.\r\n *\r\n * @return {number} the determinant.\r\n */\r\nfunction det (m00, m01, m10, m11)\r\n{\r\n    return (m00 * m11) - (m01 * m10);\r\n}\r\n\r\n/**\r\n * Computes the circumcentre of a triangle. The circumcentre is the centre of\r\n * the circumcircle, the smallest circle which encloses the triangle. It is also\r\n * the common intersection point of the perpendicular bisectors of the sides of\r\n * the triangle, and is the only point which has equal distance to all three\r\n * vertices of the triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.CircumCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the circumcenter of.\r\n * @param {Phaser.Math.Vector2} [out] - The Vector2 object to store the position in. If not given, a new Vector2 instance is created.\r\n *\r\n * @return {Phaser.Math.Vector2} A Vector2 object holding the coordinates of the circumcenter of the Triangle.\r\n */\r\nvar CircumCenter = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = new Vector2(); }\r\n\r\n    var cx = triangle.x3;\r\n    var cy = triangle.y3;\r\n\r\n    var ax = triangle.x1 - cx;\r\n    var ay = triangle.y1 - cy;\r\n\r\n    var bx = triangle.x2 - cx;\r\n    var by = triangle.y2 - cy;\r\n\r\n    var denom = 2 * det(ax, ay, bx, by);\r\n    var numx = det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\r\n    var numy = det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\r\n\r\n    out.x = cx - numx / denom;\r\n    out.y = cy + numy / denom;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = CircumCenter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('../circle/Circle');\r\n\r\n//  Adapted from https://gist.github.com/mutoo/5617691\r\n\r\n/**\r\n * Finds the circumscribed circle (circumcircle) of a Triangle object. The circumcircle is the circle which touches all of the triangle's vertices.\r\n *\r\n * @function Phaser.Geom.Triangle.CircumCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Circle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to use as input.\r\n * @param {Phaser.Geom.Circle} [out] - An optional Circle to store the result in.\r\n *\r\n * @return {Phaser.Geom.Circle} The updated `out` Circle, or a new Circle if none was provided.\r\n */\r\nvar CircumCircle = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = new Circle(); }\r\n\r\n    //  A\r\n    var x1 = triangle.x1;\r\n    var y1 = triangle.y1;\r\n\r\n    //  B\r\n    var x2 = triangle.x2;\r\n    var y2 = triangle.y2;\r\n\r\n    //  C\r\n    var x3 = triangle.x3;\r\n    var y3 = triangle.y3;\r\n\r\n    var A = x2 - x1;\r\n    var B = y2 - y1;\r\n    var C = x3 - x1;\r\n    var D = y3 - y1;\r\n    var E = A * (x1 + x2) + B * (y1 + y2);\r\n    var F = C * (x1 + x3) + D * (y1 + y3);\r\n    var G = 2 * (A * (y3 - y2) - B * (x3 - x2));\r\n\r\n    var dx;\r\n    var dy;\r\n\r\n    //  If the points of the triangle are collinear, then just find the\r\n    //  extremes and use the midpoint as the center of the circumcircle.\r\n\r\n    if (Math.abs(G) < 0.000001)\r\n    {\r\n        var minX = Math.min(x1, x2, x3);\r\n        var minY = Math.min(y1, y2, y3);\r\n        dx = (Math.max(x1, x2, x3) - minX) * 0.5;\r\n        dy = (Math.max(y1, y2, y3) - minY) * 0.5;\r\n\r\n        out.x = minX + dx;\r\n        out.y = minY + dy;\r\n        out.radius = Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    else\r\n    {\r\n        out.x = (D * E - B * F) / G;\r\n        out.y = (A * F - C * E) / G;\r\n        dx = out.x - x1;\r\n        dy = out.y - y1;\r\n        out.radius = Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = CircumCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Triangle = require('./Triangle');\r\n\r\n/**\r\n * Clones a Triangle object.\r\n *\r\n * @function Phaser.Geom.Triangle.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} source - The Triangle to clone.\r\n *\r\n * @return {Phaser.Geom.Triangle} A new Triangle identical to the given one but separate from it.\r\n */\r\nvar Clone = function (source)\r\n{\r\n    return new Triangle(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  http://www.blackpawn.com/texts/pointinpoly/\r\n\r\n//  points is an array of Point-like objects with public x/y properties\r\n//  returns an array containing all points that are within the triangle, or an empty array if none\r\n//  if 'returnFirst' is true it will return after the first point within the triangle is found\r\n\r\n/**\r\n * Filters an array of point-like objects to only those contained within a triangle.\r\n * If `returnFirst` is true, will return an array containing only the first point in the provided array that is within the triangle (or an empty array if there are no such points).\r\n *\r\n * @function Phaser.Geom.Triangle.ContainsArray\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The triangle that the points are being checked in.\r\n * @param {Phaser.Geom.Point[]} points - An array of point-like objects (objects that have an `x` and `y` property)\r\n * @param {boolean} [returnFirst=false] - If `true`, return an array containing only the first point found that is within the triangle.\r\n * @param {array} [out] - If provided, the points that are within the triangle will be appended to this array instead of being added to a new array. If `returnFirst` is true, only the first point found within the triangle will be appended. This array will also be returned by this function.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array containing all the points from `points` that are within the triangle, if an array was provided as `out`, points will be appended to that array and it will also be returned here.\r\n */\r\nvar ContainsArray = function (triangle, points, returnFirst, out)\r\n{\r\n    if (returnFirst === undefined) { returnFirst = false; }\r\n    if (out === undefined) { out = []; }\r\n\r\n    var v0x = triangle.x3 - triangle.x1;\r\n    var v0y = triangle.y3 - triangle.y1;\r\n\r\n    var v1x = triangle.x2 - triangle.x1;\r\n    var v1y = triangle.y2 - triangle.y1;\r\n\r\n    var dot00 = (v0x * v0x) + (v0y * v0y);\r\n    var dot01 = (v0x * v1x) + (v0y * v1y);\r\n    var dot11 = (v1x * v1x) + (v1y * v1y);\r\n\r\n    // Compute barycentric coordinates\r\n    var b = ((dot00 * dot11) - (dot01 * dot01));\r\n    var inv = (b === 0) ? 0 : (1 / b);\r\n\r\n    var u;\r\n    var v;\r\n    var v2x;\r\n    var v2y;\r\n    var dot02;\r\n    var dot12;\r\n\r\n    var x1 = triangle.x1;\r\n    var y1 = triangle.y1;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        v2x = points[i].x - x1;\r\n        v2y = points[i].y - y1;\r\n\r\n        dot02 = (v0x * v2x) + (v0y * v2y);\r\n        dot12 = (v1x * v2x) + (v1y * v2y);\r\n\r\n        u = ((dot11 * dot02) - (dot01 * dot12)) * inv;\r\n        v = ((dot00 * dot12) - (dot01 * dot02)) * inv;\r\n    \r\n        if (u >= 0 && v >= 0 && (u + v < 1))\r\n        {\r\n            out.push({ x: points[i].x, y: points[i].y });\r\n\r\n            if (returnFirst)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ContainsArray;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Contains = require('./Contains');\r\n\r\n/**\r\n * Tests if a triangle contains a point.\r\n *\r\n * @function Phaser.Geom.Triangle.ContainsPoint\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The triangle.\r\n * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|any)} point - The point to test, or any point-like object with public `x` and `y` properties.\r\n *\r\n * @return {boolean} `true` if the point is within the triangle, otherwise `false`.\r\n */\r\nvar ContainsPoint = function (triangle, point)\r\n{\r\n    return Contains(triangle, point.x, point.y);\r\n};\r\n\r\nmodule.exports = ContainsPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Copy the values of one Triangle to a destination Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.CopyFrom\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [dest,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} source - The source Triangle to copy the values from.\r\n * @param {Phaser.Geom.Triangle} dest - The destination Triangle to copy the values to.\r\n *\r\n * @return {Phaser.Geom.Triangle} The destination Triangle.\r\n */\r\nvar CopyFrom = function (source, dest)\r\n{\r\n    return dest.setTo(source.x1, source.y1, source.x2, source.y2, source.x3, source.y3);\r\n};\r\n\r\nmodule.exports = CopyFrom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Decomposes a Triangle into an array of its points.\r\n *\r\n * @function Phaser.Geom.Triangle.Decompose\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to decompose.\r\n * @param {array} [out] - An array to store the points into.\r\n *\r\n * @return {array} The provided `out` array, or a new array if none was provided, with three objects with `x` and `y` properties representing each point of the Triangle appended to it.\r\n */\r\nvar Decompose = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    out.push({ x: triangle.x1, y: triangle.y1 });\r\n    out.push({ x: triangle.x2, y: triangle.y2 });\r\n    out.push({ x: triangle.x3, y: triangle.y3 });\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Decompose;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns true if two triangles have the same coordinates.\r\n *\r\n * @function Phaser.Geom.Triangle.Equals\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The first triangle to check.\r\n * @param {Phaser.Geom.Triangle} toCompare - The second triangle to check.\r\n *\r\n * @return {boolean} `true` if the two given triangles have the exact same coordinates, otherwise `false`.\r\n */\r\nvar Equals = function (triangle, toCompare)\r\n{\r\n    return (\r\n        triangle.x1 === toCompare.x1 &&\r\n        triangle.y1 === toCompare.y1 &&\r\n        triangle.x2 === toCompare.x2 &&\r\n        triangle.y2 === toCompare.y2 &&\r\n        triangle.x3 === toCompare.x3 &&\r\n        triangle.y3 === toCompare.y3\r\n    );\r\n};\r\n\r\nmodule.exports = Equals;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n// The three angle bisectors of a triangle meet in one point called the incenter.\r\n// It is the center of the incircle, the circle inscribed in the triangle.\r\n\r\nfunction getLength (x1, y1, x2, y2)\r\n{\r\n    var x = x1 - x2;\r\n    var y = y1 - y2;\r\n    var magnitude = (x * x) + (y * y);\r\n\r\n    return Math.sqrt(magnitude);\r\n}\r\n\r\n/**\r\n * Calculates the position of the incenter of a Triangle object. This is the point where its three angle bisectors meet and it's also the center of the incircle, which is the circle inscribed in the triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.InCenter\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to find the incenter of.\r\n * @param {Phaser.Geom.Point} [out] - An optional Point in which to store the coordinates.\r\n *\r\n * @return {Phaser.Geom.Point} Point (x, y) of the center pixel of the triangle.\r\n */\r\nvar InCenter = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var x1 = triangle.x1;\r\n    var y1 = triangle.y1;\r\n\r\n    var x2 = triangle.x2;\r\n    var y2 = triangle.y2;\r\n\r\n    var x3 = triangle.x3;\r\n    var y3 = triangle.y3;\r\n\r\n    var d1 = getLength(x3, y3, x2, y2);\r\n    var d2 = getLength(x1, y1, x3, y3);\r\n    var d3 = getLength(x2, y2, x1, y1);\r\n\r\n    var p = d1 + d2 + d3;\r\n\r\n    out.x = (x1 * d1 + x2 * d2 + x3 * d3) / p;\r\n    out.y = (y1 * d1 + y2 * d2 + y3 * d3) / p;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = InCenter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Moves each point (vertex) of a Triangle by a given offset, thus moving the entire Triangle by that offset.\r\n *\r\n * @function Phaser.Geom.Triangle.Offset\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to move.\r\n * @param {number} x - The horizontal offset (distance) by which to move each point. Can be positive or negative.\r\n * @param {number} y - The vertical offset (distance) by which to move each point. Can be positive or negative.\r\n *\r\n * @return {Phaser.Geom.Triangle} The modified Triangle.\r\n */\r\nvar Offset = function (triangle, x, y)\r\n{\r\n    triangle.x1 += x;\r\n    triangle.y1 += y;\r\n\r\n    triangle.x2 += x;\r\n    triangle.y2 += y;\r\n\r\n    triangle.x3 += x;\r\n    triangle.y3 += y;\r\n\r\n    return triangle;\r\n};\r\n\r\nmodule.exports = Offset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\n\r\n/**\r\n * Gets the length of the perimeter of the given triangle.\r\n * Calculated by adding together the length of each of the three sides.\r\n *\r\n * @function Phaser.Geom.Triangle.Perimeter\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the length from.\r\n *\r\n * @return {number} The length of the Triangle.\r\n */\r\nvar Perimeter = function (triangle)\r\n{\r\n    var line1 = triangle.getLineA();\r\n    var line2 = triangle.getLineB();\r\n    var line3 = triangle.getLineC();\r\n\r\n    return (Length(line1) + Length(line2) + Length(line3));\r\n};\r\n\r\nmodule.exports = Perimeter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RotateAroundXY = require('./RotateAroundXY');\r\nvar InCenter = require('./InCenter');\r\n\r\n/**\r\n * Rotates a Triangle about its incenter, which is the point at which its three angle bisectors meet.\r\n *\r\n * @function Phaser.Geom.Triangle.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to rotate.\r\n * @param {number} angle - The angle by which to rotate the Triangle, in radians.\r\n *\r\n * @return {Phaser.Geom.Triangle} The rotated Triangle.\r\n */\r\nvar Rotate = function (triangle, angle)\r\n{\r\n    var point = InCenter(triangle);\r\n\r\n    return RotateAroundXY(triangle, point.x, point.y, angle);\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RotateAroundXY = require('./RotateAroundXY');\r\n\r\n/**\r\n * Rotates a Triangle at a certain angle about a given Point or object with public `x` and `y` properties.\r\n *\r\n * @function Phaser.Geom.Triangle.RotateAroundPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to rotate.\r\n * @param {Phaser.Geom.Point} point - The Point to rotate the Triangle about.\r\n * @param {number} angle - The angle by which to rotate the Triangle, in radians.\r\n *\r\n * @return {Phaser.Geom.Triangle} The rotated Triangle.\r\n */\r\nvar RotateAroundPoint = function (triangle, point, angle)\r\n{\r\n    return RotateAroundXY(triangle, point.x, point.y, angle);\r\n};\r\n\r\nmodule.exports = RotateAroundPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotates an entire Triangle at a given angle about a specific point.\r\n *\r\n * @function Phaser.Geom.Triangle.RotateAroundXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Triangle} O - [triangle,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to rotate.\r\n * @param {number} x - The X coordinate of the point to rotate the Triangle about.\r\n * @param {number} y - The Y coordinate of the point to rotate the Triangle about.\r\n * @param {number} angle - The angle by which to rotate the Triangle, in radians.\r\n *\r\n * @return {Phaser.Geom.Triangle} The rotated Triangle.\r\n */\r\nvar RotateAroundXY = function (triangle, x, y, angle)\r\n{\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var tx = triangle.x1 - x;\r\n    var ty = triangle.y1 - y;\r\n\r\n    triangle.x1 = tx * c - ty * s + x;\r\n    triangle.y1 = tx * s + ty * c + y;\r\n\r\n    tx = triangle.x2 - x;\r\n    ty = triangle.y2 - y;\r\n\r\n    triangle.x2 = tx * c - ty * s + x;\r\n    triangle.y2 = tx * s + ty * c + y;\r\n\r\n    tx = triangle.x3 - x;\r\n    ty = triangle.y3 - y;\r\n\r\n    triangle.x3 = tx * c - ty * s + x;\r\n    triangle.y3 = tx * s + ty * c + y;\r\n\r\n    return triangle;\r\n};\r\n\r\nmodule.exports = RotateAroundXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Triangle = require('./Triangle');\r\n\r\nTriangle.Area = require('./Area');\r\nTriangle.BuildEquilateral = require('./BuildEquilateral');\r\nTriangle.BuildFromPolygon = require('./BuildFromPolygon');\r\nTriangle.BuildRight = require('./BuildRight');\r\nTriangle.CenterOn = require('./CenterOn');\r\nTriangle.Centroid = require('./Centroid');\r\nTriangle.CircumCenter = require('./CircumCenter');\r\nTriangle.CircumCircle = require('./CircumCircle');\r\nTriangle.Clone = require('./Clone');\r\nTriangle.Contains = require('./Contains');\r\nTriangle.ContainsArray = require('./ContainsArray');\r\nTriangle.ContainsPoint = require('./ContainsPoint');\r\nTriangle.CopyFrom = require('./CopyFrom');\r\nTriangle.Decompose = require('./Decompose');\r\nTriangle.Equals = require('./Equals');\r\nTriangle.GetPoint = require('./GetPoint');\r\nTriangle.GetPoints = require('./GetPoints');\r\nTriangle.InCenter = require('./InCenter');\r\nTriangle.Perimeter = require('./Perimeter');\r\nTriangle.Offset = require('./Offset');\r\nTriangle.Random = require('./Random');\r\nTriangle.Rotate = require('./Rotate');\r\nTriangle.RotateAroundPoint = require('./RotateAroundPoint');\r\nTriangle.RotateAroundXY = require('./RotateAroundXY');\r\n\r\nmodule.exports = Triangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random integer between the `min` and `max` values, inclusive.\r\n *\r\n * @function Phaser.Math.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The random integer.\r\n */\r\nvar Between = function (min, max)\r\n{\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent + min;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 4D space.\r\n *\r\n * A four-component vector.\r\n *\r\n * @class Vector4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Vector4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector4 (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        /**\r\n         * The w component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.w = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector4.\r\n     *\r\n     * @method Phaser.Math.Vector4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} A clone of this Vector4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n        this.w = src.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict quality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector4#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The vector to check equality with.\r\n     *\r\n     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.\r\n     *\r\n     * @method Phaser.Math.Vector4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.\r\n     * @param {number} y - The y value to set for this Vector.\r\n     * @param {number} z - The z value to set for this Vector.\r\n     * @param {number} w - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n        this.w += v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n        this.w -= v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector4#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n        this.w *= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n        this.w /= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz + dw * dw;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y`, `z` and `w` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        this.w = -this.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector4#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nVector4.prototype.sub = Vector4.prototype.subtract;\r\nVector4.prototype.mul = Vector4.prototype.multiply;\r\nVector4.prototype.div = Vector4.prototype.divide;\r\nVector4.prototype.dist = Vector4.prototype.distance;\r\nVector4.prototype.distSq = Vector4.prototype.distanceSq;\r\nVector4.prototype.len = Vector4.prototype.length;\r\nVector4.prototype.lenSq = Vector4.prototype.lengthSq;\r\n\r\nmodule.exports = Vector4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two points.\r\n *\r\n * @function Phaser.Math.Distance.BetweenPoints\r\n * @since 3.22.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} a - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} b - The second point.\r\n *\r\n * @return {number} The distance between the points.\r\n */\r\nvar DistanceBetweenPoints = function (a, b)\r\n{\r\n    var dx = a.x - b.x;\r\n    var dy = a.y - b.y;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetweenPoints;\r\n"],"names":["module","exports","circle","radius","Math","PI","Circle","source","x","y","Contains","point","rect","right","bottom","dest","setTo","toCompare","Rectangle","out","undefined","left","top","width","diameter","height","Area","Circumference","CircumferencePoint","Clone","ContainsPoint","ContainsRect","CopyFrom","Equals","GetBounds","GetPoint","GetPoints","Offset","OffsetPoint","Random","ellipse","isEmpty","getMajorRadius","getMinorRadius","Ellipse","CONST","Extend","Geom","Intersects","Line","Mesh","Point","Polygon","Triangle","DistanceBetween","circleA","circleB","CircleToCircle","coefficientA","coefficientB","lambda","x0","y0","r0","x1","y1","r1","push","sqrt","v1","n","GetLineToCircle","CircleToRectangle","lineA","getLineA","lineB","getLineB","lineC","getLineC","lineD","getLineD","LineToCircle","line","lx1","ly1","lx2","x2","ly2","y2","cx","cy","cr","lDirX","lDirY","oDirX","oDirY","root","root1","root2","Vector3","line1","line2","x3","y3","dx1","dy1","dx2","dy2","T2","T1","set","GetLineToLine","segment","tempIntersect","points","closestIntersect","prev","i","length","current","z","copy","Vector4","GetLineToPoints","polygons","Array","isArray","LineToLine","LineToRectangle","output","result","GetLineToPolygon","CheckIntersects","angle","intersects","dx","cos","dy","sin","w","SortIntersects","a","b","angles","p","atan2","indexOf","sort","RectangleToRectangle","rectA","rectB","max","min","GetLineToRectangle","RectangleToTriangle","triangle","TriangleToCircle","TriangleToLine","TriangleToTriangle","GetTriangleToLine","triangleA","triangleB","tmp","nearest","lcx","lcy","dLen2","px","py","dp","x4","y4","deNom","uA","uB","bx1","by1","bx2","by2","t","lineThickness","L2","r","s","abs","PointToLine","xMin","xMax","yMin","yMax","ContainsArray","Decompose","triA","triB","triC","rectC","rectD","tolerance","contains","lineAA","lineAB","lineAC","lineBA","lineBB","lineBC","within","GetCircleToCircle","GetCircleToRectangle","GetRaysFromPointToPolygon","GetRectangleIntersection","GetRectangleToRectangle","GetRectangleToTriangle","GetTriangleToCircle","GetTriangleToTriangle","PointToLineSegment","RectangleToValues","tx","ty","Length","slopX","slopY","DistanceBetweenPoints","GetEaseFunction","ease","quantity","collinearThreshold","easeParams","v","results","spaceX","spaceY","easeFunc","q","prevPoint","sortedResults","endPoint","pop","MATH_CONST","Angle","TAU","Wrap","NormalAngle","RotateAroundXY","c","BresenhamPoints","CenterOn","GetEasedPoints","GetMidPoint","GetNearestPoint","GetNormal","GetShortestDistance","Height","NormalX","NormalY","PerpSlope","ReflectAngle","Rotate","RotateAroundPoint","SetToAngle","Slope","Width","Face","GetFastValue","Matrix4","Vertex","tempPosition","tempRotation","tempMatrix","config","mesh","texture","frame","widthSegments","heightSegments","posX","posY","posZ","rotateX","rotateY","rotateZ","zIsUp","isOrtho","dirtyCache","colors","alphas","tile","flipY","widthSet","faces","verts","fromRotationXYTranslation","scene","sys","textures","get","textureFrame","ix","iy","halfWidth","halfHeight","gridX","floor","gridY","gridX1","gridY1","segmentWidth","segmentHeight","uvs","vertices","frameU0","frameU1","frameV0","frameV1","u0","u1","v0","frameU","frameV","tu","tv","alphaIndex","colorIndex","d","color","alpha","vert1","transformMat4","vert2","vert3","vert4","vert5","vert6","setUVs","concat","flip","defaultModelName","currentGroup","currentMaterial","currentModel","models","name","textureCoords","vertexNormals","parseObject","lineItems","modelName","parseGroup","parseVertexCoords","len","parseFloat","parseTextureCoords","u","isNaN","parseVertexNormal","parsePolygon","totalVertices","face","group","material","vertexValues","split","vvLen","vertexIndex","textureCoordsIndex","vertexNormalIndex","parseInt","parseMtlLib","materialLibraries","parseUseMtl","data","flipUV","idx","materials","lines","substring","replace","trim","toLowerCase","GetColor","mtl","g","inCenter","getInCenter","vertex1","v2","vertex2","v3","vertex3","GenerateGridVerts","GenerateObjVerts","GenerateVerts","ParseObj","ParseObjMaterial","RotateFace","ceil","Error","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","pointA","pointB","GetMagnitudeSq","amt","GetMagnitude","magnitude","m","Ceil","Floor","GetCentroid","GetRectangleFromPoints","Interpolate","Invert","Negative","Project","ProjectUnit","SetMagnitude","polygon","reverse","getSqSegDist","p1","p2","simplifyDPStep","first","last","sqTolerance","simplified","index","maxSqDist","sqDist","simplifyDouglasPeucker","highestQuality","newPoints","simplifyRadialDist","Earcut","GetAABB","GetNumberArray","Perimeter","Reverse","Simplify","Smooth","Translate","GetAspectRatio","target","ratio","setSize","setPosition","centerX","centerY","minX","MAX_VALUE","minY","maxX","MIN_SAFE_INTEGER","maxY","NaN","setEmpty","DegToRad","rectangle","Between","outer","inner","random","CeilAll","FitInside","FitOutside","FloorAll","FromPoints","FromXY","GetCenter","GetSize","Inflate","Intersection","MarchingAnts","MergePoints","MergeRect","MergeXY","Overlaps","PerimeterPoint","RandomOutside","SameDimensions","Scale","Union","EarCut","holes","scaleX","scaleY","tris","Centroid","centerFunc","center","diffX","diffY","Vector2","det","m00","m01","m10","m11","ax","ay","bx","by","denom","numx","numy","A","B","C","D","E","F","G","returnFirst","v2x","v2y","dot02","dot12","v0x","v0y","v1x","v1y","dot00","dot01","dot11","inv","getLength","d1","d2","d3","line3","InCenter","BuildEquilateral","BuildFromPolygon","BuildRight","CircumCenter","CircumCircle","Clamp","percent","initialize","this","clone","src","equals","add","subtract","scale","lengthSq","normalize","dot","lerp","az","aw","multiply","divide","distance","dz","dw","distanceSq","negate","mat","val","transformQuat","qx","qy","qz","qw","iz","iw","reset","prototype","sub","mul","div","dist","distSq","lenSq"],"sourceRoot":""}