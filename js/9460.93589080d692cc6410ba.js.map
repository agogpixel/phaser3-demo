{"version":3,"file":"js/9460.93589080d692cc6410ba.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/AnimationManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/NumberArray.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/string/Pad.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Animation = require('./Animation');\r\nvar Class = require('../utils/Class');\r\nvar CustomMap = require('../structs/Map');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar Pad = require('../utils/string/Pad');\r\nvar NumberArray = require('../utils/array/NumberArray');\r\n\r\n/**\r\n * @classdesc\r\n * The Animation Manager.\r\n *\r\n * Animations are managed by the global Animation Manager. This is a singleton class that is\r\n * responsible for creating and delivering animations and their corresponding data to all Game Objects.\r\n * Unlike plugins it is owned by the Game instance, not the Scene.\r\n *\r\n * Sprites and other Game Objects get the data they need from the AnimationManager.\r\n *\r\n * @class AnimationManager\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\r\nvar AnimationManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function AnimationManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Phaser.Game instance.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.textureManager = null;\r\n\r\n        /**\r\n         * The global time scale of the Animation Manager.\r\n         *\r\n         * This scales the time delta between two frames, thus influencing the speed of time for the Animation Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#globalTimeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.globalTimeScale = 1;\r\n\r\n        /**\r\n         * The Animations registered in the Animation Manager.\r\n         *\r\n         * This map should be modified with the {@link #add} and {@link #create} methods of the Animation Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#anims\r\n         * @type {Phaser.Structs.Map.<string, Phaser.Animations.Animation>}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.anims = new CustomMap();\r\n\r\n        /**\r\n         * A list of animation mix times.\r\n         *\r\n         * See the {@link #setMix} method for more details.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#mixes\r\n         * @type {Phaser.Structs.Map.<string, Phaser.Animations.Animation>}\r\n         * @since 3.50.0\r\n         */\r\n        this.mixes = new CustomMap();\r\n\r\n        /**\r\n         * Whether the Animation Manager is paused along with all of its Animations.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * The name of this Animation Manager.\r\n         *\r\n         * @name Phaser.Animations.AnimationManager#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = 'AnimationManager';\r\n\r\n        game.events.once(GameEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * Registers event listeners after the Game boots.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#boot\r\n     * @listens Phaser.Core.Events#DESTROY\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.textureManager = this.game.textures;\r\n\r\n        this.game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Adds a mix between two animations.\r\n     *\r\n     * Mixing allows you to specify a unique delay between a pairing of animations.\r\n     *\r\n     * When playing Animation A on a Game Object, if you then play Animation B, and a\r\n     * mix exists, it will wait for the specified delay to be over before playing Animation B.\r\n     *\r\n     * This allows you to customise smoothing between different types of animation, such\r\n     * as blending between an idle and a walk state, or a running and a firing state.\r\n     *\r\n     * Note that mixing is only applied if you use the `Sprite.play` method. If you opt to use\r\n     * `playAfterRepeat` or `playAfterDelay` instead, those will take priority and the mix\r\n     * delay will not be used.\r\n     *\r\n     * To update an existing mix, just call this method with the new delay.\r\n     *\r\n     * To remove a mix pairing, see the `removeMix` method.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#addMix\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation)} animA - The string-based key, or instance of, Animation A.\r\n     * @param {(string|Phaser.Animations.Animation)} animB - The string-based key, or instance of, Animation B.\r\n     * @param {number} delay - The delay, in milliseconds, to wait when transitioning from Animation A to B.\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    addMix: function (animA, animB, delay)\r\n    {\r\n        var anims = this.anims;\r\n        var mixes = this.mixes;\r\n\r\n        var keyA = (typeof(animA) === 'string') ? animA : animA.key;\r\n        var keyB = (typeof(animB) === 'string') ? animB : animB.key;\r\n\r\n        if (anims.has(keyA) && anims.has(keyB))\r\n        {\r\n            var mixObj = mixes.get(keyA);\r\n\r\n            if (!mixObj)\r\n            {\r\n                mixObj = {};\r\n            }\r\n\r\n            mixObj[keyB] = delay;\r\n\r\n            mixes.set(keyA, mixObj);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a mix between two animations.\r\n     *\r\n     * Mixing allows you to specify a unique delay between a pairing of animations.\r\n     *\r\n     * Calling this method lets you remove those pairings. You can either remove\r\n     * it between `animA` and `animB`, or if you do not provide the `animB` parameter,\r\n     * it will remove all `animA` mixes.\r\n     *\r\n     * If you wish to update an existing mix instead, call the `addMix` method with the\r\n     * new delay.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#removeMix\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation)} animA - The string-based key, or instance of, Animation A.\r\n     * @param {(string|Phaser.Animations.Animation)} [animB] - The string-based key, or instance of, Animation B. If not given, all mixes for Animation A will be removed.\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    removeMix: function (animA, animB)\r\n    {\r\n        var mixes = this.mixes;\r\n\r\n        var keyA = (typeof(animA) === 'string') ? animA : animA.key;\r\n\r\n        var mixObj = mixes.get(keyA);\r\n\r\n        if (mixObj)\r\n        {\r\n            if (animB)\r\n            {\r\n                var keyB = (typeof(animB) === 'string') ? animB : animB.key;\r\n\r\n                if (mixObj.hasOwnProperty(keyB))\r\n                {\r\n                    //  Remove just this pairing\r\n                    delete mixObj[keyB];\r\n                }\r\n            }\r\n            else if (!animB)\r\n            {\r\n                //  Remove everything for animA\r\n                mixes.delete(keyA);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the mix delay between two animations.\r\n     *\r\n     * If no mix has been set-up, this method will return zero.\r\n     *\r\n     * If you wish to create, or update, a new mix, call the `addMix` method.\r\n     * If you wish to remove a mix, call the `removeMix` method.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#getMix\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation)} animA - The string-based key, or instance of, Animation A.\r\n     * @param {(string|Phaser.Animations.Animation)} animB - The string-based key, or instance of, Animation B.\r\n     *\r\n     * @return {number} The mix duration, or zero if no mix exists.\r\n     */\r\n    getMix: function (animA, animB)\r\n    {\r\n        var mixes = this.mixes;\r\n\r\n        var keyA = (typeof(animA) === 'string') ? animA : animA.key;\r\n        var keyB = (typeof(animB) === 'string') ? animB : animB.key;\r\n\r\n        var mixObj = mixes.get(keyA);\r\n\r\n        if (mixObj && mixObj.hasOwnProperty(keyB))\r\n        {\r\n            return mixObj[keyB];\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Animation to the Animation Manager.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#add\r\n     * @fires Phaser.Animations.Events#ADD_ANIMATION\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key under which the Animation should be added. The Animation will be updated with it. Must be unique.\r\n     * @param {Phaser.Animations.Animation} animation - The Animation which should be added to the Animation Manager.\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    add: function (key, animation)\r\n    {\r\n        if (this.anims.has(key))\r\n        {\r\n            console.warn('Animation key exists: ' + key);\r\n\r\n            return this;\r\n        }\r\n\r\n        animation.key = key;\r\n\r\n        this.anims.set(key, animation);\r\n\r\n        this.emit(Events.ADD_ANIMATION, key, animation);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given key is already in use within the Animation Manager or not.\r\n     *\r\n     * Animations are global. Keys created in one scene can be used from any other Scene in your game. They are not Scene specific.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#exists\r\n     * @since 3.16.0\r\n     *\r\n     * @param {string} key - The key of the Animation to check.\r\n     *\r\n     * @return {boolean} `true` if the Animation already exists in the Animation Manager, or `false` if the key is available.\r\n     */\r\n    exists: function (key)\r\n    {\r\n        return this.anims.has(key);\r\n    },\r\n\r\n    /**\r\n     * Create one, or more animations from a loaded Aseprite JSON file.\r\n     *\r\n     * Aseprite is a powerful animated sprite editor and pixel art tool.\r\n     *\r\n     * You can find more details at https://www.aseprite.org/\r\n     *\r\n     * To export a compatible JSON file in Aseprite, please do the following:\r\n     *\r\n     * 1. Go to \"File - Export Sprite Sheet\"\r\n     *\r\n     * 2. On the **Layout** tab:\r\n     * 2a. Set the \"Sheet type\" to \"Packed\"\r\n     * 2b. Set the \"Constraints\" to \"None\"\r\n     * 2c. Check the \"Merge Duplicates\" checkbox\r\n     *\r\n     * 3. On the **Sprite** tab:\r\n     * 3a. Set \"Layers\" to \"Visible layers\"\r\n     * 3b. Set \"Frames\" to \"All frames\", unless you only wish to export a sub-set of tags\r\n     *\r\n     * 4. On the **Borders** tab:\r\n     * 4a. Check the \"Trim Sprite\" and \"Trim Cells\" options\r\n     * 4b. Ensure \"Border Padding\", \"Spacing\" and \"Inner Padding\" are all > 0 (1 is usually enough)\r\n     *\r\n     * 5. On the **Output** tab:\r\n     * 5a. Check \"Output File\", give your image a name and make sure you choose \"png files\" as the file type\r\n     * 5b. Check \"JSON Data\" and give your json file a name\r\n     * 5c. The JSON Data type can be either a Hash or Array, Phaser doesn't mind.\r\n     * 5d. Make sure \"Tags\" is checked in the Meta options\r\n     * 5e. In the \"Item Filename\" input box, make sure it says just \"{frame}\" and nothing more.\r\n     *\r\n     * 6. Click export\r\n     *\r\n     * This was tested with Aseprite 1.2.25.\r\n     *\r\n     * This will export a png and json file which you can load using the Aseprite Loader, i.e.:\r\n     *\r\n     * ```javascript\r\n     * function preload ()\r\n     * {\r\n     *     this.load.path = 'assets/animations/aseprite/';\r\n     *     this.load.aseprite('paladin', 'paladin.png', 'paladin.json');\r\n     * }\r\n     * ```\r\n     *\r\n     * Once loaded, you can call this method from within a Scene with the 'atlas' key:\r\n     *\r\n     * ```javascript\r\n     * this.anims.createFromAseprite('paladin');\r\n     * ```\r\n     *\r\n     * Any animations defined in the JSON will now be available to use in Phaser and you play them\r\n     * via their Tag name. For example, if you have an animation called 'War Cry' on your Aseprite timeline,\r\n     * you can play it in Phaser using that Tag name:\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(400, 300).play('War Cry');\r\n     * ```\r\n     *\r\n     * When calling this method you can optionally provide an array of tag names, and only those animations\r\n     * will be created. For example:\r\n     *\r\n     * ```javascript\r\n     * this.anims.createFromAseprite('paladin', [ 'step', 'War Cry', 'Magnum Break' ]);\r\n     * ```\r\n     *\r\n     * This will only create the 3 animations defined. Note that the tag names are case-sensitive.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#createFromAseprite\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the loaded Aseprite atlas. It must have been loaded prior to calling this method.\r\n     * @param {string[]} [tags] - An array of Tag names. If provided, only animations found in this array will be created.\r\n     *\r\n     * @return {Phaser.Animations.Animation[]} An array of Animation instances that were successfully created.\r\n     */\r\n    createFromAseprite: function (key, tags)\r\n    {\r\n        var output = [];\r\n\r\n        var data = this.game.cache.json.get(key);\r\n\r\n        if (!data)\r\n        {\r\n            return output;\r\n        }\r\n\r\n        var _this = this;\r\n\r\n        var meta = GetValue(data, 'meta', null);\r\n        var frames = GetValue(data, 'frames', null);\r\n\r\n        if (meta && frames)\r\n        {\r\n            var frameTags = GetValue(meta, 'frameTags', []);\r\n\r\n            frameTags.forEach(function (tag)\r\n            {\r\n                var animFrames = [];\r\n\r\n                var name = GetFastValue(tag, 'name', null);\r\n                var from = GetFastValue(tag, 'from', 0);\r\n                var to = GetFastValue(tag, 'to', 0);\r\n                var direction = GetFastValue(tag, 'direction', 'forward');\r\n\r\n                if (!name)\r\n                {\r\n                    //  Skip if no name\r\n                    return;\r\n                }\r\n\r\n                if (!tags || (tags && tags.indexOf(name) > -1))\r\n                {\r\n                    //  Get all the frames for this tag\r\n                    var tempFrames = [];\r\n                    var minDuration = Number.MAX_SAFE_INTEGER;\r\n\r\n                    for (var i = from; i <= to; i++)\r\n                    {\r\n                        var frameKey = i.toString();\r\n                        var frame = frames[frameKey];\r\n\r\n                        if (frame)\r\n                        {\r\n                            var frameDuration = GetFastValue(frame, 'duration', Number.MAX_SAFE_INTEGER);\r\n\r\n                            if (frameDuration < minDuration)\r\n                            {\r\n                                minDuration = frameDuration;\r\n                            }\r\n\r\n                            tempFrames.push({ frame: frameKey, duration: frameDuration });\r\n                        }\r\n                    }\r\n\r\n                    tempFrames.forEach(function (entry)\r\n                    {\r\n                        animFrames.push({\r\n                            key: key,\r\n                            frame: entry.frame,\r\n                            duration: (minDuration - entry.duration)\r\n                        });\r\n                    });\r\n\r\n                    var totalDuration = (minDuration * animFrames.length);\r\n\r\n                    if (direction === 'reverse')\r\n                    {\r\n                        animFrames = animFrames.reverse();\r\n                    }\r\n\r\n                    //  Create the animation\r\n                    var createConfig = {\r\n                        key: name,\r\n                        frames: animFrames,\r\n                        duration: totalDuration,\r\n                        yoyo: (direction === 'pingpong')\r\n                    };\r\n\r\n                    var result = _this.create(createConfig);\r\n\r\n                    if (result)\r\n                    {\r\n                        output.push(result);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Animation and adds it to the Animation Manager.\r\n     *\r\n     * Animations are global. Once created, you can use them in any Scene in your game. They are not Scene specific.\r\n     *\r\n     * If an invalid key is given this method will return `false`.\r\n     *\r\n     * If you pass the key of an animation that already exists in the Animation Manager, that animation will be returned.\r\n     *\r\n     * A brand new animation is only created if the key is valid and not already in use.\r\n     *\r\n     * If you wish to re-use an existing key, call `AnimationManager.remove` first, then this method.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#create\r\n     * @fires Phaser.Animations.Events#ADD_ANIMATION\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Animations.Animation} config - The configuration settings for the Animation.\r\n     *\r\n     * @return {(Phaser.Animations.Animation|false)} The Animation that was created, or `false` if the key is already in use.\r\n     */\r\n    create: function (config)\r\n    {\r\n        var key = config.key;\r\n\r\n        var anim = false;\r\n\r\n        if (key)\r\n        {\r\n            anim = this.get(key);\r\n\r\n            if (!anim)\r\n            {\r\n                anim = new Animation(this, key, config);\r\n\r\n                this.anims.set(key, anim);\r\n\r\n                this.emit(Events.ADD_ANIMATION, key, anim);\r\n            }\r\n        }\r\n\r\n        return anim;\r\n    },\r\n\r\n    /**\r\n     * Loads this Animation Manager's Animations and settings from a JSON object.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Types.Animations.JSONAnimations|Phaser.Types.Animations.JSONAnimation)} data - The JSON object to parse.\r\n     * @param {boolean} [clearCurrentAnimations=false] - If set to `true`, the current animations will be removed (`anims.clear()`). If set to `false` (default), the animations in `data` will be added.\r\n     *\r\n     * @return {Phaser.Animations.Animation[]} An array containing all of the Animation objects that were created as a result of this call.\r\n     */\r\n    fromJSON: function (data, clearCurrentAnimations)\r\n    {\r\n        if (clearCurrentAnimations === undefined) { clearCurrentAnimations = false; }\r\n\r\n        if (clearCurrentAnimations)\r\n        {\r\n            this.anims.clear();\r\n        }\r\n\r\n        //  Do we have a String (i.e. from JSON, or an Object?)\r\n        if (typeof data === 'string')\r\n        {\r\n            data = JSON.parse(data);\r\n        }\r\n\r\n        var output = [];\r\n\r\n        //  Array of animations, or a single animation?\r\n        if (data.hasOwnProperty('anims') && Array.isArray(data.anims))\r\n        {\r\n            for (var i = 0; i < data.anims.length; i++)\r\n            {\r\n                output.push(this.create(data.anims[i]));\r\n            }\r\n\r\n            if (data.hasOwnProperty('globalTimeScale'))\r\n            {\r\n                this.globalTimeScale = data.globalTimeScale;\r\n            }\r\n        }\r\n        else if (data.hasOwnProperty('key') && data.type === 'frame')\r\n        {\r\n            output.push(this.create(data));\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.\r\n     *\r\n     * Generates objects with string based frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNames}.\r\n     *\r\n     * It's a helper method, designed to make it easier for you to extract all of the frame names from texture atlases.\r\n     * If you're working with a sprite sheet, see the `generateFrameNumbers` method instead.\r\n     *\r\n     * Example:\r\n     *\r\n     * If you have a texture atlases loaded called `gems` and it contains 6 frames called `ruby_0001`, `ruby_0002`, and so on,\r\n     * then you can call this method using: `this.anims.generateFrameNames('gems', { prefix: 'ruby_', end: 6, zeroPad: 4 })`.\r\n     *\r\n     * The `end` value tells it to look for 6 frames, incrementally numbered, all starting with the prefix `ruby_`. The `zeroPad`\r\n     * value tells it how many zeroes pad out the numbers. To create an animation using this method, you can do:\r\n     *\r\n     * ```javascript\r\n     * this.anims.create({\r\n     *   key: 'ruby',\r\n     *   repeat: -1,\r\n     *   frames: this.anims.generateFrameNames('gems', {\r\n     *     prefix: 'ruby_',\r\n     *     end: 6,\r\n     *     zeroPad: 4\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     * Please see the animation examples for further details.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#generateFrameNames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key for the texture containing the animation frames.\r\n     * @param {Phaser.Types.Animations.GenerateFrameNames} [config] - The configuration object for the animation frame names.\r\n     *\r\n     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.\r\n     */\r\n    generateFrameNames: function (key, config)\r\n    {\r\n        var prefix = GetValue(config, 'prefix', '');\r\n        var start = GetValue(config, 'start', 0);\r\n        var end = GetValue(config, 'end', 0);\r\n        var suffix = GetValue(config, 'suffix', '');\r\n        var zeroPad = GetValue(config, 'zeroPad', 0);\r\n        var out = GetValue(config, 'outputArray', []);\r\n        var frames = GetValue(config, 'frames', false);\r\n\r\n        var texture = this.textureManager.get(key);\r\n\r\n        if (!texture)\r\n        {\r\n            return out;\r\n        }\r\n\r\n        var i;\r\n\r\n        if (!config)\r\n        {\r\n            //  Use every frame in the atlas\r\n            frames = texture.getFrameNames();\r\n\r\n            for (i = 0; i < frames.length; i++)\r\n            {\r\n                out.push({ key: key, frame: frames[i] });\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (!frames)\r\n            {\r\n                frames = NumberArray(start, end);\r\n            }\r\n\r\n            for (i = 0; i < frames.length; i++)\r\n            {\r\n                var frame = prefix + Pad(frames[i], zeroPad, '0', 1) + suffix;\r\n\r\n                if (texture.has(frame))\r\n                {\r\n                    out.push({ key: key, frame: frame });\r\n                }\r\n                else\r\n                {\r\n                    console.warn('generateFrameNames: Frame missing: ' + frame + ' from texture: ' + key);\r\n                }\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Generate an array of {@link Phaser.Types.Animations.AnimationFrame} objects from a texture key and configuration object.\r\n     *\r\n     * Generates objects with numbered frame names, as configured by the given {@link Phaser.Types.Animations.GenerateFrameNumbers}.\r\n     *\r\n     * If you're working with a texture atlas, see the `generateFrameNames` method instead.\r\n     *\r\n     * It's a helper method, designed to make it easier for you to extract frames from sprite sheets.\r\n     * If you're working with a texture atlas, see the `generateFrameNames` method instead.\r\n     *\r\n     * Example:\r\n     *\r\n     * If you have a sprite sheet loaded called `explosion` and it contains 12 frames, then you can call this method using:\r\n     *\r\n     * `this.anims.generateFrameNumbers('explosion', { start: 0, end: 11 })`.\r\n     *\r\n     * The `end` value of 11 tells it to stop after the 12th frame has been added, because it started at zero.\r\n     *\r\n     * To create an animation using this method, you can do:\r\n     *\r\n     * ```javascript\r\n     * this.anims.create({\r\n     *   key: 'boom',\r\n     *   frames: this.anims.generateFrameNames('explosion', {\r\n     *     start: 0,\r\n     *     end: 11\r\n     *   })\r\n     * });\r\n     * ```\r\n     *\r\n     * Note that `start` is optional and you don't need to include it if the animation starts from frame 0.\r\n     *\r\n     * To specify an animation in reverse, swap the `start` and `end` values.\r\n     *\r\n     * If the frames are not sequential, you may pass an array of frame numbers instead, for example:\r\n     *\r\n     * `this.anims.generateFrameNumbers('explosion', { frames: [ 0, 1, 2, 1, 2, 3, 4, 0, 1, 2 ] })`\r\n     *\r\n     * Please see the animation examples and `GenerateFrameNumbers` config docs for further details.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#generateFrameNumbers\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key for the texture containing the animation frames.\r\n     * @param {Phaser.Types.Animations.GenerateFrameNumbers} config - The configuration object for the animation frames.\r\n     *\r\n     * @return {Phaser.Types.Animations.AnimationFrame[]} The array of {@link Phaser.Types.Animations.AnimationFrame} objects.\r\n     */\r\n    generateFrameNumbers: function (key, config)\r\n    {\r\n        var start = GetValue(config, 'start', 0);\r\n        var end = GetValue(config, 'end', -1);\r\n        var first = GetValue(config, 'first', false);\r\n        var out = GetValue(config, 'outputArray', []);\r\n        var frames = GetValue(config, 'frames', false);\r\n\r\n        var texture = this.textureManager.get(key);\r\n\r\n        if (!texture)\r\n        {\r\n            return out;\r\n        }\r\n\r\n        if (first && texture.has(first))\r\n        {\r\n            out.push({ key: key, frame: first });\r\n        }\r\n\r\n        //  No 'frames' array? Then generate one automatically\r\n        if (!frames)\r\n        {\r\n            if (end === -1)\r\n            {\r\n                //  -1 because of __BASE, which we don't want in our results\r\n                //  and -1 because frames are zero based\r\n                end = texture.frameTotal - 2;\r\n            }\r\n\r\n            frames = NumberArray(start, end);\r\n        }\r\n\r\n        for (var i = 0; i < frames.length; i++)\r\n        {\r\n            if (texture.has(frames[i]))\r\n            {\r\n                out.push({ key: key, frame: frames[i] });\r\n            }\r\n            else\r\n            {\r\n                console.warn('generateFrameNumbers: Frame ' + i + ' missing from texture: ' + key);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Get an Animation.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Animation to retrieve.\r\n     *\r\n     * @return {Phaser.Animations.Animation} The Animation.\r\n     */\r\n    get: function (key)\r\n    {\r\n        return this.anims.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pause all animations.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#pauseAll\r\n     * @fires Phaser.Animations.Events#PAUSE_ALL\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    pauseAll: function ()\r\n    {\r\n        if (!this.paused)\r\n        {\r\n            this.paused = true;\r\n\r\n            this.emit(Events.PAUSE_ALL);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Play an animation on the given Game Objects that have an Animation Component.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} children - An array of Game Objects to play the animation on. They must have an Animation Component.\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    play: function (key, children)\r\n    {\r\n        if (!Array.isArray(children))\r\n        {\r\n            children = [ children ];\r\n        }\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            children[i].anims.play(key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes an array of Game Objects that have an Animation Component and then\r\n     * starts the given animation playing on them. The start time of each Game Object\r\n     * is offset, incrementally, by the `stagger` amount.\r\n     *\r\n     * For example, if you pass an array with 4 children and a stagger time of 1000,\r\n     * the delays will be:\r\n     *\r\n     * child 1: 1000ms delay\r\n     * child 2: 2000ms delay\r\n     * child 3: 3000ms delay\r\n     * child 4: 4000ms delay\r\n     *\r\n     * If you set the `staggerFirst` parameter to `false` they would be:\r\n     *\r\n     * child 1: 0ms delay\r\n     * child 2: 1000ms delay\r\n     * child 3: 2000ms delay\r\n     * child 4: 3000ms delay\r\n     *\r\n     * You can also set `stagger` to be a negative value. If it was -1000, the above would be:\r\n     *\r\n     * child 1: 3000ms delay\r\n     * child 2: 2000ms delay\r\n     * child 3: 1000ms delay\r\n     * child 4: 0ms delay\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#staggerPlay\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n     *\r\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} children - An array of Game Objects to play the animation on. They must have an Animation Component.\r\n     * @param {number} stagger - The amount of time, in milliseconds, to offset each play time by. If a negative value is given, it's applied to the children in reverse order.\r\n     * @param {boolean} [staggerFirst=true] -Should the first child be staggered as well?\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    staggerPlay: function (key, children, stagger, staggerFirst)\r\n    {\r\n        if (stagger === undefined) { stagger = 0; }\r\n        if (staggerFirst === undefined) { staggerFirst = true; }\r\n\r\n        if (!Array.isArray(children))\r\n        {\r\n            children = [ children ];\r\n        }\r\n\r\n        var len = children.length;\r\n\r\n        if (!staggerFirst)\r\n        {\r\n            len--;\r\n        }\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var time = (stagger < 0) ? Math.abs(stagger) * (len - i) : stagger * i;\r\n\r\n            children[i].anims.playAfterDelay(key, time);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Animation from this Animation Manager, based on the given key.\r\n     *\r\n     * This is a global action. Once an Animation has been removed, no Game Objects\r\n     * can carry on using it.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#remove\r\n     * @fires Phaser.Animations.Events#REMOVE_ANIMATION\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the animation to remove.\r\n     *\r\n     * @return {Phaser.Animations.Animation} The Animation instance that was removed from the Animation Manager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        var anim = this.get(key);\r\n\r\n        if (anim)\r\n        {\r\n            this.emit(Events.REMOVE_ANIMATION, key, anim);\r\n\r\n            this.anims.delete(key);\r\n\r\n            this.removeMix(key);\r\n        }\r\n\r\n        return anim;\r\n    },\r\n\r\n    /**\r\n     * Resume all paused animations.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#resumeAll\r\n     * @fires Phaser.Animations.Events#RESUME_ALL\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Animation Manager.\r\n     */\r\n    resumeAll: function ()\r\n    {\r\n        if (this.paused)\r\n        {\r\n            this.paused = false;\r\n\r\n            this.emit(Events.RESUME_ALL);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the Animation data as JavaScript object based on the given key.\r\n     * Or, if not key is defined, it will return the data of all animations as array of objects.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [key] - The animation to get the JSONAnimation data from. If not provided, all animations are returned as an array.\r\n     *\r\n     * @return {Phaser.Types.Animations.JSONAnimations} The resulting JSONAnimations formatted object.\r\n     */\r\n    toJSON: function (key)\r\n    {\r\n        var output = {\r\n            anims: [],\r\n            globalTimeScale: this.globalTimeScale\r\n        };\r\n\r\n        if (key !== undefined && key !== '')\r\n        {\r\n            output.anims.push(this.anims.get(key).toJSON());\r\n        }\r\n        else\r\n        {\r\n            this.anims.each(function (animationKey, animation)\r\n            {\r\n                output.anims.push(animation.toJSON());\r\n            });\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Destroy this Animation Manager and clean up animation definitions and references to other objects.\r\n     * This method should not be called directly. It will be called automatically as a response to a `destroy` event from the Phaser.Game instance.\r\n     *\r\n     * @method Phaser.Animations.AnimationManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.anims.clear();\r\n        this.mixes.clear();\r\n\r\n        this.textureManager = null;\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = AnimationManager;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Create an array representing the range of numbers (usually integers), between, and inclusive of,\n * the given `start` and `end` arguments. For example:\n *\n * `var array = Phaser.Utils.Array.NumberArray(2, 4); // array = [2, 3, 4]`\n * `var array = Phaser.Utils.Array.NumberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`\n * `var array = Phaser.Utils.Array.NumberArray(8, 2); // array = [8, 7, 6, 5, 4, 3, 2]`\n *\n * This is equivalent to `Phaser.Utils.Array.NumberArrayStep(start, end, 1)`.\n *\n * You can optionally provide a prefix and / or suffix string. If given the array will contain\n * strings, not integers. For example:\n *\n * `var array = Phaser.Utils.Array.NumberArray(1, 4, 'Level '); // array = [\"Level 1\", \"Level 2\", \"Level 3\", \"Level 4\"]`\n * `var array = Phaser.Utils.Array.NumberArray(5, 7, 'HD-', '.png'); // array = [\"HD-5.png\", \"HD-6.png\", \"HD-7.png\"]`\n *\n * @function Phaser.Utils.Array.NumberArray\n * @since 3.0.0\n *\n * @param {number} start - The minimum value the array starts with.\n * @param {number} end - The maximum value the array contains.\n * @param {string} [prefix] - Optional prefix to place before the number. If provided the array will contain strings, not integers.\n * @param {string} [suffix] - Optional suffix to place after the number. If provided the array will contain strings, not integers.\n *\n * @return {(number[]|string[])} The array of number values, or strings if a prefix or suffix was provided.\n */\nvar NumberArray = function (start, end, prefix, suffix)\n{\n    var result = [];\n\n    var i;\n    var asString = false;\n\n    if (prefix || suffix)\n    {\n        asString = true;\n\n        if (!prefix)\n        {\n            prefix = '';\n        }\n\n        if (!suffix)\n        {\n            suffix = '';\n        }\n    }\n\n    if (end < start)\n    {\n        for (i = start; i >= end; i--)\n        {\n            if (asString)\n            {\n                result.push(prefix + i.toString() + suffix);\n            }\n            else\n            {\n                result.push(i);\n            }\n        }\n    }\n    else\n    {\n        for (i = start; i <= end; i++)\n        {\n            if (asString)\n            {\n                result.push(prefix + i.toString() + suffix);\n            }\n            else\n            {\n                result.push(i);\n            }\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = NumberArray;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes the given string and pads it out, to the length required, using the character\r\n * specified. For example if you need a string to be 6 characters long, you can call:\r\n *\r\n * `pad('bob', 6, '-', 2)`\r\n *\r\n * This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.\r\n *\r\n * You can also use it to pad numbers (they are always returned as strings):\r\n * \r\n * `pad(512, 6, '0', 1)`\r\n *\r\n * Would return: `000512` with the string padded to the left.\r\n *\r\n * If you don't specify a direction it'll pad to both sides:\r\n * \r\n * `pad('c64', 7, '*')`\r\n *\r\n * Would return: `**c64**`\r\n *\r\n * @function Phaser.Utils.String.Pad\r\n * @since 3.0.0\r\n *\r\n * @param {string|number|object} str - The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.\r\n * @param {number} [len=0] - The number of characters to be added.\r\n * @param {string} [pad=\" \"] - The string to pad it out with (defaults to a space).\r\n * @param {number} [dir=3] - The direction dir = 1 (left), 2 (right), 3 (both).\r\n * \r\n * @return {string} The padded string.\r\n */\r\nvar Pad = function (str, len, pad, dir)\r\n{\r\n    if (len === undefined) { len = 0; }\r\n    if (pad === undefined) { pad = ' '; }\r\n    if (dir === undefined) { dir = 3; }\r\n\r\n    str = str.toString();\r\n\r\n    var padlen = 0;\r\n\r\n    if (len + 1 >= str.length)\r\n    {\r\n        switch (dir)\r\n        {\r\n            case 1:\r\n                str = new Array(len + 1 - str.length).join(pad) + str;\r\n                break;\r\n\r\n            case 3:\r\n                var right = Math.ceil((padlen = len - str.length) / 2);\r\n                var left = padlen - right;\r\n                str = new Array(left + 1).join(pad) + str + new Array(right + 1).join(pad);\r\n                break;\r\n\r\n            default:\r\n                str = str + new Array(len + 1 - str.length).join(pad);\r\n                break;\r\n        }\r\n    }\r\n\r\n    return str;\r\n};\r\n\r\nmodule.exports = Pad;\r\n"],"names":["Animation","Class","CustomMap","EventEmitter","Events","GameEvents","GetFastValue","GetValue","Pad","NumberArray","AnimationManager","Extends","initialize","game","call","this","textureManager","globalTimeScale","anims","mixes","paused","name","events","once","BOOT","boot","textures","DESTROY","destroy","addMix","animA","animB","delay","keyA","key","keyB","has","mixObj","get","set","removeMix","hasOwnProperty","delete","getMix","add","animation","console","warn","emit","ADD_ANIMATION","exists","createFromAseprite","tags","output","data","cache","json","_this","meta","frames","forEach","tag","animFrames","from","to","direction","indexOf","tempFrames","minDuration","Number","MAX_SAFE_INTEGER","i","frameKey","toString","frame","frameDuration","push","duration","entry","totalDuration","length","reverse","createConfig","yoyo","result","create","config","anim","fromJSON","clearCurrentAnimations","undefined","clear","JSON","parse","Array","isArray","type","generateFrameNames","prefix","start","end","suffix","zeroPad","out","texture","getFrameNames","generateFrameNumbers","first","frameTotal","pauseAll","PAUSE_ALL","play","children","staggerPlay","stagger","staggerFirst","len","time","Math","abs","playAfterDelay","remove","REMOVE_ANIMATION","resumeAll","RESUME_ALL","toJSON","each","animationKey","module","exports","asString","str","pad","dir","padlen","join","right","ceil"],"sourceRoot":""}