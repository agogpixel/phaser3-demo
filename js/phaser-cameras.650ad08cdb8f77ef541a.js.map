{"version":3,"file":"js/phaser-cameras.650ad08cdb8f77ef541a.js","mappings":";sHAMA,IAAIA,EAAa,EAAQ,OACrBC,EAAW,EAAQ,OACnBC,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBC,EAAa,EAAQ,OACrBC,EAAU,EAAQ,OAClBC,EAAS,EAAQ,OACjBC,EAAS,EAAQ,MACjBC,EAAY,EAAQ,OACpBC,EAAU,EAAQ,OAwClBC,EAAS,IAAIP,EAAM,CAEnBQ,QAASX,EAETY,OAAQ,CACJR,EAAWS,KACXT,EAAWU,KACXV,EAAWW,UAGfC,WAEA,SAAiBC,EAAGC,EAAGC,EAAOC,GAE1BpB,EAAWqB,KAAKC,KAAML,EAAGC,EAAGC,EAAOC,GAEnCE,KAAKC,cAAgB,GACrBD,KAAKE,aAAe,GAUpBF,KAAKG,cAAe,EAUpBH,KAAKI,WAAa,IAAIrB,EAAQsB,KAAKL,MAUnCA,KAAKM,YAAc,IAAIvB,EAAQwB,MAAMP,MAUrCA,KAAKQ,YAAc,IAAIzB,EAAQ0B,MAAMT,MAUrCA,KAAKU,UAAY,IAAI3B,EAAQ4B,IAAIX,MAUjCA,KAAKY,eAAiB,IAAI7B,EAAQ8B,SAASb,MAU3CA,KAAKc,WAAa,IAAI/B,EAAQgC,KAAKf,MAkBnCA,KAAKgB,KAAO,IAAI7B,EAAQ,EAAG,GAW3Ba,KAAKiB,aAAe,IAAI9B,EAyBxBa,KAAKkB,SAAW,KAWhBlB,KAAKmB,QAAU,MA2BnBC,YAAa,SAAUvB,EAAOC,GAE1B,QAAcuB,IAAVxB,EAEAG,KAAKkB,SAAW,SAGpB,CAWI,GAVIlB,KAAKkB,UAELlB,KAAKkB,SAASrB,MAAQA,EACtBG,KAAKkB,SAASpB,OAASA,GAIvBE,KAAKkB,SAAW,IAAIhC,EAAU,EAAG,EAAGW,EAAOC,GAG3CE,KAAKmB,QACT,CACI,IAAIG,EAAUtB,KAAKH,MAAQ,EACvB0B,EAAUvB,KAAKF,OAAS,EAExB0B,EAAKxB,KAAKmB,QAAQxB,EAAIK,KAAKiB,aAAatB,EACxC8B,EAAKzB,KAAKmB,QAAQvB,EAAII,KAAKiB,aAAarB,EAE5CI,KAAK0B,SAASC,IAAIH,EAAIC,GAEtBzB,KAAK4B,QAAUJ,EAAKF,EACpBtB,KAAK6B,QAAUJ,EAAKF,EAGxB5C,EAASqB,KAAKkB,SAAUlB,KAAK0B,SAAS/B,EAAGK,KAAK0B,SAAS9B,GAG3D,OAAOI,MAqBX8B,OAAQ,SAAUC,EAAUC,EAAKC,EAAOC,EAAMC,EAAUC,GAEpD,OAAOpC,KAAKI,WAAWiC,OAAM,EAAON,EAAUC,EAAKC,EAAOC,GAAM,EAAMC,EAAUC,IAsBpFE,QAAS,SAAUP,EAAUC,EAAKC,EAAOC,EAAMC,EAAUC,GAErD,OAAOpC,KAAKI,WAAWiC,OAAM,EAAMN,EAAUC,EAAKC,EAAOC,GAAM,EAAMC,EAAUC,IAsBnFG,SAAU,SAAUR,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,GAE7D,OAAOpC,KAAKI,WAAWiC,OAAM,EAAON,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,IAsBrFK,KAAM,SAAUV,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,GAEzD,OAAOpC,KAAKI,WAAWiC,OAAM,EAAMN,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,IAsBpFM,MAAO,SAAUX,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,GAE1D,OAAOpC,KAAKM,YAAY+B,MAAMN,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,IAoB/EO,MAAO,SAAUZ,EAAUa,EAAWJ,EAAOL,EAAUC,GAEnD,OAAOpC,KAAKQ,YAAY6B,MAAMN,EAAUa,EAAWJ,EAAOL,EAAUC,IAwBxES,IAAK,SAAUlD,EAAGC,EAAGmC,EAAUe,EAAMN,EAAOL,EAAUC,GAElD,OAAOpC,KAAKU,UAAU2B,MAAM1C,EAAGC,EAAGmC,EAAUe,EAAMN,EAAOL,EAAUC,IAsBvEW,SAAU,SAAUC,EAASC,EAAclB,EAAUe,EAAMN,EAAOL,EAAUC,GAExE,OAAOpC,KAAKY,eAAeyB,MAAMW,EAASC,EAAclB,EAAUe,EAAMN,EAAOL,EAAUC,IAsB7Fc,OAAQ,SAAUC,EAAMpB,EAAUe,EAAMN,EAAOL,EAAUC,GAErD,OAAOpC,KAAKc,WAAWuB,MAAMc,EAAMpB,EAAUe,EAAMN,EAAOL,EAAUC,IAUxEgB,UAAW,WAEPpD,KAAKqD,WAAWC,OAAS,EAEzB,IAAIzD,EAAQG,KAAKH,MACbC,EAASE,KAAKF,OAEdyD,EAAoB,GAAR1D,EACZ2D,EAAsB,GAAT1D,EAEbqD,EAAOnD,KAAKmD,KACZM,EAASzD,KAAKyD,OAEdnC,EAAUzB,EAAQG,KAAKsB,QACvBC,EAAUzB,EAASE,KAAKuB,QAExBmC,EAAS1D,KAAKmB,QACdD,EAAWlB,KAAKkB,SAEhByC,EAAK3D,KAAK4B,QACVgC,EAAK5D,KAAK6B,QAEVX,GAEAvC,EAASuC,EAAUlB,KAAK0B,SAAS/B,EAAGK,KAAK0B,SAAS9B,GAGtD,IAAIiE,GAAkB,EAEtB,GAAIH,IAAW1D,KAAKU,UAAUoD,UAC9B,CACI,IAAItC,EAAMkC,EAAO/D,EAAIK,KAAKiB,aAAatB,EACnC8B,EAAMiC,EAAO9D,EAAII,KAAKiB,aAAarB,EAEnCsB,GAEIM,EAAKN,EAASvB,EAEdgE,EAAK1E,EAAO0E,EAAIA,GAAMzC,EAASvB,EAAI6B,GAAKxB,KAAKgB,KAAKrB,GAE7C6B,EAAKN,EAAS6C,QAEnBJ,EAAK1E,EAAO0E,EAAIA,GAAMnC,EAAKN,EAAS6C,OAAQ/D,KAAKgB,KAAKrB,IAGtD8B,EAAKP,EAAStB,EAEdgE,EAAK3E,EAAO2E,EAAIA,GAAM1C,EAAStB,EAAI6B,GAAKzB,KAAKgB,KAAKpB,GAE7C6B,EAAKP,EAAS8C,SAEnBJ,EAAK3E,EAAO2E,EAAIA,GAAMnC,EAAKP,EAAS8C,QAAShE,KAAKgB,KAAKpB,MAK3D+D,EAAK1E,EAAO0E,EAAInC,EAAKF,EAAStB,KAAKgB,KAAKrB,GACxCiE,EAAK3E,EAAO2E,EAAInC,EAAKF,EAASvB,KAAKgB,KAAKpB,IAG5CiE,GAAkB,EAGlB7D,KAAKiE,YAELN,EAAK3D,KAAKkE,OAAOP,GACjBC,EAAK5D,KAAKmE,OAAOP,IAGjB5D,KAAKoE,cAEL9C,EAAU+C,KAAKC,MAAMhD,GACrBC,EAAU8C,KAAKC,MAAM/C,GAErBoC,EAAKU,KAAKC,MAAMX,GAChBC,EAAKS,KAAKC,MAAMV,IAIpB5D,KAAK4B,QAAU+B,EACf3D,KAAK6B,QAAU+B,EAEf,IAAIW,EAAOZ,EAAKJ,EACZiB,EAAOZ,EAAKJ,EAIhBxD,KAAK0B,SAASC,IAAI4C,EAAMC,GAExB,IAAIC,EAAe5E,EAAQsD,EACvBuB,EAAgB5E,EAASqD,EAEzBwB,EAAMJ,EAAQE,EAAe,EAC7BG,EAAMJ,EAAQE,EAAgB,EAE9B1E,KAAKoE,cAELO,EAAMN,KAAKC,MAAMK,GACjBC,EAAMP,KAAKC,MAAMM,IAGrB5E,KAAK6E,UAAUC,MAAMH,EAAKC,EAAKH,EAAcC,GAE7CjB,EAAOsB,UAAU/E,KAAKL,EAAI2B,EAAStB,KAAKJ,EAAI2B,EAASvB,KAAKgF,SAAU7B,EAAMA,GAC1EM,EAAOwB,WAAW3D,GAAUC,GAE5BvB,KAAKQ,YAAY4C,YAEbS,GAEA7D,KAAKkF,KAAKlG,EAAOmG,cAAenF,KAAM0D,IAsB9C0B,QAAS,SAAUzF,EAAGC,GAOlB,YALUyB,IAAN1B,IAAmBA,EAAI,QACjB0B,IAANzB,IAAmBA,EAAID,GAE3BK,KAAKgB,KAAKW,IAAIhC,EAAGC,GAEVI,MAeXqF,gBAAiB,SAAU1F,EAAGC,GAO1B,YALUyB,IAAN1B,IAAmBA,EAAI,QACjB0B,IAANzB,IAAmBA,EAAI,GAE3BI,KAAKiB,aAAaU,IAAIhC,EAAGC,GAElBI,MA6BXsF,YAAa,SAAUC,EAAQnB,EAAaoB,EAAOC,EAAOC,EAASC,QAE3CtE,IAAhB+C,IAA6BA,GAAc,QACjC/C,IAAVmE,IAAuBA,EAAQ,QACrBnE,IAAVoE,IAAuBA,EAAQD,QACnBnE,IAAZqE,IAAyBA,EAAU,QACvBrE,IAAZsE,IAAyBA,EAAUD,GAEvC1F,KAAKmB,QAAUoE,EAEfvF,KAAKoE,YAAcA,EAEnBoB,EAAQ5G,EAAM4G,EAAO,EAAG,GACxBC,EAAQ7G,EAAM6G,EAAO,EAAG,GAExBzF,KAAKgB,KAAKW,IAAI6D,EAAOC,GAErBzF,KAAKiB,aAAaU,IAAI+D,EAASC,GAE/B,IAAIrE,EAAUtB,KAAKH,MAAQ,EACvB0B,EAAUvB,KAAKF,OAAS,EAExB0B,EAAK+D,EAAO5F,EAAI+F,EAChBjE,EAAK8D,EAAO3F,EAAI+F,EAapB,OAXA3F,KAAK0B,SAASC,IAAIH,EAAIC,GAEtBzB,KAAK4B,QAAUJ,EAAKF,EACpBtB,KAAK6B,QAAUJ,EAAKF,EAEhBvB,KAAKiE,YAELjE,KAAK4B,QAAU5B,KAAKkE,OAAOlE,KAAK4B,SAChC5B,KAAK6B,QAAU7B,KAAKmE,OAAOnE,KAAK6B,UAG7B7B,MAWX4F,WAAY,WAIR,OAFA5F,KAAKmB,QAAU,KAERnB,MAYX6F,QAAS,WAQL,OANA7F,KAAKY,eAAekF,QACpB9F,KAAKU,UAAUoF,QACf9F,KAAKQ,YAAYsF,QACjB9F,KAAKM,YAAYwF,QACjB9F,KAAKI,WAAW0F,QAET9F,MAaX+F,OAAQ,SAAUC,EAAMC,GAEhBjG,KAAKkG,UAELlG,KAAKY,eAAemF,OAAOC,EAAMC,GACjCjG,KAAKU,UAAUqF,OAAOC,EAAMC,GAC5BjG,KAAKc,WAAWiF,OAAOC,EAAMC,GAC7BjG,KAAKQ,YAAYuF,OAAOC,EAAMC,GAC9BjG,KAAKM,YAAYyF,OAAOC,EAAMC,GAC9BjG,KAAKI,WAAW2F,OAAOC,EAAMC,KAcrCE,QAAS,WAELnG,KAAK6F,UAELnH,EAAW0H,UAAUD,QAAQpG,KAAKC,MAElCA,KAAKmB,QAAU,KAEfnB,KAAKkB,SAAW,QAKxBmF,EAAOC,QAAUlH,G,eC9xBjB,IAAIA,EAAS,EAAQ,OACjBP,EAAQ,EAAQ,OAChB0H,EAAe,EAAQ,OACvBC,EAAc,EAAQ,OACtBC,EAAoB,EAAQ,OAC5BC,EAAc,EAAQ,OACtBC,EAAc,EAAQ,OAwCtBC,EAAgB,IAAI/H,EAAM,CAE1Ba,WAEA,SAAwBmH,GASpB7G,KAAK6G,MAAQA,EASb7G,KAAK8G,QAAUD,EAAME,IAYrB/G,KAAKoE,YAAcyC,EAAME,IAAIC,KAAKC,OAAO7C,YAYzCpE,KAAKkH,QAAU,GAiBflH,KAAKmH,KAYLnH,KAAKoH,QAELP,EAAME,IAAIM,OAAOC,KAAKX,EAAYY,KAAMvH,KAAKwH,KAAMxH,MACnD6G,EAAME,IAAIM,OAAOI,GAAGd,EAAYe,MAAO1H,KAAKqC,MAAOrC,OAYvDwH,KAAM,WAEF,IAAIT,EAAM/G,KAAK8G,QAEXC,EAAIY,SAAST,QAGblH,KAAK4H,SAASb,EAAIY,SAAST,SAK3BlH,KAAK6H,MAGT7H,KAAKmH,KAAOnH,KAAKkH,QAAQ,GAGzBlH,KAAKoH,QAAU,IAAIhI,EAAO,EAAG,EAAG2H,EAAIe,MAAMjI,MAAOkH,EAAIe,MAAMhI,QAAQiI,SAAS/H,KAAK6G,OAEjFE,EAAIC,KAAKc,MAAML,GAAGf,EAAYsB,OAAQhI,KAAKiI,SAAUjI,MAErDA,KAAK8G,QAAQO,OAAOC,KAAKX,EAAYuB,QAASlI,KAAKmG,QAASnG,OAchEqC,MAAO,WAEH,IAAKrC,KAAKmH,KACV,CACI,IAAIJ,EAAM/G,KAAK8G,QAEXC,EAAIY,SAAST,QAGblH,KAAK4H,SAASb,EAAIY,SAAST,SAK3BlH,KAAK6H,MAGT7H,KAAKmH,KAAOnH,KAAKkH,QAAQ,GAG7B,IAAIiB,EAAenI,KAAK8G,QAAQO,OAEhCc,EAAaV,GAAGd,EAAYyB,OAAQpI,KAAK+F,OAAQ/F,MACjDmI,EAAab,KAAKX,EAAY0B,SAAUrI,KAAKsI,SAAUtI,OAgC3D6H,IAAK,SAAUlI,EAAGC,EAAGC,EAAOC,EAAQyI,EAAUC,QAEhCnH,IAAN1B,IAAmBA,EAAI,QACjB0B,IAANzB,IAAmBA,EAAI,QACbyB,IAAVxB,IAAuBA,EAAQG,KAAK6G,MAAME,IAAIe,MAAMjI,YACzCwB,IAAXvB,IAAwBA,EAASE,KAAK6G,MAAME,IAAIe,MAAMhI,aACzCuB,IAAbkH,IAA0BA,GAAW,QAC5BlH,IAATmH,IAAsBA,EAAO,IAEjC,IAAIC,EAAS,IAAIrJ,EAAOO,EAAGC,EAAGC,EAAOC,GAerC,OAbA2I,EAAOC,QAAQF,GACfC,EAAOV,SAAS/H,KAAK6G,OACrB4B,EAAOE,eAAe3I,KAAKoE,aAE3BqE,EAAOG,GAAK5I,KAAK6I,YAEjB7I,KAAKkH,QAAQ4B,KAAKL,GAEdF,IAEAvI,KAAKmH,KAAOsB,GAGTA,GAwBXM,YAAa,SAAUN,EAAQF,GAM3B,YAJiBlH,IAAbkH,IAA0BA,GAAW,IAI1B,IAFHvI,KAAKkH,QAAQ8B,QAAQP,IAI7BA,EAAOG,GAAK5I,KAAK6I,YAEjBJ,EAAOE,eAAe3I,KAAKoE,aAE3BpE,KAAKkH,QAAQ4B,KAAKL,GAEdF,IAEAvI,KAAKmH,KAAOsB,GAGTA,GAGJ,MAeXI,UAAW,WAQP,IANA,IAAI3B,EAAUlH,KAAKkH,QAEf+B,EAAS,EAIJC,EAAI,EAAGA,EAAI,GAAIA,IACxB,CAGI,IAFA,IAAIC,GAAQ,EAEHC,EAAI,EAAGA,EAAIlC,EAAQ5D,OAAQ8F,IACpC,CACI,IAAIX,EAASvB,EAAQkC,GAEjBX,GAAUA,EAAOG,KAAOK,IAExBE,GAAQ,GAKhB,IAAIA,EAMA,OAAOF,EAJPA,IAAmB,EAQ3B,OAAO,GAeXI,SAAU,SAAUC,QAEEjI,IAAdiI,IAA2BA,GAAY,GAM3C,IAJA,IAAIC,EAAQ,EAERrC,EAAUlH,KAAKkH,QAEVkC,EAAI,EAAGA,EAAIlC,EAAQ5D,OAAQ8F,IACpC,CACI,IAAIX,EAASvB,EAAQkC,KAEhBE,GAAcA,GAAab,EAAOvC,UAEnCqD,IAIR,OAAOA,GAeX3B,SAAU,SAAUX,GAEXuC,MAAMC,QAAQxC,KAEfA,EAAS,CAAEA,IAMf,IAHA,IAAIyC,EAAY1J,KAAK6G,MAAME,IAAIe,MAAMjI,MACjC8J,EAAa3J,KAAK6G,MAAME,IAAIe,MAAMhI,OAE7BsJ,EAAI,EAAGA,EAAInC,EAAO3D,OAAQ8F,IACnC,CACI,IAAIQ,EAAe3C,EAAOmC,GAEtBzJ,EAAI4G,EAAaqD,EAAc,IAAK,GACpChK,EAAI2G,EAAaqD,EAAc,IAAK,GACpC/J,EAAQ0G,EAAaqD,EAAc,QAASF,GAC5C5J,EAASyG,EAAaqD,EAAc,SAAUD,GAE9ClB,EAASzI,KAAK6H,IAAIlI,EAAGC,EAAGC,EAAOC,GAGnC2I,EAAOD,KAAOjC,EAAaqD,EAAc,OAAQ,IACjDnB,EAAOtF,KAAOoD,EAAaqD,EAAc,OAAQ,GACjDnB,EAAOzD,SAAWuB,EAAaqD,EAAc,WAAY,GACzDnB,EAAO7G,QAAU2E,EAAaqD,EAAc,UAAW,GACvDnB,EAAO5G,QAAU0E,EAAaqD,EAAc,UAAW,GACvDnB,EAAOrE,YAAcmC,EAAaqD,EAAc,eAAe,GAC/DnB,EAAOvC,QAAUK,EAAaqD,EAAc,WAAW,GAIvD,IAAIC,EAAkBtD,EAAaqD,EAAc,mBAAmB,GAEhEC,GAEApB,EAAOqB,mBAAmBD,GAK9B,IAAIE,EAAexD,EAAaqD,EAAc,SAAU,MAExD,GAAIG,EACJ,CACI,IAAIC,EAAKzD,EAAawD,EAAc,IAAK,GACrCE,EAAK1D,EAAawD,EAAc,IAAK,GACrCG,EAAS3D,EAAawD,EAAc,QAASL,GAC7CS,EAAU5D,EAAawD,EAAc,SAAUJ,GAEnDlB,EAAO2B,UAAUJ,EAAIC,EAAIC,EAAQC,IAIzC,OAAOnK,MAgBXqK,UAAW,SAAU7B,GAIjB,IAFA,IAAItB,EAAUlH,KAAKkH,QAEVkC,EAAI,EAAGA,EAAIlC,EAAQ5D,OAAQ8F,IAEhC,GAAIlC,EAAQkC,GAAGZ,OAASA,EAEpB,OAAOtB,EAAQkC,GAIvB,OAAO,MAeXkB,uBAAwB,SAAUC,GAS9B,IAPA,IAAIrD,EAAUlH,KAAKkH,QAEfvH,EAAI4K,EAAQ5K,EACZC,EAAI2K,EAAQ3K,EAEZ4K,EAAS,GAEJpB,EAAI,EAAGA,EAAIlC,EAAQ5D,OAAQ8F,IACpC,CACI,IAAIX,EAASvB,EAAQkC,GAEjBX,EAAOvC,SAAWuC,EAAOtI,cAAgBsG,EAAkBgC,EAAQ9I,EAAGC,IAGtE4K,EAAOC,QAAQhC,GAIvB,OAAO+B,GAqBXE,OAAQ,SAAUjC,EAAQkC,QAEHtJ,IAAfsJ,IAA4BA,GAAa,GAExCnB,MAAMC,QAAQhB,KAEfA,EAAS,CAAEA,IAMf,IAHA,IAAIc,EAAQ,EACRrC,EAAUlH,KAAKkH,QAEVkC,EAAI,EAAGA,EAAIX,EAAOnF,OAAQ8F,IACnC,CACI,IAAIwB,EAAQ1D,EAAQ8B,QAAQP,EAAOW,KAEpB,IAAXwB,IAEID,EAEAzD,EAAQ0D,GAAOzE,UAIfe,EAAQ0D,GAAOvH,WAAa,GAGhC6D,EAAQ2D,OAAOD,EAAO,GAEtBrB,KASR,OALKvJ,KAAKmH,MAAQD,EAAQ,KAEtBlH,KAAKmH,KAAOD,EAAQ,IAGjBqC,GAgBXuB,OAAQ,SAAUC,EAAUC,GAKxB,IAHA,IAAInE,EAAQ7G,KAAK6G,MACbK,EAAUlH,KAAKkH,QAEVkC,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IACzC,CACI,IAAIX,EAASvB,EAAQkC,GAErB,GAAIX,EAAOvC,SAAWuC,EAAOwC,MAAQ,EACrC,CACIxC,EAAOrF,YAEP,IAAI8H,EAAkBlL,KAAKmL,mBAAmBH,EAAYI,cAAe3C,GAEzEsC,EAASD,OAAOjE,EAAOqE,EAAiBzC,MAkBpD0C,mBAAoB,SAAUE,EAAU5C,GAIpC,IAFA,IAAIvC,EAAU,GAELkD,EAAI,EAAGA,EAAIiC,EAAS/H,OAAQ8F,IACrC,CACI,IAAIkC,EAAQD,EAASjC,GAEjBkC,EAAMC,WAAW9C,IAEjBvC,EAAQ4C,KAAKwC,GAIrB,OAAOpF,GAcXsF,SAAU,WAEN,IAAK,IAAIpC,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IAErCpJ,KAAKkH,QAAQkC,GAAGjD,UAOpB,OAJAnG,KAAKkH,QAAU,GAEflH,KAAKmH,KAAOnH,KAAK6H,MAEV7H,KAAKmH,MAahBpB,OAAQ,SAAUC,EAAMC,GAEpB,IAAK,IAAImD,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IAErCpJ,KAAKkH,QAAQkC,GAAGrD,OAAOC,EAAMC,IAarCgC,SAAU,SAAUwD,EAAUC,EAAUC,EAAaC,EAAeC,GAEhE,IAAK,IAAIzC,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IACzC,CACI,IAAI0C,EAAM9L,KAAKkH,QAAQkC,GAKR,IAAX0C,EAAIC,IAAuB,IAAXD,EAAIE,IAAYF,EAAIG,SAAWL,GAAiBE,EAAII,UAAYL,GAEhFC,EAAIK,QAAQT,EAAS7L,MAAO6L,EAAS5L,UAcjDsM,OAAQ,SAAUvM,EAAOC,GAErB,IAAK,IAAIsJ,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IAErCpJ,KAAKkH,QAAQkC,GAAG+C,QAAQtM,EAAOC,IAYvCwI,SAAU,WAENtI,KAAKmH,UAAO9F,EAEZ,IAAK,IAAI+H,EAAI,EAAGA,EAAIpJ,KAAKkH,QAAQ5D,OAAQ8F,IAErCpJ,KAAKkH,QAAQkC,GAAGjD,UAGpBnG,KAAKkH,QAAU,GAEf,IAAIiB,EAAenI,KAAK8G,QAAQO,OAEhCc,EAAakE,IAAI1F,EAAYyB,OAAQpI,KAAK+F,OAAQ/F,MAClDmI,EAAakE,IAAI1F,EAAY0B,SAAUrI,KAAKsI,SAAUtI,OAW1DmG,QAAS,WAELnG,KAAKsI,WAELtI,KAAKoH,QAAQjB,UAEbnG,KAAK6G,MAAME,IAAIM,OAAOgF,IAAI1F,EAAYe,MAAO1H,KAAKqC,MAAOrC,MAEzDA,KAAK6G,MAAQ,KACb7G,KAAK8G,QAAU,QAKvBN,EAAY8F,SAAS,gBAAiB1F,EAAe,WAErDP,EAAOC,QAAUM,G,gBCjwBjB,IAAIhI,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBG,EAAS,EAAQ,OAqBjBqB,EAAO,IAAIxB,EAAM,CAEjBa,WAEA,SAAe+I,GAUXzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAcjB9D,KAAKuM,YAAa,EAWlBvM,KAAKwM,WAAY,EAWjBxM,KAAK+B,SAAW,EAWhB/B,KAAKgC,IAAM,EAWXhC,KAAKiC,MAAQ,EAWbjC,KAAKkC,KAAO,EAWZlC,KAAKiL,MAAQ,EASbjL,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAWhB1M,KAAK2M,UAUL3M,KAAK4M,gBAuBTvK,MAAO,SAAUmK,EAAWzK,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,GAWrE,QATkBf,IAAdmL,IAA2BA,GAAY,QAC1BnL,IAAbU,IAA0BA,EAAW,UAC7BV,IAARW,IAAqBA,EAAM,QACjBX,IAAVY,IAAuBA,EAAQ,QACtBZ,IAATa,IAAsBA,EAAO,QACnBb,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,QAE9CrE,GAASxC,KAAK8D,UAEf,OAAO9D,KAAKyI,OAGhBzI,KAAK8D,WAAY,EACjB9D,KAAKuM,YAAa,EAClBvM,KAAK+B,SAAWA,EAChB/B,KAAKwM,UAAYA,EACjBxM,KAAKyM,SAAW,EAEhBzM,KAAKgC,IAAMA,EACXhC,KAAKiC,MAAQA,EACbjC,KAAKkC,KAAOA,EACZlC,KAAKiL,MAAQ,EAAc4B,OAAOC,UAAY,EAE9C9M,KAAK0M,SAAW,EAEhB1M,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAEtB,IAAI2K,EAAY,EAAc/N,EAAOgO,eAAiBhO,EAAOiO,cAI7D,OAFAjN,KAAKyI,OAAOvD,KAAK6H,EAAW/M,KAAKyI,OAAQzI,KAAM+B,EAAUC,EAAKC,EAAOC,GAE9DlC,KAAKyI,QAYhB1C,OAAQ,SAAUC,EAAMC,GAEfjG,KAAK8D,YAKV9D,KAAK0M,UAAYzG,EAEjBjG,KAAKyM,SAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEpD/B,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgB5M,KAAKyI,OAAQzI,KAAKyM,UAG3DzM,KAAK0M,SAAW1M,KAAK+B,SAErB/B,KAAKiL,MAASjL,KAAc,UAAIA,KAAKyM,SAAW,EAAIzM,KAAKyM,UAIzDzM,KAAKiL,MAASjL,KAAc,UAAI,EAAI,EACpCA,KAAKkN,oBAcbC,iBAAkB,SAAUC,GAExB,IAAKpN,KAAK8D,YAAc9D,KAAKuM,WAEzB,OAAO,EAGX,IAAI9D,EAASzI,KAAKyI,OAKlB,OAHA2E,EAAIC,UAAY,QAAUrN,KAAKgC,IAAM,IAAMhC,KAAKiC,MAAQ,IAAMjC,KAAKkC,KAAO,IAAMlC,KAAKiL,MAAQ,IAC7FmC,EAAIE,SAAS7E,EAAO9I,EAAG8I,EAAO7I,EAAG6I,EAAO5I,MAAO4I,EAAO3I,SAE/C,GAcXyN,gBAAiB,SAAUC,EAAUC,GAEjC,IAAKzN,KAAK8D,YAAc9D,KAAKuM,WAEzB,OAAO,EAGX,IAAI9D,EAASzI,KAAKyI,OACdzG,EAAMhC,KAAKgC,IAAM,IACjBC,EAAQjC,KAAKiC,MAAQ,IACrBC,EAAOlC,KAAKkC,KAAO,IAQvB,OANAsL,EAASE,aACLjF,EAAO9I,EAAG8I,EAAO7I,EAAG6I,EAAO5I,MAAO4I,EAAO3I,OACzC2N,EAAgBvL,EAAMD,EAAOD,EAAK,GAClChC,KAAKiL,QAGF,GAWXiC,eAAgB,WAEZlN,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EACjB9D,KAAKuM,YAAa,EAElB,IAAIQ,EAAa/M,KAAc,UAAIhB,EAAO2O,kBAAoB3O,EAAO4O,iBAErE5N,KAAKyI,OAAOvD,KAAK6H,EAAW/M,KAAKyI,OAAQzI,OAU7C8F,MAAO,WAEH9F,KAAK8D,WAAY,EACjB9D,KAAKuM,YAAa,EAElBvM,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,QAKtBpC,EAAOC,QAAUjG,G,gBCvXjB,IAAIzB,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBG,EAAS,EAAQ,OAqBjBuB,EAAQ,IAAI1B,EAAM,CAElBa,WAEA,SAAgB+I,GAUZzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAWjB9D,KAAK+B,SAAW,EAWhB/B,KAAKgC,IAAM,EAWXhC,KAAKiC,MAAQ,EAWbjC,KAAKkC,KAAO,EAWZlC,KAAKiL,MAAQ,EASbjL,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAWhB1M,KAAK2M,UAUL3M,KAAK4M,gBAsBTvK,MAAO,SAAUN,EAAUC,EAAKC,EAAOC,EAAMM,EAAOL,EAAUC,GAU1D,YARiBf,IAAbU,IAA0BA,EAAW,UAC7BV,IAARW,IAAqBA,EAAM,UACjBX,IAAVY,IAAuBA,EAAQ,UACtBZ,IAATa,IAAsBA,EAAO,UACnBb,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,QAE9CrE,GAASxC,KAAK8D,YAKnB9D,KAAK8D,WAAY,EACjB9D,KAAK+B,SAAWA,EAChB/B,KAAKyM,SAAW,EAEhBzM,KAAKgC,IAAMA,EACXhC,KAAKiC,MAAQA,EACbjC,KAAKkC,KAAOA,EACZlC,KAAKiL,MAAQ,EAEbjL,KAAK0M,SAAW,EAEhB1M,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAEtBpC,KAAKyI,OAAOvD,KAAKlG,EAAO6O,YAAa7N,KAAKyI,OAAQzI,KAAM+B,EAAUC,EAAKC,EAAOC,IAjBnElC,KAAKyI,QA+BpB1C,OAAQ,SAAUC,EAAMC,GAEfjG,KAAK8D,YAKV9D,KAAK0M,UAAYzG,EAEjBjG,KAAKyM,SAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEpD/B,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgB5M,KAAKyI,OAAQzI,KAAKyM,UAG3DzM,KAAK0M,SAAW1M,KAAK+B,SAErB/B,KAAKiL,MAAQ,EAAIjL,KAAKyM,SAItBzM,KAAKkN,mBAcbC,iBAAkB,SAAUC,GAExB,IAAKpN,KAAK8D,UAEN,OAAO,EAGX,IAAI2E,EAASzI,KAAKyI,OAKlB,OAHA2E,EAAIC,UAAY,QAAUrN,KAAKgC,IAAM,IAAMhC,KAAKiC,MAAQ,IAAMjC,KAAKkC,KAAO,IAAMlC,KAAKiL,MAAQ,IAC7FmC,EAAIE,SAAS7E,EAAO9I,EAAG8I,EAAO7I,EAAG6I,EAAO5I,MAAO4I,EAAO3I,SAE/C,GAcXyN,gBAAiB,SAAUC,EAAUC,GAEjC,IAAKzN,KAAK8D,UAEN,OAAO,EAGX,IAAI2E,EAASzI,KAAKyI,OACdzG,EAAMhC,KAAKgC,IAAM,IACjBC,EAAQjC,KAAKiC,MAAQ,IACrBC,EAAOlC,KAAKkC,KAAO,IAQvB,OANAsL,EAASE,aACLjF,EAAO9I,EAAG8I,EAAO7I,EAAG6I,EAAO5I,MAAO4I,EAAO3I,OACzC2N,EAAgBvL,EAAMD,EAAOD,EAAK,GAClChC,KAAKiL,QAGF,GAUXiC,eAAgB,WAEZlN,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EAEjB9D,KAAKyI,OAAOvD,KAAKlG,EAAO8O,eAAgB9N,KAAKyI,OAAQzI,OAUzD8F,MAAO,WAEH9F,KAAK8D,WAAY,EAEjB9D,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,QAKtBpC,EAAOC,QAAU/F,G,gBClVjB,IAAI3B,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBkP,EAAU,EAAQ,OAClB/O,EAAS,EAAQ,OACjBG,EAAU,EAAQ,OAsBlBwB,EAAM,IAAI9B,EAAM,CAEhBa,WAEA,SAAc+I,GAUVzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAWjB9D,KAAK+B,SAAW,EAShB/B,KAAKgO,OAAS,IAAI7O,EASlBa,KAAKiO,QAAU,IAAI9O,EASnBa,KAAKkO,YAAc,IAAI/O,EASvBa,KAAK8C,KASL9C,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAWhB1M,KAAK2M,UAUL3M,KAAK4M,gBAwBTvK,MAAO,SAAU1C,EAAGC,EAAGmC,EAAUe,EAAMN,EAAOL,EAAUC,QAEnCf,IAAbU,IAA0BA,EAAW,UAC5BV,IAATyB,IAAsBA,EAAOiL,EAAQ9O,aAC3BoC,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,OAEnD,IAAIiF,EAAM9L,KAAKyI,OAEf,OAAKjG,GAASxC,KAAK8D,YAKnB9D,KAAK8D,WAAY,EACjB9D,KAAK+B,SAAWA,EAChB/B,KAAKyM,SAAW,EAGhBzM,KAAKgO,OAAOrM,IAAImK,EAAIlK,QAASkK,EAAIjK,SAGjC7B,KAAKkO,YAAYvM,IAAIhC,EAAGC,GAGxBkM,EAAIqC,UAAUxO,EAAGC,EAAGI,KAAKiO,SAGL,iBAATnL,GAAqBiL,EAAQK,eAAetL,GAEnD9C,KAAK8C,KAAOiL,EAAQjL,GAEC,mBAATA,IAEZ9C,KAAK8C,KAAOA,GAGhB9C,KAAK0M,SAAW,EAEhB1M,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAEtBpC,KAAKyI,OAAOvD,KAAKlG,EAAOqP,UAAWrO,KAAKyI,OAAQzI,KAAM+B,EAAUpC,EAAGC,IA/BxDkM,GA6Cf/F,OAAQ,SAAUC,EAAMC,GAEpB,GAAKjG,KAAK8D,UAAV,CAKA9D,KAAK0M,UAAYzG,EAEjB,IAAIwG,EAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEvD/B,KAAKyM,SAAWA,EAEhB,IAAIX,EAAM9L,KAAKyI,OAEf,GAAIzI,KAAK0M,SAAW1M,KAAK+B,SACzB,CACI,IAAIuM,EAAItO,KAAK8C,KAAK2J,GAElBX,EAAIqC,UAAUnO,KAAKkO,YAAYvO,EAAGK,KAAKkO,YAAYtO,EAAGI,KAAKiO,SAE3D,IAAItO,EAAIK,KAAKgO,OAAOrO,GAAMK,KAAKiO,QAAQtO,EAAIK,KAAKgO,OAAOrO,GAAK2O,EACxD1O,EAAII,KAAKgO,OAAOpO,GAAMI,KAAKiO,QAAQrO,EAAII,KAAKgO,OAAOpO,GAAK0O,EAE5DxC,EAAIyC,UAAU5O,EAAGC,GAEbI,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgBd,EAAKW,EAAU9M,EAAGC,QAK/DkM,EAAI0C,SAASxO,KAAKkO,YAAYvO,EAAGK,KAAKkO,YAAYtO,GAE9CI,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgBd,EAAKW,EAAUX,EAAIlK,QAASkK,EAAIjK,SAG7E7B,KAAKkN,mBAWbA,eAAgB,WAEZlN,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EAEjB9D,KAAKyI,OAAOvD,KAAKlG,EAAOyP,aAAczO,KAAKyI,OAAQzI,OAUvD8F,MAAO,WAEH9F,KAAK8D,WAAY,EAEjB9D,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,KACdzI,KAAKgO,OAAS,KACdhO,KAAKkO,YAAc,QAK3B7H,EAAOC,QAAU3F,G,eCxTjB,IAAI/B,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBG,EAAS,EAAQ,OACjB+O,EAAU,EAAQ,OA4BlBlN,EAAW,IAAIhC,EAAM,CAErBa,WAEA,SAAmB+I,GAUfzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAWjB9D,KAAK+B,SAAW,EAShB/B,KAAKgO,OAAS,EASdhO,KAAKiO,QAAU,EASfjO,KAAKkO,YAAc,EASnBlO,KAAK8C,KASL9C,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAmBhB1M,KAAK2M,UAUL3M,KAAK4M,eASL5M,KAAK0O,WAAY,EASjB1O,KAAKiD,cAAe,GAwBxBZ,MAAO,SAAUW,EAASC,EAAclB,EAAUe,EAAMN,EAAOL,EAAUC,QAEpDf,IAAbU,IAA0BA,EAAW,UAC5BV,IAATyB,IAAsBA,EAAOiL,EAAQ9O,aAC3BoC,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,YAC9BxF,IAAjB4B,IAA8BA,GAAe,GAEjDjD,KAAKiD,aAAeA,EAEpB,IAAI0L,EAAiB3L,EAEjBA,EAAU,GAEV2L,GAAkB,EAAI3L,EACtBhD,KAAK0O,WAAY,GAIjB1O,KAAK0O,WAAY,EAGrB,IAAIE,EAAU,IAAMvK,KAAKwK,GAAM,IAE/BF,GAAmCtK,KAAKyK,MAAMH,EAAiBC,GAAUA,EAEzE,IAAI9C,EAAM9L,KAAKyI,OAEf,IAAKjG,GAASxC,KAAK8D,UAEf,OAAOgI,EA6BX,GA1BA9L,KAAK8D,WAAY,EACjB9D,KAAK+B,SAAWA,EAChB/B,KAAKyM,SAAW,EAGhBzM,KAAKgO,OAASlC,EAAI9G,SAGlBhF,KAAKkO,YAAcS,EAGC,iBAAT7L,GAAqBiL,EAAQK,eAAetL,GAEnD9C,KAAK8C,KAAOiL,EAAQjL,GAEC,mBAATA,IAEZ9C,KAAK8C,KAAOA,GAGhB9C,KAAK0M,SAAW,EAEhB1M,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAGlBpC,KAAKiD,aACT,CAEI,IAAI8L,EACAC,GAIAD,EAFA/O,KAAKkO,YAAclO,KAAKgO,OAEf3J,KAAK4K,IAAIjP,KAAKkO,YAAclO,KAAKgO,QAIhC3J,KAAK4K,IAAIjP,KAAKkO,YAAcU,GAAU5O,KAAKgO,SAKrDgB,EAFAhP,KAAKgO,OAAShO,KAAKkO,YAET7J,KAAK4K,IAAIjP,KAAKgO,OAAShO,KAAKkO,aAI3B7J,KAAK4K,IAAIjP,KAAKgO,OAASY,GAAU5O,KAAKkO,aAKjDlO,KAAK0O,WAAY,EAEZK,EAASC,IAEdhP,KAAK0O,WAAY,GAMzB,OAFA1O,KAAKyI,OAAOvD,KAAKlG,EAAOkQ,aAAclP,KAAKyI,OAAQzI,KAAM+B,EAAU4M,GAE5D7C,GAYX/F,OAAQ,SAAUC,EAAMC,GAEpB,GAAKjG,KAAK8D,UAAV,CAKA9D,KAAK0M,UAAYzG,EAEjB,IAAIwG,EAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEvD/B,KAAKyM,SAAWA,EAEhB,IAAIX,EAAM9L,KAAKyI,OAEf,GAAIzI,KAAK0M,SAAW1M,KAAK+B,SACzB,CACI,IAAIuM,EAAItO,KAAK8C,KAAK2J,GAElBzM,KAAKiO,QAAUnC,EAAI9G,SACnB,IAAImK,EACAP,EAAU,IAAMvK,KAAKwK,GAAM,IAC3BtJ,EAASvF,KAAKkO,YACdD,EAAUjO,KAAKiO,SAEI,IAAnBjO,KAAK0O,YAELnJ,EAASvF,KAAKiO,QACdA,EAAUjO,KAAKkO,aAKfiB,EAFA5J,GAAU0I,EAEC5J,KAAK4K,IAAI1J,EAAS0I,GAIjB5J,KAAK4K,IAAI1J,EAASqJ,GAAUX,EAG5C,IAAImB,EAIAA,EAFApP,KAAK0O,UAEA5C,EAAI9G,SAAYmK,EAAWb,EAI3BxC,EAAI9G,SAAYmK,EAAWb,EAGpCxC,EAAI9G,SAAWoK,EAEXpP,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgBd,EAAKW,EAAU2C,QAK5DtD,EAAI9G,SAAWhF,KAAKkO,YAEhBlO,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgBd,EAAKW,EAAUzM,KAAKkO,aAGjElO,KAAKkN,mBAUbA,eAAgB,WAEZlN,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EAEjB9D,KAAKyI,OAAOvD,KAAKlG,EAAOqQ,gBAAiBrP,KAAKyI,OAAQzI,OAU1D8F,MAAO,WAEH9F,KAAK8D,WAAY,EAEjB9D,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,KACdzI,KAAKgO,OAAS,KACdhO,KAAKkO,YAAc,QAK3B7H,EAAOC,QAAUzF,G,gBCpajB,IAAIjC,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBG,EAAS,EAAQ,OACjBG,EAAU,EAAQ,OAqBlBsB,EAAQ,IAAI5B,EAAM,CAElBa,WAEA,SAAgB+I,GAUZzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAWjB9D,KAAK+B,SAAW,EAWhB/B,KAAK4C,UAAY,IAAIzD,EASrBa,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAWhB1M,KAAKsP,SAAW,EAWhBtP,KAAKuP,SAAW,EAWhBvP,KAAK2M,UAUL3M,KAAK4M,gBAoBTvK,MAAO,SAAUN,EAAUa,EAAWJ,EAAOL,EAAUC,GAQnD,YANiBf,IAAbU,IAA0BA,EAAW,UACvBV,IAAduB,IAA2BA,EAAY,UAC7BvB,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,QAE9CrE,GAASxC,KAAK8D,YAKnB9D,KAAK8D,WAAY,EACjB9D,KAAK+B,SAAWA,EAChB/B,KAAKyM,SAAW,EAES,iBAAd7J,EAEP5C,KAAK4C,UAAUjB,IAAIiB,GAInB5C,KAAK4C,UAAUjB,IAAIiB,EAAUjD,EAAGiD,EAAUhD,GAG9CI,KAAK0M,SAAW,EAChB1M,KAAKsP,SAAW,EAChBtP,KAAKuP,SAAW,EAEhBvP,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAEtBpC,KAAKyI,OAAOvD,KAAKlG,EAAOwQ,YAAaxP,KAAKyI,OAAQzI,KAAM+B,EAAUa,IAvBvD5C,KAAKyI,QAkCpBrF,UAAW,WAEHpD,KAAK8D,WAEL9D,KAAKyI,OAAOhF,OAAOwB,UAAUjF,KAAKsP,SAAUtP,KAAKuP,WAazDxJ,OAAQ,SAAUC,EAAMC,GAEpB,GAAKjG,KAAK8D,UAcV,GATA9D,KAAK0M,UAAYzG,EAEjBjG,KAAKyM,SAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEpD/B,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgB5M,KAAKyI,OAAQzI,KAAKyM,UAG3DzM,KAAK0M,SAAW1M,KAAK+B,SACzB,CACI,IAAIa,EAAY5C,KAAK4C,UACjB/C,EAAQG,KAAKyI,OAAO5I,MACpBC,EAASE,KAAKyI,OAAO3I,OACrBqD,EAAOnD,KAAKyI,OAAOtF,KAEvBnD,KAAKsP,UAAYjL,KAAKoL,SAAW7M,EAAUjD,EAAIE,EAAQ,EAAI+C,EAAUjD,EAAIE,GAASsD,EAClFnD,KAAKuP,UAAYlL,KAAKoL,SAAW7M,EAAUhD,EAAIE,EAAS,EAAI8C,EAAUhD,EAAIE,GAAUqD,EAEhFnD,KAAKyI,OAAOrE,cAEZpE,KAAKsP,SAAWjL,KAAKC,MAAMtE,KAAKsP,UAChCtP,KAAKuP,SAAWlL,KAAKC,MAAMtE,KAAKuP,gBAKpCvP,KAAKkN,kBAWbA,eAAgB,WAEZlN,KAAKsP,SAAW,EAChBtP,KAAKuP,SAAW,EAEhBvP,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EAEjB9D,KAAKyI,OAAOvD,KAAKlG,EAAO0Q,eAAgB1P,KAAKyI,OAAQzI,OAUzD8F,MAAO,WAEH9F,KAAK8D,WAAY,EAEjB9D,KAAKsP,SAAW,EAChBtP,KAAKuP,SAAW,EAEhBvP,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,KACdzI,KAAK4C,UAAY,QAKzByD,EAAOC,QAAU7F,G,gBClTjB,IAAI7B,EAAQ,EAAQ,MAChBC,EAAQ,EAAQ,OAChBkP,EAAU,EAAQ,OAClB/O,EAAS,EAAQ,OAkBjB+B,EAAO,IAAIlC,EAAM,CAEjBa,WAEA,SAAe+I,GAUXzI,KAAKyI,OAASA,EAWdzI,KAAK8D,WAAY,EAWjB9D,KAAK+B,SAAW,EAShB/B,KAAKgO,OAAS,EASdhO,KAAKkO,YAAc,EASnBlO,KAAK8C,KASL9C,KAAKyM,SAAW,EAUhBzM,KAAK0M,SAAW,EAWhB1M,KAAK2M,UAUL3M,KAAK4M,gBAsBTvK,MAAO,SAAUc,EAAMpB,EAAUe,EAAMN,EAAOL,EAAUC,QAEnCf,IAAbU,IAA0BA,EAAW,UAC5BV,IAATyB,IAAsBA,EAAOiL,EAAQ9O,aAC3BoC,IAAVmB,IAAuBA,GAAQ,QAClBnB,IAAbc,IAA0BA,EAAW,WACzBd,IAAZe,IAAyBA,EAAUpC,KAAKyI,OAAO5B,OAEnD,IAAIiF,EAAM9L,KAAKyI,OAEf,OAAKjG,GAASxC,KAAK8D,YAKnB9D,KAAK8D,WAAY,EACjB9D,KAAK+B,SAAWA,EAChB/B,KAAKyM,SAAW,EAGhBzM,KAAKgO,OAASlC,EAAI3I,KAGlBnD,KAAKkO,YAAc/K,EAGC,iBAATL,GAAqBiL,EAAQK,eAAetL,GAEnD9C,KAAK8C,KAAOiL,EAAQjL,GAEC,mBAATA,IAEZ9C,KAAK8C,KAAOA,GAGhB9C,KAAK0M,SAAW,EAEhB1M,KAAK2M,UAAYxK,EACjBnC,KAAK4M,eAAiBxK,EAEtBpC,KAAKyI,OAAOvD,KAAKlG,EAAO2Q,WAAY3P,KAAKyI,OAAQzI,KAAM+B,EAAUoB,IA5BtD2I,GA0Cf/F,OAAQ,SAAUC,EAAMC,GAEfjG,KAAK8D,YAKV9D,KAAK0M,UAAYzG,EAEjBjG,KAAKyM,SAAW7N,EAAMoB,KAAK0M,SAAW1M,KAAK+B,SAAU,EAAG,GAEpD/B,KAAK0M,SAAW1M,KAAK+B,UAErB/B,KAAKyI,OAAOtF,KAAOnD,KAAKgO,QAAWhO,KAAKkO,YAAclO,KAAKgO,QAAUhO,KAAK8C,KAAK9C,KAAKyM,UAEhFzM,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgB5M,KAAKyI,OAAQzI,KAAKyM,SAAUzM,KAAKyI,OAAOtF,QAKrFnD,KAAKyI,OAAOtF,KAAOnD,KAAKkO,YAEpBlO,KAAK2M,WAEL3M,KAAK2M,UAAU5M,KAAKC,KAAK4M,eAAgB5M,KAAKyI,OAAQzI,KAAKyM,SAAUzM,KAAKkO,aAG9ElO,KAAKkN,oBAWbA,eAAgB,WAEZlN,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,KAEtB5M,KAAK8D,WAAY,EAEjB9D,KAAKyI,OAAOvD,KAAKlG,EAAO4Q,cAAe5P,KAAKyI,OAAQzI,OAUxD8F,MAAO,WAEH9F,KAAK8D,WAAY,EAEjB9D,KAAK2M,UAAY,KACjB3M,KAAK4M,eAAiB,MAS1BzG,QAAS,WAELnG,KAAK8F,QAEL9F,KAAKyI,OAAS,QAKtBpC,EAAOC,QAAUvF,G,gBCpRjBsF,EAAOC,QAAU,CAEbjG,KAAM,EAAQ,OACdE,MAAO,EAAQ,OACfI,IAAK,EAAQ,OACbF,MAAO,EAAQ,OACfI,SAAU,EAAQ,MAClBE,KAAM,EAAQ,S,UCDlBsF,EAAOC,QAAU,iB,UCGjBD,EAAOC,QAAU,wB,UCIjBD,EAAOC,QAAU,qB,UCJjBD,EAAOC,QAAU,yB,UCIjBD,EAAOC,QAAU,sB,UCNjBD,EAAOC,QAAU,uB,UCIjBD,EAAOC,QAAU,oB,UCAjBD,EAAOC,QAAU,gB,UCJjBD,EAAOC,QAAU,qB,UCGjBD,EAAOC,QAAU,kB,UCDjBD,EAAOC,QAAU,c,UCAjBD,EAAOC,QAAU,a,UCFjBD,EAAOC,QAAU,wB,UCEjBD,EAAOC,QAAU,qB,UCFjBD,EAAOC,QAAU,uB,UCEjBD,EAAOC,QAAU,oB,UCFjBD,EAAOC,QAAU,sB,UCEjBD,EAAOC,QAAU,mB,gBCTjBD,EAAOC,QAAU,CAEb4B,QAAS,EAAQ,OACjB0F,iBAAkB,EAAQ,OAC1BX,cAAe,EAAQ,OACvBU,kBAAmB,EAAQ,OAC3BX,eAAgB,EAAQ,OACxBc,eAAgB,EAAQ,OACxBD,YAAa,EAAQ,OACrB1I,cAAe,EAAQ,OACvBsJ,aAAc,EAAQ,OACtBJ,UAAW,EAAQ,OACnBwB,YAAa,EAAQ,OACrBC,WAAY,EAAQ,OACpBT,gBAAiB,EAAQ,OACzBH,aAAc,EAAQ,OACtBQ,eAAgB,EAAQ,OACxBF,YAAa,EAAQ,OACrBI,cAAe,EAAQ,OACvBD,WAAY,EAAQ,S,gBCnBxBtJ,EAAOC,QAAU,CAEblH,OAAQ,EAAQ,OAChBV,WAAY,EAAQ,OACpBkI,cAAe,EAAQ,MACvB7H,QAAS,EAAQ,OACjBC,OAAQ,EAAQ,S,gBCVpB,IAAIH,EAAQ,EAAQ,OAChBkR,EAAW,EAAQ,OA4BnBC,EAAkB,IAAInR,EAAM,CAE5Ba,WAEA,SAA0BuH,GAUtBjH,KAAKyI,OAASsH,EAAS9I,EAAQ,SAAU,MAUzCjH,KAAKiQ,KAAOF,EAAS9I,EAAQ,OAAQ,MAUrCjH,KAAK+D,MAAQgM,EAAS9I,EAAQ,QAAS,MAUvCjH,KAAKkQ,GAAKH,EAAS9I,EAAQ,KAAM,MAUjCjH,KAAKmQ,KAAOJ,EAAS9I,EAAQ,OAAQ,MAUrCjH,KAAKoQ,OAASL,EAAS9I,EAAQ,SAAU,MAUzCjH,KAAKqQ,QAAUN,EAAS9I,EAAQ,UAAW,MAU3CjH,KAAKsQ,UAAYP,EAAS9I,EAAQ,YAAa,KAU/CjH,KAAKuQ,QAAUR,EAAS9I,EAAQ,UAAW,MAU3CjH,KAAKwQ,QAAUT,EAAS9I,EAAQ,UAAW,KAU3CjH,KAAKyQ,OAAS,EAUdzQ,KAAK0Q,OAAS,EAEd,IAAIC,EAAQZ,EAAS9I,EAAQ,QAAS,MAEjB,iBAAV0J,GAEP3Q,KAAKyQ,OAASE,EACd3Q,KAAK0Q,OAASC,IAId3Q,KAAKyQ,OAASV,EAAS9I,EAAQ,UAAW,GAC1CjH,KAAK0Q,OAASX,EAAS9I,EAAQ,UAAW,IAY9CjH,KAAK4Q,MAAQ,EASb5Q,KAAK6Q,OAA0B,OAAhB7Q,KAAKyI,QAWxBpG,MAAO,WAIH,OAFArC,KAAK6Q,OAA0B,OAAhB7Q,KAAKyI,OAEbzI,MAWX8Q,KAAM,WAIF,OAFA9Q,KAAK6Q,QAAS,EAEP7Q,MAaX+Q,UAAW,SAAUtI,GAIjB,OAFAzI,KAAKyI,OAASA,EAEPzI,MAaX+F,OAAQ,SAAUE,GAEd,GAAKjG,KAAK6Q,OAAV,MAKcxP,IAAV4E,IAAuBA,EAAQ,GAEnC,IAAI6F,EAAM9L,KAAKyI,OAEXzI,KAAKkQ,IAAMlQ,KAAKkQ,GAAGc,OAEnBlF,EAAIjK,SAAa7B,KAAK0Q,OAASzK,EAAS,EAEnCjG,KAAKmQ,MAAQnQ,KAAKmQ,KAAKa,SAE5BlF,EAAIjK,SAAa7B,KAAK0Q,OAASzK,EAAS,GAGxCjG,KAAKiQ,MAAQjQ,KAAKiQ,KAAKe,OAEvBlF,EAAIlK,SAAa5B,KAAKyQ,OAASxK,EAAS,EAEnCjG,KAAK+D,OAAS/D,KAAK+D,MAAMiN,SAE9BlF,EAAIlK,SAAa5B,KAAKyQ,OAASxK,EAAS,GAKxCjG,KAAKoQ,QAAUpQ,KAAKoQ,OAAOY,QAE3BlF,EAAI3I,MAAQnD,KAAKsQ,UAEbxE,EAAI3I,KAAOnD,KAAKuQ,UAEhBzE,EAAI3I,KAAOnD,KAAKuQ,UAGfvQ,KAAKqQ,SAAWrQ,KAAKqQ,QAAQW,SAElClF,EAAI3I,MAAQnD,KAAKsQ,UAEbxE,EAAI3I,KAAOnD,KAAKwQ,UAEhB1E,EAAI3I,KAAOnD,KAAKwQ,YAW5BrK,QAAS,WAELnG,KAAKyI,OAAS,KAEdzI,KAAKiQ,KAAO,KACZjQ,KAAK+D,MAAQ,KACb/D,KAAKkQ,GAAK,KACVlQ,KAAKmQ,KAAO,KAEZnQ,KAAKoQ,OAAS,KACdpQ,KAAKqQ,QAAU,QAKvBhK,EAAOC,QAAU0J,G,gBC9TjB,IAAInR,EAAQ,EAAQ,OAChBkR,EAAW,EAAQ,OAkCnBkB,EAAqB,IAAIpS,EAAM,CAE/Ba,WAEA,SAA6BuH,GAUzBjH,KAAKyI,OAASsH,EAAS9I,EAAQ,SAAU,MAUzCjH,KAAKiQ,KAAOF,EAAS9I,EAAQ,OAAQ,MAUrCjH,KAAK+D,MAAQgM,EAAS9I,EAAQ,QAAS,MAUvCjH,KAAKkQ,GAAKH,EAAS9I,EAAQ,KAAM,MAUjCjH,KAAKmQ,KAAOJ,EAAS9I,EAAQ,OAAQ,MAUrCjH,KAAKoQ,OAASL,EAAS9I,EAAQ,SAAU,MAUzCjH,KAAKqQ,QAAUN,EAAS9I,EAAQ,UAAW,MAU3CjH,KAAKsQ,UAAYP,EAAS9I,EAAQ,YAAa,KAU/CjH,KAAKuQ,QAAUR,EAAS9I,EAAQ,UAAW,MAU3CjH,KAAKwQ,QAAUT,EAAS9I,EAAQ,UAAW,KAU3CjH,KAAKkR,OAAS,EAUdlR,KAAKmR,OAAS,EAEd,IAAIC,EAAQrB,EAAS9I,EAAQ,eAAgB,MAExB,iBAAVmK,GAEPpR,KAAKkR,OAASE,EACdpR,KAAKmR,OAASC,IAIdpR,KAAKkR,OAASnB,EAAS9I,EAAQ,iBAAkB,GACjDjH,KAAKmR,OAASpB,EAAS9I,EAAQ,iBAAkB,IAWrDjH,KAAKqR,MAAQ,EAUbrR,KAAKsR,MAAQ,EAEb,IAAIC,EAAOxB,EAAS9I,EAAQ,OAAQ,MAEhB,iBAATsK,GAEPvR,KAAKqR,MAAQE,EACbvR,KAAKsR,MAAQC,IAIbvR,KAAKqR,MAAQtB,EAAS9I,EAAQ,SAAU,GACxCjH,KAAKsR,MAAQvB,EAAS9I,EAAQ,SAAU,IAW5CjH,KAAKwR,UAAY,EAUjBxR,KAAKyR,UAAY,EAEjB,IAAIC,EAAW3B,EAAS9I,EAAQ,WAAY,MAEpB,iBAAbyK,GAEP1R,KAAKwR,UAAYE,EACjB1R,KAAKyR,UAAYC,IAIjB1R,KAAKwR,UAAYzB,EAAS9I,EAAQ,aAAc,GAChDjH,KAAKyR,UAAY1B,EAAS9I,EAAQ,aAAc,IAYpDjH,KAAK2R,QAAU,EAWf3R,KAAK4R,QAAU,EAWf5R,KAAK4Q,MAAQ,EASb5Q,KAAK6Q,OAA0B,OAAhB7Q,KAAKyI,QAWxBpG,MAAO,WAIH,OAFArC,KAAK6Q,OAA0B,OAAhB7Q,KAAKyI,OAEbzI,MAWX8Q,KAAM,WAIF,OAFA9Q,KAAK6Q,QAAS,EAEP7Q,MAaX+Q,UAAW,SAAUtI,GAIjB,OAFAzI,KAAKyI,OAASA,EAEPzI,MAaX+F,OAAQ,SAAUE,GAEd,GAAKjG,KAAK6Q,OAAV,MAKcxP,IAAV4E,IAAuBA,EAAQ,GAEnC,IAAI6F,EAAM9L,KAAKyI,OAIXzI,KAAK2R,QAAU,GAEf3R,KAAK2R,SAAW3R,KAAKqR,MAAQpL,EAEzBjG,KAAK2R,QAAU,IAEf3R,KAAK2R,QAAU,IAGd3R,KAAK2R,QAAU,IAEpB3R,KAAK2R,SAAW3R,KAAKqR,MAAQpL,EAEzBjG,KAAK2R,QAAU,IAEf3R,KAAK2R,QAAU,IAInB3R,KAAK4R,QAAU,GAEf5R,KAAK4R,SAAW5R,KAAKsR,MAAQrL,EAEzBjG,KAAK4R,QAAU,IAEf5R,KAAK4R,QAAU,IAGd5R,KAAK4R,QAAU,IAEpB5R,KAAK4R,SAAW5R,KAAKsR,MAAQrL,EAEzBjG,KAAK4R,QAAU,IAEf5R,KAAK4R,QAAU,IAMnB5R,KAAKkQ,IAAMlQ,KAAKkQ,GAAGc,QAEnBhR,KAAK4R,SAAW5R,KAAKmR,OAEjBnR,KAAK4R,QAAU5R,KAAKyR,YAEpBzR,KAAK4R,QAAU5R,KAAKyR,YAGnBzR,KAAKmQ,MAAQnQ,KAAKmQ,KAAKa,SAE5BhR,KAAK4R,SAAW5R,KAAKmR,OAEjBnR,KAAK4R,SAAW5R,KAAKyR,YAErBzR,KAAK4R,SAAW5R,KAAKyR,YAIzBzR,KAAKiQ,MAAQjQ,KAAKiQ,KAAKe,QAEvBhR,KAAK2R,SAAW3R,KAAKkR,OAEjBlR,KAAK2R,QAAU3R,KAAKwR,YAEpBxR,KAAK2R,QAAU3R,KAAKwR,YAGnBxR,KAAK+D,OAAS/D,KAAK+D,MAAMiN,SAE9BhR,KAAK2R,SAAW3R,KAAKkR,OAEjBlR,KAAK2R,SAAW3R,KAAKwR,YAErBxR,KAAK2R,SAAW3R,KAAKwR,YAMzBxR,KAAKoQ,QAAUpQ,KAAKoQ,OAAOY,OAE3BhR,KAAK4Q,OAAS5Q,KAAKsQ,UAEdtQ,KAAKqQ,SAAWrQ,KAAKqQ,QAAQW,OAElChR,KAAK4Q,MAAQ5Q,KAAKsQ,UAIlBtQ,KAAK4Q,MAAQ,EAKI,IAAjB5Q,KAAK2R,UAEL7F,EAAIlK,SAAa5B,KAAK2R,QAAU1L,EAAS,GAGxB,IAAjBjG,KAAK4R,UAEL9F,EAAIjK,SAAa7B,KAAK4R,QAAU3L,EAAS,GAG1B,IAAfjG,KAAK4Q,QAEL9E,EAAI3I,MAAQnD,KAAK4Q,MAEb9E,EAAI3I,KAAOnD,KAAKuQ,QAEhBzE,EAAI3I,KAAOnD,KAAKuQ,QAEXzE,EAAI3I,KAAOnD,KAAKwQ,UAErB1E,EAAI3I,KAAOnD,KAAKwQ,YAW5BrK,QAAS,WAELnG,KAAKyI,OAAS,KAEdzI,KAAKiQ,KAAO,KACZjQ,KAAK+D,MAAQ,KACb/D,KAAKkQ,GAAK,KACVlQ,KAAKmQ,KAAO,KAEZnQ,KAAKoQ,OAAS,KACdpQ,KAAKqQ,QAAU,QAKvBhK,EAAOC,QAAU2K,G,gBC1ejB5K,EAAOC,QAAU,CAEb0J,gBAAiB,EAAQ,OACzBiB,mBAAoB,EAAQ,S,gBCChC5K,EAAOC,QAAU,CAEbuL,SAAU,EAAQ,OAClBC,QAAS,EAAQ,S,UCarBzL,EAAOC,QARQ,SAAUyL,EAAMpS,EAAGC,GAK9B,OAHAmS,EAAKpS,EAAIA,EAAKoS,EAAKlS,MAAQ,EAC3BkS,EAAKnS,EAAIA,EAAKmS,EAAKjS,OAAS,EAErBiS,I,SCJX1L,EAAOC,QALM,SAAU0L,EAAIC,EAAI/I,GAE3B,OAAQ+I,EAAKD,GAAM9I,EAAI8I,I,gBCd3B,IAAIE,EAAO,EAAQ,OACfC,EAAS,EAAQ,OACjBC,EAAW,EAAQ,OACnBC,EAAQ,EAAQ,OAChBC,EAAU,EAAQ,OAClBC,EAAO,EAAQ,OACftT,EAAS,EAAQ,OACjBuT,EAAY,EAAQ,OACpBC,EAAU,EAAQ,MAClBC,EAAU,EAAQ,OAClBC,EAAO,EAAQ,MACfC,EAAU,EAAQ,OAGtBvM,EAAOC,QAAU,CAEbuM,OAAQ5T,EACR6T,OAAQN,EAAUO,IAClBC,OAAQX,EAAMU,IACdE,OAAQR,EAAQM,IAChBG,OAAQR,EAAQK,IAEhB9T,OAAQA,EACRkU,KAAMX,EAAUO,IAChBV,MAAOA,EAAMU,IACbK,MAAOX,EAAQM,IACfM,MAAOX,EAAQK,IACfJ,KAAMA,EAAKI,IACXR,KAAMA,EAAKQ,IACXO,KAAMlB,EAASW,IACfT,QAASA,EAAQS,IACjBb,KAAMA,EAAKa,IACXZ,OAAQA,EAAOY,IACfH,QAASA,EAET,cAAeJ,EAAUe,GACzB,eAAgBlB,EAAMkB,GACtB,eAAgBd,EAAQc,GACxB,eAAgBb,EAAQa,GACxB,cAAeZ,EAAKY,GACpB,cAAehB,EAAKgB,GACpB,cAAenB,EAASmB,GACxB,iBAAkBjB,EAAQiB,GAC1B,cAAerB,EAAKqB,GACpB,gBAAiBpB,EAAOoB,GAExB,eAAgBf,EAAUO,IAC1B,gBAAiBV,EAAMU,IACvB,gBAAiBN,EAAQM,IACzB,gBAAiBL,EAAQK,IACzB,eAAgBJ,EAAKI,IACrB,eAAgBR,EAAKQ,IACrB,eAAgBX,EAASW,IACzB,kBAAmBT,EAAQS,IAC3B,eAAgBb,EAAKa,IACrB,iBAAkBZ,EAAOY,IAEzB,iBAAkBP,EAAUgB,MAC5B,kBAAmBnB,EAAMmB,MACzB,kBAAmBf,EAAQe,MAC3B,kBAAmBd,EAAQc,MAC3B,iBAAkBb,EAAKa,MACvB,iBAAkBjB,EAAKiB,MACvB,iBAAkBpB,EAASoB,MAC3B,oBAAqBlB,EAAQkB,MAC7B,iBAAkBtB,EAAKsB,MACvB,mBAAoBrB,EAAOqB,Q,UChE/B,IAAIC,EAAc,GAIdC,EAAgB,GAEhBlN,EAAc,CAoBlB,SAAuB,SAAUmN,EAAKC,EAAQC,EAASC,QAEpCzS,IAAXyS,IAAwBA,GAAS,GAErCL,EAAYE,GAAO,CAAEC,OAAQA,EAAQC,QAASA,EAASC,OAAQA,IAenE,eAA6B,SAAUH,EAAKC,EAAQC,EAASE,GAEzDL,EAAcC,GAAO,CAAEC,OAAQA,EAAQC,QAASA,EAASE,KAAMA,IAanE,QAAsB,SAAUJ,GAE5B,OAAOF,EAAYrF,eAAeuF,IAatC,UAAwB,SAAUA,GAE9B,OAAOD,EAActF,eAAeuF,IAaxC,QAAsB,SAAUA,GAE5B,OAAOF,EAAYE,IAavB,UAAwB,SAAUA,GAE9B,OAAOD,EAAcC,IAazB,eAA6B,SAAUA,GAEnC,OAAQD,EAActF,eAAeuF,GAAQD,EAAcC,GAAKC,OAAS,MAW7E,OAAqB,SAAUD,GAEvBF,EAAYrF,eAAeuF,WAEpBF,EAAYE,IAY3B,aAA2B,SAAUA,GAE7BD,EAActF,eAAeuF,WAEtBD,EAAcC,IAa7B,mBAAiC,WAE7B,IAAK,IAAIA,KAAOF,EAERA,EAAYrF,eAAeuF,WAEpBF,EAAYE,IAW/B,qBAAmC,WAE/B,IAAK,IAAIA,KAAOD,EAERA,EAActF,eAAeuF,WAEtBD,EAAcC,KAKjCtN,EAAOC,QAAUE,G,UC9LjBH,EAAOC,QAAU,mB,UCAjBD,EAAOC,QAAU,oB,UCAjBD,EAAOC,QAAU,yB,UCCjBD,EAAOC,QAAU,mB,UCGjBD,EAAOC,QAAU,qB,UCOjBD,EAAOC,QAAU,U,gBCbjBD,EAAOC,QAAU,CAEb0N,iBAAkB,EAAQ,OAC1BC,kBAAmB,EAAQ,OAC3BC,uBAAwB,EAAQ,OAChCC,iBAAkB,EAAQ,OAC1BC,mBAAoB,EAAQ,OAC5BpM,OAAQ,EAAQ,Y","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/Camera.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/CameraManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/Fade.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/Flash.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/Pan.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/RotateTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/Shake.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/Zoom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/effects/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/DESTROY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FADE_IN_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FADE_IN_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FADE_OUT_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FADE_OUT_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FLASH_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FLASH_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/FOLLOW_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/PAN_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/PAN_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/POST_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/PRE_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/ROTATE_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/ROTATE_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/SHAKE_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/SHAKE_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/ZOOM_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/ZOOM_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/2d/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/controls/FixedKeyControl.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/controls/SmoothedKeyControl.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/controls/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/cameras/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/CenterOn.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Linear.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/easing/EaseMap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/ENTER_FULLSCREEN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/FULLSCREEN_FAILED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/FULLSCREEN_UNSUPPORTED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/LEAVE_FULLSCREEN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/ORIENTATION_CHANGE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/RESIZE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BaseCamera = require('./BaseCamera');\r\nvar CenterOn = require('../../geom/rectangle/CenterOn');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../../gameobjects/components');\r\nvar Effects = require('./effects');\r\nvar Events = require('./events');\r\nvar Linear = require('../../math/Linear');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera.\r\n *\r\n * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,\r\n * and can be positioned, rotated, zoomed and scrolled accordingly.\r\n *\r\n * A Camera consists of two elements: The viewport and the scroll values.\r\n *\r\n * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are\r\n * created the same size as your game, but their position and size can be set to anything. This means if you\r\n * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,\r\n * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).\r\n *\r\n * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this\r\n * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the\r\n * viewport, and changing the viewport has no impact on the scrolling.\r\n *\r\n * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,\r\n * allowing you to filter Game Objects out on a per-Camera basis.\r\n *\r\n * A Camera also has built-in special effects including Fade, Flash and Camera Shake.\r\n *\r\n * @class Camera\r\n * @memberof Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Cameras.Scene2D.BaseCamera\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n *\r\n * @param {number} x - The x position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} y - The y position of the Camera, relative to the top-left of the game canvas.\r\n * @param {number} width - The width of the Camera, in pixels.\r\n * @param {number} height - The height of the Camera, in pixels.\r\n */\r\nvar Camera = new Class({\r\n\r\n    Extends: BaseCamera,\r\n\r\n    Mixins: [\r\n        Components.Flip,\r\n        Components.Tint,\r\n        Components.Pipeline\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Camera (x, y, width, height)\r\n    {\r\n        BaseCamera.call(this, x, y, width, height);\r\n\r\n        this.postPipelines = [];\r\n        this.pipelineData = {};\r\n\r\n        /**\r\n         * Does this Camera allow the Game Objects it renders to receive input events?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#inputEnabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.inputEnabled = true;\r\n\r\n        /**\r\n         * The Camera Fade effect handler.\r\n         * To fade this camera see the `Camera.fade` methods.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#fadeEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.Fade}\r\n         * @since 3.5.0\r\n         */\r\n        this.fadeEffect = new Effects.Fade(this);\r\n\r\n        /**\r\n         * The Camera Flash effect handler.\r\n         * To flash this camera see the `Camera.flash` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#flashEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.Flash}\r\n         * @since 3.5.0\r\n         */\r\n        this.flashEffect = new Effects.Flash(this);\r\n\r\n        /**\r\n         * The Camera Shake effect handler.\r\n         * To shake this camera see the `Camera.shake` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#shakeEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.Shake}\r\n         * @since 3.5.0\r\n         */\r\n        this.shakeEffect = new Effects.Shake(this);\r\n\r\n        /**\r\n         * The Camera Pan effect handler.\r\n         * To pan this camera see the `Camera.pan` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#panEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.Pan}\r\n         * @since 3.11.0\r\n         */\r\n        this.panEffect = new Effects.Pan(this);\r\n\r\n        /**\r\n         * The Camera Rotate To effect handler.\r\n         * To rotate this camera see the `Camera.rotateTo` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#rotateToEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.RotateTo}\r\n         * @since 3.23.0\r\n         */\r\n        this.rotateToEffect = new Effects.RotateTo(this);\r\n\r\n        /**\r\n         * The Camera Zoom effect handler.\r\n         * To zoom this camera see the `Camera.zoom` method.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#zoomEffect\r\n         * @type {Phaser.Cameras.Scene2D.Effects.Zoom}\r\n         * @since 3.11.0\r\n         */\r\n        this.zoomEffect = new Effects.Zoom(this);\r\n\r\n        /**\r\n         * The linear interpolation value to use when following a target.\r\n         *\r\n         * Can also be set via `setLerp` or as part of the `startFollow` call.\r\n         *\r\n         * The default values of 1 means the camera will instantly snap to the target coordinates.\r\n         * A lower value, such as 0.1 means the camera will more slowly track the target, giving\r\n         * a smooth transition. You can set the horizontal and vertical values independently, and also\r\n         * adjust this value in real-time during your game.\r\n         *\r\n         * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#lerp\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.9.0\r\n         */\r\n        this.lerp = new Vector2(1, 1);\r\n\r\n        /**\r\n         * The values stored in this property are subtracted from the Camera targets position, allowing you to\r\n         * offset the camera from the actual target x/y coordinates by this amount.\r\n         * Can also be set via `setFollowOffset` or as part of the `startFollow` call.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#followOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.9.0\r\n         */\r\n        this.followOffset = new Vector2();\r\n\r\n        /**\r\n         * The Camera dead zone.\r\n         *\r\n         * The deadzone is only used when the camera is following a target.\r\n         *\r\n         * It defines a rectangular region within which if the target is present, the camera will not scroll.\r\n         * If the target moves outside of this area, the camera will begin scrolling in order to follow it.\r\n         *\r\n         * The `lerp` values that you can set for a follower target also apply when using a deadzone.\r\n         *\r\n         * You can directly set this property to be an instance of a Rectangle. Or, you can use the\r\n         * `setDeadzone` method for a chainable approach.\r\n         *\r\n         * The rectangle you provide can have its dimensions adjusted dynamically, however, please\r\n         * note that its position is updated every frame, as it is constantly re-centered on the cameras mid point.\r\n         *\r\n         * Calling `setDeadzone` with no arguments will reset an active deadzone, as will setting this property\r\n         * to `null`.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#deadzone\r\n         * @type {?Phaser.Geom.Rectangle}\r\n         * @since 3.11.0\r\n         */\r\n        this.deadzone = null;\r\n\r\n        /**\r\n         * Internal follow target reference.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Camera#_follow\r\n         * @type {?any}\r\n         * @private\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this._follow = null;\r\n    },\r\n\r\n    /**\r\n     * Sets the Camera dead zone.\r\n     *\r\n     * The deadzone is only used when the camera is following a target.\r\n     *\r\n     * It defines a rectangular region within which if the target is present, the camera will not scroll.\r\n     * If the target moves outside of this area, the camera will begin scrolling in order to follow it.\r\n     *\r\n     * The deadzone rectangle is re-positioned every frame so that it is centered on the mid-point\r\n     * of the camera. This allows you to use the object for additional game related checks, such as\r\n     * testing if an object is within it or not via a Rectangle.contains call.\r\n     *\r\n     * The `lerp` values that you can set for a follower target also apply when using a deadzone.\r\n     *\r\n     * Calling this method with no arguments will reset an active deadzone.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setDeadzone\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} [width] - The width of the deadzone rectangle in pixels. If not specified the deadzone is removed.\r\n     * @param {number} [height] - The height of the deadzone rectangle in pixels.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    setDeadzone: function (width, height)\r\n    {\r\n        if (width === undefined)\r\n        {\r\n            this.deadzone = null;\r\n        }\r\n        else\r\n        {\r\n            if (this.deadzone)\r\n            {\r\n                this.deadzone.width = width;\r\n                this.deadzone.height = height;\r\n            }\r\n            else\r\n            {\r\n                this.deadzone = new Rectangle(0, 0, width, height);\r\n            }\r\n\r\n            if (this._follow)\r\n            {\r\n                var originX = this.width / 2;\r\n                var originY = this.height / 2;\r\n\r\n                var fx = this._follow.x - this.followOffset.x;\r\n                var fy = this._follow.y - this.followOffset.y;\r\n\r\n                this.midPoint.set(fx, fy);\r\n\r\n                this.scrollX = fx - originX;\r\n                this.scrollY = fy - originY;\r\n            }\r\n\r\n            CenterOn(this.deadzone, this.midPoint.x, this.midPoint.y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fades the Camera in from the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fadeIn\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    fadeIn: function (duration, red, green, blue, callback, context)\r\n    {\r\n        return this.fadeEffect.start(false, duration, red, green, blue, true, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Fades the Camera out to the given color over the duration specified.\r\n     * This is an alias for Camera.fade that forces the fade to start, regardless of existing fades.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fadeOut\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    fadeOut: function (duration, red, green, blue, callback, context)\r\n    {\r\n        return this.fadeEffect.start(true, duration, red, green, blue, true, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Fades the Camera from the given color to transparent over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fadeFrom\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.\r\n     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    fadeFrom: function (duration, red, green, blue, force, callback, context)\r\n    {\r\n        return this.fadeEffect.start(false, duration, red, green, blue, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Fades the Camera from transparent to the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#fade\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.\r\n     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    fade: function (duration, red, green, blue, force, callback, context)\r\n    {\r\n        return this.fadeEffect.start(true, duration, red, green, blue, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Flashes the Camera by setting it to the given color immediately and then fading it away again quickly over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#flash\r\n     * @fires Phaser.Cameras.Scene2D.Events#FLASH_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [duration=250] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=255] - The amount to fade the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=255] - The amount to fade the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=255] - The amount to fade the blue channel towards. A value between 0 and 255.\r\n     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    flash: function (duration, red, green, blue, force, callback, context)\r\n    {\r\n        return this.flashEffect.start(duration, red, green, blue, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Shakes the Camera by the given intensity over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#shake\r\n     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [duration=100] - The duration of the effect in milliseconds.\r\n     * @param {(number|Phaser.Math.Vector2)} [intensity=0.05] - The intensity of the shake.\r\n     * @param {boolean} [force=false] - Force the shake effect to start immediately, even if already running.\r\n     * @param {function} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    shake: function (duration, intensity, force, callback, context)\r\n    {\r\n        return this.shakeEffect.start(duration, intensity, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,\r\n     * over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#pan\r\n     * @fires Phaser.Cameras.Scene2D.Events#PAN_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The destination x coordinate to scroll the center of the Camera viewport to.\r\n     * @param {number} y - The destination y coordinate to scroll the center of the Camera viewport to.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * the current camera scroll x coordinate and the current camera scroll y coordinate.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    pan: function (x, y, duration, ease, force, callback, context)\r\n    {\r\n        return this.panEffect.start(x, y, duration, ease, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * This effect will rotate the Camera so that the viewport finishes at the given angle in radians,\r\n     * over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#rotateTo\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} radians - The destination angle in radians to rotate the Camera viewport to. If the angle is positive then the rotation is clockwise else anticlockwise\r\n     * @param {boolean} [shortestPath=false] - If shortest path is set to true the camera will rotate in the quickest direction clockwise or anti-clockwise.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the rotation. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the rotation effect to start immediately, even if already running.\r\n     * @param {CameraRotateCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * the current camera rotation angle in radians.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} This Camera instance.\r\n     */\r\n    rotateTo: function (radians, shortestPath, duration, ease, force, callback, context)\r\n    {\r\n        return this.rotateToEffect.start(radians, shortestPath, duration, ease, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#zoomTo\r\n     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} zoom - The target Camera zoom value.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * the current camera scroll x coordinate and the current camera scroll y coordinate.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    zoomTo: function (zoom, duration, ease, force, callback, context)\r\n    {\r\n        return this.zoomEffect.start(zoom, duration, ease, force, callback, context);\r\n    },\r\n\r\n    /**\r\n     * Internal preRender step.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#preRender\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        this.renderList.length = 0;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        var halfWidth = width * 0.5;\r\n        var halfHeight = height * 0.5;\r\n\r\n        var zoom = this.zoom;\r\n        var matrix = this.matrix;\r\n\r\n        var originX = width * this.originX;\r\n        var originY = height * this.originY;\r\n\r\n        var follow = this._follow;\r\n        var deadzone = this.deadzone;\r\n\r\n        var sx = this.scrollX;\r\n        var sy = this.scrollY;\r\n\r\n        if (deadzone)\r\n        {\r\n            CenterOn(deadzone, this.midPoint.x, this.midPoint.y);\r\n        }\r\n\r\n        var emitFollowEvent = false;\r\n\r\n        if (follow && !this.panEffect.isRunning)\r\n        {\r\n            var fx = (follow.x - this.followOffset.x);\r\n            var fy = (follow.y - this.followOffset.y);\r\n\r\n            if (deadzone)\r\n            {\r\n                if (fx < deadzone.x)\r\n                {\r\n                    sx = Linear(sx, sx - (deadzone.x - fx), this.lerp.x);\r\n                }\r\n                else if (fx > deadzone.right)\r\n                {\r\n                    sx = Linear(sx, sx + (fx - deadzone.right), this.lerp.x);\r\n                }\r\n\r\n                if (fy < deadzone.y)\r\n                {\r\n                    sy = Linear(sy, sy - (deadzone.y - fy), this.lerp.y);\r\n                }\r\n                else if (fy > deadzone.bottom)\r\n                {\r\n                    sy = Linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                sx = Linear(sx, fx - originX, this.lerp.x);\r\n                sy = Linear(sy, fy - originY, this.lerp.y);\r\n            }\r\n\r\n            emitFollowEvent = true;\r\n        }\r\n\r\n        if (this.useBounds)\r\n        {\r\n            sx = this.clampX(sx);\r\n            sy = this.clampY(sy);\r\n        }\r\n\r\n        if (this.roundPixels)\r\n        {\r\n            originX = Math.round(originX);\r\n            originY = Math.round(originY);\r\n\r\n            sx = Math.round(sx);\r\n            sy = Math.round(sy);\r\n        }\r\n\r\n        //  Values are in pixels and not impacted by zooming the Camera\r\n        this.scrollX = sx;\r\n        this.scrollY = sy;\r\n\r\n        var midX = sx + halfWidth;\r\n        var midY = sy + halfHeight;\r\n\r\n        //  The center of the camera, in world space, so taking zoom into account\r\n        //  Basically the pixel value of what it's looking at in the middle of the cam\r\n        this.midPoint.set(midX, midY);\r\n\r\n        var displayWidth = width / zoom;\r\n        var displayHeight = height / zoom;\r\n\r\n        var vwx = midX - (displayWidth / 2);\r\n        var vwy = midY - (displayHeight / 2);\r\n\r\n        if (this.roundPixels)\r\n        {\r\n            vwx = Math.round(vwx);\r\n            vwy = Math.round(vwy);\r\n        }\r\n\r\n        this.worldView.setTo(vwx, vwy, displayWidth, displayHeight);\r\n\r\n        matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);\r\n        matrix.translate(-originX, -originY);\r\n\r\n        this.shakeEffect.preRender();\r\n\r\n        if (emitFollowEvent)\r\n        {\r\n            this.emit(Events.FOLLOW_UPDATE, this, follow);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the linear interpolation value to use when following a target.\r\n     *\r\n     * The default values of 1 means the camera will instantly snap to the target coordinates.\r\n     * A lower value, such as 0.1 means the camera will more slowly track the target, giving\r\n     * a smooth transition. You can set the horizontal and vertical values independently, and also\r\n     * adjust this value in real-time during your game.\r\n     *\r\n     * Be sure to keep the value between 0 and 1. A value of zero will disable tracking on that axis.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setLerp\r\n     * @since 3.9.0\r\n     *\r\n     * @param {number} [x=1] - The amount added to the horizontal linear interpolation of the follow target.\r\n     * @param {number} [y=1] - The amount added to the vertical linear interpolation of the follow target.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    setLerp: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.lerp.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical offset of the camera from its follow target.\r\n     * The values are subtracted from the targets position during the Cameras update step.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#setFollowOffset\r\n     * @since 3.9.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal offset from the camera follow target.x position.\r\n     * @param {number} [y=0] - The vertical offset from the camera follow target.y position.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    setFollowOffset: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        this.followOffset.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Camera to follow a Game Object.\r\n     *\r\n     * When enabled the Camera will automatically adjust its scroll position to keep the target Game Object\r\n     * in its center.\r\n     *\r\n     * You can set the linear interpolation value used in the follow code.\r\n     * Use low lerp values (such as 0.1) to automatically smooth the camera motion.\r\n     *\r\n     * If you find you're getting a slight \"jitter\" effect when following an object it's probably to do with sub-pixel\r\n     * rendering of the targets position. This can be rounded by setting the `roundPixels` argument to `true` to\r\n     * force full pixel rounding rendering. Note that this can still be broken if you have specified a non-integer zoom\r\n     * value on the camera. So be sure to keep the camera zoom to integers.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#startFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|object)} target - The target for the Camera to follow.\r\n     * @param {boolean} [roundPixels=false] - Round the camera position to whole integers to avoid sub-pixel rendering?\r\n     * @param {number} [lerpX=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when horizontally tracking the target. The closer the value to 1, the faster the camera will track.\r\n     * @param {number} [lerpY=1] - A value between 0 and 1. This value specifies the amount of linear interpolation to use when vertically tracking the target. The closer the value to 1, the faster the camera will track.\r\n     * @param {number} [offsetX=0] - The horizontal offset from the camera follow target.x position.\r\n     * @param {number} [offsetY=0] - The vertical offset from the camera follow target.y position.\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    startFollow: function (target, roundPixels, lerpX, lerpY, offsetX, offsetY)\r\n    {\r\n        if (roundPixels === undefined) { roundPixels = false; }\r\n        if (lerpX === undefined) { lerpX = 1; }\r\n        if (lerpY === undefined) { lerpY = lerpX; }\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = offsetX; }\r\n\r\n        this._follow = target;\r\n\r\n        this.roundPixels = roundPixels;\r\n\r\n        lerpX = Clamp(lerpX, 0, 1);\r\n        lerpY = Clamp(lerpY, 0, 1);\r\n\r\n        this.lerp.set(lerpX, lerpY);\r\n\r\n        this.followOffset.set(offsetX, offsetY);\r\n\r\n        var originX = this.width / 2;\r\n        var originY = this.height / 2;\r\n\r\n        var fx = target.x - offsetX;\r\n        var fy = target.y - offsetY;\r\n\r\n        this.midPoint.set(fx, fy);\r\n\r\n        this.scrollX = fx - originX;\r\n        this.scrollY = fy - originY;\r\n\r\n        if (this.useBounds)\r\n        {\r\n            this.scrollX = this.clampX(this.scrollX);\r\n            this.scrollY = this.clampY(this.scrollY);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops a Camera from following a Game Object, if previously set via `Camera.startFollow`.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#stopFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    stopFollow: function ()\r\n    {\r\n        this._follow = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets any active FX, such as a fade, flash or shake. Useful to call after a fade in order to\r\n     * remove the fade.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#resetFX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Camera instance.\r\n     */\r\n    resetFX: function ()\r\n    {\r\n        this.rotateToEffect.reset();\r\n        this.panEffect.reset();\r\n        this.shakeEffect.reset();\r\n        this.flashEffect.reset();\r\n        this.fadeEffect.reset();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method called automatically by the Camera Manager.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#update\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (this.visible)\r\n        {\r\n            this.rotateToEffect.update(time, delta);\r\n            this.panEffect.update(time, delta);\r\n            this.zoomEffect.update(time, delta);\r\n            this.shakeEffect.update(time, delta);\r\n            this.flashEffect.update(time, delta);\r\n            this.fadeEffect.update(time, delta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Camera instance. You rarely need to call this directly.\r\n     *\r\n     * Called by the Camera Manager. If you wish to destroy a Camera please use `CameraManager.remove` as\r\n     * cameras are stored in a pool, ready for recycling later, and calling this directly will prevent that.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Camera#destroy\r\n     * @fires Phaser.Cameras.Scene2D.Events#DESTROY\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.resetFX();\r\n\r\n        BaseCamera.prototype.destroy.call(this);\r\n\r\n        this._follow = null;\r\n\r\n        this.deadzone = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Camera;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Camera = require('./Camera');\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar ScaleEvents = require('../../scale/events');\r\nvar SceneEvents = require('../../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Camera Manager is a plugin that belongs to a Scene and is responsible for managing all of the Scene Cameras.\r\n *\r\n * By default you can access the Camera Manager from within a Scene using `this.cameras`, although this can be changed\r\n * in your game config.\r\n *\r\n * Create new Cameras using the `add` method. Or extend the Camera class with your own addition code and then add\r\n * the new Camera in using the `addExisting` method.\r\n *\r\n * Cameras provide a view into your game world, and can be positioned, rotated, zoomed and scrolled accordingly.\r\n *\r\n * A Camera consists of two elements: The viewport and the scroll values.\r\n *\r\n * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are\r\n * created the same size as your game, but their position and size can be set to anything. This means if you\r\n * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,\r\n * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).\r\n *\r\n * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this\r\n * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the\r\n * viewport, and changing the viewport has no impact on the scrolling.\r\n *\r\n * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,\r\n * allowing you to filter Game Objects out on a per-Camera basis. The Camera Manager can manage up to 31 unique\r\n * 'Game Object ignore capable' Cameras. Any Cameras beyond 31 that you create will all be given a Camera ID of\r\n * zero, meaning that they cannot be used for Game Object exclusion. This means if you need your Camera to ignore\r\n * Game Objects, make sure it's one of the first 31 created.\r\n *\r\n * A Camera also has built-in special effects including Fade, Flash, Camera Shake, Pan and Zoom.\r\n *\r\n * @class CameraManager\r\n * @memberof Phaser.Cameras.Scene2D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that owns the Camera Manager plugin.\r\n */\r\nvar CameraManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function CameraManager (scene)\r\n    {\r\n        /**\r\n         * The Scene that owns the Camera Manager plugin.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene.Systems handler for the Scene that owns the Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * All Cameras created by, or added to, this Camera Manager, will have their `roundPixels`\r\n         * property set to match this value. By default it is set to match the value set in the\r\n         * game configuration, but can be changed at any point. Equally, individual cameras can\r\n         * also be changed as needed.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#roundPixels\r\n         * @type {boolean}\r\n         * @since 3.11.0\r\n         */\r\n        this.roundPixels = scene.sys.game.config.roundPixels;\r\n\r\n        /**\r\n         * An Array of the Camera objects being managed by this Camera Manager.\r\n         * The Cameras are updated and rendered in the same order in which they appear in this array.\r\n         * Do not directly add or remove entries to this array. However, you can move the contents\r\n         * around the array should you wish to adjust the display order.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#cameras\r\n         * @type {Phaser.Cameras.Scene2D.Camera[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras = [];\r\n\r\n        /**\r\n         * A handy reference to the 'main' camera. By default this is the first Camera the\r\n         * Camera Manager creates. You can also set it directly, or use the `makeMain` argument\r\n         * in the `add` and `addExisting` methods. It allows you to access it from your game:\r\n         *\r\n         * ```javascript\r\n         * var cam = this.cameras.main;\r\n         * ```\r\n         *\r\n         * Also see the properties `camera1`, `camera2` and so on.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#main\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */\r\n        this.main;\r\n\r\n        /**\r\n         * A default un-transformed Camera that doesn't exist on the camera list and doesn't\r\n         * count towards the total number of cameras being managed. It exists for other\r\n         * systems, as well as your own code, should they require a basic un-transformed\r\n         * camera instance from which to calculate a view matrix.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.CameraManager#default\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.17.0\r\n         */\r\n        this.default;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#boot\r\n     * @private\r\n     * @listens Phaser.Scenes.Events#DESTROY\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        var sys = this.systems;\r\n\r\n        if (sys.settings.cameras)\r\n        {\r\n            //  We have cameras to create\r\n            this.fromJSON(sys.settings.cameras);\r\n        }\r\n        else\r\n        {\r\n            //  Make one\r\n            this.add();\r\n        }\r\n\r\n        this.main = this.cameras[0];\r\n\r\n        //  Create a default camera\r\n        this.default = new Camera(0, 0, sys.scale.width, sys.scale.height).setScene(this.scene);\r\n\r\n        sys.game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#start\r\n     * @private\r\n     * @listens Phaser.Scenes.Events#UPDATE\r\n     * @listens Phaser.Scenes.Events#SHUTDOWN\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.main)\r\n        {\r\n            var sys = this.systems;\r\n\r\n            if (sys.settings.cameras)\r\n            {\r\n                //  We have cameras to create\r\n                this.fromJSON(sys.settings.cameras);\r\n            }\r\n            else\r\n            {\r\n                //  Make one\r\n                this.add();\r\n            }\r\n\r\n            this.main = this.cameras[0];\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.UPDATE, this.update, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Adds a new Camera into the Camera Manager. The Camera Manager can support up to 31 different Cameras.\r\n     *\r\n     * Each Camera has its own viewport, which controls the size of the Camera and its position within the canvas.\r\n     *\r\n     * Use the `Camera.scrollX` and `Camera.scrollY` properties to change where the Camera is looking, or the\r\n     * Camera methods such as `centerOn`. Cameras also have built in special effects, such as fade, flash, shake,\r\n     * pan and zoom.\r\n     *\r\n     * By default Cameras are transparent and will render anything that they can see based on their `scrollX`\r\n     * and `scrollY` values. Game Objects can be set to be ignored by a Camera by using the `Camera.ignore` method.\r\n     *\r\n     * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change\r\n     * it after creation if required.\r\n     *\r\n     * See the Camera class documentation for more details.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the Camera viewport.\r\n     * @param {number} [y=0] - The vertical position of the Camera viewport.\r\n     * @param {number} [width] - The width of the Camera viewport. If not given it'll be the game config size.\r\n     * @param {number} [height] - The height of the Camera viewport. If not given it'll be the game config size.\r\n     * @param {boolean} [makeMain=false] - Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it.\r\n     * @param {string} [name=''] - The name of the Camera.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The newly created Camera.\r\n     */\r\n    add: function (x, y, width, height, makeMain, name)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n        if (makeMain === undefined) { makeMain = false; }\r\n        if (name === undefined) { name = ''; }\r\n\r\n        var camera = new Camera(x, y, width, height);\r\n\r\n        camera.setName(name);\r\n        camera.setScene(this.scene);\r\n        camera.setRoundPixels(this.roundPixels);\r\n\r\n        camera.id = this.getNextID();\r\n\r\n        this.cameras.push(camera);\r\n\r\n        if (makeMain)\r\n        {\r\n            this.main = camera;\r\n        }\r\n\r\n        return camera;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Camera into the Camera Manager.\r\n     *\r\n     * The Camera should either be a `Phaser.Cameras.Scene2D.Camera` instance, or a class that extends from it.\r\n     *\r\n     * The Camera will have its `roundPixels` property set to whatever `CameraManager.roundPixels` is. You can change\r\n     * it after addition if required.\r\n     *\r\n     * The Camera will be assigned an ID, which is used for Game Object exclusion and then added to the\r\n     * manager. As long as it doesn't already exist in the manager it will be added then returned.\r\n     *\r\n     * If this method returns `null` then the Camera already exists in this Camera Manager.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#addExisting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to be added to the Camera Manager.\r\n     * @param {boolean} [makeMain=false] - Set this Camera as being the 'main' camera. This just makes the property `main` a reference to it.\r\n     *\r\n     * @return {?Phaser.Cameras.Scene2D.Camera} The Camera that was added to the Camera Manager, or `null` if it couldn't be added.\r\n     */\r\n    addExisting: function (camera, makeMain)\r\n    {\r\n        if (makeMain === undefined) { makeMain = false; }\r\n\r\n        var index = this.cameras.indexOf(camera);\r\n\r\n        if (index === -1)\r\n        {\r\n            camera.id = this.getNextID();\r\n\r\n            camera.setRoundPixels(this.roundPixels);\r\n\r\n            this.cameras.push(camera);\r\n\r\n            if (makeMain)\r\n            {\r\n                this.main = camera;\r\n            }\r\n\r\n            return camera;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the next available Camera ID number.\r\n     *\r\n     * The Camera Manager supports up to 31 unique cameras, after which the ID returned will always be zero.\r\n     * You can create additional cameras beyond 31, but they cannot be used for Game Object exclusion.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getNextID\r\n     * @private\r\n     * @since 3.11.0\r\n     *\r\n     * @return {number} The next available Camera ID, or 0 if they're all already in use.\r\n     */\r\n    getNextID: function ()\r\n    {\r\n        var cameras = this.cameras;\r\n\r\n        var testID = 1;\r\n\r\n        //  Find the first free camera ID we can use\r\n\r\n        for (var t = 0; t < 32; t++)\r\n        {\r\n            var found = false;\r\n\r\n            for (var i = 0; i < cameras.length; i++)\r\n            {\r\n                var camera = cameras[i];\r\n\r\n                if (camera && camera.id === testID)\r\n                {\r\n                    found = true;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (found)\r\n            {\r\n                testID = testID << 1;\r\n            }\r\n            else\r\n            {\r\n                return testID;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of Cameras in this Camera Manager.\r\n     *\r\n     * If the optional `isVisible` argument is set it will only count Cameras that are currently visible.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getTotal\r\n     * @since 3.11.0\r\n     *\r\n     * @param {boolean} [isVisible=false] - Set the `true` to only include visible Cameras in the total.\r\n     *\r\n     * @return {number} The total number of Cameras in this Camera Manager.\r\n     */\r\n    getTotal: function (isVisible)\r\n    {\r\n        if (isVisible === undefined) { isVisible = false; }\r\n\r\n        var total = 0;\r\n\r\n        var cameras = this.cameras;\r\n\r\n        for (var i = 0; i < cameras.length; i++)\r\n        {\r\n            var camera = cameras[i];\r\n\r\n            if (!isVisible || (isVisible && camera.visible))\r\n            {\r\n                total++;\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Populates this Camera Manager based on the given configuration object, or an array of config objects.\r\n     *\r\n     * See the `Phaser.Types.Cameras.Scene2D.CameraConfig` documentation for details of the object structure.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.Cameras.Scene2D.CameraConfig|Phaser.Types.Cameras.Scene2D.CameraConfig[])} config - A Camera configuration object, or an array of them, to be added to this Camera Manager.\r\n     *\r\n     * @return {this} This Camera Manager instance.\r\n     */\r\n    fromJSON: function (config)\r\n    {\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var gameWidth = this.scene.sys.scale.width;\r\n        var gameHeight = this.scene.sys.scale.height;\r\n\r\n        for (var i = 0; i < config.length; i++)\r\n        {\r\n            var cameraConfig = config[i];\r\n\r\n            var x = GetFastValue(cameraConfig, 'x', 0);\r\n            var y = GetFastValue(cameraConfig, 'y', 0);\r\n            var width = GetFastValue(cameraConfig, 'width', gameWidth);\r\n            var height = GetFastValue(cameraConfig, 'height', gameHeight);\r\n\r\n            var camera = this.add(x, y, width, height);\r\n\r\n            //  Direct properties\r\n            camera.name = GetFastValue(cameraConfig, 'name', '');\r\n            camera.zoom = GetFastValue(cameraConfig, 'zoom', 1);\r\n            camera.rotation = GetFastValue(cameraConfig, 'rotation', 0);\r\n            camera.scrollX = GetFastValue(cameraConfig, 'scrollX', 0);\r\n            camera.scrollY = GetFastValue(cameraConfig, 'scrollY', 0);\r\n            camera.roundPixels = GetFastValue(cameraConfig, 'roundPixels', false);\r\n            camera.visible = GetFastValue(cameraConfig, 'visible', true);\r\n\r\n            // Background Color\r\n\r\n            var backgroundColor = GetFastValue(cameraConfig, 'backgroundColor', false);\r\n\r\n            if (backgroundColor)\r\n            {\r\n                camera.setBackgroundColor(backgroundColor);\r\n            }\r\n\r\n            //  Bounds\r\n\r\n            var boundsConfig = GetFastValue(cameraConfig, 'bounds', null);\r\n\r\n            if (boundsConfig)\r\n            {\r\n                var bx = GetFastValue(boundsConfig, 'x', 0);\r\n                var by = GetFastValue(boundsConfig, 'y', 0);\r\n                var bwidth = GetFastValue(boundsConfig, 'width', gameWidth);\r\n                var bheight = GetFastValue(boundsConfig, 'height', gameHeight);\r\n\r\n                camera.setBounds(bx, by, bwidth, bheight);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a Camera based on its name.\r\n     *\r\n     * Camera names are optional and don't have to be set, so this method is only of any use if you\r\n     * have given your Cameras unique names.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Camera.\r\n     *\r\n     * @return {?Phaser.Cameras.Scene2D.Camera} The first Camera with a name matching the given string, otherwise `null`.\r\n     */\r\n    getCamera: function (name)\r\n    {\r\n        var cameras = this.cameras;\r\n\r\n        for (var i = 0; i < cameras.length; i++)\r\n        {\r\n            if (cameras[i].name === name)\r\n            {\r\n                return cameras[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all cameras below the given Pointer.\r\n     *\r\n     * The first camera in the array is the top-most camera in the camera list.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getCamerasBelowPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera[]} An array of cameras below the Pointer.\r\n     */\r\n    getCamerasBelowPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras;\r\n\r\n        var x = pointer.x;\r\n        var y = pointer.y;\r\n\r\n        var output = [];\r\n\r\n        for (var i = 0; i < cameras.length; i++)\r\n        {\r\n            var camera = cameras[i];\r\n\r\n            if (camera.visible && camera.inputEnabled && RectangleContains(camera, x, y))\r\n            {\r\n                //  So the top-most camera is at the top of the search array\r\n                output.unshift(camera);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Camera, or an array of Cameras, from this Camera Manager.\r\n     *\r\n     * If found in the Camera Manager it will be immediately removed from the local cameras array.\r\n     * If also currently the 'main' camera, 'main' will be reset to be camera 0.\r\n     *\r\n     * The removed Cameras are automatically destroyed if the `runDestroy` argument is `true`, which is the default.\r\n     * If you wish to re-use the cameras then set this to `false`, but know that they will retain their references\r\n     * and internal data until destroyed or re-added to a Camera Manager.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Cameras.Scene2D.Camera|Phaser.Cameras.Scene2D.Camera[])} camera - The Camera, or an array of Cameras, to be removed from this Camera Manager.\r\n     * @param {boolean} [runDestroy=true] - Automatically call `Camera.destroy` on each Camera removed from this Camera Manager.\r\n     *\r\n     * @return {number} The total number of Cameras removed.\r\n     */\r\n    remove: function (camera, runDestroy)\r\n    {\r\n        if (runDestroy === undefined) { runDestroy = true; }\r\n\r\n        if (!Array.isArray(camera))\r\n        {\r\n            camera = [ camera ];\r\n        }\r\n\r\n        var total = 0;\r\n        var cameras = this.cameras;\r\n\r\n        for (var i = 0; i < camera.length; i++)\r\n        {\r\n            var index = cameras.indexOf(camera[i]);\r\n\r\n            if (index !== -1)\r\n            {\r\n                if (runDestroy)\r\n                {\r\n                    cameras[index].destroy();\r\n                }\r\n                else\r\n                {\r\n                    cameras[index].renderList = [];\r\n                }\r\n\r\n                cameras.splice(index, 1);\r\n\r\n                total++;\r\n            }\r\n        }\r\n\r\n        if (!this.main && cameras[0])\r\n        {\r\n            this.main = cameras[0];\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * The internal render method. This is called automatically by the Scene and should not be invoked directly.\r\n     *\r\n     * It will iterate through all local cameras and render them in turn, as long as they're visible and have\r\n     * an alpha level > 0.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#render\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The Renderer that will render the children to this camera.\r\n     * @param {Phaser.GameObjects.DisplayList} displayList - The Display List for the Scene.\r\n     */\r\n    render: function (renderer, displayList)\r\n    {\r\n        var scene = this.scene;\r\n        var cameras = this.cameras;\r\n\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            var camera = cameras[i];\r\n\r\n            if (camera.visible && camera.alpha > 0)\r\n            {\r\n                camera.preRender();\r\n\r\n                var visibleChildren = this.getVisibleChildren(displayList.getChildren(), camera);\r\n\r\n                renderer.render(scene, visibleChildren, camera);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes an array of Game Objects and a Camera and returns a new array\r\n     * containing only those Game Objects that pass the `willRender` test\r\n     * against the given Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#getVisibleChildren\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} children - An array of Game Objects to be checked against the camera.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to filte the Game Objects against.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} A filtered list of only Game Objects within the Scene that will render against the given Camera.\r\n     */\r\n    getVisibleChildren: function (children, camera)\r\n    {\r\n        var visible = [];\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var child = children[i];\r\n\r\n            if (child.willRender(camera))\r\n            {\r\n                visible.push(child);\r\n            }\r\n        }\r\n\r\n        return visible;\r\n    },\r\n\r\n    /**\r\n     * Resets this Camera Manager.\r\n     *\r\n     * This will iterate through all current Cameras, destroying them all, then it will reset the\r\n     * cameras array, reset the ID counter and create 1 new single camera using the default values.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#resetAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The freshly created main Camera.\r\n     */\r\n    resetAll: function ()\r\n    {\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            this.cameras[i].destroy();\r\n        }\r\n\r\n        this.cameras = [];\r\n\r\n        this.main = this.add();\r\n\r\n        return this.main;\r\n    },\r\n\r\n    /**\r\n     * The main update loop. Called automatically when the Scene steps.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#update\r\n     * @protected\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            this.cameras[i].update(time, delta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#onResize\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions. The canvas width / height values match this.\r\n     */\r\n    onResize: function (gameSize, baseSize, displaySize, previousWidth, previousHeight)\r\n    {\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            var cam = this.cameras[i];\r\n\r\n            //  if camera is at 0x0 and was the size of the previous game size, then we can safely assume it\r\n            //  should be updated to match the new game size too\r\n\r\n            if (cam._x === 0 && cam._y === 0 && cam._width === previousWidth && cam._height === previousHeight)\r\n            {\r\n                cam.setSize(baseSize.width, baseSize.height);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resizes all cameras to the given dimensions.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#resize\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} width - The new width of the camera.\r\n     * @param {number} height - The new height of the camera.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            this.cameras[i].setSize(width, height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.main = undefined;\r\n\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            this.cameras[i].destroy();\r\n        }\r\n\r\n        this.cameras = [];\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.UPDATE, this.update, this);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.CameraManager#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.default.destroy();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('CameraManager', CameraManager, 'cameras');\r\n\r\nmodule.exports = CameraManager;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Clamp = require('../../../math/Clamp');\nvar Class = require('../../../utils/Class');\nvar Events = require('../events');\n\n/**\n * @classdesc\n * A Camera Fade effect.\n *\n * This effect will fade the camera viewport to the given color, over the duration specified.\n *\n * Only the camera viewport is faded. None of the objects it is displaying are impacted, i.e. their colors do\n * not change.\n *\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\n * which is invoked each frame for the duration of the effect, if required.\n *\n * @class Fade\n * @memberof Phaser.Cameras.Scene2D.Effects\n * @constructor\n * @since 3.5.0\n *\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\n */\nvar Fade = new Class({\n\n    initialize:\n\n    function Fade (camera)\n    {\n        /**\n         * The Camera this effect belongs to.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#camera\n         * @type {Phaser.Cameras.Scene2D.Camera}\n         * @readonly\n         * @since 3.5.0\n         */\n        this.camera = camera;\n\n        /**\n         * Is this effect actively running?\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#isRunning\n         * @type {boolean}\n         * @readonly\n         * @default false\n         * @since 3.5.0\n         */\n        this.isRunning = false;\n\n        /**\n         * Has this effect finished running?\n         *\n         * This is different from `isRunning` because it remains set to `true` when the effect is over,\n         * until the effect is either reset or started again.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#isComplete\n         * @type {boolean}\n         * @readonly\n         * @default false\n         * @since 3.5.0\n         */\n        this.isComplete = false;\n\n        /**\n         * The direction of the fade.\n         * `true` = fade out (transparent to color), `false` = fade in (color to transparent)\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#direction\n         * @type {boolean}\n         * @readonly\n         * @since 3.5.0\n         */\n        this.direction = true;\n\n        /**\n         * The duration of the effect, in milliseconds.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#duration\n         * @type {number}\n         * @readonly\n         * @default 0\n         * @since 3.5.0\n         */\n        this.duration = 0;\n\n        /**\n         * The value of the red color channel the camera will use for the fade effect.\n         * A value between 0 and 255.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#red\n         * @type {number}\n         * @private\n         * @since 3.5.0\n         */\n        this.red = 0;\n\n        /**\n         * The value of the green color channel the camera will use for the fade effect.\n         * A value between 0 and 255.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#green\n         * @type {number}\n         * @private\n         * @since 3.5.0\n         */\n        this.green = 0;\n\n        /**\n         * The value of the blue color channel the camera will use for the fade effect.\n         * A value between 0 and 255.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#blue\n         * @type {number}\n         * @private\n         * @since 3.5.0\n         */\n        this.blue = 0;\n\n        /**\n         * The value of the alpha channel used during the fade effect.\n         * A value between 0 and 1.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#alpha\n         * @type {number}\n         * @private\n         * @since 3.5.0\n         */\n        this.alpha = 0;\n\n        /**\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#progress\n         * @type {number}\n         * @since 3.5.0\n         */\n        this.progress = 0;\n\n        /**\n         * Effect elapsed timer.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#_elapsed\n         * @type {number}\n         * @private\n         * @since 3.5.0\n         */\n        this._elapsed = 0;\n\n        /**\n         * This callback is invoked every frame for the duration of the effect.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#_onUpdate\n         * @type {?Phaser.Types.Cameras.Scene2D.CameraFadeCallback}\n         * @private\n         * @default null\n         * @since 3.5.0\n         */\n        this._onUpdate;\n\n        /**\n         * On Complete callback scope.\n         *\n         * @name Phaser.Cameras.Scene2D.Effects.Fade#_onUpdateScope\n         * @type {any}\n         * @private\n         * @since 3.5.0\n         */\n        this._onUpdateScope;\n    },\n\n    /**\n     * Fades the Camera to or from the given color over the duration specified.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#start\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_START\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_START\n     * @since 3.5.0\n     *\n     * @param {boolean} [direction=true] - The direction of the fade. `true` = fade out (transparent to color), `false` = fade in (color to transparent)\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\n     * @param {number} [red=0] - The amount to fade the red channel towards. A value between 0 and 255.\n     * @param {number} [green=0] - The amount to fade the green channel towards. A value between 0 and 255.\n     * @param {number} [blue=0] - The amount to fade the blue channel towards. A value between 0 and 255.\n     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.\n     * @param {Phaser.Types.Cameras.Scene2D.CameraFadeCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\n     *\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\n     */\n    start: function (direction, duration, red, green, blue, force, callback, context)\n    {\n        if (direction === undefined) { direction = true; }\n        if (duration === undefined) { duration = 1000; }\n        if (red === undefined) { red = 0; }\n        if (green === undefined) { green = 0; }\n        if (blue === undefined) { blue = 0; }\n        if (force === undefined) { force = false; }\n        if (callback === undefined) { callback = null; }\n        if (context === undefined) { context = this.camera.scene; }\n\n        if (!force && this.isRunning)\n        {\n            return this.camera;\n        }\n\n        this.isRunning = true;\n        this.isComplete = false;\n        this.duration = duration;\n        this.direction = direction;\n        this.progress = 0;\n\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.alpha = (direction) ? Number.MIN_VALUE : 1;\n\n        this._elapsed = 0;\n\n        this._onUpdate = callback;\n        this._onUpdateScope = context;\n\n        var eventName = (direction) ? Events.FADE_OUT_START : Events.FADE_IN_START;\n\n        this.camera.emit(eventName, this.camera, this, duration, red, green, blue);\n\n        return this.camera;\n    },\n\n    /**\n     * The main update loop for this effect. Called automatically by the Camera.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#update\n     * @since 3.5.0\n     *\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    update: function (time, delta)\n    {\n        if (!this.isRunning)\n        {\n            return;\n        }\n\n        this._elapsed += delta;\n\n        this.progress = Clamp(this._elapsed / this.duration, 0, 1);\n\n        if (this._onUpdate)\n        {\n            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);\n        }\n\n        if (this._elapsed < this.duration)\n        {\n            this.alpha = (this.direction) ? this.progress : 1 - this.progress;\n        }\n        else\n        {\n            this.alpha = (this.direction) ? 1 : 0;\n            this.effectComplete();\n        }\n    },\n\n    /**\n     * Called internally by the Canvas Renderer.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#postRenderCanvas\n     * @since 3.5.0\n     *\n     * @param {CanvasRenderingContext2D} ctx - The Canvas context to render to.\n     *\n     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.\n     */\n    postRenderCanvas: function (ctx)\n    {\n        if (!this.isRunning && !this.isComplete)\n        {\n            return false;\n        }\n\n        var camera = this.camera;\n\n        ctx.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')';\n        ctx.fillRect(camera.x, camera.y, camera.width, camera.height);\n\n        return true;\n    },\n\n    /**\n     * Called internally by the WebGL Renderer.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#postRenderWebGL\n     * @since 3.5.0\n     *\n     * @param {Phaser.Renderer.WebGL.Pipelines.MultiPipeline} pipeline - The WebGL Pipeline to render to. Must provide the `drawFillRect` method.\n     * @param {function} getTintFunction - A function that will return the gl safe tint colors.\n     *\n     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.\n     */\n    postRenderWebGL: function (pipeline, getTintFunction)\n    {\n        if (!this.isRunning && !this.isComplete)\n        {\n            return false;\n        }\n\n        var camera = this.camera;\n        var red = this.red / 255;\n        var green = this.green / 255;\n        var blue = this.blue / 255;\n\n        pipeline.drawFillRect(\n            camera.x, camera.y, camera.width, camera.height,\n            getTintFunction(blue, green, red, 1),\n            this.alpha\n        );\n\n        return true;\n    },\n\n    /**\n     * Called internally when the effect completes.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#effectComplete\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE\n     * @fires Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE\n     * @since 3.5.0\n     */\n    effectComplete: function ()\n    {\n        this._onUpdate = null;\n        this._onUpdateScope = null;\n\n        this.isRunning = false;\n        this.isComplete = true;\n\n        var eventName = (this.direction) ? Events.FADE_OUT_COMPLETE : Events.FADE_IN_COMPLETE;\n\n        this.camera.emit(eventName, this.camera, this);\n    },\n\n    /**\n     * Resets this camera effect.\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#reset\n     * @since 3.5.0\n     */\n    reset: function ()\n    {\n        this.isRunning = false;\n        this.isComplete = false;\n\n        this._onUpdate = null;\n        this._onUpdateScope = null;\n    },\n\n    /**\n     * Destroys this effect, releasing it from the Camera.\n     *\n     * @method Phaser.Cameras.Scene2D.Effects.Fade#destroy\n     * @since 3.5.0\n     */\n    destroy: function ()\n    {\n        this.reset();\n\n        this.camera = null;\n    }\n\n});\n\nmodule.exports = Fade;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera Flash effect.\r\n *\r\n * This effect will flash the camera viewport to the given color, over the duration specified.\r\n *\r\n * Only the camera viewport is flashed. None of the objects it is displaying are impacted, i.e. their colors do\r\n * not change.\r\n *\r\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\r\n * which is invoked each frame for the duration of the effect, if required.\r\n *\r\n * @class Flash\r\n * @memberof Phaser.Cameras.Scene2D.Effects\r\n * @constructor\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\r\n */\r\nvar Flash = new Class({\r\n\r\n    initialize:\r\n\r\n    function Flash (camera)\r\n    {\r\n        /**\r\n         * The Camera this effect belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @readonly\r\n         * @since 3.5.0\r\n         */\r\n        this.camera = camera;\r\n\r\n        /**\r\n         * Is this effect actively running?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#isRunning\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * The duration of the effect, in milliseconds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#duration\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 0\r\n         * @since 3.5.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The value of the red color channel the camera will use for the flash effect.\r\n         * A value between 0 and 255.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#red\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this.red = 0;\r\n\r\n        /**\r\n         * The value of the green color channel the camera will use for the flash effect.\r\n         * A value between 0 and 255.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#green\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this.green = 0;\r\n\r\n        /**\r\n         * The value of the blue color channel the camera will use for the flash effect.\r\n         * A value between 0 and 255.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#blue\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this.blue = 0;\r\n\r\n        /**\r\n         * The value of the alpha channel used during the flash effect.\r\n         * A value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#alpha\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this.alpha = 0;\r\n\r\n        /**\r\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#progress\r\n         * @type {number}\r\n         * @since 3.5.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Effect elapsed timer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * This callback is invoked every frame for the duration of the effect.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#_onUpdate\r\n         * @type {?Phaser.Types.Cameras.Scene2D.CameraFlashCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * On Complete callback scope.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Flash#_onUpdateScope\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdateScope;\r\n    },\r\n\r\n    /**\r\n     * Flashes the Camera to or from the given color over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#start\r\n     * @fires Phaser.Cameras.Scene2D.Events#FLASH_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} [duration=250] - The duration of the effect in milliseconds.\r\n     * @param {number} [red=255] - The amount to flash the red channel towards. A value between 0 and 255.\r\n     * @param {number} [green=255] - The amount to flash the green channel towards. A value between 0 and 255.\r\n     * @param {number} [blue=255] - The amount to flash the blue channel towards. A value between 0 and 255.\r\n     * @param {boolean} [force=false] - Force the effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraFlashCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\r\n     */\r\n    start: function (duration, red, green, blue, force, callback, context)\r\n    {\r\n        if (duration === undefined) { duration = 250; }\r\n        if (red === undefined) { red = 255; }\r\n        if (green === undefined) { green = 255; }\r\n        if (blue === undefined) { blue = 255; }\r\n        if (force === undefined) { force = false; }\r\n        if (callback === undefined) { callback = null; }\r\n        if (context === undefined) { context = this.camera.scene; }\r\n\r\n        if (!force && this.isRunning)\r\n        {\r\n            return this.camera;\r\n        }\r\n\r\n        this.isRunning = true;\r\n        this.duration = duration;\r\n        this.progress = 0;\r\n\r\n        this.red = red;\r\n        this.green = green;\r\n        this.blue = blue;\r\n        this.alpha = 1;\r\n\r\n        this._elapsed = 0;\r\n\r\n        this._onUpdate = callback;\r\n        this._onUpdateScope = context;\r\n\r\n        this.camera.emit(Events.FLASH_START, this.camera, this, duration, red, green, blue);\r\n\r\n        return this.camera;\r\n    },\r\n\r\n    /**\r\n     * The main update loop for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#update\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._elapsed += delta;\r\n\r\n        this.progress = Clamp(this._elapsed / this.duration, 0, 1);\r\n\r\n        if (this._onUpdate)\r\n        {\r\n            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);\r\n        }\r\n\r\n        if (this._elapsed < this.duration)\r\n        {\r\n            this.alpha = 1 - this.progress;\r\n        }\r\n        else\r\n        {\r\n            this.effectComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called internally by the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#postRenderCanvas\r\n     * @since 3.5.0\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx - The Canvas context to render to.\r\n     *\r\n     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.\r\n     */\r\n    postRenderCanvas: function (ctx)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var camera = this.camera;\r\n\r\n        ctx.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')';\r\n        ctx.fillRect(camera.x, camera.y, camera.width, camera.height);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Called internally by the WebGL Renderer.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#postRenderWebGL\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.Pipelines.MultiPipeline} pipeline - The WebGL Pipeline to render to. Must provide the `drawFillRect` method.\r\n     * @param {function} getTintFunction - A function that will return the gl safe tint colors.\r\n     *\r\n     * @return {boolean} `true` if the effect drew to the renderer, otherwise `false`.\r\n     */\r\n    postRenderWebGL: function (pipeline, getTintFunction)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var camera = this.camera;\r\n        var red = this.red / 255;\r\n        var green = this.green / 255;\r\n        var blue = this.blue / 255;\r\n\r\n        pipeline.drawFillRect(\r\n            camera.x, camera.y, camera.width, camera.height,\r\n            getTintFunction(blue, green, red, 1),\r\n            this.alpha\r\n        );\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Called internally when the effect completes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#effectComplete\r\n     * @fires Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE\r\n     * @since 3.5.0\r\n     */\r\n    effectComplete: function ()\r\n    {\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        this.isRunning = false;\r\n\r\n        this.camera.emit(Events.FLASH_COMPLETE, this.camera, this);\r\n    },\r\n\r\n    /**\r\n     * Resets this camera effect.\r\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#reset\r\n     * @since 3.5.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.isRunning = false;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n    },\r\n\r\n    /**\r\n     * Destroys this effect, releasing it from the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Flash#destroy\r\n     * @since 3.5.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.camera = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Flash;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Class = require('../../../utils/Class');\r\nvar EaseMap = require('../../../math/easing/EaseMap');\r\nvar Events = require('../events');\r\nvar Vector2 = require('../../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera Pan effect.\r\n *\r\n * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,\r\n * over the duration and with the ease specified.\r\n *\r\n * Only the camera scroll is moved. None of the objects it is displaying are impacted, i.e. their positions do\r\n * not change.\r\n *\r\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\r\n * which is invoked each frame for the duration of the effect if required.\r\n *\r\n * @class Pan\r\n * @memberof Phaser.Cameras.Scene2D.Effects\r\n * @constructor\r\n * @since 3.11.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\r\n */\r\nvar Pan = new Class({\r\n\r\n    initialize:\r\n\r\n    function Pan (camera)\r\n    {\r\n        /**\r\n         * The Camera this effect belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.camera = camera;\r\n\r\n        /**\r\n         * Is this effect actively running?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#isRunning\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.11.0\r\n         */\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * The duration of the effect, in milliseconds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#duration\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The starting scroll coordinates to pan the camera from.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#source\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.11.0\r\n         */\r\n        this.source = new Vector2();\r\n\r\n        /**\r\n         * The constantly updated value based on zoom.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#current\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.11.0\r\n         */\r\n        this.current = new Vector2();\r\n\r\n        /**\r\n         * The destination scroll coordinates to pan the camera to.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#destination\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.11.0\r\n         */\r\n        this.destination = new Vector2();\r\n\r\n        /**\r\n         * The ease function to use during the pan.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#ease\r\n         * @type {function}\r\n         * @since 3.11.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#progress\r\n         * @type {number}\r\n         * @since 3.11.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Effect elapsed timer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * This callback is invoked every frame for the duration of the effect.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#_onUpdate\r\n         * @type {?Phaser.Types.Cameras.Scene2D.CameraPanCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.11.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * On Complete callback scope.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Pan#_onUpdateScope\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._onUpdateScope;\r\n    },\r\n\r\n    /**\r\n     * This effect will scroll the Camera so that the center of its viewport finishes at the given destination,\r\n     * over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Pan#start\r\n     * @fires Phaser.Cameras.Scene2D.Events#PAN_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The destination x coordinate to scroll the center of the Camera viewport to.\r\n     * @param {number} y - The destination y coordinate to scroll the center of the Camera viewport to.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the pan. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the pan effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraPanCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * the current camera scroll x coordinate and the current camera scroll y coordinate.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\r\n     */\r\n    start: function (x, y, duration, ease, force, callback, context)\r\n    {\r\n        if (duration === undefined) { duration = 1000; }\r\n        if (ease === undefined) { ease = EaseMap.Linear; }\r\n        if (force === undefined) { force = false; }\r\n        if (callback === undefined) { callback = null; }\r\n        if (context === undefined) { context = this.camera.scene; }\r\n\r\n        var cam = this.camera;\r\n\r\n        if (!force && this.isRunning)\r\n        {\r\n            return cam;\r\n        }\r\n\r\n        this.isRunning = true;\r\n        this.duration = duration;\r\n        this.progress = 0;\r\n\r\n        //  Starting from\r\n        this.source.set(cam.scrollX, cam.scrollY);\r\n\r\n        //  Destination\r\n        this.destination.set(x, y);\r\n\r\n        //  Zoom factored version\r\n        cam.getScroll(x, y, this.current);\r\n\r\n        //  Using this ease\r\n        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))\r\n        {\r\n            this.ease = EaseMap[ease];\r\n        }\r\n        else if (typeof ease === 'function')\r\n        {\r\n            this.ease = ease;\r\n        }\r\n\r\n        this._elapsed = 0;\r\n\r\n        this._onUpdate = callback;\r\n        this._onUpdateScope = context;\r\n\r\n        this.camera.emit(Events.PAN_START, this.camera, this, duration, x, y);\r\n\r\n        return cam;\r\n    },\r\n\r\n    /**\r\n     * The main update loop for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Pan#update\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._elapsed += delta;\r\n\r\n        var progress = Clamp(this._elapsed / this.duration, 0, 1);\r\n\r\n        this.progress = progress;\r\n\r\n        var cam = this.camera;\r\n\r\n        if (this._elapsed < this.duration)\r\n        {\r\n            var v = this.ease(progress);\r\n\r\n            cam.getScroll(this.destination.x, this.destination.y, this.current);\r\n\r\n            var x = this.source.x + ((this.current.x - this.source.x) * v);\r\n            var y = this.source.y + ((this.current.y - this.source.y) * v);\r\n\r\n            cam.setScroll(x, y);\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, cam, progress, x, y);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            cam.centerOn(this.destination.x, this.destination.y);\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, cam, progress, cam.scrollX, cam.scrollY);\r\n            }\r\n    \r\n            this.effectComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called internally when the effect completes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Pan#effectComplete\r\n     * @fires Phaser.Cameras.Scene2D.Events#PAN_COMPLETE\r\n     * @since 3.11.0\r\n     */\r\n    effectComplete: function ()\r\n    {\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        this.isRunning = false;\r\n\r\n        this.camera.emit(Events.PAN_COMPLETE, this.camera, this);\r\n    },\r\n\r\n    /**\r\n     * Resets this camera effect.\r\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Pan#reset\r\n     * @since 3.11.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.isRunning = false;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n    },\r\n\r\n    /**\r\n     * Destroys this effect, releasing it from the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Pan#destroy\r\n     * @since 3.11.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.camera = null;\r\n        this.source = null;\r\n        this.destination = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Pan;\r\n","/**\r\n * @author       Jason Nicholls <nicholls.jason@gmail.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar EaseMap = require('../../../math/easing/EaseMap');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera Rotate effect.\r\n *\r\n * This effect will rotate the Camera so that the its viewport finishes at the given angle in radians,\r\n * over the duration and with the ease specified.\r\n * \r\n * Camera rotation always takes place based on the Camera viewport. By default, rotation happens\r\n * in the center of the viewport. You can adjust this with the `originX` and `originY` properties.\r\n *\r\n * Rotation influences the rendering of _all_ Game Objects visible by this Camera. However, it does not\r\n * rotate the Camera viewport itself, which always remains an axis-aligned rectangle.\r\n *\r\n * Only the camera is rotates. None of the objects it is displaying are impacted, i.e. their positions do\r\n * not change.\r\n *\r\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\r\n * which is invoked each frame for the duration of the effect if required.\r\n *\r\n * @class RotateTo\r\n * @memberof Phaser.Cameras.Scene2D.Effects\r\n * @constructor\r\n * @since 3.23.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\r\n */\r\nvar RotateTo = new Class({\r\n\r\n    initialize:\r\n\r\n    function RotateTo (camera)\r\n    {\r\n        /**\r\n         * The Camera this effect belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @readonly\r\n         * @since 3.23.0\r\n         */\r\n        this.camera = camera;\r\n\r\n        /**\r\n         * Is this effect actively running?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#isRunning\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.23.0\r\n         */\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * The duration of the effect, in milliseconds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#duration\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 0\r\n         * @since 3.23.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The starting angle to rotate the camera from.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#source\r\n         * @type {number}\r\n         * @since 3.23.0\r\n         */\r\n        this.source = 0;\r\n\r\n        /**\r\n         * The constantly updated value based on the force.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#current\r\n         * @type {number}\r\n         * @since 3.23.0\r\n         */\r\n        this.current = 0;\r\n\r\n        /**\r\n         * The destination angle in radians to rotate the camera to.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#destination\r\n         * @type {number}\r\n         * @since 3.23.0\r\n         */\r\n        this.destination = 0;\r\n\r\n        /**\r\n         * The ease function to use during the Rotate.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#ease\r\n         * @type {function}\r\n         * @since 3.23.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#progress\r\n         * @type {number}\r\n         * @since 3.23.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Effect elapsed timer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * @callback CameraRotateCallback\r\n         *\r\n         * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera on which the effect is running.\r\n         * @param {number} progress - The progress of the effect. A value between 0 and 1.\r\n         * @param {number} angle - The Camera's new angle in radians.\r\n         */\r\n\r\n        /**\r\n         * This callback is invoked every frame for the duration of the effect.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_onUpdate\r\n         * @type {?CameraRotateCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.23.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * On Complete callback scope.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#_onUpdateScope\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._onUpdateScope;\r\n\r\n        /**\r\n         * The direction of the rotation.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#clockwise\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.clockwise = true;\r\n\r\n        /**\r\n         * The shortest direction to the target rotation.\r\n         * \r\n         * @name Phaser.Cameras.Scene2D.Effects.RotateTo#shortestPath\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.shortestPath = false;\r\n    },\r\n\r\n    /**\r\n     * This effect will scroll the Camera so that the center of its viewport finishes at the given angle,\r\n     * over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#start\r\n     * @fires Phaser.Cameras.Scene2D.Events#ROTATE_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#ROTATE_COMPLETE\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} radians - The destination angle in radians to rotate the Camera viewport to. If the angle is positive then the rotation is clockwise else anticlockwise\r\n     * @param {boolean} [shortestPath=false] - If shortest path is set to true the camera will rotate in the quickest direction clockwise or anti-clockwise.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the Rotate. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the rotation effect to start immediately, even if already running.\r\n     * @param {CameraRotateCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent four arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * the current camera scroll x coordinate and the current camera scroll y coordinate.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\r\n     */\r\n    start: function (radians, shortestPath, duration, ease, force, callback, context)\r\n    {\r\n        if (duration === undefined) { duration = 1000; }\r\n        if (ease === undefined) { ease = EaseMap.Linear; }\r\n        if (force === undefined) { force = false; }\r\n        if (callback === undefined) { callback = null; }\r\n        if (context === undefined) { context = this.camera.scene; }\r\n        if (shortestPath === undefined) { shortestPath = false; }\r\n\r\n        this.shortestPath = shortestPath;\r\n\r\n        var tmpDestination = radians;\r\n\r\n        if (radians < 0)\r\n        {\r\n            tmpDestination = -1 * radians;\r\n            this.clockwise = false;\r\n        }\r\n        else\r\n        {\r\n            this.clockwise = true;\r\n        }\r\n\r\n        var maxRad = (360 * Math.PI) / 180;\r\n\r\n        tmpDestination = tmpDestination - (Math.floor(tmpDestination / maxRad) * maxRad);\r\n\r\n        var cam = this.camera;\r\n\r\n        if (!force && this.isRunning)\r\n        {\r\n            return cam;\r\n        }\r\n\r\n        this.isRunning = true;\r\n        this.duration = duration;\r\n        this.progress = 0;\r\n\r\n        //  Starting from\r\n        this.source = cam.rotation;\r\n\r\n        //  Destination\r\n        this.destination = tmpDestination;\r\n\r\n        //  Using this ease\r\n        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))\r\n        {\r\n            this.ease = EaseMap[ease];\r\n        }\r\n        else if (typeof ease === 'function')\r\n        {\r\n            this.ease = ease;\r\n        }\r\n\r\n        this._elapsed = 0;\r\n\r\n        this._onUpdate = callback;\r\n        this._onUpdateScope = context;\r\n\r\n\r\n        if (this.shortestPath)\r\n        {\r\n            // The shortest path is true so calculate the quickest direction\r\n            var cwDist = 0;\r\n            var acwDist = 0;\r\n\r\n            if (this.destination > this.source)\r\n            {\r\n                cwDist = Math.abs(this.destination - this.source);\r\n            }\r\n            else\r\n            {\r\n                cwDist = (Math.abs(this.destination + maxRad) - this.source);\r\n            }\r\n\r\n            if (this.source > this.destination)\r\n            {\r\n                acwDist = Math.abs(this.source - this.destination);\r\n            }\r\n            else\r\n            {\r\n                acwDist = (Math.abs(this.source + maxRad) - this.destination);\r\n            }\r\n\r\n            if (cwDist < acwDist)\r\n            {\r\n                this.clockwise = true;\r\n            }\r\n            else if (cwDist > acwDist)\r\n            {\r\n                this.clockwise = false;\r\n            }\r\n        }\r\n\r\n        this.camera.emit(Events.ROTATE_START, this.camera, this, duration, tmpDestination);\r\n\r\n        return cam;\r\n    },\r\n\r\n    /**\r\n     * The main update loop for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#update\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._elapsed += delta;\r\n\r\n        var progress = Clamp(this._elapsed / this.duration, 0, 1);\r\n\r\n        this.progress = progress;\r\n\r\n        var cam = this.camera;\r\n\r\n        if (this._elapsed < this.duration)\r\n        {\r\n            var v = this.ease(progress);\r\n\r\n            this.current = cam.rotation;\r\n            var distance = 0;\r\n            var maxRad = (360 * Math.PI) / 180;\r\n            var target = this.destination;\r\n            var current = this.current;\r\n\r\n            if (this.clockwise === false)\r\n            {\r\n                target = this.current;\r\n                current = this.destination;\r\n            }\r\n\r\n            if (target >= current)\r\n            {\r\n                distance = Math.abs(target - current);\r\n            }\r\n            else\r\n            {\r\n                distance = (Math.abs(target + maxRad) - current);\r\n            }\r\n\r\n            var r = 0;\r\n\r\n            if (this.clockwise)\r\n            {\r\n                r = (cam.rotation + (distance * v));\r\n            }\r\n            else\r\n            {\r\n                r = (cam.rotation - (distance * v));\r\n            }\r\n\r\n            cam.rotation = r;\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, cam, progress, r);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            cam.rotation = this.destination;\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, cam, progress, this.destination);\r\n            }\r\n    \r\n            this.effectComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called internally when the effect completes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#effectComplete\r\n     * @since 3.23.0\r\n     */\r\n    effectComplete: function ()\r\n    {\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        this.isRunning = false;\r\n\r\n        this.camera.emit(Events.ROTATE_COMPLETE, this.camera, this);\r\n    },\r\n\r\n    /**\r\n     * Resets this camera effect.\r\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#reset\r\n     * @since 3.23.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.isRunning = false;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n    },\r\n\r\n    /**\r\n     * Destroys this effect, releasing it from the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.RotateTo#destroy\r\n     * @since 3.23.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.camera = null;\r\n        this.source = null;\r\n        this.destination = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RotateTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar Vector2 = require('../../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera Shake effect.\r\n *\r\n * This effect will shake the camera viewport by a random amount, bounded by the specified intensity, each frame.\r\n *\r\n * Only the camera viewport is moved. None of the objects it is displaying are impacted, i.e. their positions do\r\n * not change.\r\n *\r\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\r\n * which is invoked each frame for the duration of the effect if required.\r\n *\r\n * @class Shake\r\n * @memberof Phaser.Cameras.Scene2D.Effects\r\n * @constructor\r\n * @since 3.5.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\r\n */\r\nvar Shake = new Class({\r\n\r\n    initialize:\r\n\r\n    function Shake (camera)\r\n    {\r\n        /**\r\n         * The Camera this effect belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @readonly\r\n         * @since 3.5.0\r\n         */\r\n        this.camera = camera;\r\n\r\n        /**\r\n         * Is this effect actively running?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#isRunning\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * The duration of the effect, in milliseconds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#duration\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 0\r\n         * @since 3.5.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The intensity of the effect. Use small float values. The default when the effect starts is 0.05.\r\n         * This is a Vector2 object, allowing you to control the shake intensity independently across x and y.\r\n         * You can modify this value while the effect is active to create more varied shake effects.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#intensity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.5.0\r\n         */\r\n        this.intensity = new Vector2();\r\n\r\n        /**\r\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#progress\r\n         * @type {number}\r\n         * @since 3.5.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Effect elapsed timer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * How much to offset the camera by horizontally.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#_offsetX\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._offsetX = 0;\r\n\r\n        /**\r\n         * How much to offset the camera by vertically.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#_offsetY\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._offsetY = 0;\r\n\r\n        /**\r\n         * This callback is invoked every frame for the duration of the effect.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#_onUpdate\r\n         * @type {?Phaser.Types.Cameras.Scene2D.CameraShakeCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * On Complete callback scope.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Shake#_onUpdateScope\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdateScope;\r\n    },\r\n\r\n    /**\r\n     * Shakes the Camera by the given intensity over the duration specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#start\r\n     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} [duration=100] - The duration of the effect in milliseconds.\r\n     * @param {(number|Phaser.Math.Vector2)} [intensity=0.05] - The intensity of the shake.\r\n     * @param {boolean} [force=false] - Force the shake effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraShakeCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\r\n     */\r\n    start: function (duration, intensity, force, callback, context)\r\n    {\r\n        if (duration === undefined) { duration = 100; }\r\n        if (intensity === undefined) { intensity = 0.05; }\r\n        if (force === undefined) { force = false; }\r\n        if (callback === undefined) { callback = null; }\r\n        if (context === undefined) { context = this.camera.scene; }\r\n\r\n        if (!force && this.isRunning)\r\n        {\r\n            return this.camera;\r\n        }\r\n\r\n        this.isRunning = true;\r\n        this.duration = duration;\r\n        this.progress = 0;\r\n\r\n        if (typeof intensity === 'number')\r\n        {\r\n            this.intensity.set(intensity);\r\n        }\r\n        else\r\n        {\r\n            this.intensity.set(intensity.x, intensity.y);\r\n        }\r\n\r\n        this._elapsed = 0;\r\n        this._offsetX = 0;\r\n        this._offsetY = 0;\r\n\r\n        this._onUpdate = callback;\r\n        this._onUpdateScope = context;\r\n\r\n        this.camera.emit(Events.SHAKE_START, this.camera, this, duration, intensity);\r\n\r\n        return this.camera;\r\n    },\r\n\r\n    /**\r\n     * The pre-render step for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#preRender\r\n     * @since 3.5.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        if (this.isRunning)\r\n        {\r\n            this.camera.matrix.translate(this._offsetX, this._offsetY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The main update loop for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#update\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._elapsed += delta;\r\n\r\n        this.progress = Clamp(this._elapsed / this.duration, 0, 1);\r\n\r\n        if (this._onUpdate)\r\n        {\r\n            this._onUpdate.call(this._onUpdateScope, this.camera, this.progress);\r\n        }\r\n\r\n        if (this._elapsed < this.duration)\r\n        {\r\n            var intensity = this.intensity;\r\n            var width = this.camera.width;\r\n            var height = this.camera.height;\r\n            var zoom = this.camera.zoom;\r\n\r\n            this._offsetX = (Math.random() * intensity.x * width * 2 - intensity.x * width) * zoom;\r\n            this._offsetY = (Math.random() * intensity.y * height * 2 - intensity.y * height) * zoom;\r\n\r\n            if (this.camera.roundPixels)\r\n            {\r\n                this._offsetX = Math.round(this._offsetX);\r\n                this._offsetY = Math.round(this._offsetY);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.effectComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called internally when the effect completes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#effectComplete\r\n     * @fires Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE\r\n     * @since 3.5.0\r\n     */\r\n    effectComplete: function ()\r\n    {\r\n        this._offsetX = 0;\r\n        this._offsetY = 0;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        this.isRunning = false;\r\n\r\n        this.camera.emit(Events.SHAKE_COMPLETE, this.camera, this);\r\n    },\r\n\r\n    /**\r\n     * Resets this camera effect.\r\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#reset\r\n     * @since 3.5.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.isRunning = false;\r\n\r\n        this._offsetX = 0;\r\n        this._offsetY = 0;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n    },\r\n\r\n    /**\r\n     * Destroys this effect, releasing it from the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Shake#destroy\r\n     * @since 3.5.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.camera = null;\r\n        this.intensity = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shake;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Class = require('../../../utils/Class');\r\nvar EaseMap = require('../../../math/easing/EaseMap');\r\nvar Events = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A Camera Zoom effect.\r\n *\r\n * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.\r\n *\r\n * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,\r\n * which is invoked each frame for the duration of the effect if required.\r\n *\r\n * @class Zoom\r\n * @memberof Phaser.Cameras.Scene2D.Effects\r\n * @constructor\r\n * @since 3.11.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera this effect is acting upon.\r\n */\r\nvar Zoom = new Class({\r\n\r\n    initialize:\r\n\r\n    function Zoom (camera)\r\n    {\r\n        /**\r\n         * The Camera this effect belongs to.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.camera = camera;\r\n\r\n        /**\r\n         * Is this effect actively running?\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#isRunning\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.11.0\r\n         */\r\n        this.isRunning = false;\r\n\r\n        /**\r\n         * The duration of the effect, in milliseconds.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#duration\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The starting zoom value;\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#source\r\n         * @type {number}\r\n         * @since 3.11.0\r\n         */\r\n        this.source = 1;\r\n\r\n        /**\r\n         * The destination zoom value.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#destination\r\n         * @type {number}\r\n         * @since 3.11.0\r\n         */\r\n        this.destination = 1;\r\n\r\n        /**\r\n         * The ease function to use during the zoom.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#ease\r\n         * @type {function}\r\n         * @since 3.11.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#progress\r\n         * @type {number}\r\n         * @since 3.11.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Effect elapsed timer.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * This callback is invoked every frame for the duration of the effect.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_onUpdate\r\n         * @type {?Phaser.Types.Cameras.Scene2D.CameraZoomCallback}\r\n         * @private\r\n         * @default null\r\n         * @since 3.11.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * On Complete callback scope.\r\n         *\r\n         * @name Phaser.Cameras.Scene2D.Effects.Zoom#_onUpdateScope\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._onUpdateScope;\r\n    },\r\n\r\n    /**\r\n     * This effect will zoom the Camera to the given scale, over the duration and with the ease specified.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Zoom#start\r\n     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_START\r\n     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} zoom - The target Camera zoom value.\r\n     * @param {number} [duration=1000] - The duration of the effect in milliseconds.\r\n     * @param {(string|function)} [ease='Linear'] - The ease to use for the Zoom. Can be any of the Phaser Easing constants or a custom function.\r\n     * @param {boolean} [force=false] - Force the zoom effect to start immediately, even if already running.\r\n     * @param {Phaser.Types.Cameras.Scene2D.CameraZoomCallback} [callback] - This callback will be invoked every frame for the duration of the effect.\r\n     * It is sent three arguments: A reference to the camera, a progress amount between 0 and 1 indicating how complete the effect is,\r\n     * and the current camera zoom value.\r\n     * @param {any} [context] - The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.\r\n     *\r\n     * @return {Phaser.Cameras.Scene2D.Camera} The Camera on which the effect was started.\r\n     */\r\n    start: function (zoom, duration, ease, force, callback, context)\r\n    {\r\n        if (duration === undefined) { duration = 1000; }\r\n        if (ease === undefined) { ease = EaseMap.Linear; }\r\n        if (force === undefined) { force = false; }\r\n        if (callback === undefined) { callback = null; }\r\n        if (context === undefined) { context = this.camera.scene; }\r\n\r\n        var cam = this.camera;\r\n\r\n        if (!force && this.isRunning)\r\n        {\r\n            return cam;\r\n        }\r\n\r\n        this.isRunning = true;\r\n        this.duration = duration;\r\n        this.progress = 0;\r\n\r\n        //  Starting from\r\n        this.source = cam.zoom;\r\n\r\n        //  Zooming to\r\n        this.destination = zoom;\r\n\r\n        //  Using this ease\r\n        if (typeof ease === 'string' && EaseMap.hasOwnProperty(ease))\r\n        {\r\n            this.ease = EaseMap[ease];\r\n        }\r\n        else if (typeof ease === 'function')\r\n        {\r\n            this.ease = ease;\r\n        }\r\n\r\n        this._elapsed = 0;\r\n\r\n        this._onUpdate = callback;\r\n        this._onUpdateScope = context;\r\n\r\n        this.camera.emit(Events.ZOOM_START, this.camera, this, duration, zoom);\r\n\r\n        return cam;\r\n    },\r\n\r\n    /**\r\n     * The main update loop for this effect. Called automatically by the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Zoom#update\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.isRunning)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._elapsed += delta;\r\n\r\n        this.progress = Clamp(this._elapsed / this.duration, 0, 1);\r\n\r\n        if (this._elapsed < this.duration)\r\n        {\r\n            this.camera.zoom = this.source + ((this.destination - this.source) * this.ease(this.progress));\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.camera.zoom = this.destination;\r\n\r\n            if (this._onUpdate)\r\n            {\r\n                this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination);\r\n            }\r\n\r\n            this.effectComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called internally when the effect completes.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Zoom#effectComplete\r\n     * @fires Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE\r\n     * @since 3.11.0\r\n     */\r\n    effectComplete: function ()\r\n    {\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        this.isRunning = false;\r\n\r\n        this.camera.emit(Events.ZOOM_COMPLETE, this.camera, this);\r\n    },\r\n\r\n    /**\r\n     * Resets this camera effect.\r\n     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Zoom#reset\r\n     * @since 3.11.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.isRunning = false;\r\n\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n    },\r\n\r\n    /**\r\n     * Destroys this effect, releasing it from the Camera.\r\n     *\r\n     * @method Phaser.Cameras.Scene2D.Effects.Zoom#destroy\r\n     * @since 3.11.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.camera = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Zoom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras.Scene2D.Effects\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Fade: require('./Fade'),\r\n    Flash: require('./Flash'),\r\n    Pan: require('./Pan'),\r\n    Shake: require('./Shake'),\r\n    RotateTo: require('./RotateTo'),\r\n    Zoom: require('./Zoom')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Destroy Camera Event.\r\n * \r\n * This event is dispatched by a Camera instance when it is destroyed by the Camera Manager.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#DESTROY\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that was destroyed.\r\n */\r\nmodule.exports = 'cameradestroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Fade In Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Fade In Effect completes.\r\n * \r\n * Listen to it from a Camera instance using `Camera.on('camerafadeincomplete', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FADE_IN_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerafadeincomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Fade In Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Fade In Effect starts.\r\n * \r\n * Listen to it from a Camera instance using `Camera.on('camerafadeinstart', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FADE_IN_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} red - The red color channel value.\r\n * @param {number} green - The green color channel value.\r\n * @param {number} blue - The blue color channel value.\r\n */\r\nmodule.exports = 'camerafadeinstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Fade Out Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Fade Out Effect completes.\r\n * \r\n * Listen to it from a Camera instance using `Camera.on('camerafadeoutcomplete', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FADE_OUT_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerafadeoutcomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Fade Out Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Fade Out Effect starts.\r\n * \r\n * Listen to it from a Camera instance using `Camera.on('camerafadeoutstart', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FADE_OUT_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Fade} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} red - The red color channel value.\r\n * @param {number} green - The green color channel value.\r\n * @param {number} blue - The blue color channel value.\r\n */\r\nmodule.exports = 'camerafadeoutstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Flash Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Flash Effect completes.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FLASH_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Flash} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'cameraflashcomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Flash Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Flash Effect starts.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FLASH_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Flash} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} red - The red color channel value.\r\n * @param {number} green - The green color channel value.\r\n * @param {number} blue - The blue color channel value.\r\n */\r\nmodule.exports = 'cameraflashstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Follower Update Event.\r\n *\r\n * This event is dispatched by a Camera instance when it is following a\r\n * Game Object and the Camera position has been updated as a result of\r\n * that following.\r\n *\r\n * Listen to it from a Camera instance using: `camera.on('followupdate', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#FOLLOW_UPDATE\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that emitted the event.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object the camera is following.\r\n */\r\nmodule.exports = 'followupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Pan Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Pan Effect completes.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#PAN_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Pan} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerapancomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Pan Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Pan Effect starts.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#PAN_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Pan} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} x - The destination scroll x coordinate.\r\n * @param {number} y - The destination scroll y coordinate.\r\n */\r\nmodule.exports = 'camerapanstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Post-Render Event.\r\n * \r\n * This event is dispatched by a Camera instance after is has finished rendering.\r\n * It is only dispatched if the Camera is rendering to a texture.\r\n * \r\n * Listen to it from a Camera instance using: `camera.on('postrender', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#POST_RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that has finished rendering to a texture.\r\n */\r\nmodule.exports = 'postrender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Pre-Render Event.\r\n * \r\n * This event is dispatched by a Camera instance when it is about to render.\r\n * It is only dispatched if the Camera is rendering to a texture.\r\n * \r\n * Listen to it from a Camera instance using: `camera.on('prerender', listener)`.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#PRE_RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.BaseCamera} camera - The camera that is about to render to a texture.\r\n */\r\nmodule.exports = 'prerender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Rotate Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Rotate Effect completes.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#ROTATE_COMPLETE\r\n * @since 3.23.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.RotateTo} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerarotatecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Rotate Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Rotate Effect starts.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#ROTATE_START\r\n * @since 3.23.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.RotateTo} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} destination - The destination value.\r\n */\r\nmodule.exports = 'camerarotatestart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Shake Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Shake Effect completes.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#SHAKE_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Shake} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerashakecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Shake Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Shake Effect starts.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#SHAKE_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Shake} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} intensity - The intensity of the effect.\r\n */\r\nmodule.exports = 'camerashakestart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Zoom Complete Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Zoom Effect completes.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#ZOOM_COMPLETE\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Zoom} effect - A reference to the effect instance.\r\n */\r\nmodule.exports = 'camerazoomcomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Camera Zoom Start Event.\r\n * \r\n * This event is dispatched by a Camera instance when the Zoom Effect starts.\r\n *\r\n * @event Phaser.Cameras.Scene2D.Events#ZOOM_START\r\n * @since 3.3.0\r\n * \r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera that the effect began on.\r\n * @param {Phaser.Cameras.Scene2D.Effects.Zoom} effect - A reference to the effect instance.\r\n * @param {number} duration - The duration of the effect.\r\n * @param {number} zoom - The destination zoom value.\r\n */\r\nmodule.exports = 'camerazoomstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras.Scene2D.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    FADE_IN_COMPLETE: require('./FADE_IN_COMPLETE_EVENT'),\r\n    FADE_IN_START: require('./FADE_IN_START_EVENT'),\r\n    FADE_OUT_COMPLETE: require('./FADE_OUT_COMPLETE_EVENT'),\r\n    FADE_OUT_START: require('./FADE_OUT_START_EVENT'),\r\n    FLASH_COMPLETE: require('./FLASH_COMPLETE_EVENT'),\r\n    FLASH_START: require('./FLASH_START_EVENT'),\r\n    FOLLOW_UPDATE: require('./FOLLOW_UPDATE_EVENT'),\r\n    PAN_COMPLETE: require('./PAN_COMPLETE_EVENT'),\r\n    PAN_START: require('./PAN_START_EVENT'),\r\n    POST_RENDER: require('./POST_RENDER_EVENT'),\r\n    PRE_RENDER: require('./PRE_RENDER_EVENT'),\r\n    ROTATE_COMPLETE: require('./ROTATE_COMPLETE_EVENT'),\r\n    ROTATE_START: require('./ROTATE_START_EVENT'),\r\n    SHAKE_COMPLETE: require('./SHAKE_COMPLETE_EVENT'),\r\n    SHAKE_START: require('./SHAKE_START_EVENT'),\r\n    ZOOM_COMPLETE: require('./ZOOM_COMPLETE_EVENT'),\r\n    ZOOM_START: require('./ZOOM_START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras.Scene2D\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Camera: require('./Camera'),\r\n    BaseCamera: require('./BaseCamera'),\r\n    CameraManager: require('./CameraManager'),\r\n    Effects: require('./effects'),\r\n    Events: require('./events')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetValue = require('../../utils/object/GetValue');\r\n\r\n/**\r\n * @classdesc\r\n * A Fixed Key Camera Control.\r\n *\r\n * This allows you to control the movement and zoom of a camera using the defined keys.\r\n *\r\n * ```javascript\r\n * var camControl = new FixedKeyControl({\r\n *     camera: this.cameras.main,\r\n *     left: cursors.left,\r\n *     right: cursors.right,\r\n *     speed: float OR { x: 0, y: 0 }\r\n * });\r\n * ```\r\n *\r\n * Movement is precise and has no 'smoothing' applied to it.\r\n *\r\n * You must call the `update` method of this controller every frame.\r\n *\r\n * @class FixedKeyControl\r\n * @memberof Phaser.Cameras.Controls\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Cameras.Controls.FixedKeyControlConfig} config - The Fixed Key Control configuration object.\r\n */\r\nvar FixedKeyControl = new Class({\r\n\r\n    initialize:\r\n\r\n    function FixedKeyControl (config)\r\n    {\r\n        /**\r\n         * The Camera that this Control will update.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#camera\r\n         * @type {?Phaser.Cameras.Scene2D.Camera}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.camera = GetValue(config, 'camera', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera left.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#left\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.left = GetValue(config, 'left', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera right.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#right\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.right = GetValue(config, 'right', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera up.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#up\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.up = GetValue(config, 'up', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera down.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#down\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.down = GetValue(config, 'down', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will zoom the Camera in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomIn\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomIn = GetValue(config, 'zoomIn', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will zoom the Camera out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomOut\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomOut = GetValue(config, 'zoomOut', null);\r\n\r\n        /**\r\n         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#zoomSpeed\r\n         * @type {number}\r\n         * @default 0.01\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);\r\n\r\n        /**\r\n         * The smallest zoom value the camera will reach when zoomed out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#minZoom\r\n         * @type {number}\r\n         * @default 0.001\r\n         * @since 3.53.0\r\n         */\r\n        this.minZoom = GetValue(config, 'minZoom', 0.001);\r\n\r\n        /**\r\n         * The largest zoom value the camera will reach when zoomed in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#maxZoom\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.53.0\r\n         */\r\n        this.maxZoom = GetValue(config, 'maxZoom', 1000);\r\n\r\n        /**\r\n         * The horizontal speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#speedX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.speedX = 0;\r\n\r\n        /**\r\n         * The vertical speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#speedY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.speedY = 0;\r\n\r\n        var speed = GetValue(config, 'speed', null);\r\n\r\n        if (typeof speed === 'number')\r\n        {\r\n            this.speedX = speed;\r\n            this.speedY = speed;\r\n        }\r\n        else\r\n        {\r\n            this.speedX = GetValue(config, 'speed.x', 0);\r\n            this.speedY = GetValue(config, 'speed.y', 0);\r\n        }\r\n\r\n        /**\r\n         * Internal property to track the current zoom level.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._zoom = 0;\r\n\r\n        /**\r\n         * A flag controlling if the Controls will update the Camera or not.\r\n         *\r\n         * @name Phaser.Cameras.Controls.FixedKeyControl#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.active = (this.camera !== null);\r\n    },\r\n\r\n    /**\r\n     * Starts the Key Control running, providing it has been linked to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    start: function ()\r\n    {\r\n        this.active = (this.camera !== null);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops this Key Control from running. Call `start` to start it again.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds this Key Control to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#setCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    setCamera: function (camera)\r\n    {\r\n        this.camera = camera;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Applies the results of pressing the control keys to the Camera.\r\n     *\r\n     * You must call this every step, it is not called automatically.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (delta)\r\n    {\r\n        if (!this.active)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (delta === undefined) { delta = 1; }\r\n\r\n        var cam = this.camera;\r\n\r\n        if (this.up && this.up.isDown)\r\n        {\r\n            cam.scrollY -= ((this.speedY * delta) | 0);\r\n        }\r\n        else if (this.down && this.down.isDown)\r\n        {\r\n            cam.scrollY += ((this.speedY * delta) | 0);\r\n        }\r\n\r\n        if (this.left && this.left.isDown)\r\n        {\r\n            cam.scrollX -= ((this.speedX * delta) | 0);\r\n        }\r\n        else if (this.right && this.right.isDown)\r\n        {\r\n            cam.scrollX += ((this.speedX * delta) | 0);\r\n        }\r\n\r\n        //  Camera zoom\r\n\r\n        if (this.zoomIn && this.zoomIn.isDown)\r\n        {\r\n            cam.zoom -= this.zoomSpeed;\r\n\r\n            if (cam.zoom < this.minZoom)\r\n            {\r\n                cam.zoom = this.minZoom;\r\n            }\r\n        }\r\n        else if (this.zoomOut && this.zoomOut.isDown)\r\n        {\r\n            cam.zoom += this.zoomSpeed;\r\n\r\n            if (cam.zoom > this.maxZoom)\r\n            {\r\n                cam.zoom = this.maxZoom;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Control.\r\n     *\r\n     * @method Phaser.Cameras.Controls.FixedKeyControl#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.camera = null;\r\n\r\n        this.left = null;\r\n        this.right = null;\r\n        this.up = null;\r\n        this.down = null;\r\n\r\n        this.zoomIn = null;\r\n        this.zoomOut = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = FixedKeyControl;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetValue = require('../../utils/object/GetValue');\r\n\r\n/**\r\n * @classdesc\r\n * A Smoothed Key Camera Control.\r\n *\r\n * This allows you to control the movement and zoom of a camera using the defined keys.\r\n * Unlike the Fixed Camera Control you can also provide physics values for acceleration, drag and maxSpeed for smoothing effects.\r\n *\r\n * ```javascript\r\n * var controlConfig = {\r\n *     camera: this.cameras.main,\r\n *     left: cursors.left,\r\n *     right: cursors.right,\r\n *     up: cursors.up,\r\n *     down: cursors.down,\r\n *     zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),\r\n *     zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),\r\n *     zoomSpeed: 0.02,\r\n *     acceleration: 0.06,\r\n *     drag: 0.0005,\r\n *     maxSpeed: 1.0\r\n * };\r\n * ```\r\n *\r\n * You must call the `update` method of this controller every frame.\r\n *\r\n * @class SmoothedKeyControl\r\n * @memberof Phaser.Cameras.Controls\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Cameras.Controls.SmoothedKeyControlConfig} config - The Smoothed Key Control configuration object.\r\n */\r\nvar SmoothedKeyControl = new Class({\r\n\r\n    initialize:\r\n\r\n    function SmoothedKeyControl (config)\r\n    {\r\n        /**\r\n         * The Camera that this Control will update.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#camera\r\n         * @type {?Phaser.Cameras.Scene2D.Camera}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.camera = GetValue(config, 'camera', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera left.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#left\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.left = GetValue(config, 'left', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera right.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#right\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.right = GetValue(config, 'right', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera up.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#up\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.up = GetValue(config, 'up', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will move the Camera down.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#down\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.down = GetValue(config, 'down', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will zoom the Camera in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomIn\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomIn = GetValue(config, 'zoomIn', null);\r\n\r\n        /**\r\n         * The Key to be pressed that will zoom the Camera out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomOut\r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomOut = GetValue(config, 'zoomOut', null);\r\n\r\n        /**\r\n         * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#zoomSpeed\r\n         * @type {number}\r\n         * @default 0.01\r\n         * @since 3.0.0\r\n         */\r\n        this.zoomSpeed = GetValue(config, 'zoomSpeed', 0.01);\r\n\r\n        /**\r\n         * The smallest zoom value the camera will reach when zoomed out.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#minZoom\r\n         * @type {number}\r\n         * @default 0.001\r\n         * @since 3.53.0\r\n         */\r\n        this.minZoom = GetValue(config, 'minZoom', 0.001);\r\n\r\n        /**\r\n         * The largest zoom value the camera will reach when zoomed in.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxZoom\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.53.0\r\n         */\r\n        this.maxZoom = GetValue(config, 'maxZoom', 1000);\r\n\r\n        /**\r\n         * The horizontal acceleration the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelX = 0;\r\n\r\n        /**\r\n         * The vertical acceleration the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#accelY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelY = 0;\r\n\r\n        var accel = GetValue(config, 'acceleration', null);\r\n\r\n        if (typeof accel === 'number')\r\n        {\r\n            this.accelX = accel;\r\n            this.accelY = accel;\r\n        }\r\n        else\r\n        {\r\n            this.accelX = GetValue(config, 'acceleration.x', 0);\r\n            this.accelY = GetValue(config, 'acceleration.y', 0);\r\n        }\r\n\r\n        /**\r\n         * The horizontal drag applied to the camera when it is moving.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragX = 0;\r\n\r\n        /**\r\n         * The vertical drag applied to the camera when it is moving.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#dragY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragY = 0;\r\n\r\n        var drag = GetValue(config, 'drag', null);\r\n\r\n        if (typeof drag === 'number')\r\n        {\r\n            this.dragX = drag;\r\n            this.dragY = drag;\r\n        }\r\n        else\r\n        {\r\n            this.dragX = GetValue(config, 'drag.x', 0);\r\n            this.dragY = GetValue(config, 'drag.y', 0);\r\n        }\r\n\r\n        /**\r\n         * The maximum horizontal speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxSpeedX = 0;\r\n\r\n        /**\r\n         * The maximum vertical speed the camera will move.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#maxSpeedY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxSpeedY = 0;\r\n\r\n        var maxSpeed = GetValue(config, 'maxSpeed', null);\r\n\r\n        if (typeof maxSpeed === 'number')\r\n        {\r\n            this.maxSpeedX = maxSpeed;\r\n            this.maxSpeedY = maxSpeed;\r\n        }\r\n        else\r\n        {\r\n            this.maxSpeedX = GetValue(config, 'maxSpeed.x', 0);\r\n            this.maxSpeedY = GetValue(config, 'maxSpeed.y', 0);\r\n        }\r\n\r\n        /**\r\n         * Internal property to track the speed of the control.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedX\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._speedX = 0;\r\n\r\n        /**\r\n         * Internal property to track the speed of the control.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_speedY\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._speedY = 0;\r\n\r\n        /**\r\n         * Internal property to track the zoom of the control.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._zoom = 0;\r\n\r\n        /**\r\n         * A flag controlling if the Controls will update the Camera or not.\r\n         *\r\n         * @name Phaser.Cameras.Controls.SmoothedKeyControl#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.active = (this.camera !== null);\r\n    },\r\n\r\n    /**\r\n     * Starts the Key Control running, providing it has been linked to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    start: function ()\r\n    {\r\n        this.active = (this.camera !== null);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops this Key Control from running. Call `start` to start it again.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds this Key Control to a camera.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#setCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera to bind this Key Control to.\r\n     *\r\n     * @return {this} This Key Control instance.\r\n     */\r\n    setCamera: function (camera)\r\n    {\r\n        this.camera = camera;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Applies the results of pressing the control keys to the Camera.\r\n     *\r\n     * You must call this every step, it is not called automatically.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (delta)\r\n    {\r\n        if (!this.active)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (delta === undefined) { delta = 1; }\r\n\r\n        var cam = this.camera;\r\n\r\n        //  Apply Deceleration\r\n\r\n        if (this._speedX > 0)\r\n        {\r\n            this._speedX -= this.dragX * delta;\r\n\r\n            if (this._speedX < 0)\r\n            {\r\n                this._speedX = 0;\r\n            }\r\n        }\r\n        else if (this._speedX < 0)\r\n        {\r\n            this._speedX += this.dragX * delta;\r\n\r\n            if (this._speedX > 0)\r\n            {\r\n                this._speedX = 0;\r\n            }\r\n        }\r\n\r\n        if (this._speedY > 0)\r\n        {\r\n            this._speedY -= this.dragY * delta;\r\n\r\n            if (this._speedY < 0)\r\n            {\r\n                this._speedY = 0;\r\n            }\r\n        }\r\n        else if (this._speedY < 0)\r\n        {\r\n            this._speedY += this.dragY * delta;\r\n\r\n            if (this._speedY > 0)\r\n            {\r\n                this._speedY = 0;\r\n            }\r\n        }\r\n\r\n        //  Check for keys\r\n\r\n        if (this.up && this.up.isDown)\r\n        {\r\n            this._speedY += this.accelY;\r\n\r\n            if (this._speedY > this.maxSpeedY)\r\n            {\r\n                this._speedY = this.maxSpeedY;\r\n            }\r\n        }\r\n        else if (this.down && this.down.isDown)\r\n        {\r\n            this._speedY -= this.accelY;\r\n\r\n            if (this._speedY < -this.maxSpeedY)\r\n            {\r\n                this._speedY = -this.maxSpeedY;\r\n            }\r\n        }\r\n\r\n        if (this.left && this.left.isDown)\r\n        {\r\n            this._speedX += this.accelX;\r\n\r\n            if (this._speedX > this.maxSpeedX)\r\n            {\r\n                this._speedX = this.maxSpeedX;\r\n            }\r\n        }\r\n        else if (this.right && this.right.isDown)\r\n        {\r\n            this._speedX -= this.accelX;\r\n\r\n            if (this._speedX < -this.maxSpeedX)\r\n            {\r\n                this._speedX = -this.maxSpeedX;\r\n            }\r\n        }\r\n\r\n        //  Camera zoom\r\n\r\n        if (this.zoomIn && this.zoomIn.isDown)\r\n        {\r\n            this._zoom = -this.zoomSpeed;\r\n        }\r\n        else if (this.zoomOut && this.zoomOut.isDown)\r\n        {\r\n            this._zoom = this.zoomSpeed;\r\n        }\r\n        else\r\n        {\r\n            this._zoom = 0;\r\n        }\r\n\r\n        //  Apply to Camera\r\n\r\n        if (this._speedX !== 0)\r\n        {\r\n            cam.scrollX -= ((this._speedX * delta) | 0);\r\n        }\r\n\r\n        if (this._speedY !== 0)\r\n        {\r\n            cam.scrollY -= ((this._speedY * delta) | 0);\r\n        }\r\n\r\n        if (this._zoom !== 0)\r\n        {\r\n            cam.zoom += this._zoom;\r\n\r\n            if (cam.zoom < this.minZoom)\r\n            {\r\n                cam.zoom = this.minZoom;\r\n            }\r\n            else if (cam.zoom > this.maxZoom)\r\n            {\r\n                cam.zoom = this.maxZoom;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Control.\r\n     *\r\n     * @method Phaser.Cameras.Controls.SmoothedKeyControl#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.camera = null;\r\n\r\n        this.left = null;\r\n        this.right = null;\r\n        this.up = null;\r\n        this.down = null;\r\n\r\n        this.zoomIn = null;\r\n        this.zoomOut = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SmoothedKeyControl;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras.Controls\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    FixedKeyControl: require('./FixedKeyControl'),\r\n    SmoothedKeyControl: require('./SmoothedKeyControl')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Types.Cameras\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Controls: require('./controls'),\r\n    Scene2D: require('./2d')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// Centers this Rectangle so that the center coordinates match the given x and y values.\r\n\r\n/**\r\n * Moves the top-left corner of a Rectangle so that its center is at the given coordinates.\r\n *\r\n * @function Phaser.Geom.Rectangle.CenterOn\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [rect,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to be centered.\r\n * @param {number} x - The X coordinate of the Rectangle's center.\r\n * @param {number} y - The Y coordinate of the Rectangle's center.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The centered rectangle.\r\n */\r\nvar CenterOn = function (rect, x, y)\r\n{\r\n    rect.x = x - (rect.width / 2);\r\n    rect.y = y - (rect.height / 2);\r\n\r\n    return rect;\r\n};\r\n\r\nmodule.exports = CenterOn;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a linear (interpolation) value over t.\r\n *\r\n * @function Phaser.Math.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} p0 - The first point.\r\n * @param {number} p1 - The second point.\r\n * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.\r\n *\r\n * @return {number} The step t% of the way between p0 and p1.\r\n */\r\nvar Linear = function (p0, p1, t)\r\n{\r\n    return (p1 - p0) * t + p0;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Back = require('./back');\r\nvar Bounce = require('./bounce');\r\nvar Circular = require('./circular');\r\nvar Cubic = require('./cubic');\r\nvar Elastic = require('./elastic');\r\nvar Expo = require('./expo');\r\nvar Linear = require('./linear');\r\nvar Quadratic = require('./quadratic');\r\nvar Quartic = require('./quartic');\r\nvar Quintic = require('./quintic');\r\nvar Sine = require('./sine');\r\nvar Stepped = require('./stepped');\r\n\r\n//  EaseMap\r\nmodule.exports = {\r\n\r\n    Power0: Linear,\r\n    Power1: Quadratic.Out,\r\n    Power2: Cubic.Out,\r\n    Power3: Quartic.Out,\r\n    Power4: Quintic.Out,\r\n\r\n    Linear: Linear,\r\n    Quad: Quadratic.Out,\r\n    Cubic: Cubic.Out,\r\n    Quart: Quartic.Out,\r\n    Quint: Quintic.Out,\r\n    Sine: Sine.Out,\r\n    Expo: Expo.Out,\r\n    Circ: Circular.Out,\r\n    Elastic: Elastic.Out,\r\n    Back: Back.Out,\r\n    Bounce: Bounce.Out,\r\n    Stepped: Stepped,\r\n\r\n    'Quad.easeIn': Quadratic.In,\r\n    'Cubic.easeIn': Cubic.In,\r\n    'Quart.easeIn': Quartic.In,\r\n    'Quint.easeIn': Quintic.In,\r\n    'Sine.easeIn': Sine.In,\r\n    'Expo.easeIn': Expo.In,\r\n    'Circ.easeIn': Circular.In,\r\n    'Elastic.easeIn': Elastic.In,\r\n    'Back.easeIn': Back.In,\r\n    'Bounce.easeIn': Bounce.In,\r\n\r\n    'Quad.easeOut': Quadratic.Out,\r\n    'Cubic.easeOut': Cubic.Out,\r\n    'Quart.easeOut': Quartic.Out,\r\n    'Quint.easeOut': Quintic.Out,\r\n    'Sine.easeOut': Sine.Out,\r\n    'Expo.easeOut': Expo.Out,\r\n    'Circ.easeOut': Circular.Out,\r\n    'Elastic.easeOut': Elastic.Out,\r\n    'Back.easeOut': Back.Out,\r\n    'Bounce.easeOut': Bounce.Out,\r\n\r\n    'Quad.easeInOut': Quadratic.InOut,\r\n    'Cubic.easeInOut': Cubic.InOut,\r\n    'Quart.easeInOut': Quartic.InOut,\r\n    'Quint.easeInOut': Quintic.InOut,\r\n    'Sine.easeInOut': Sine.InOut,\r\n    'Expo.easeInOut': Expo.InOut,\r\n    'Circ.easeInOut': Circular.InOut,\r\n    'Elastic.easeInOut': Elastic.InOut,\r\n    'Back.easeInOut': Back.InOut,\r\n    'Bounce.easeInOut': Bounce.InOut\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager has successfully entered fullscreen mode.\r\n *\r\n * @event Phaser.Scale.Events#ENTER_FULLSCREEN\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'enterfullscreen';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager tried to enter fullscreen mode but failed.\r\n *\r\n * @event Phaser.Scale.Events#FULLSCREEN_FAILED\r\n * @since 3.17.0\r\n */\r\nmodule.exports = 'fullscreenfailed';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager tried to enter fullscreen mode, but it is unsupported by the browser.\r\n *\r\n * @event Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'fullscreenunsupported';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager was in fullscreen mode, but has since left, either directly via game code,\r\n * or via a user gestured, such as pressing the ESC key.\r\n *\r\n * @event Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'leavefullscreen';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Orientation Change Event.\r\n *\r\n * This event is dispatched whenever the Scale Manager detects an orientation change event from the browser.\r\n *\r\n * @event Phaser.Scale.Events#ORIENTATION_CHANGE\r\n * @since 3.16.1\r\n *\r\n * @param {string} orientation - The new orientation value. Either `Phaser.Scale.Orientation.LANDSCAPE` or `Phaser.Scale.Orientation.PORTRAIT`.\r\n */\r\nmodule.exports = 'orientationchange';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Resize Event.\r\n *\r\n * This event is dispatched whenever the Scale Manager detects a resize event from the browser.\r\n * It sends three parameters to the callback, each of them being Size components. You can read\r\n * the `width`, `height`, `aspectRatio` and other properties of these components to help with\r\n * scaling your own game content.\r\n *\r\n * @event Phaser.Scale.Events#RESIZE\r\n * @since 3.16.1\r\n *\r\n * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.\r\n * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size.\r\n * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.\r\n * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.\r\n * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Scale.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ENTER_FULLSCREEN: require('./ENTER_FULLSCREEN_EVENT'),\r\n    FULLSCREEN_FAILED: require('./FULLSCREEN_FAILED_EVENT'),\r\n    FULLSCREEN_UNSUPPORTED: require('./FULLSCREEN_UNSUPPORTED_EVENT'),\r\n    LEAVE_FULLSCREEN: require('./LEAVE_FULLSCREEN_EVENT'),\r\n    ORIENTATION_CHANGE: require('./ORIENTATION_CHANGE_EVENT'),\r\n    RESIZE: require('./RESIZE_EVENT')\r\n\r\n};\r\n"],"names":["BaseCamera","CenterOn","Clamp","Class","Components","Effects","Events","Linear","Rectangle","Vector2","Camera","Extends","Mixins","Flip","Tint","Pipeline","initialize","x","y","width","height","call","this","postPipelines","pipelineData","inputEnabled","fadeEffect","Fade","flashEffect","Flash","shakeEffect","Shake","panEffect","Pan","rotateToEffect","RotateTo","zoomEffect","Zoom","lerp","followOffset","deadzone","_follow","setDeadzone","undefined","originX","originY","fx","fy","midPoint","set","scrollX","scrollY","fadeIn","duration","red","green","blue","callback","context","start","fadeOut","fadeFrom","force","fade","flash","shake","intensity","pan","ease","rotateTo","radians","shortestPath","zoomTo","zoom","preRender","renderList","length","halfWidth","halfHeight","matrix","follow","sx","sy","emitFollowEvent","isRunning","right","bottom","useBounds","clampX","clampY","roundPixels","Math","round","midX","midY","displayWidth","displayHeight","vwx","vwy","worldView","setTo","applyITRS","rotation","translate","emit","FOLLOW_UPDATE","setLerp","setFollowOffset","startFollow","target","lerpX","lerpY","offsetX","offsetY","stopFollow","resetFX","reset","update","time","delta","visible","destroy","prototype","module","exports","GetFastValue","PluginCache","RectangleContains","ScaleEvents","SceneEvents","CameraManager","scene","systems","sys","game","config","cameras","main","default","events","once","BOOT","boot","on","START","settings","fromJSON","add","scale","setScene","RESIZE","onResize","DESTROY","eventEmitter","UPDATE","SHUTDOWN","shutdown","makeMain","name","camera","setName","setRoundPixels","id","getNextID","push","addExisting","indexOf","testID","t","found","i","getTotal","isVisible","total","Array","isArray","gameWidth","gameHeight","cameraConfig","backgroundColor","setBackgroundColor","boundsConfig","bx","by","bwidth","bheight","setBounds","getCamera","getCamerasBelowPointer","pointer","output","unshift","remove","runDestroy","index","splice","render","renderer","displayList","alpha","visibleChildren","getVisibleChildren","getChildren","children","child","willRender","resetAll","gameSize","baseSize","displaySize","previousWidth","previousHeight","cam","_x","_y","_width","_height","setSize","resize","off","register","isComplete","direction","progress","_elapsed","_onUpdate","_onUpdateScope","Number","MIN_VALUE","eventName","FADE_OUT_START","FADE_IN_START","effectComplete","postRenderCanvas","ctx","fillStyle","fillRect","postRenderWebGL","pipeline","getTintFunction","drawFillRect","FADE_OUT_COMPLETE","FADE_IN_COMPLETE","FLASH_START","FLASH_COMPLETE","EaseMap","source","current","destination","getScroll","hasOwnProperty","PAN_START","v","setScroll","centerOn","PAN_COMPLETE","clockwise","tmpDestination","maxRad","PI","floor","cwDist","acwDist","abs","ROTATE_START","distance","r","ROTATE_COMPLETE","_offsetX","_offsetY","SHAKE_START","random","SHAKE_COMPLETE","ZOOM_START","ZOOM_COMPLETE","POST_RENDER","PRE_RENDER","GetValue","FixedKeyControl","left","up","down","zoomIn","zoomOut","zoomSpeed","minZoom","maxZoom","speedX","speedY","speed","_zoom","active","stop","setCamera","isDown","SmoothedKeyControl","accelX","accelY","accel","dragX","dragY","drag","maxSpeedX","maxSpeedY","maxSpeed","_speedX","_speedY","Controls","Scene2D","rect","p0","p1","Back","Bounce","Circular","Cubic","Elastic","Expo","Quadratic","Quartic","Quintic","Sine","Stepped","Power0","Power1","Out","Power2","Power3","Power4","Quad","Quart","Quint","Circ","In","InOut","corePlugins","customPlugins","key","plugin","mapping","custom","data","ENTER_FULLSCREEN","FULLSCREEN_FAILED","FULLSCREEN_UNSUPPORTED","LEAVE_FULLSCREEN","ORIENTATION_CHANGE"],"sourceRoot":""}