{"version":3,"file":"js/phaser-loader.a8f25774db845d9d7e3f.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/eventemitter3/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/color/GetColor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/shader/BaseShader.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/dom/ParseXML.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/ParseObj.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/ParseObjMaterial.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/File.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/FileTypesManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/GetURL.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/LoaderPlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/MergeXHRSettings.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/MultiFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/XHRLoader.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/XHRSettings.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_LOAD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/FILE_PROGRESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/POST_PROCESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/PROGRESS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AnimationJSONFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AsepriteFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AtlasXMLFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AudioFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/AudioSpriteFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/BinaryFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/BitmapFontFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/CSSFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/GLSLFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/HTML5AudioFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/HTMLFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/HTMLTextureFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/ImageFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/JSONFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/MultiAtlasFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/MultiScriptFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/OBJFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/PackFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/PluginFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/SVGFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/SceneFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/ScenePluginFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/ScriptFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/SpriteSheetFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/TextFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/TilemapCSVFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/TilemapImpactFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/TilemapJSONFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/UnityAtlasFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/VideoFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/XMLFile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/filetypes/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/loader/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Set.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tilemaps/Formats.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/Class.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetFastValue.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetValue.js"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given 3 separate color values this will return an integer representation of it.\r\n *\r\n * @function Phaser.Display.Color.GetColor\r\n * @since 3.0.0\r\n *\r\n * @param {number} red - The red color value. A number between 0 and 255.\r\n * @param {number} green - The green color value. A number between 0 and 255.\r\n * @param {number} blue - The blue color value. A number between 0 and 255.\r\n *\r\n * @return {number} The combined color value.\r\n */\r\nvar GetColor = function (red, green, blue)\r\n{\r\n    return red << 16 | green << 8 | blue;\r\n};\r\n\r\nmodule.exports = GetColor;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\n\n/**\n * @classdesc\n * A BaseShader is a small resource class that contains the data required for a WebGL Shader to be created.\n *\n * It contains the raw source code to the fragment and vertex shader, as well as an object that defines\n * the uniforms the shader requires, if any.\n *\n * BaseShaders are stored in the Shader Cache, available in a Scene via `this.cache.shaders` and are referenced\n * by a unique key-based string. Retrieve them via `this.cache.shaders.get(key)`.\n *\n * BaseShaders are created automatically by the GLSL File Loader when loading an external shader resource.\n * They can also be created at runtime, allowing you to use dynamically generated shader source code.\n *\n * Default fragment and vertex source is used if not provided in the constructor, setting-up a basic shader,\n * suitable for debug rendering.\n *\n * @class BaseShader\n * @memberof Phaser.Display\n * @constructor\n * @since 3.17.0\n *\n * @param {string} key - The key of this shader. Must be unique within the shader cache.\n * @param {string} [fragmentSrc] - The fragment source for the shader.\n * @param {string} [vertexSrc] - The vertex source for the shader.\n * @param {any} [uniforms] - Optional object defining the uniforms the shader uses.\n */\nvar BaseShader = new Class({\n\n    initialize:\n\n    function BaseShader (key, fragmentSrc, vertexSrc, uniforms)\n    {\n        if (!fragmentSrc || fragmentSrc === '')\n        {\n            fragmentSrc = [\n                'precision mediump float;',\n\n                'uniform vec2 resolution;',\n\n                'varying vec2 fragCoord;',\n\n                'void main () {',\n                '    vec2 uv = fragCoord / resolution.xy;',\n                '    gl_FragColor = vec4(uv.xyx, 1.0);',\n                '}'\n            ].join('\\n');\n        }\n\n        if (!vertexSrc || vertexSrc === '')\n        {\n            vertexSrc = [\n                'precision mediump float;',\n\n                'uniform mat4 uProjectionMatrix;',\n                'uniform mat4 uViewMatrix;',\n                'uniform vec2 uResolution;',\n\n                'attribute vec2 inPosition;',\n\n                'varying vec2 fragCoord;',\n                'varying vec2 outTexCoord;',\n\n                'void main () {',\n                '   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);',\n                '   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);',\n                '   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);',\n                '}'\n            ].join('\\n');\n        }\n\n        if (uniforms === undefined) { uniforms = null; }\n\n        /**\n         * The key of this shader, unique within the shader cache of this Phaser game instance.\n         *\n         * @name Phaser.Display.BaseShader#key\n         * @type {string}\n         * @since 3.17.0\n         */\n        this.key = key;\n\n        /**\n         * The source code, as a string, of the fragment shader being used.\n         *\n         * @name Phaser.Display.BaseShader#fragmentSrc\n         * @type {string}\n         * @since 3.17.0\n         */\n        this.fragmentSrc = fragmentSrc;\n\n        /**\n         * The source code, as a string, of the vertex shader being used.\n         *\n         * @name Phaser.Display.BaseShader#vertexSrc\n         * @type {string}\n         * @since 3.17.0\n         */\n        this.vertexSrc = vertexSrc;\n\n        /**\n         * The default uniforms for this shader.\n         *\n         * @name Phaser.Display.BaseShader#uniforms\n         * @type {?any}\n         * @since 3.17.0\n         */\n        this.uniforms = uniforms;\n    }\n\n});\n\nmodule.exports = BaseShader;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes the given data string and parses it as XML.\r\n * First tries to use the window.DOMParser and reverts to the Microsoft.XMLDOM if that fails.\r\n * The parsed XML object is returned, or `null` if there was an error while parsing the data.\r\n *\r\n * @function Phaser.DOM.ParseXML\r\n * @since 3.0.0\r\n *\r\n * @param {string} data - The XML source stored in a string.\r\n *\r\n * @return {?(DOMParser|ActiveXObject)} The parsed XML data, or `null` if the data could not be parsed.\r\n */\r\nvar ParseXML = function (data)\r\n{\r\n    var xml = '';\r\n\r\n    try\r\n    {\r\n        if (window['DOMParser'])\r\n        {\r\n            var domparser = new DOMParser();\r\n            xml = domparser.parseFromString(data, 'text/xml');\r\n        }\r\n        else\r\n        {\r\n            xml = new ActiveXObject('Microsoft.XMLDOM');\r\n            xml.loadXML(data);\r\n        }\r\n    }\r\n    catch (e)\r\n    {\r\n        xml = null;\r\n    }\r\n\r\n    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length)\r\n    {\r\n        return null;\r\n    }\r\n    else\r\n    {\r\n        return xml;\r\n    }\r\n};\r\n\r\nmodule.exports = ParseXML;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Read an integer value from an XML Node.\n *\n * @function getValue\n * @since 3.0.0\n * @private\n *\n * @param {Node} node - The XML Node.\n * @param {string} attribute - The attribute to read.\n *\n * @return {number} The parsed value.\n */\nfunction getValue (node, attribute)\n{\n    return parseInt(node.getAttribute(attribute), 10);\n}\n\n/**\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\n *\n * @function ParseXMLBitmapFont\n * @since 3.0.0\n * @private\n *\n * @param {XMLDocument} xml - The XML Document to parse the font from.\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\n * @param {Phaser.Textures.Texture} [texture] - If provided, each glyph in the Bitmap Font will be added to this texture as a frame.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\n */\nvar ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)\n{\n    if (xSpacing === undefined) { xSpacing = 0; }\n    if (ySpacing === undefined) { ySpacing = 0; }\n\n    var textureX = frame.cutX;\n    var textureY = frame.cutY;\n    var textureWidth = frame.source.width;\n    var textureHeight = frame.source.height;\n    var sourceIndex = frame.sourceIndex;\n\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = getValue(info, 'size');\n    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n    data.chars = {};\n\n    var letters = xml.getElementsByTagName('char');\n\n    var adjustForTrim = (frame !== undefined && frame.trimmed);\n\n    if (adjustForTrim)\n    {\n        var top = frame.height;\n        var left = frame.width;\n    }\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var node = letters[i];\n\n        var charCode = getValue(node, 'id');\n        var letter = String.fromCharCode(charCode);\n        var gx = getValue(node, 'x');\n        var gy = getValue(node, 'y');\n        var gw = getValue(node, 'width');\n        var gh = getValue(node, 'height');\n\n        //  Handle frame trim issues\n\n        if (adjustForTrim)\n        {\n            if (gx < left)\n            {\n                left = gx;\n            }\n\n            if (gy < top)\n            {\n                top = gy;\n            }\n        }\n\n        if (adjustForTrim && top !== 0 && left !== 0)\n        {\n            //  Now we know the top and left coordinates of the glyphs in the original data\n            //  so we can work out how much to adjust the glyphs by\n\n            gx -= frame.x;\n            gy -= frame.y;\n        }\n\n        var u0 = (textureX + gx) / textureWidth;\n        var v0 = (textureY + gy) / textureHeight;\n        var u1 = (textureX + gx + gw) / textureWidth;\n        var v1 = (textureY + gy + gh) / textureHeight;\n\n        data.chars[charCode] =\n        {\n            x: gx,\n            y: gy,\n            width: gw,\n            height: gh,\n            centerX: Math.floor(gw / 2),\n            centerY: Math.floor(gh / 2),\n            xOffset: getValue(node, 'xoffset'),\n            yOffset: getValue(node, 'yoffset'),\n            xAdvance: getValue(node, 'xadvance') + xSpacing,\n            data: {},\n            kerning: {},\n            u0: u0,\n            v0: v0,\n            u1: u1,\n            v1: v1\n        };\n\n        if (texture && gw !== 0 && gh !== 0)\n        {\n            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);\n\n            if (charFrame)\n            {\n                charFrame.setUVs(gw, gh, u0, v0, u1, v1);\n            }\n        }\n    }\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (i = 0; i < kernings.length; i++)\n    {\n        var kern = kernings[i];\n\n        var first = getValue(kern, 'first');\n        var second = getValue(kern, 'second');\n        var amount = getValue(kern, 'amount');\n\n        data.chars[second].kerning[first] = amount;\n    }\n\n    return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar flip = true;\n\nvar defaultModelName = 'untitled';\nvar currentGroup = '';\nvar currentMaterial = '';\n\n/**\n * @ignore\n */\nfunction stripComments (line)\n{\n    var idx = line.indexOf('#');\n\n    return (idx > -1) ? line.substring(0, idx) : line;\n}\n\n/**\n * @ignore\n */\nfunction currentModel (result)\n{\n    if (result.models.length === 0)\n    {\n        result.models.push({\n            faces: [],\n            name: defaultModelName,\n            textureCoords: [],\n            vertexNormals: [],\n            vertices: []\n        });\n    }\n\n    currentGroup = '';\n\n    return result.models[result.models.length - 1];\n}\n\n/**\n * @ignore\n */\nfunction parseObject (lineItems, result)\n{\n    var modelName = lineItems.length >= 2 ? lineItems[1] : defaultModelName;\n\n    result.models.push({\n        faces: [],\n        name: modelName,\n        textureCoords: [],\n        vertexNormals: [],\n        vertices: []\n    });\n\n    currentGroup = '';\n}\n\n/**\n * @ignore\n */\nfunction parseGroup (lineItems)\n{\n    if (lineItems.length === 2)\n    {\n        currentGroup = lineItems[1];\n    }\n}\n\n/**\n * @ignore\n */\nfunction parseVertexCoords (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    currentModel(result).vertices.push({ x: x, y: y, z: z });\n}\n\n/**\n * @ignore\n */\nfunction parseTextureCoords (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var u = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var v = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var w = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    if (isNaN(u))\n    {\n        u = 0;\n    }\n\n    if (isNaN(v))\n    {\n        v = 0;\n    }\n\n    if (isNaN(w))\n    {\n        w = 0;\n    }\n\n    if (flip)\n    {\n        v = 1 - v;\n    }\n\n    currentModel(result).textureCoords.push({ u: u, v: v, w: w });\n}\n\n/**\n * @ignore\n */\nfunction parseVertexNormal (lineItems, result)\n{\n    var len = lineItems.length;\n\n    var x = (len >= 2) ? parseFloat(lineItems[1]) : 0;\n    var y = (len >= 3) ? parseFloat(lineItems[2]) : 0;\n    var z = (len >= 4) ? parseFloat(lineItems[3]) : 0;\n\n    currentModel(result).vertexNormals.push({ x: x, y: y, z: z });\n}\n\n/**\n * @ignore\n */\nfunction parsePolygon (lineItems, result)\n{\n    var totalVertices = lineItems.length - 1;\n\n    if (totalVertices < 3)\n    {\n        return;\n    }\n\n    var face = {\n        group: currentGroup,\n        material: currentMaterial,\n        vertices: []\n    };\n\n    for (var i = 0; i < totalVertices; i++)\n    {\n        var vertexString = lineItems[i + 1];\n        var vertexValues = vertexString.split('/');\n        var vvLen = vertexValues.length;\n\n        if (vvLen < 1 || vvLen > 3)\n        {\n            continue;\n        }\n\n        var vertexIndex = 0;\n        var textureCoordsIndex = 0;\n        var vertexNormalIndex = 0;\n\n        vertexIndex = parseInt(vertexValues[0], 10);\n\n        if (vvLen > 1 && vertexValues[1] !== '')\n        {\n            textureCoordsIndex = parseInt(vertexValues[1], 10);\n        }\n\n        if (vvLen > 2)\n        {\n            vertexNormalIndex = parseInt(vertexValues[2], 10);\n        }\n\n        if (vertexIndex !== 0)\n        {\n            // Negative vertex indices refer to the nth last defined vertex\n            // convert these to postive indices for simplicity\n            if (vertexIndex < 0)\n            {\n                vertexIndex = currentModel(result).vertices.length + 1 + vertexIndex;\n            }\n\n            textureCoordsIndex -= 1;\n            vertexIndex -= 1;\n            vertexNormalIndex -= 1;\n\n            face.vertices.push({\n                textureCoordsIndex: textureCoordsIndex,\n                vertexIndex: vertexIndex,\n                vertexNormalIndex: vertexNormalIndex\n            });\n        }\n    }\n\n    currentModel(result).faces.push(face);\n}\n\n/**\n * @ignore\n */\nfunction parseMtlLib (lineItems, result)\n{\n    if (lineItems.length >= 2)\n    {\n        result.materialLibraries.push(lineItems[1]);\n    }\n}\n\n/**\n * @ignore\n */\nfunction parseUseMtl (lineItems)\n{\n    if (lineItems.length >= 2)\n    {\n        currentMaterial = lineItems[1];\n    }\n}\n\n/**\n * Parses a Wavefront OBJ File, extracting the models from it and returning them in an array.\n *\n * The model data *must* be triangulated for a Mesh Game Object to be able to render it.\n *\n * @function Phaser.Geom.Mesh.ParseObj\n * @since 3.50.0\n *\n * @param {string} data - The OBJ File data as a raw string.\n * @param {boolean} [flipUV=true] - Flip the UV coordinates?\n *\n * @return {Phaser.Types.Geom.Mesh.OBJData} The parsed model and material data.\n */\nvar ParseObj = function (data, flipUV)\n{\n    if (flipUV === undefined) { flipUV = true; }\n\n    flip = flipUV;\n\n    //  Store results in here\n    var result = {\n        materials: {},\n        materialLibraries: [],\n        models: []\n    };\n\n    currentGroup = '';\n    currentMaterial = '';\n\n    var lines = data.split('\\n');\n\n    for (var i = 0; i < lines.length; i++)\n    {\n        var line = stripComments(lines[i]);\n\n        var lineItems = line.replace(/\\s\\s+/g, ' ').trim().split(' ');\n\n        switch (lineItems[0].toLowerCase())\n        {\n            case 'o':\n                // Start A New Model\n                parseObject(lineItems, result);\n                break;\n\n            case 'g':\n                // Start a new polygon group\n                parseGroup(lineItems);\n                break;\n\n            case 'v':\n                // Define a vertex for the current model\n                parseVertexCoords(lineItems, result);\n                break;\n\n            case 'vt':\n                // Texture Coords\n                parseTextureCoords(lineItems, result);\n                break;\n\n            case 'vn':\n                // Define a vertex normal for the current model\n                parseVertexNormal(lineItems, result);\n                break;\n\n            case 'f':\n                // Define a Face/Polygon\n                parsePolygon(lineItems, result);\n                break;\n\n            case 'mtllib':\n                // Reference to a material library file (.mtl)\n                parseMtlLib(lineItems, result);\n                break;\n\n            case 'usemtl':\n                // Sets the current material to be applied to polygons defined from this point forward\n                parseUseMtl(lineItems);\n                break;\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = ParseObj;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetColor = require('../../display/color/GetColor');\r\n\r\n/**\r\n * Takes a Wavefront Material file and extracts the diffuse reflectivity of the named\r\n * materials, converts them to integer color values and returns them.\r\n *\r\n * This is used internally by the `addOBJ` and `addModel` methods, but is exposed for\r\n * public consumption as well.\r\n *\r\n * Note this only works with diffuse values, specified in the `Kd r g b` format, where\r\n * `g` and `b` are optional, but `r` is required. It does not support spectral rfl files,\r\n * or any other material statement (such as `Ka` or `Ks`)\r\n *\r\n * @method Phaser.Geom.Mesh.ParseObjMaterial\r\n * @since 3.50.0\r\n *\r\n * @param {string} mtl - The OBJ MTL file as a raw string, i.e. loaded via `this.load.text`.\r\n *\r\n * @return {object} The parsed material colors, where each property of the object matches the material name.\r\n */\r\nvar ParseObjMaterial = function (mtl)\r\n{\r\n    var output = {};\r\n\r\n    var lines = mtl.split('\\n');\r\n\r\n    var currentMaterial = '';\r\n\r\n    for (var i = 0; i < lines.length; i++)\r\n    {\r\n        var line = lines[i].trim();\r\n\r\n        if (line.indexOf('#') === 0 || line === '')\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var lineItems = line.replace(/\\s\\s+/g, ' ').trim().split(' ');\r\n\r\n        switch (lineItems[0].toLowerCase())\r\n        {\r\n            case 'newmtl':\r\n            {\r\n                currentMaterial = lineItems[1];\r\n                break;\r\n            }\r\n\r\n            //  The diffuse reflectivity of the current material\r\n            //  Support r, [g], [b] format, where g and b are optional\r\n            case 'kd':\r\n            {\r\n                var r = Math.floor(lineItems[1] * 255);\r\n                var g = (lineItems.length >= 2) ? Math.floor(lineItems[2] * 255) : r;\r\n                var b = (lineItems.length >= 3) ? Math.floor(lineItems[3] * 255) : r;\r\n\r\n                output[currentMaterial] = GetColor(r, g, b);\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = ParseObjMaterial;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Invalid Loader.' + this.type + ' key');\r\n        }\r\n\r\n        var url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (url === undefined)\r\n        {\r\n            url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof url === 'string' && !url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n        {\r\n            url = loader.path + url;\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         *\r\n         * Automatically has Loader.path prepended to it if a string.\r\n         *\r\n         * Can also be a JavaScript Object, such as the results of parsing JSON data.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {object|string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = url;\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.FILE_LOADING;\r\n\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //\r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        // On iOS, Capacitor often runs on a capacitor:// protocol, meaning local files are served from capacitor:// rather than file://\r\n        // See: https://github.com/photonstorm/phaser/issues/5685\r\n\r\n        var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf('file://') === 0 || xhr.responseURL.indexOf('capacitor://') === 0);\r\n\r\n        var localFileOk = (isLocalFile && event.target.status === 0);\r\n\r\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.state = CONST.FILE_LOADED;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\r\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\r\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar types = {};\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypesManager\r\n */\r\n\r\nvar FileTypesManager = {\r\n\r\n    /**\r\n     * Static method called when a LoaderPlugin is created.\r\n     * \r\n     * Loops through the local types object and injects all of them as\r\n     * properties into the LoaderPlugin instance.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.install\r\n     * @since 3.0.0\r\n     * \r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.\r\n     */\r\n    install: function (loader)\r\n    {\r\n        for (var key in types)\r\n        {\r\n            loader[key] = types[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Static method called directly by the File Types.\r\n     * \r\n     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.register\r\n     * @since 3.0.0\r\n     * \r\n     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.\r\n     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.\r\n     */\r\n    register: function (key, factoryFunction)\r\n    {\r\n        types[key] = factoryFunction;\r\n    },\r\n\r\n    /**\r\n     * Removed all associated file types.\r\n     *\r\n     * @method Phaser.Loader.FileTypesManager.destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        types = {};\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = FileTypesManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CustomSet = require('../structs/Set');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar FileTypesManager = require('./FileTypesManager');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\r\n * You typically interact with it via `this.load` in your Scene. Scenes can have a `preload` method, which is always\r\n * called before the Scenes `create` method, allowing you to preload assets that the Scene may need.\r\n *\r\n * If you call any `this.load` methods from outside of `Scene.preload` then you need to start the Loader going\r\n * yourself by calling `Loader.start()`. It's only automatically started during the Scene preload.\r\n *\r\n * The Loader uses a combination of tag loading (eg. Audio elements) and XHR and provides progress and completion events.\r\n * Files are loaded in parallel by default. The amount of concurrent connections can be controlled in your Game Configuration.\r\n *\r\n * Once the Loader has started loading you are still able to add files to it. These can be injected as a result of a loader\r\n * event, the type of file being loaded (such as a pack file) or other external events. As long as the Loader hasn't finished\r\n * simply adding a new file to it, while running, will ensure it's added into the current queue.\r\n *\r\n * Every Scene has its own instance of the Loader and they are bound to the Scene in which they are created. However,\r\n * assets loaded by the Loader are placed into global game-level caches. For example, loading an XML file will place that\r\n * file inside `Game.cache.xml`, which is accessible from every Scene in your game, no matter who was responsible\r\n * for loading it. The same is true of Textures. A texture loaded in one Scene is instantly available to all other Scenes\r\n * in your game.\r\n *\r\n * The Loader works by using custom File Types. These are stored in the FileTypesManager, which injects them into the Loader\r\n * when it's instantiated. You can create your own custom file types by extending either the File or MultiFile classes.\r\n * See those files for more details.\r\n *\r\n * @class LoaderPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene which owns this Loader instance.\r\n */\r\nvar LoaderPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function LoaderPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var gameConfig = scene.sys.game.config;\r\n        var sceneConfig = scene.sys.settings.loader;\r\n\r\n        /**\r\n         * The Scene which owns this Loader instance.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the global Cache Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#cacheManager\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.cacheManager = scene.sys.cache;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * A reference to the global Scene Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#sceneManager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @protected\r\n         * @since 3.16.0\r\n         */\r\n        this.sceneManager = scene.sys.game.scene;\r\n\r\n        //  Inject the available filetypes into the Loader\r\n        FileTypesManager.install(this);\r\n\r\n        /**\r\n         * An optional prefix that is automatically prepended to the start of every file key.\r\n         * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n         * You can set this directly, or call `Loader.setPrefix()`. It will then affect every file added to the Loader\r\n         * from that point on. It does _not_ change any file already in the load queue.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#prefix\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.7.0\r\n         */\r\n        this.prefix = '';\r\n\r\n        /**\r\n         * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n         *\r\n         * ```javascript\r\n         * this.load.path = \"images/sprites/\";\r\n         * this.load.image(\"ball\", \"ball.png\");\r\n         * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n         * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n         * ```\r\n         *\r\n         * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n         * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n         * given as it's an absolute URL.\r\n         *\r\n         * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setPath()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#path\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.path = '';\r\n\r\n        /**\r\n         * If you want to append a URL before the path of any asset you can set this here.\r\n         *\r\n         * Useful if allowing the asset base url to be configured outside of the game code.\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setBaseURL()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#baseURL\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.baseURL = '';\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        /**\r\n         * The number of concurrent / parallel resources to try and fetch at once.\r\n         *\r\n         * Old browsers limit 6 requests per domain; modern ones, especially those with HTTP/2 don't limit it at all.\r\n         *\r\n         * The default is 32 but you can change this in your Game Config, or by changing this property before the Loader starts.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#maxParallelDownloads\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxParallelDownloads = GetFastValue(sceneConfig, 'maxParallelDownloads', gameConfig.loaderMaxParallelDownloads);\r\n\r\n        /**\r\n         * xhr specific global settings (can be overridden on a per-file basis)\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#xhr\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhr = XHRSettings(\r\n            GetFastValue(sceneConfig, 'responseType', gameConfig.loaderResponseType),\r\n            GetFastValue(sceneConfig, 'async', gameConfig.loaderAsync),\r\n            GetFastValue(sceneConfig, 'user', gameConfig.loaderUser),\r\n            GetFastValue(sceneConfig, 'password', gameConfig.loaderPassword),\r\n            GetFastValue(sceneConfig, 'timeout', gameConfig.loaderTimeout),\r\n            GetFastValue(sceneConfig, 'withCredentials', gameConfig.loaderWithCredentials)\r\n        );\r\n\r\n        /**\r\n         * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#crossOrigin\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = GetFastValue(sceneConfig, 'crossOrigin', gameConfig.loaderCrossOrigin);\r\n\r\n        /**\r\n         * The total number of files to load. It may not always be accurate because you may add to the Loader during the process\r\n         * of loading, especially if you load a Pack File. Therefore this value can change, but in most cases remains static.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalToLoad\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalToLoad = 0;\r\n\r\n        /**\r\n         * The progress of the current load queue, as a float value between 0 and 1.\r\n         * This is updated automatically as files complete loading.\r\n         * Note that it is possible for this value to go down again if you add content to the current load queue during a load.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Files are placed in this Set when they're added to the Loader via `addFile`.\r\n         *\r\n         * They are moved to the `inflight` Set when they start loading, and assuming a successful\r\n         * load, to the `queue` Set for further processing.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#list\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're in the process of being loaded.\r\n         *\r\n         * Upon a successful load they are moved to the `queue` Set.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#inflight\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.inflight = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're being processed.\r\n         *\r\n         * If the process is successful they are moved to their final destination, which could be\r\n         * a Cache or the Texture Manager.\r\n         *\r\n         * At the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#queue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.queue = new CustomSet();\r\n\r\n        /**\r\n         * A temporary Set in which files are stored after processing,\r\n         * awaiting destruction at the end of the load process.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#_deleteQueue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._deleteQueue = new CustomSet();\r\n\r\n        /**\r\n         * The total number of files that failed to load during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalFailed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalFailed = 0;\r\n\r\n        /**\r\n         * The total number of files that successfully loaded during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalComplete\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalComplete = 0;\r\n\r\n        /**\r\n         * The current state of the Loader.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#state\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.state = CONST.LOADER_IDLE;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = 0;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * If you want to append a URL before the path of any asset you can set this here.\r\n     *\r\n     * Useful if allowing the asset base url to be configured outside of the game code.\r\n     *\r\n     * Once a base URL is set it will affect every file loaded by the Loader from that point on. It does _not_ change any\r\n     * file _already_ being loaded. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setBaseURL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [url] - The URL to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setBaseURL: function (url)\r\n    {\r\n        if (url === undefined) { url = ''; }\r\n\r\n        if (url !== '' && url.substr(-1) !== '/')\r\n        {\r\n            url = url.concat('/');\r\n        }\r\n\r\n        this.baseURL = url;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n     *\r\n     * ```javascript\r\n     * this.load.setPath(\"images/sprites/\");\r\n     * this.load.image(\"ball\", \"ball.png\");\r\n     * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n     * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n     * ```\r\n     *\r\n     * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n     * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n     * given as it's an absolute URL.\r\n     *\r\n     * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n     *\r\n     * Once a path is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [path] - The path to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPath: function (path)\r\n    {\r\n        if (path === undefined) { path = ''; }\r\n\r\n        if (path !== '' && path.substr(-1) !== '/')\r\n        {\r\n            path = path.concat('/');\r\n        }\r\n\r\n        this.path = path;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * An optional prefix that is automatically prepended to the start of every file key.\r\n     *\r\n     * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n     *\r\n     * Once a prefix is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPrefix\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} [prefix] - The prefix to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPrefix: function (prefix)\r\n    {\r\n        if (prefix === undefined) { prefix = ''; }\r\n\r\n        this.prefix = prefix;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Cross Origin Resource Sharing value used when loading files.\r\n     *\r\n     * Files can override this value on a per-file basis by specifying an alternative `crossOrigin` value in their file config.\r\n     *\r\n     * Once CORs is set it will then affect every file loaded by the Loader from that point on, as long as they don't have\r\n     * their own CORs setting. To reset it, call this method with no arguments.\r\n     *\r\n     * For more details about CORs see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setCORS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [crossOrigin] - The value to use for the `crossOrigin` property in the load request.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setCORS: function (crossOrigin)\r\n    {\r\n        this.crossOrigin = crossOrigin;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a file, or array of files, into the load queue.\r\n     *\r\n     * The file must be an instance of `Phaser.Loader.File`, or a class that extends it. The Loader will check that the key\r\n     * used by the file won't conflict with any other key either in the loader, the inflight queue or the target cache.\r\n     * If allowed it will then add the file into the pending list, read for the load to start. Or, if the load has already\r\n     * started, ready for the next batch of files to be pulled from the list to the inflight queue.\r\n     *\r\n     * You should not normally call this method directly, but rather use one of the Loader methods like `image` or `atlas`,\r\n     * however you can call this as long as the file given to it is well formed.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addFile\r\n     * @fires Phaser.Loader.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Loader.File|Phaser.Loader.File[])} file - The file, or array of files, to be added to the load queue.\r\n     */\r\n    addFile: function (file)\r\n    {\r\n        if (!Array.isArray(file))\r\n        {\r\n            file = [ file ];\r\n        }\r\n\r\n        for (var i = 0; i < file.length; i++)\r\n        {\r\n            var item = file[i];\r\n\r\n            //  Does the file already exist in the cache or texture manager?\r\n            //  Or will it conflict with a file already in the queue or inflight?\r\n            if (!this.keyExists(item))\r\n            {\r\n                this.list.set(item);\r\n\r\n                this.emit(Events.ADD, item.key, item.type, this, item);\r\n\r\n                if (this.isLoading())\r\n                {\r\n                    this.totalToLoad++;\r\n                    this.updateProgress();\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks the key and type of the given file to see if it will conflict with anything already\r\n     * in a Cache, the Texture Manager, or the list or inflight queues.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#keyExists\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file to check the key of.\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a cache or queue conflict, otherwise `false`.\r\n     */\r\n    keyExists: function (file)\r\n    {\r\n        var keyConflict = file.hasCacheConflict();\r\n\r\n        if (!keyConflict)\r\n        {\r\n            this.list.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        if (!keyConflict && this.isLoading())\r\n        {\r\n            this.inflight.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n\r\n            this.queue.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        return keyConflict;\r\n    },\r\n\r\n    /**\r\n     * Takes a well formed, fully parsed pack file object and adds its entries into the load queue. Usually you do not call\r\n     * this method directly, but instead use `Loader.pack` and supply a path to a JSON file that holds the\r\n     * pack data. However, if you've got the data prepared you can pass it to this method.\r\n     *\r\n     * You can also provide an optional key. If you do then it will only add the entries from that part of the pack into\r\n     * to the load queue. If not specified it will add all entries it finds. For more details about the pack file format\r\n     * see the `LoaderPlugin.pack` method.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addPack\r\n     * @since 3.7.0\r\n     *\r\n     * @param {any} pack - The Pack File data to be parsed and each entry of it to added to the load queue.\r\n     * @param {string} [packKey] - An optional key to use from the pack file data.\r\n     *\r\n     * @return {boolean} `true` if any files were added to the queue, otherwise `false`.\r\n     */\r\n    addPack: function (pack, packKey)\r\n    {\r\n        //  if no packKey provided we'll add everything to the queue\r\n        if (packKey && pack.hasOwnProperty(packKey))\r\n        {\r\n            pack = { packKey: pack[packKey] };\r\n        }\r\n\r\n        var total = 0;\r\n\r\n        //  Store the loader settings in case this pack replaces them\r\n        var currentBaseURL = this.baseURL;\r\n        var currentPath = this.path;\r\n        var currentPrefix = this.prefix;\r\n\r\n        //  Here we go ...\r\n        for (var key in pack)\r\n        {\r\n            if (!Object.prototype.hasOwnProperty.call(pack, key))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var config = pack[key];\r\n\r\n            //  Any meta data to process?\r\n            var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\r\n            var path = GetFastValue(config, 'path', currentPath);\r\n            var prefix = GetFastValue(config, 'prefix', currentPrefix);\r\n            var files = GetFastValue(config, 'files', null);\r\n            var defaultType = GetFastValue(config, 'defaultType', 'void');\r\n\r\n            if (Array.isArray(files))\r\n            {\r\n                this.setBaseURL(baseURL);\r\n                this.setPath(path);\r\n                this.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < files.length; i++)\r\n                {\r\n                    var file = files[i];\r\n                    var type = (file.hasOwnProperty('type')) ? file.type : defaultType;\r\n\r\n                    if (this[type])\r\n                    {\r\n                        this[type](file);\r\n                        total++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Reset the loader settings\r\n        this.setBaseURL(currentBaseURL);\r\n        this.setPath(currentPath);\r\n        this.setPrefix(currentPrefix);\r\n\r\n        return (total > 0);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader actively loading, or processing loaded files?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isLoading\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is busy loading or processing, otherwise `false`.\r\n     */\r\n    isLoading: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader ready to start a new load?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isReady\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is ready to start a new load, otherwise `false`.\r\n     */\r\n    isReady: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE);\r\n    },\r\n\r\n    /**\r\n     * Starts the Loader running. This will reset the progress and totals and then emit a `start` event.\r\n     * If there is nothing in the queue the Loader will immediately complete, otherwise it will start\r\n     * loading the first batch of files.\r\n     *\r\n     * The Loader is started automatically if the queue is populated within your Scenes `preload` method.\r\n     *\r\n     * However, outside of this, you need to call this method to start it.\r\n     *\r\n     * If the Loader is already running this method will simply return.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#start\r\n     * @fires Phaser.Loader.Events#START\r\n     * @since 3.0.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.isReady())\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.progress = 0;\r\n\r\n        this.totalFailed = 0;\r\n        this.totalComplete = 0;\r\n        this.totalToLoad = this.list.size;\r\n\r\n        this.emit(Events.START, this);\r\n\r\n        if (this.list.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.LOADER_LOADING;\r\n\r\n            this.inflight.clear();\r\n            this.queue.clear();\r\n\r\n            this.updateProgress();\r\n\r\n            this.checkLoadQueue();\r\n\r\n            this.systems.events.on(SceneEvents.UPDATE, this.update, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     * It updates the `progress` value and then emits a progress event, which you can use to\r\n     * display a loading bar in your game.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#updateProgress\r\n     * @fires Phaser.Loader.Events#PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    updateProgress: function ()\r\n    {\r\n        this.progress = 1 - ((this.list.size + this.inflight.size) / this.totalToLoad);\r\n\r\n        this.emit(Events.PROGRESS, this.progress);\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#update\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads)\r\n        {\r\n            this.checkLoadQueue();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method called by the Loader.\r\n     *\r\n     * It will check to see if there are any more files in the pending list that need loading, and if so it will move\r\n     * them from the list Set into the inflight Set, set their CORs flag and start them loading.\r\n     *\r\n     * It will carrying on doing this for each file in the pending list until it runs out, or hits the max allowed parallel downloads.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#checkLoadQueue\r\n     * @private\r\n     * @since 3.7.0\r\n     */\r\n    checkLoadQueue: function ()\r\n    {\r\n        this.list.each(function (file)\r\n        {\r\n            if (file.state === CONST.FILE_POPULATED || (file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads))\r\n            {\r\n                this.inflight.set(file);\r\n\r\n                this.list.delete(file);\r\n\r\n                //  If the file doesn't have its own crossOrigin set, we'll use the Loaders (which is undefined by default)\r\n                if (!file.crossOrigin)\r\n                {\r\n                    file.crossOrigin = this.crossOrigin;\r\n                }\r\n\r\n                file.load();\r\n            }\r\n\r\n            if (this.inflight.size === this.maxParallelDownloads)\r\n            {\r\n                //  Tells the Set iterator to abort\r\n                return false;\r\n            }\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * An internal method called automatically by the XHRLoader belong to a File.\r\n     *\r\n     * This method will remove the given file from the inflight Set and update the load progress.\r\n     * If the file was successful its `onProcess` method is called, otherwise it is added to the delete queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#nextFile\r\n     * @fires Phaser.Loader.Events#FILE_LOAD\r\n     * @fires Phaser.Loader.Events#FILE_LOAD_ERROR\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that just finished loading, or errored during load.\r\n     * @param {boolean} success - `true` if the file loaded successfully, otherwise `false`.\r\n     */\r\n    nextFile: function (file, success)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.inflight)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.inflight.delete(file);\r\n\r\n        this.updateProgress();\r\n\r\n        if (success)\r\n        {\r\n            this.totalComplete++;\r\n\r\n            this.queue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD, file);\r\n\r\n            file.onProcess();\r\n        }\r\n        else\r\n        {\r\n            this.totalFailed++;\r\n\r\n            this._deleteQueue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD_ERROR, file);\r\n\r\n            this.fileProcessComplete(file);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that is called automatically by the File when it has finished processing.\r\n     *\r\n     * If the process was successful, and the File isn't part of a MultiFile, its `addToCache` method is called.\r\n     *\r\n     * It this then removed from the queue. If there are no more files to load `loadComplete` is called.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#fileProcessComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file that has finished processing.\r\n     */\r\n    fileProcessComplete: function (file)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  This file has failed, so move it to the failed Set\r\n        if (file.state === CONST.FILE_ERRORED)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                file.multiFile.onFileFailed(file);\r\n            }\r\n        }\r\n        else if (file.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                if (file.multiFile.isReadyToProcess())\r\n                {\r\n                    //  If we got here then all files the link file needs are ready to add to the cache\r\n                    file.multiFile.addToCache();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  If we got here, then the file processed, so let it add itself to its cache\r\n                file.addToCache();\r\n            }\r\n        }\r\n\r\n        //  Remove it from the queue\r\n        this.queue.delete(file);\r\n\r\n        //  Nothing left to do?\r\n\r\n        if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called at the end when the load queue is exhausted and all files have either loaded or errored.\r\n     * By this point every loaded file will now be in its associated cache and ready for use.\r\n     *\r\n     * Also clears down the Sets, puts progress to 1 and clears the deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#loadComplete\r\n     * @fires Phaser.Loader.Events#COMPLETE\r\n     * @fires Phaser.Loader.Events#POST_PROCESS\r\n     * @since 3.7.0\r\n     */\r\n    loadComplete: function ()\r\n    {\r\n        this.emit(Events.POST_PROCESS, this);\r\n\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        this.progress = 1;\r\n\r\n        this.state = CONST.LOADER_COMPLETE;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n\r\n        //  Call 'destroy' on each file ready for deletion\r\n        this._deleteQueue.iterateLocal('destroy');\r\n\r\n        this._deleteQueue.clear();\r\n\r\n        this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);\r\n    },\r\n\r\n    /**\r\n     * Adds a File into the pending-deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#flagForRemoval\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File to be queued for deletion when the Loader completes.\r\n     */\r\n    flagForRemoval: function (file)\r\n    {\r\n        this._deleteQueue.set(file);\r\n    },\r\n\r\n    /**\r\n     * Converts the given JSON data into a file that the browser then prompts you to download so you can save it locally.\r\n     *\r\n     * The data must be well formed JSON and ready-parsed, not a JavaScript object.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#saveJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The JSON data, ready parsed.\r\n     * @param {string} [filename=file.json] - The name to save the JSON file as.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    saveJSON: function (data, filename)\r\n    {\r\n        return this.save(JSON.stringify(data), filename);\r\n    },\r\n\r\n    /**\r\n     * Causes the browser to save the given data as a file to its default Downloads folder.\r\n     *\r\n     * Creates a DOM level anchor link, assigns it as being a `download` anchor, sets the href\r\n     * to be an ObjectURL based on the given data, and then invokes a click event.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#save\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The data to be saved. Will be passed through URL.createObjectURL.\r\n     * @param {string} [filename=file.json] - The filename to save the file as.\r\n     * @param {string} [filetype=application/json] - The file type to use when saving the file. Defaults to JSON.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    save: function (data, filename, filetype)\r\n    {\r\n        if (filename === undefined) { filename = 'file.json'; }\r\n        if (filetype === undefined) { filetype = 'application/json'; }\r\n\r\n        var blob = new Blob([ data ], { type: filetype });\r\n\r\n        var url = URL.createObjectURL(blob);\r\n\r\n        var a = document.createElement('a');\r\n\r\n        a.download = filename;\r\n        a.textContent = 'Download ' + filename;\r\n        a.href = url;\r\n        a.click();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the Loader.\r\n     *\r\n     * This will clear all lists and reset the base URL, path and prefix.\r\n     *\r\n     * Warning: If the Loader is currently downloading files, or has files in its queue, they will be aborted.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#reset\r\n     * @since 3.0.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        var gameConfig = this.systems.game.config;\r\n        var sceneConfig = this.systems.settings.loader;\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        this.state = CONST.LOADER_IDLE;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.state = CONST.LOADER_SHUTDOWN;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.state = CONST.LOADER_DESTROYED;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.START, this.pluginStart, this);\r\n\r\n        this.list = null;\r\n        this.inflight = null;\r\n        this.queue = null;\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.textureManager = null;\r\n        this.cacheManager = null;\r\n        this.sceneManager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('Loader', LoaderPlugin, 'load');\r\n\r\nmodule.exports = LoaderPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n *\r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        var finalFiles = [];\r\n\r\n        //  Clean out any potential 'null' or 'undefined' file entries\r\n        files.forEach(function (file)\r\n        {\r\n            if (file)\r\n            {\r\n                finalFiles.push(file);\r\n            }\r\n        });\r\n\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = loader.multiKeyIndex++;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = finalFiles;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {number}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = finalFiles.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        /**\r\n         * A reference to the Loaders baseURL at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#baseURL\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.baseURL = loader.baseURL;\r\n\r\n        /**\r\n         * A reference to the Loaders path at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#path\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.path = loader.path;\r\n\r\n        /**\r\n         * A reference to the Loaders prefix at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#prefix\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.prefix = loader.prefix;\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < finalFiles.length; i++)\r\n        {\r\n            finalFiles[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.headers)\r\n    {\r\n        for (var key in config.headers)\r\n        {\r\n            xhr.setRequestHeader(key, config.headers[key]);\r\n        }\r\n    }\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    if (config.withCredentials)\r\n    {\r\n        xhr.withCredentials = true;\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file, xhr);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {number} [timeout=0] - Optional XHR timeout value.\r\n * @param {boolean} [withCredentials=false] - Optional XHR withCredentials value.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout, withCredentials)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n    if (withCredentials === undefined) { withCredentials = false; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        headers: undefined,\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined,\r\n\r\n        //  withCredentials\r\n        withCredentials: withCredentials\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Add File Event.\r\n * \r\n * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('addfile', listener)`.\r\n * \r\n * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.\r\n *\r\n * @event Phaser.Loader.Events#ADD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The unique key of the file that was added to the Loader.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.\r\n */\r\nmodule.exports = 'addfile';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Complete Event.\r\n * \r\n * This event is dispatched when the Loader has fully processed everything in the load queue.\r\n * By this point every loaded file will now be in its associated cache and ready for use.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('complete', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n * @param {number} totalComplete - The total number of files that successfully loaded.\r\n * @param {number} totalFailed - The total number of files that failed to load.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.\r\n * \r\n * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Complete Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\r\n * \r\n * It uses a special dynamic event name constructed from the key and type of the file.\r\n * \r\n * For example, if you have loaded an `image` with a key of `monster`, you can listen for it\r\n * using the following:\r\n *\r\n * ```javascript\r\n * this.load.on('filecomplete-image-monster', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n *\r\n * Or, if you have loaded a texture `atlas` with a key of `Level1`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\r\n * \r\n * ```javascript\r\n * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\r\n *     // Your handler code\r\n * });\r\n * ```\r\n * \r\n * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.\r\n *\r\n * @event Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the file that just loaded and finished processing.\r\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\r\n * @param {any} data - The raw data the file contained.\r\n */\r\nmodule.exports = 'filecomplete-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Error Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file fails to load.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD_ERROR\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n */\r\nmodule.exports = 'loaderror';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when a file finishes loading,\r\n * but _before_ it is processed and added to the internal Phaser caches.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('load', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_LOAD\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.\r\n */\r\nmodule.exports = 'load';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The File Load Progress Event.\r\n * \r\n * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\r\n * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#FILE_PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\r\n * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.\r\n */\r\nmodule.exports = 'fileprogress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Post Process Event.\r\n * \r\n * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\r\n * It is dispatched before the internal lists are cleared and each File is destroyed.\r\n * \r\n * Use this hook to perform any last minute processing of files that can only happen once the\r\n * Loader has completed, but prior to it emitting the `complete` event.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#POST_PROCESS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'postprocess';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Progress Event.\r\n * \r\n * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('progress', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#PROGRESS\r\n * @since 3.0.0\r\n * \r\n * @param {number} progress - The current progress of the load. A value between 0 and 1.\r\n */\r\nmodule.exports = 'progress';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Loader Plugin Start Event.\r\n * \r\n * This event is dispatched when the Loader starts running. At this point load progress is zero.\r\n * \r\n * This event is dispatched even if there aren't any files in the load queue.\r\n * \r\n * Listen to it from a Scene using: `this.load.on('start', listener)`.\r\n *\r\n * @event Phaser.Loader.Events#START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\r\n */\r\nmodule.exports = 'start';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD: require('./ADD_EVENT'),\r\n    COMPLETE: require('./COMPLETE_EVENT'),\r\n    FILE_COMPLETE: require('./FILE_COMPLETE_EVENT'),\r\n    FILE_KEY_COMPLETE: require('./FILE_KEY_COMPLETE_EVENT'),\r\n    FILE_LOAD_ERROR: require('./FILE_LOAD_ERROR_EVENT'),\r\n    FILE_LOAD: require('./FILE_LOAD_EVENT'),\r\n    FILE_PROGRESS: require('./FILE_PROGRESS_EVENT'),\r\n    POST_PROCESS: require('./POST_PROCESS_EVENT'),\r\n    PROGRESS: require('./PROGRESS_EVENT'),\r\n    START: require('./START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar LoaderEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A single Animation JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#animation method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#animation.\r\n *\r\n * @class AnimationJSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar AnimationJSONFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function AnimationJSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'animationJSON';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        //  We need to hook into this event:\r\n        this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);\r\n\r\n        //  But the rest is the same as a normal JSON file\r\n        JSONFile.prototype.onProcess.call(this);\r\n    },\r\n\r\n    /**\r\n     * Called at the end of the load process, after the Loader has finished all files in its queue.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onLoadComplete\r\n     * @since 3.7.0\r\n     */\r\n    onLoadComplete: function ()\r\n    {\r\n        this.loader.systems.anims.fromJSON(this.data);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Animation JSON Data file, or array of Animation JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.animation({\r\n *     key: 'baddieAnims',\r\n *     url: 'files/BaddieAnims.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be passed to the global Animation Managers `fromJSON` method.\r\n * This will parse all of the JSON data and create animation data from it. This process happens at the very end\r\n * of the Loader, once every other file in the load queue has finished. The reason for this is to allow you to load\r\n * both animation data and the images it relies upon in the same load call.\r\n *\r\n * Once the animation data has been parsed you will be able to play animations using that data.\r\n * Please see the Animation Manager `fromJSON` method for more details about the format and playback.\r\n *\r\n * You can also access the raw animation data from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('baddieAnims');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And if you only wanted to create animations from the `boss` data, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#animation\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the Animation JSON file loads only this property will be stored in the Cache and used to create animation data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('animation', function (key, url, dataKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new AnimationJSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AnimationJSONFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar ImageFile = require('./ImageFile.js');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\nvar JSONFile = require('./JSONFile.js');\nvar MultiFile = require('../MultiFile.js');\n\n/**\n * @classdesc\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\n *\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\n *\n * @class AsepriteFile\n * @extends Phaser.Loader.MultiFile\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n */\nvar AsepriteFile = new Class({\n\n    Extends: MultiFile,\n\n    initialize:\n\n    function AsepriteFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n    {\n        var image;\n        var data;\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n\n            image = new ImageFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'textureURL'),\n                extension: GetFastValue(config, 'textureExtension', 'png'),\n                normalMap: GetFastValue(config, 'normalMap'),\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\n            });\n\n            data = new JSONFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'atlasURL'),\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\n            });\n        }\n        else\n        {\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\n        }\n\n        if (image.linkFile)\n        {\n            //  Image has a normal map\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\n        }\n        else\n        {\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\n        }\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.AsepriteFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        if (this.isReadyToProcess())\n        {\n            var image = this.files[0];\n            var json = this.files[1];\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\n\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\n\n            json.addToCache();\n\n            this.complete = true;\n        }\n    }\n\n});\n\n/**\n * Aseprite is a powerful animated sprite editor and pixel art tool.\n *\n * You can find more details at https://www.aseprite.org/\n *\n * Adds a JSON based Aseprite Animation, or array of animations, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.aseprite('gladiator', 'images/Gladiator.png', 'images/Gladiator.json');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\n *\n * To export a compatible JSON file in Aseprite, please do the following:\n *\n * 1. Go to \"File - Export Sprite Sheet\"\n *\n * 2. On the **Layout** tab:\n * 2a. Set the \"Sheet type\" to \"Packed\"\n * 2b. Set the \"Constraints\" to \"None\"\n * 2c. Check the \"Merge Duplicates\" checkbox\n *\n * 3. On the **Sprite** tab:\n * 3a. Set \"Layers\" to \"Visible layers\"\n * 3b. Set \"Frames\" to \"All frames\", unless you only wish to export a sub-set of tags\n *\n * 4. On the **Borders** tab:\n * 4a. Check the \"Trim Sprite\" and \"Trim Cells\" options\n * 4b. Ensure \"Border Padding\", \"Spacing\" and \"Inner Padding\" are all > 0 (1 is usually enough)\n *\n * 5. On the **Output** tab:\n * 5a. Check \"Output File\", give your image a name and make sure you choose \"png files\" as the file type\n * 5b. Check \"JSON Data\" and give your json file a name\n * 5c. The JSON Data type can be either a Hash or Array, Phaser doesn't mind.\n * 5d. Make sure \"Tags\" is checked in the Meta options\n * 5e. In the \"Item Filename\" input box, make sure it says just \"{frame}\" and nothing more.\n *\n * 6. Click export\n *\n * This was tested with Aseprite 1.2.25.\n *\n * This will export a png and json file which you can load using the Aseprite Loader, i.e.:\n *\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n *\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Texture Manager first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.aseprite({\n *     key: 'gladiator',\n *     textureURL: 'images/Gladiator.png',\n *     atlasURL: 'images/Gladiator.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.AsepriteFileConfig` for more details.\n *\n * Instead of passing a URL for the JSON data you can also pass in a well formed JSON object instead.\n *\n * Once loaded, you can call this method from within a Scene with the 'atlas' key:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin');\n * ```\n *\n * Any animations defined in the JSON will now be available to use in Phaser and you play them\n * via their Tag name. For example, if you have an animation called 'War Cry' on your Aseprite timeline,\n * you can play it in Phaser using that Tag name:\n *\n * ```javascript\n * this.add.sprite(400, 300).play('War Cry');\n * ```\n *\n * When calling this method you can optionally provide an array of tag names, and only those animations\n * will be created. For example:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin', [ 'step', 'War Cry', 'Magnum Break' ]);\n * ```\n *\n * This will only create the 3 animations defined. Note that the tag names are case-sensitive.\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\n * this is what you would use to retrieve the image from the Texture Manager.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Aseprite File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#aseprite\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.50.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig|Phaser.Types.Loader.FileTypes.AsepriteFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('aseprite', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n{\n    var multifile;\n\n    //  Supports an Object file definition in the key argument\n    //  Or an array of objects in the key argument\n    //  Or a single entry where all arguments have been defined\n\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            multifile = new AsepriteFile(this, key[i]);\n\n            this.addFile(multifile.files);\n        }\n    }\n    else\n    {\n        multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\n\n        this.addFile(multifile.files);\n    }\n\n    return this;\n});\n\nmodule.exports = AsepriteFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\r\n *\r\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\r\n *\r\n * @class AtlasJSONFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasJSONFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasJSONFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasJSONFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var json = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\r\n\r\n            json.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file, using either the JSON Hash or JSON Array format.\r\n * These files are created by software such as Texture Packer, Shoebox and Adobe Flash / Animate.\r\n * If you are using Texture Packer and have enabled multi-atlas support, then please use the Phaser Multi Atlas loader\r\n * instead of this one.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.json');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasJSONFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasJSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlasXML method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlasXML.\r\n *\r\n * @class AtlasXMLFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasXMLFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasXMLFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasXMLFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);\r\n\r\n            xml.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in an XML file format.\r\n * These files are created by software such as Shoebox and Adobe Flash / Animate.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlasXML\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlasXML', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasXMLFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasXMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HTML5AudioFile = require('./HTML5AudioFile');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {AudioContext} [audioContext] - The AudioContext this file will use to process itself.\r\n */\r\nvar AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by AudioFile.findAudioURL\r\n    function AudioFile (loader, key, urlConfig, xhrSettings, audioContext)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            audioContext = GetFastValue(config, 'context', audioContext);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: { context: audioContext }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioFile#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var _this = this;\r\n\r\n        // interesting read https://github.com/WebAudio/web-audio-api/issues/1305\r\n        this.config.context.decodeAudioData(this.xhrLoader.response,\r\n            function (audioBuffer)\r\n            {\r\n                _this.data = audioBuffer;\r\n\r\n                _this.onProcessComplete();\r\n            },\r\n            function (e)\r\n            {\r\n                // eslint-disable-next-line no-console\r\n                console.error('Error decoding audio: ' + _this.key + ' - ', e ? e.message : null);\r\n\r\n                _this.onProcessError();\r\n            }\r\n        );\r\n\r\n        this.config.context = null;\r\n    }\r\n\r\n});\r\n\r\nAudioFile.create = function (loader, key, urls, config, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        config = GetFastValue(key, 'config', {});\r\n    }\r\n\r\n    var urlConfig = AudioFile.getAudioURL(game, urls);\r\n\r\n    if (!urlConfig)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // https://developers.google.com/web/updates/2012/02/HTML5-audio-and-the-Web-Audio-API-are-BFFs\r\n    // var stream = GetFastValue(config, 'stream', false);\r\n\r\n    if (deviceAudio.webAudio && !audioConfig.disableWebAudio)\r\n    {\r\n        return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);\r\n    }\r\n    else\r\n    {\r\n        return new HTML5AudioFile(loader, key, urlConfig, config);\r\n    }\r\n};\r\n\r\nAudioFile.getAudioURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0 || url.indexOf('data:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var audioType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n\r\n        audioType = GetFastValue(urls[i], 'type', (audioType) ? audioType[1] : '').toLowerCase();\r\n\r\n        if (game.device.audio[audioType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: audioType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds an Audio or HTML5Audio file, or array of audio files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audio('title', [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audio({\r\n *     key: 'title',\r\n *     url: [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audio\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig|Phaser.Types.Loader.FileTypes.AudioFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the audio files from.\r\n * @param {any} [config] - An object containing an `instances` property for HTML5Audio. Defaults to 1.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('audio', function (key, urls, config, xhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if (audioConfig.noAudio || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var audioFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            audioFile = AudioFile.create(this, key[i]);\r\n\r\n            if (audioFile)\r\n            {\r\n                this.addFile(audioFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        audioFile = AudioFile.create(this, key, urls, config, xhrSettings);\r\n\r\n        if (audioFile)\r\n        {\r\n            this.addFile(audioFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AudioFile = require('./AudioFile.js');\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * An Audio Sprite File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audioSprite method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audioSprite.\r\n *\r\n * @class AudioSpriteFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {{(string|string[])}} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AudioSpriteFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AudioSpriteFile (loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            jsonURL = GetFastValue(config, 'jsonURL');\r\n            audioURL = GetFastValue(config, 'audioURL');\r\n            audioConfig = GetFastValue(config, 'audioConfig');\r\n            audioXhrSettings = GetFastValue(config, 'audioXhrSettings');\r\n            jsonXhrSettings = GetFastValue(config, 'jsonXhrSettings');\r\n        }\r\n\r\n        var data;\r\n\r\n        //  No url? then we're going to do a json load and parse it from that\r\n        if (!audioURL)\r\n        {\r\n            data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n            MultiFile.call(this, loader, 'audiosprite', key, [ data ]);\r\n\r\n            this.config.resourceLoad = true;\r\n            this.config.audioConfig = audioConfig;\r\n            this.config.audioXhrSettings = audioXhrSettings;\r\n        }\r\n        else\r\n        {\r\n            var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);\r\n\r\n            if (audio)\r\n            {\r\n                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n                MultiFile.call(this, loader, 'audiosprite', key, [ audio, data ]);\r\n\r\n                this.config.resourceLoad = false;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (this.config.resourceLoad && file.type === 'json' && file.data.hasOwnProperty('resources'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var urls = file.data.resources;\r\n\r\n                var audioConfig = GetFastValue(this.config, 'audioConfig');\r\n                var audioXhrSettings = GetFastValue(this.config, 'audioXhrSettings');\r\n\r\n                var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);\r\n\r\n                if (audio)\r\n                {\r\n                    this.addToMultiFile(audio);\r\n\r\n                    this.loader.addFile(audio);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileA = this.files[0];\r\n            var fileB = this.files[1];\r\n\r\n            fileA.addToCache();\r\n            fileB.addToCache();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Audio Sprite, or array of audio sprites, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json', [\r\n *         'kyobi.ogg',\r\n *         'kyobi.mp3',\r\n *         'kyobi.m4a'\r\n *     ]);\r\n * }\r\n * ```\r\n *\r\n * Audio Sprites are a combination of audio files and a JSON configuration.\r\n * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\r\n *\r\n * If the JSON file includes a 'resource' object then you can let Phaser parse it and load the audio\r\n * files automatically based on its content. To do this exclude the audio URLs from the load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite({\r\n *     key: 'kyobi',\r\n *     jsonURL: 'audio/Kyobi.json',\r\n *     audioURL: [\r\n *         'audio/Kyobi.ogg',\r\n *         'audio/Kyobi.mp3',\r\n *         'audio/Kyobi.m4a'\r\n *     ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the audio JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the audio has finished loading you can use it create an Audio Sprite by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite('kyobi', 'kyobi.json');\r\n * // and later in your game ...\r\n * var music = this.sound.addAudioSprite('kyobi');\r\n * music.play('title');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio Sprite File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audioSprite\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig[])} key - The key to use for this file, or a file configuration object, or an array of objects.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {(string|string[])} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader.\r\n */\r\nFileTypesManager.register('audioSprite', function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var gameAudioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if ((gameAudioConfig && gameAudioConfig.noAudio) || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AudioSpriteFile(this, key[i]);\r\n\r\n            if (multifile.files)\r\n            {\r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);\r\n\r\n        if (multifile.files)\r\n        {\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Binary File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#binary method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#binary.\r\n *\r\n * @class BinaryFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n */\r\nvar BinaryFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function BinaryFile (loader, key, url, xhrSettings, dataType)\r\n    {\r\n        var extension = 'bin';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataType = GetFastValue(config, 'dataType', dataType);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'binary',\r\n            cache: loader.cacheManager.binary,\r\n            extension: extension,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: { dataType: dataType }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BinaryFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var ctor = this.config.dataType;\r\n\r\n        this.data = (ctor) ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Binary file, or array of Binary files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.binary('doom', 'files/Doom.wad');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Binary Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Binary Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Binary Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.binary({\r\n *     key: 'doom',\r\n *     url: 'files/Doom.wad',\r\n *     dataType: Uint8Array\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BinaryFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.binary('doom', 'files/Doom.wad');\r\n * // and later in your game ...\r\n * var data = this.cache.binary.get('doom');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and\r\n * this is what you would use to retrieve the text from the Binary Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"doom\"\r\n * and no URL is given then the Loader will set the URL to be \"doom.bin\". It will always add `.bin` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Binary File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#binary\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig|Phaser.Types.Loader.FileTypes.BinaryFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('binary', function (key, url, dataType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new BinaryFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BinaryFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ParseXMLBitmapFont = require('../../gameobjects/bitmaptext/ParseXMLBitmapFont.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Bitmap Font based File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#bitmapFont method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#bitmapFont.\r\n *\r\n * @class BitmapFontFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar BitmapFontFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function BitmapFontFile (loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'fontDataURL'),\r\n                extension: GetFastValue(config, 'fontDataExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'fontDataXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BitmapFontFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n\r\n            image.addToCache();\r\n            xml.pendingDestroy();\r\n\r\n            var texture = image.cache.get(image.key);\r\n\r\n            var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);\r\n\r\n            this.loader.cacheManager.bitmapFont.add(image.key, { data: data, texture: image.key, frame: null });\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Bitmap Font, or array of fonts, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the font data to be provided in an XML file format.\r\n * These files are created by software such as the [Angelcode Bitmap Font Generator](http://www.angelcode.com/products/bmfont/),\r\n * [Littera](http://kvazars.com/littera/) or [Glyph Designer](https://71squared.com/glyphdesigner)\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BitmapFontFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use key of it when creating a Bitmap Text Game Object:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * // and later in your game ...\r\n * this.add.bitmapText(x, y, 'goldenFont', 'Hello World');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use when creating a Bitmap Text object.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', [ 'images/GoldFont.png', 'images/GoldFont-n.png' ], 'images/GoldFont.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     normalMap: 'images/GoldFont-n.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Bitmap Font File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#bitmapFont\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('bitmapFont', function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new BitmapFontFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BitmapFontFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single CSS File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#css method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#css.\r\n *\r\n * @class CSSFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar CSSFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function CSSFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'css';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CSSFile#onProcess\r\n     * @since 3.17.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('style');\r\n        this.data.defer = false;\r\n        this.data.innerHTML = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSS file, or array of CSS files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.css('headers', 'styles/headers.css');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.css({\r\n *     key: 'headers',\r\n *     url: 'styles/headers.css'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.CSSFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a style DOM element\r\n * via `document.createElement('style')`. It will have its `defer` property set to false and then the\r\n * resulting element will be appended to `document.head`. The CSS styles are then applied to the current document.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.css\". It will always add `.css` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the CSS File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#css\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig|Phaser.Types.Loader.FileTypes.CSSFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.css`, i.e. if `key` was \"alien\" then the URL will be \"alien.css\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('css', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new CSSFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new CSSFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = CSSFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Shader = require('../../display/shader/BaseShader');\r\n\r\n/**\r\n * @classdesc\r\n * A single GLSL File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#glsl method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#glsl.\r\n *\r\n * @class GLSLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar GLSLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function GLSLFile (loader, key, url, shaderType, xhrSettings)\r\n    {\r\n        var extension = 'glsl';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            shaderType = GetFastValue(config, 'shaderType', 'fragment');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n        else if (shaderType === undefined)\r\n        {\r\n            shaderType = 'fragment';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'glsl',\r\n            cache: loader.cacheManager.shader,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            config: {\r\n                shaderType: shaderType\r\n            },\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var data = this.data.split('\\n');\r\n\r\n        //  Check to see if this is a shader bundle, or raw glsl file.\r\n        var block = this.extractBlock(data, 0);\r\n\r\n        if (block)\r\n        {\r\n            while (block)\r\n            {\r\n                var key = this.getShaderName(block.header);\r\n                var shaderType = this.getShaderType(block.header);\r\n                var uniforms = this.getShaderUniforms(block.header);\r\n                var shaderSrc = block.shader;\r\n\r\n                if (this.cache.has(key))\r\n                {\r\n                    var shader = this.cache.get(key);\r\n\r\n                    if (shaderType === 'fragment')\r\n                    {\r\n                        shader.fragmentSrc = shaderSrc;\r\n                    }\r\n                    else\r\n                    {\r\n                        shader.vertexSrc = shaderSrc;\r\n                    }\r\n\r\n                    if (!shader.uniforms)\r\n                    {\r\n                        shader.uniforms = uniforms;\r\n                    }\r\n                }\r\n                else if (shaderType === 'fragment')\r\n                {\r\n                    this.cache.add(key, new Shader(key, shaderSrc, '', uniforms));\r\n                }\r\n                else\r\n                {\r\n                    this.cache.add(key, new Shader(key, '', shaderSrc, uniforms));\r\n                }\r\n\r\n                block = this.extractBlock(data, block.offset);\r\n            }\r\n        }\r\n        else if (this.config.shaderType === 'fragment')\r\n        {\r\n            //  Single shader\r\n            this.cache.add(this.key, new Shader(this.key, this.data));\r\n        }\r\n        else\r\n        {\r\n            this.cache.add(this.key, new Shader(this.key, '', this.data));\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Returns the name of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader name.\r\n     */\r\n    getShaderName: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'name:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.key;\r\n    },\r\n\r\n    /**\r\n     * Returns the type of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderType\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader type. Either 'fragment' or 'vertex'.\r\n     */\r\n    getShaderType: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'type:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.config.shaderType;\r\n    },\r\n\r\n    /**\r\n     * Returns the shader uniforms from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderUniforms\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {any} The shader uniforms object.\r\n     */\r\n    getShaderUniforms: function (headerSource)\r\n    {\r\n        var uniforms = {};\r\n\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 8) === 'uniform.')\r\n            {\r\n                var pos = line.indexOf(':');\r\n\r\n                if (pos)\r\n                {\r\n                    var key = line.substring(8, pos);\r\n\r\n                    try\r\n                    {\r\n                        uniforms[key] = JSON.parse(line.substring(pos + 1));\r\n                    }\r\n                    catch (e)\r\n                    {\r\n                        console.warn('Invalid uniform JSON: ' + key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return uniforms;\r\n    },\r\n\r\n    /**\r\n     * Processes the shader file and extracts the relevant data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#extractBlock\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} data - The array of shader data to process.\r\n     * @param {number} offset - The offset to start processing from.\r\n     *\r\n     * @return {any} The processed shader block, or null.\r\n     */\r\n    extractBlock: function (data, offset)\r\n    {\r\n        var headerStart = -1;\r\n        var headerEnd = -1;\r\n        var blockEnd = -1;\r\n        var headerOpen = false;\r\n        var captureSource = false;\r\n        var headerSource = [];\r\n        var shaderSource = [];\r\n\r\n        for (var i = offset; i < data.length; i++)\r\n        {\r\n            var line = data[i].trim();\r\n\r\n            if (line === '---')\r\n            {\r\n                if (headerStart === -1)\r\n                {\r\n                    headerStart = i;\r\n                    headerOpen = true;\r\n                }\r\n                else if (headerOpen)\r\n                {\r\n                    headerEnd = i;\r\n                    headerOpen = false;\r\n                    captureSource = true;\r\n                }\r\n                else\r\n                {\r\n                    //  We've hit another --- delimiter, break out\r\n                    captureSource = false;\r\n                    break;\r\n                }\r\n            }\r\n            else if (headerOpen)\r\n            {\r\n                headerSource.push(line);\r\n            }\r\n            else if (captureSource)\r\n            {\r\n                shaderSource.push(line);\r\n                blockEnd = i;\r\n            }\r\n        }\r\n\r\n        if (!headerOpen && headerEnd !== -1)\r\n        {\r\n            return { header: headerSource, shader: shaderSource.join('\\n'), offset: blockEnd };\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a GLSL file, or array of GLSL files, to the current load queue.\r\n * In Phaser 3 GLSL files are just plain Text files at the current moment in time.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Shader Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Shader Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Shader Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.glsl({\r\n *     key: 'plasma',\r\n *     shaderType: 'fragment',\r\n *     url: 'shaders/Plasma.glsl'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.GLSLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * // and later in your game ...\r\n * var data = this.cache.shader.get('plasma');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `FX.` and the key was `Plasma` the final key will be `FX.Plasma` and\r\n * this is what you would use to retrieve the text from the Shader Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"plasma\"\r\n * and no URL is given then the Loader will set the URL to be \"plasma.glsl\". It will always add `.glsl` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the GLSL File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#glsl\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig|Phaser.Types.Loader.FileTypes.GLSLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was \"alien\" then the URL will be \"alien.glsl\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('glsl', function (key, url, shaderType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new GLSLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = GLSLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar File = require('../File');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetURL = require('../GetURL');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class HTML5AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [urlConfig] - The absolute or relative URL to load this file from.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTML5AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTML5AudioFile (loader, key, urlConfig, audioConfig)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            audioConfig = GetFastValue(config, 'config', audioConfig);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            key: key,\r\n            url: urlConfig.url,\r\n            config: audioConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  New properties specific to this class\r\n        this.locked = 'ontouchstart' in window;\r\n        this.loaded = false;\r\n        this.filesLoaded = 0;\r\n        this.filesTotal = 0;\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onLoad\r\n     * @since 3.0.0\r\n     */\r\n    onLoad: function ()\r\n    {\r\n        if (this.loaded)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.loaded = true;\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onError\r\n     * @since 3.0.0\r\n     */\r\n    onError: function ()\r\n    {\r\n        for (var i = 0; i < this.data.length; i++)\r\n        {\r\n            var audio = this.data[i];\r\n\r\n            audio.oncanplaythrough = null;\r\n            audio.onerror = null;\r\n        }\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        var audio = event.target;\r\n\r\n        audio.oncanplaythrough = null;\r\n        audio.onerror = null;\r\n\r\n        this.filesLoaded++;\r\n\r\n        this.percentComplete = Math.min((this.filesLoaded / this.filesTotal), 1);\r\n\r\n        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n\r\n        if (this.filesLoaded === this.filesTotal)\r\n        {\r\n            this.onLoad();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        this.data = [];\r\n\r\n        var instances = (this.config && this.config.instances) || 1;\r\n\r\n        this.filesTotal = instances;\r\n        this.filesLoaded = 0;\r\n        this.percentComplete = 0;\r\n\r\n        for (var i = 0; i < instances; i++)\r\n        {\r\n            var audio = new Audio();\r\n\r\n            if (!audio.dataset)\r\n            {\r\n                audio.dataset = {};\r\n            }\r\n\r\n            audio.dataset.name = this.key + ('0' + i).slice(-2);\r\n            audio.dataset.used = 'false';\r\n\r\n            if (this.locked)\r\n            {\r\n                audio.dataset.locked = 'true';\r\n            }\r\n            else\r\n            {\r\n                audio.dataset.locked = 'false';\r\n\r\n                audio.preload = 'auto';\r\n                audio.oncanplaythrough = this.onProgress.bind(this);\r\n                audio.onerror = this.onError.bind(this);\r\n            }\r\n\r\n            this.data.push(audio);\r\n        }\r\n\r\n        for (i = 0; i < this.data.length; i++)\r\n        {\r\n            audio = this.data[i];\r\n            audio.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (!this.locked)\r\n            {\r\n                audio.load();\r\n            }\r\n        }\r\n\r\n        if (this.locked)\r\n        {\r\n            //  This is super-dangerous but works. Race condition potential high.\r\n            //  Is there another way?\r\n            setTimeout(this.onLoad.bind(this));\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = HTML5AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#html method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#html.\r\n *\r\n * @class HTMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.html,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML file, or array of HTML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.html('story', 'files/LoginForm.html');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global HTML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the HTML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the HTML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.html({\r\n *     key: 'login',\r\n *     url: 'files/LoginForm.html'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.html('login', 'files/LoginForm.html');\r\n * // and later in your game ...\r\n * var data = this.cache.html.get('login');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the html from the HTML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#html\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig|Phaser.Types.Loader.FileTypes.HTMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('html', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#htmlTexture method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#htmlTexture.\r\n *\r\n * @class HTMLTextureFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {number} [width] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLTextureFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLTextureFile (loader, key, url, width, height, xhrSettings)\r\n    {\r\n        if (width === undefined) { width = 512; }\r\n        if (height === undefined) { height = 512; }\r\n\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            width = GetFastValue(config, 'width', width);\r\n            height = GetFastValue(config, 'height', height);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'html',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: width,\r\n                height: height\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var w = this.config.width;\r\n        var h = this.config.height;\r\n\r\n        var data = [];\r\n\r\n        data.push('<svg width=\"' + w + 'px\" height=\"' + h + 'px\" viewBox=\"0 0 ' + w + ' ' + h + '\" xmlns=\"http://www.w3.org/2000/svg\">');\r\n        data.push('<foreignObject width=\"100%\" height=\"100%\">');\r\n        data.push('<body xmlns=\"http://www.w3.org/1999/xhtml\">');\r\n        data.push(this.xhrLoader.responseText);\r\n        data.push('</body>');\r\n        data.push('</foreignObject>');\r\n        data.push('</svg>');\r\n\r\n        var svg = [ data.join('\\n') ];\r\n        var _this = this;\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            _this.state = CONST.FILE_ERRORED;\r\n\r\n            _this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML File, or array of HTML Files, to the current load queue. When the files are loaded they\r\n * will be rendered to textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture({\r\n *     key: 'instructions',\r\n *     url: 'content/intro.html',\r\n *     width: 256,\r\n *     height: 512\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'instructions');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * The width and height are the size of the texture to which the HTML will be rendered. It's not possible to determine these\r\n * automatically, so you will need to provide them, either as arguments or in the file config object.\r\n * When the HTML file has loaded a new SVG element is created with a size and viewbox set to the width and height given.\r\n * The SVG file has a body tag added to it, with the HTML file contents included. It then calls `window.Blob` on the SVG,\r\n * and if successful is added to the Texture Manager, otherwise it fails processing. The overall quality of the rendered\r\n * HTML depends on your browser, and some of them may not even support the svg / blob process used. Be aware that there are\r\n * limitations on what HTML can be inside an SVG. You can find out more details in this\r\n * [Mozilla MDN entry](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTMLTextureFile File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#htmlTexture\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {number} [width=512] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height=512] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('htmlTexture', function (key, url, width, height, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLTextureFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLTextureFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            try\r\n            {\r\n                var json = JSON.parse(this.xhrLoader.responseText);\r\n            }\r\n            catch (e)\r\n            {\r\n                console.warn('Invalid JSON: ' + this.key);\r\n\r\n                this.onProcessError();\r\n\r\n                throw e;\r\n            }\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Multi Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#multiatlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#multiatlas.\r\n *\r\n * @class MultiAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig)} key - The key of the file. Must be unique within both the Loader and the Texture Manager. Or a config object.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the multi atlas json file from.\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas json file.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture files.\r\n */\r\nvar MultiAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiAtlasFile (loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            if (GetFastValue(config, 'url', false))\r\n            {\r\n                atlasURL = GetFastValue(config, 'url');\r\n            }\r\n            else\r\n            {\r\n                atlasURL = GetFastValue(config, 'atlasURL');\r\n            }\r\n\r\n            atlasXhrSettings = GetFastValue(config, 'xhrSettings');\r\n            path = GetFastValue(config, 'path');\r\n            baseURL = GetFastValue(config, 'baseURL');\r\n            textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n        }\r\n\r\n        var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n\r\n        MultiFile.call(this, loader, 'multiatlas', key, [ data ]);\r\n\r\n        this.config.path = path;\r\n        this.config.baseURL = baseURL;\r\n        this.config.textureXhrSettings = textureXhrSettings;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'json' && file.data.hasOwnProperty('textures'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var textures = file.data.textures;\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', this.baseURL);\r\n                var path = GetFastValue(config, 'path', this.path);\r\n                var prefix = GetFastValue(config, 'prefix', this.prefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    //  \"image\": \"texture-packer-multi-atlas-0.png\",\r\n                    var textureURL = textures[i].image;\r\n\r\n                    var key = 'MA' + this.multiKeyIndex + '_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n\r\n                    //  \"normalMap\": \"texture-packer-multi-atlas-0_n.png\",\r\n                    if (textures[i].normalMap)\r\n                    {\r\n                        var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);\r\n\r\n                        normalMap.type = 'normalMap';\r\n\r\n                        image.setLink(normalMap);\r\n\r\n                        this.addToMultiFile(normalMap);\r\n\r\n                        loader.addFile(normalMap);\r\n                    }\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            var data = [];\r\n            var images = [];\r\n            var normalMaps = [];\r\n\r\n            for (var i = 1; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                if (file.type === 'normalMap')\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var pos = file.key.indexOf('_');\r\n                var key = file.key.substr(pos + 1);\r\n\r\n                var image = file.data;\r\n\r\n                //  Now we need to find out which json entry this mapped to\r\n                for (var t = 0; t < fileJSON.data.textures.length; t++)\r\n                {\r\n                    var item = fileJSON.data.textures[t];\r\n\r\n                    if (item.image === key)\r\n                    {\r\n                        images.push(image);\r\n\r\n                        data.push(item);\r\n\r\n                        if (file.linkFile)\r\n                        {\r\n                            normalMaps.push(file.linkFile.data);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (normalMaps.length === 0)\r\n            {\r\n                normalMaps = undefined;\r\n            }\r\n\r\n            this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);\r\n\r\n            this.complete = true;\r\n\r\n            for (i = 0; i < this.files.length; i++)\r\n            {\r\n                this.files[i].pendingDestroy();\r\n            }\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Multi Texture Atlas, or array of multi atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.multiatlas('level1', 'images/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file as exported from the application Texture Packer,\r\n * version 4.6.3 or above, where you have made sure to use the Phaser 3 Export option.\r\n *\r\n * The way it works internally is that you provide a URL to the JSON file. Phaser then loads this JSON, parses it and\r\n * extracts which texture files it also needs to load to complete the process. If the JSON also defines normal maps,\r\n * Phaser will load those as well.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas({\r\n *     key: 'level1',\r\n *     atlasURL: 'images/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas('level1', 'images/Level1.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'level1', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Multi Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#multiatlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('multiatlas', function (key, atlasURL, path, baseURL, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ScriptFile = require('./ScriptFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A Multi Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scripts method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scripts.\r\n *\r\n * @class MultiScriptFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object for the script files. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar MultiScriptFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n        var files = [];\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        if (!Array.isArray(url))\r\n        {\r\n            url = [ url ];\r\n        }\r\n\r\n        for (var i = 0; i < url.length; i++)\r\n        {\r\n            var scriptFile = new ScriptFile(loader, {\r\n                key: key + '_' + i.toString(),\r\n                url: url[i],\r\n                extension: extension,\r\n                xhrSettings: xhrSettings\r\n            });\r\n\r\n            //  Override the default onProcess function\r\n            scriptFile.onProcess = function ()\r\n            {\r\n                this.onProcessComplete();\r\n            };\r\n\r\n            files.push(scriptFile);\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'scripts', key, files);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiScriptFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            for (var i = 0; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                file.data = document.createElement('script');\r\n                file.data.language = 'javascript';\r\n                file.data.type = 'text/javascript';\r\n                file.data.defer = false;\r\n                file.data.text = file.xhrLoader.responseText;\r\n\r\n                document.head.appendChild(file.data);\r\n            }\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an array of Script files to the current load queue.\r\n *\r\n * The difference between this and the `ScriptFile` file type is that you give an array of scripts to this method,\r\n * and the scripts are then processed _exactly_ in that order. This allows you to load a bunch of scripts that\r\n * may have dependencies on each other without worrying about the async nature of traditional script loading.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scripts('PostProcess', [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *    ]);\r\n * }\r\n * ```\r\n *\r\n * In the code above the script files will all be loaded in parallel but only processed (i.e. invoked) in the exact\r\n * order given in the array.\r\n *\r\n * The files are **not** loaded right away. They are added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the files are queued\r\n * it means you cannot use the files immediately after calling this method, but must wait for the files to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scripts({\r\n *     key: 'PostProcess',\r\n *     url: [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *        ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiScriptFileConfig` for more details.\r\n *\r\n * Once all the files have finished loading they will automatically be converted into a script element\r\n * via `document.createElement('script')`. They will have their language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. This is done in the exact order the files are specified in the url array.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Note: The ability to load this type of file will only be available if the MultiScript File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scripts\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {string} [extension='js'] - The default file extension to use if no url is provided.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scripts', function (key, url, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiScriptFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiScriptFile(this, key, url, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile');\r\nvar ParseObj = require('../../geom/mesh/ParseObj');\r\nvar ParseObjMaterial = require('../../geom/mesh/ParseObjMaterial');\r\nvar TextFile = require('./TextFile');\r\n\r\n/**\r\n * @classdesc\r\n * A single Wavefront OBJ File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#obj method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#obj.\r\n *\r\n * @class OBJFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - The absolute or relative URL to load the material file from. If undefined or `null` it will be set to `<key>.mat`, i.e. if `key` was \"alien\" then the URL will be \"alien.mat\".\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n */\r\nvar OBJFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function OBJFile (loader, key, objURL, matURL, flipUV, xhrSettings)\r\n    {\r\n        var obj;\r\n        var mat;\r\n\r\n        var cache = loader.cacheManager.obj;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                type: 'obj',\r\n                cache: cache,\r\n                url: GetFastValue(config, 'url'),\r\n                extension: GetFastValue(config, 'extension', 'obj'),\r\n                xhrSettings: GetFastValue(config, 'xhrSettings'),\r\n                config: {\r\n                    flipUV: GetFastValue(config, 'flipUV', flipUV)\r\n                }\r\n            });\r\n\r\n            matURL = GetFastValue(config, 'matURL');\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    url: matURL,\r\n                    extension: GetFastValue(config, 'matExtension', 'mat'),\r\n                    xhrSettings: GetFastValue(config, 'xhrSettings')\r\n                });\r\n            }\r\n        }\r\n        else\r\n        {\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                url: objURL,\r\n                type: 'obj',\r\n                cache: cache,\r\n                extension: 'obj',\r\n                xhrSettings: xhrSettings,\r\n                config: {\r\n                    flipUV: flipUV\r\n                }\r\n            });\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    url: matURL,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    extension: 'mat',\r\n                    xhrSettings: xhrSettings\r\n                });\r\n            }\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'obj', key, [ obj, mat ]);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.OBJFile#addToCache\r\n     * @since 3.50.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var obj = this.files[0];\r\n            var mat = this.files[1];\r\n\r\n            var objData = ParseObj(obj.data, obj.config.flipUV);\r\n\r\n            if (mat)\r\n            {\r\n                objData.materials = ParseObjMaterial(mat.data);\r\n            }\r\n\r\n            obj.cache.add(obj.key, objData);\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Wavefront OBJ file, or array of OBJ files, to the current load queue.\r\n *\r\n * Note: You should ensure your 3D package has triangulated the OBJ file prior to export.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj');\r\n * }\r\n * ```\r\n *\r\n * You can optionally also load a Wavefront Material file as well, by providing the 3rd parameter:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj', 'files/spaceship.mtl');\r\n * }\r\n * ```\r\n *\r\n * If given, the material will be parsed and stored along with the obj data in the cache.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global OBJ Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the OBJ Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the OBJ Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.obj({\r\n *     key: 'ufo',\r\n *     url: 'files/spaceship.obj',\r\n *     matURL: 'files/spaceship.mtl',\r\n *     flipUV: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.OBJFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.obj('ufo', 'files/spaceship.obj');\r\n * // and later in your game ...\r\n * var data = this.cache.obj.get('ufo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the obj from the OBJ Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.obj\". It will always add `.obj` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the OBJ File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#obj\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.50.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig|Phaser.Types.Loader.FileTypes.OBJFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - Optional absolute or relative URL to load the obj material file from.\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('obj', function (key, objURL, matURL, flipUVs, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new OBJFile(this, key[i]);\r\n\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = OBJFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON Pack File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#pack method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#pack.\r\n *\r\n * @class PackFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar PackFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function PackFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'packfile';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PackFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = JSON.parse(this.xhrLoader.responseText);\r\n        }\r\n\r\n        //  Let's pass the pack file data over to the Loader ...\r\n        this.loader.addPack(this.data, this.config);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON File Pack, or array of packs, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.pack('level1', 'data/Level1Files.json');\r\n * }\r\n * ```\r\n *\r\n * A File Pack is a JSON file (or object) that contains details about other files that should be added into the Loader.\r\n * Here is a small example:\r\n *\r\n * ```json\r\n * {\r\n *    \"test1\": {\r\n *        \"files\": [\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"taikodrummaster\",\r\n *                \"url\": \"assets/pics/taikodrummaster.jpg\"\r\n *            },\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"sukasuka-chtholly\",\r\n *                \"url\": \"assets/pics/sukasuka-chtholly.png\"\r\n *            }\r\n *        ]\r\n *    },\r\n *    \"meta\": {\r\n *        \"generated\": \"1401380327373\",\r\n *        \"app\": \"Phaser 3 Asset Packer\",\r\n *        \"url\": \"https://phaser.io\",\r\n *        \"version\": \"1.0\",\r\n *        \"copyright\": \"Photon Storm Ltd. 2018\"\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * The pack can be split into sections. In the example above you'll see a section called `test1. You can tell\r\n * the `load.pack` method to parse only a particular section of a pack. The pack is stored in the JSON Cache,\r\n * so you can pass it to the Loader to process additional sections as needed in your game, or you can just load\r\n * them all at once without specifying anything.\r\n *\r\n * The pack file can contain an entry for any type of file that Phaser can load. The object structures exactly\r\n * match that of the file type configs, and all properties available within the file type configs can be used\r\n * in the pack file too.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.pack({\r\n *     key: 'level1',\r\n *     url: 'data/Level1Files.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PackFileConfig` for more details.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Pack File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#pack\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig|Phaser.Types.Loader.FileTypes.PackFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('pack', function (key, url, packKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new PackFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PackFile(this, key, url, xhrSettings, packKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PackFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#plugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#plugin.\r\n *\r\n * @class PluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {boolean} [start=false] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar PluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function PluginFile (loader, key, url, start, mapping, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            start = GetFastValue(config, 'start');\r\n            mapping = GetFastValue(config, 'mapping');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'plugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                start: start,\r\n                mapping: mapping\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PluginFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var start = GetFastValue(config, 'start', false);\r\n        var mapping = GetFastValue(config, 'mapping', null);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.install(this.key, this.data, start, mapping);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            var plugin = pluginManager.install(this.key, window[this.key], start, mapping);\r\n\r\n            if (start || mapping)\r\n            {\r\n                //  Install into the current Scene Systems and Scene\r\n                this.loader.systems[mapping] = plugin;\r\n                this.loader.scene[mapping] = plugin;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.plugin('modplayer', 'plugins/ModPlayer.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.plugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Plugin File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#plugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig|Phaser.Types.Loader.FileTypes.PluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, a plugin function.\r\n * @param {boolean} [start] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('plugin', function (key, url, start, mapping, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new PluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single SVG File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#svg method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#svg.\r\n *\r\n * @class SVGFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SVGFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SVGFile (loader, key, url, svgConfig, xhrSettings)\r\n    {\r\n        var extension = 'svg';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            svgConfig = GetFastValue(config, 'svgConfig', {});\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'svg',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: GetFastValue(svgConfig, 'width'),\r\n                height: GetFastValue(svgConfig, 'height'),\r\n                scale: GetFastValue(svgConfig, 'scale')\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var text = this.xhrLoader.responseText;\r\n        var svg = [ text ];\r\n        var width = this.config.width;\r\n        var height = this.config.height;\r\n        var scale = this.config.scale;\r\n\r\n        resize: if (width && height || scale)\r\n        {\r\n            var xml = null;\r\n            var parser = new DOMParser();\r\n            xml = parser.parseFromString(text, 'text/xml');\r\n            var svgXML = xml.getElementsByTagName('svg')[0];\r\n\r\n            var hasViewBox = svgXML.hasAttribute('viewBox');\r\n            var svgWidth = parseFloat(svgXML.getAttribute('width'));\r\n            var svgHeight = parseFloat(svgXML.getAttribute('height'));\r\n\r\n            if (!hasViewBox && svgWidth && svgHeight)\r\n            {\r\n                //  If there's no viewBox attribute, set one\r\n                svgXML.setAttribute('viewBox', '0  0 ' + svgWidth + ' ' + svgHeight);\r\n            }\r\n            else if (hasViewBox && !svgWidth && !svgHeight)\r\n            {\r\n                //  Get the w/h from the viewbox\r\n                var viewBox = svgXML.getAttribute('viewBox').split(/\\s+|,/);\r\n\r\n                svgWidth = viewBox[2];\r\n                svgHeight = viewBox[3];\r\n            }\r\n\r\n            if (scale)\r\n            {\r\n                if (svgWidth && svgHeight)\r\n                {\r\n                    width = svgWidth * scale;\r\n                    height = svgHeight * scale;\r\n                }\r\n                else\r\n                {\r\n                    break resize;\r\n                }\r\n            }\r\n\r\n            svgXML.setAttribute('width', width.toString() + 'px');\r\n            svgXML.setAttribute('height', height.toString() + 'px');\r\n\r\n            svg = [ (new XMLSerializer()).serializeToString(svgXML) ];\r\n        }\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            this.onProcessError();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n        var retry = false;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            if (!retry)\r\n            {\r\n                File.revokeObjectURL(_this.data);\r\n            }\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            //  Safari 8 re-try\r\n            if (!retry)\r\n            {\r\n                retry = true;\r\n\r\n                File.revokeObjectURL(_this.data);\r\n\r\n                _this.data.src = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));\r\n            }\r\n            else\r\n            {\r\n                _this.onProcessError();\r\n            }\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an SVG File, or array of SVG Files, to the current load queue. When the files are loaded they\r\n * will be rendered to bitmap textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SVGFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.svg('morty', 'images/Morty.svg');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'morty');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can optionally pass an SVG Resize Configuration object when you load an SVG file. By default the SVG will be rendered to a texture\r\n * at the same size defined in the SVG file attributes. However, this isn't always desirable. You may wish to resize the SVG (either down\r\n * or up) to improve texture clarity, or reduce texture memory consumption. You can either specify an exact width and height to resize\r\n * the SVG to:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { width: 300, height: 600 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         width: 300,\r\n *         height: 600\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * Alternatively, you can just provide a scale factor instead:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { scale: 2.5 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         scale: 2.5\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * If scale, width and height values are all given, the scale has priority and the width and height values are ignored.\r\n *\r\n * Note: The ability to load this type of file will only be available if the SVG File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#svg\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig|Phaser.Types.Loader.FileTypes.SVGFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('svg', function (key, url, svgConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SVGFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SVGFile;\r\n\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * An external Scene JavaScript File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#sceneFile method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#sceneFile.\r\n *\r\n * @class SceneFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SceneFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SceneFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#onProcess\r\n     * @since 3.16.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#addToCache\r\n     * @since 3.16.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var code = this.data.concat('(function(){\\n' + 'return new ' + this.key + '();\\n' + '}).call(this);');\r\n\r\n        //  Stops rollup from freaking out during build\r\n        var eval2 = eval;\r\n\r\n        this.loader.sceneManager.add(this.key, eval2(code));\r\n\r\n        this.complete = true;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an external Scene file, or array of Scene files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('Level1', 'src/Level1.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Scene Manager upon a successful load.\r\n *\r\n * For a Scene File it's vitally important that the key matches the class name in the JavaScript file.\r\n *\r\n * For example here is the source file:\r\n *\r\n * ```javascript\r\n * class ExternalScene extends Phaser.Scene {\r\n *\r\n *     constructor ()\r\n *     {\r\n *         super('myScene');\r\n *     }\r\n *\r\n * }\r\n * ```\r\n *\r\n * Because the class is called `ExternalScene` that is the exact same key you must use when loading it:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('ExternalScene', 'src/yourScene.js');\r\n * }\r\n * ```\r\n *\r\n * The key that is used within the Scene Manager can either be set to the same, or you can override it in the Scene\r\n * constructor, as we've done in the example above, where the Scene key was changed to `myScene`.\r\n *\r\n * The key should be unique both in terms of files being loaded and Scenes already present in the Scene Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Scene Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.sceneFile({\r\n *     key: 'Level1',\r\n *     url: 'src/Level1.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SceneFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will be added to the Scene Manager.\r\n *\r\n * ```javascript\r\n * this.load.sceneFile('Level1', 'src/Level1.js');\r\n * // and later in your game ...\r\n * this.scene.start('Level1');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `WORLD1.` and the key was `Story` the final key will be `WORLD1.Story` and\r\n * this is what you would use to retrieve the text from the Scene Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Scene File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#sceneFile\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.16.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig|Phaser.Types.Loader.FileTypes.SceneFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('sceneFile', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SceneFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SceneFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SceneFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Scene Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scenePlugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scenePlugin.\r\n *\r\n * @class ScenePluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScenePluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScenePluginFile (loader, key, url, systemKey, sceneKey, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            systemKey = GetFastValue(config, 'systemKey');\r\n            sceneKey = GetFastValue(config, 'sceneKey');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'scenePlugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                systemKey: systemKey,\r\n                sceneKey: sceneKey\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScenePluginFile#onProcess\r\n     * @since 3.8.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var key = this.key;\r\n        var systemKey = GetFastValue(config, 'systemKey', key);\r\n        var sceneKey = GetFastValue(config, 'sceneKey', key);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Scene Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scenePlugin('ModPlayer', 'plugins/ModPlayer.js', 'modPlayer', 'mods');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scenePlugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScenePluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scenePlugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.8.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, set to a plugin function.\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scenePlugin', function (key, url, systemKey, sceneKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScenePluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScenePluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#script method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#script.\r\n *\r\n * @class ScriptFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScriptFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScriptFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('script');\r\n        this.data.language = 'javascript';\r\n        this.data.type = 'text/javascript';\r\n        this.data.defer = false;\r\n        this.data.text = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Script file, or array of Script files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.script('aliens', 'lib/aliens.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.script({\r\n *     key: 'aliens',\r\n *     url: 'lib/aliens.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScriptFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#script\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig|Phaser.Types.Loader.FileTypes.ScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('script', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScriptFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScriptFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar ImageFile = require('./ImageFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Sprite Sheet Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spritesheet method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spritesheet.\r\n *\r\n * @class SpriteSheetFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SpriteSheetFile = new Class({\r\n\r\n    Extends: ImageFile,\r\n\r\n    initialize:\r\n\r\n    function SpriteSheetFile (loader, key, url, frameConfig, xhrSettings)\r\n    {\r\n        ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);\r\n\r\n        this.type = 'spritesheet';\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpriteSheetFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Sprite Sheet Image, or array of Sprite Sheet Images, to the current load queue.\r\n *\r\n * The term 'Sprite Sheet' in Phaser means a fixed-size sheet. Where every frame in the sheet is the exact same size,\r\n * and you reference those frames using numbers, not frame names. This is not the same thing as a Texture Atlas, where\r\n * the frames are packed in a way where they take up the least amount of space, and are referenced by their names,\r\n * not numbers. Some articles and software use the term 'Sprite Sheet' to mean Texture Atlas, so please be aware of\r\n * what sort of file you're actually trying to load.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'bot',\r\n *     url: 'images/robot.png',\r\n *     frameConfig: {\r\n *         frameWidth: 32,\r\n *         frameHeight: 38,\r\n *         startFrame: 0,\r\n *         endFrame: 8\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'bot', 0);\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `PLAYER.` and the key was `Running` the final key will be `PLAYER.Running` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ], { frameWidth: 256, frameHeight: 80 });\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png',\r\n *     frameConfig: {\r\n *         frameWidth: 256,\r\n *         frameHeight: 80\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n * \r\n * Note: The ability to load this type of file will only be available if the Sprite Sheet File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#spritesheet\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. At a minimum it should have a `frameWidth` property.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('spritesheet', function (key, url, frameConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SpriteSheetFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SpriteSheetFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var type = 'text';\r\n        var extension = 'txt';\r\n        var cache = loader.cacheManager.text;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            type = GetFastValue(config, 'type', type);\r\n            cache = GetFastValue(config, 'cache', cache);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: type,\r\n            cache: cache,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Tilemap CSV File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapCSV method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapCSV.\r\n *\r\n * @class TilemapCSVFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapCSVFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TilemapCSVFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'csv';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'tilemapCSV',\r\n            cache: loader.cacheManager.tilemap,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        this.tilemapFormat = TILEMAP_FORMATS.CSV;\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: this.tilemapFormat, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSV Tilemap file, or array of CSV files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * }\r\n * ```\r\n *\r\n * Tilemap CSV data can be created in a text editor, or a 3rd party app that exports as CSV.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.csv'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.csv\". It will always add `.csv` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap CSV File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapCSV\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapCSV', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapCSVFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapCSVFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Impact.js Tilemap JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapImpact method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapImpact.\r\n *\r\n * @class TilemapImpactFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapImpactFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    function TilemapImpactFile (loader, key, url, xhrSettings)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings);\r\n\r\n        this.type = 'tilemapJSON';\r\n\r\n        this.cache = loader.cacheManager.tilemap;\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapImpactFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: TILEMAP_FORMATS.WELTMEISTER, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Impact.js Tilemap file, or array of map files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * Impact Tilemap data is created the Impact.js Map Editor called Weltmeister.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap Impact File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapImpact\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapImpact', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapImpactFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapImpactFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar JSONFile = require('./JSONFile.js');\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\n\n/**\n * @classdesc\n * A single Tiled Tilemap JSON File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapTiledJSON method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapTiledJSON.\n *\n * @class TilemapJSONFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n */\nvar TilemapJSONFile = new Class({\n\n    Extends: JSONFile,\n\n    initialize:\n\n    function TilemapJSONFile (loader, key, url, xhrSettings)\n    {\n        JSONFile.call(this, loader, key, url, xhrSettings);\n\n        this.type = 'tilemapJSON';\n\n        this.cache = loader.cacheManager.tilemap;\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.TilemapJSONFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        var tiledata = { format: TILEMAP_FORMATS.TILED_JSON, data: this.data };\n\n        this.cache.add(this.key, tiledata);\n\n        this.pendingDestroy(tiledata);\n    }\n\n});\n\n/**\n * Adds a Tiled JSON Tilemap file, or array of map files, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * }\n * ```\n *\n * The Tilemap data is created using the Tiled Map Editor and selecting JSON as the export format.\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Text Cache first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.tilemapTiledJSON({\n *     key: 'level1',\n *     url: 'maps/Level1.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig` for more details.\n *\n * Once the file has finished loading you can access it from its Cache using its key:\n *\n * ```javascript\n * this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * // and later in your game ...\n * var map = this.make.tilemap({ key: 'level1' });\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\n * this is what you would use to retrieve the text from the Tilemap Cache.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Tilemap JSON File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#tilemapTiledJSON\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('tilemapTiledJSON', function (key, url, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new TilemapJSONFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));\n    }\n\n    return this;\n});\n\nmodule.exports = TilemapJSONFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar TextFile = require('./TextFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single text file based Unity Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#unityAtlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#unityAtlas.\r\n *\r\n * @class UnityAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar UnityAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function UnityAtlasFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new TextFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'txt'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new TextFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.UnityAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var text = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);\r\n\r\n            text.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Unity Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#unityAtlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('unityAtlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new UnityAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = UnityAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetURL = require('../GetURL');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Video File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#video method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#video.\r\n *\r\n * @class VideoFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {string} [loadEvent] - The load event to listen for when _not_ loading as a blob. Either 'loadeddata', 'canplay' or 'canplaythrough'.\r\n * @param {boolean} [asBlob] - Load the video as a data blob, or via the Video element?\r\n * @param {boolean} [noAudio] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar VideoFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by VideoFile.getVideoURL\r\n    function VideoFile (loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (asBlob === undefined) { asBlob = false; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (loadEvent !== 'loadeddata' && loadEvent !== 'canplay' && loadEvent !== 'canplaythrough')\r\n        {\r\n            loadEvent = 'loadeddata';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'video',\r\n            cache: loader.cacheManager.video,\r\n            extension: urlConfig.type,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                loadEvent: loadEvent,\r\n                asBlob: asBlob,\r\n                noAudio: noAudio\r\n            }\r\n        };\r\n\r\n        this.onLoadCallback = this.onVideoLoadHandler.bind(this);\r\n        this.onErrorCallback = this.onVideoErrorHandler.bind(this);\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onProcess\r\n     * @since 3.20.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        if (!this.config.asBlob)\r\n        {\r\n            this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        //  Load Video as blob\r\n\r\n        var video = this.createVideoElement();\r\n\r\n        this.data = video;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onloadeddata = function ()\r\n        {\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(video, this.xhrLoader.response, '');\r\n\r\n        video.load();\r\n    },\r\n\r\n    /**\r\n     * Creates a Video Element within the DOM.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#createVideoElement\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @return {HTMLVideoElement} The newly created Video element.\r\n     */\r\n    createVideoElement: function ()\r\n    {\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n        video.crossOrigin = this.loader.crossOrigin;\r\n\r\n        if (this.config.noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        return video;\r\n    },\r\n\r\n    /**\r\n     * Internal load event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoLoadHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoLoadHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n        video.removeEventListener('error', this.onErrorCallback, true);\r\n\r\n        this.data = video;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Internal load error event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoErrorHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoErrorHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        if (video)\r\n        {\r\n            video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n            video.removeEventListener('error', this.onErrorCallback, true);\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#load\r\n     * @since 3.20.0\r\n     */\r\n    load: function ()\r\n    {\r\n        var loadEvent = this.config.loadEvent;\r\n\r\n        if (this.config.asBlob)\r\n        {\r\n            File.prototype.load.call(this);\r\n        }\r\n        else\r\n        {\r\n            this.percentComplete = 0;\r\n\r\n            var video = this.createVideoElement();\r\n\r\n            video.addEventListener(loadEvent, this.onLoadCallback, true);\r\n            video.addEventListener('error', this.onErrorCallback, true);\r\n\r\n            video.src = GetURL(this, this.loader.baseURL);\r\n\r\n            video.load();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nVideoFile.create = function (loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        loadEvent = GetFastValue(key, 'loadEvent', 'loadeddata');\r\n        asBlob = GetFastValue(key, 'asBlob', false);\r\n        noAudio = GetFastValue(key, 'noAudio', false);\r\n        xhrSettings = GetFastValue(key, 'xhrSettings');\r\n        key = GetFastValue(key, 'key');\r\n    }\r\n\r\n    var urlConfig = VideoFile.getVideoURL(game, urls);\r\n    \r\n    if (urlConfig)\r\n    {\r\n        return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);\r\n    }\r\n};\r\n\r\nVideoFile.getVideoURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var videoType;\r\n\r\n        if (url.indexOf('data:') === 0)\r\n        {\r\n            videoType = url.split(',')[0].match(/\\/(.*?);/);\r\n        }\r\n        else\r\n        {\r\n            videoType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n        }\r\n\r\n        videoType = GetFastValue(urls[i], 'type', (videoType) ? videoType[1] : '').toLowerCase();\r\n\r\n        if (game.device.video[videoType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: videoType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds a Video file, or array of video files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.video('intro', [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Video Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Video Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Video Cache first, before loading a new one.\r\n  *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.video({\r\n *     key: 'intro',\r\n *     url: [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ],\r\n *     asBlob: false,\r\n *     noAudio: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.VideoFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different video file types you should usually provide your video files in a variety of formats.\r\n * mp4, mov and webm are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support, starting with the first in the array and progressing to the end.\r\n *\r\n * Unlike most asset-types, videos do not _need_ to be preloaded. You can create a Video Game Object and then call its `loadURL` method,\r\n * to load a video at run-time, rather than in advance.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Video File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#video\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.20.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig|Phaser.Types.Loader.FileTypes.VideoFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the video files from.\r\n * @param {string} [loadEvent='loadeddata'] - The load event to listen for when _not_ loading as a blob. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n * @param {boolean} [asBlob=false] - Load the video as a data blob, or stream it via the Video element?\r\n * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('video', function (key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var videoFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            videoFile = VideoFile.create(this, key[i]);\r\n\r\n            if (videoFile)\r\n            {\r\n                this.addFile(videoFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);\r\n\r\n        if (videoFile)\r\n        {\r\n            this.addFile(videoFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = VideoFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar ParseXML = require('../../dom/ParseXML');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#xml method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#xml.\r\n *\r\n * @class XMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar XMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function XMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'xml';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'xml',\r\n            cache: loader.cacheManager.xml,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.XMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = ParseXML(this.xhrLoader.responseText);\r\n\r\n        if (this.data)\r\n        {\r\n            this.onProcessComplete();\r\n        }\r\n        else\r\n        {\r\n            console.warn('Invalid XMLFile: ' + this.key);\r\n            \r\n            this.onProcessError();\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML file, or array of XML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global XML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the XML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the XML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.xml({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.XMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * // and later in your game ...\r\n * var data = this.cache.xml.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the XML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.xml\". It will always add `.xml` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#xml\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig|Phaser.Types.Loader.FileTypes.XMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('xml', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new XMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new XMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = XMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypes\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AnimationJSONFile: require('./AnimationJSONFile'),\r\n    AsepriteFile: require('./AsepriteFile'),\r\n    AtlasJSONFile: require('./AtlasJSONFile'),\r\n    AtlasXMLFile: require('./AtlasXMLFile'),\r\n    AudioFile: require('./AudioFile'),\r\n    AudioSpriteFile: require('./AudioSpriteFile'),\r\n    BinaryFile: require('./BinaryFile'),\r\n    BitmapFontFile: require('./BitmapFontFile'),\r\n    CSSFile: require('./CSSFile'),\r\n    GLSLFile: require('./GLSLFile'),\r\n    HTML5AudioFile: require('./HTML5AudioFile'),\r\n    HTMLFile: require('./HTMLFile'),\r\n    HTMLTextureFile: require('./HTMLTextureFile'),\r\n    ImageFile: require('./ImageFile'),\r\n    JSONFile: require('./JSONFile'),\r\n    MultiAtlasFile: require('./MultiAtlasFile'),\r\n    MultiScriptFile: require('./MultiScriptFile'),\r\n    OBJFile: require('./OBJFile'),\r\n    PackFile: require('./PackFile'),\r\n    PluginFile: require('./PluginFile'),\r\n    SceneFile: require('./SceneFile'),\r\n    ScenePluginFile: require('./ScenePluginFile'),\r\n    ScriptFile: require('./ScriptFile'),\r\n    SpriteSheetFile: require('./SpriteSheetFile'),\r\n    SVGFile: require('./SVGFile'),\r\n    TextFile: require('./TextFile'),\r\n    TilemapCSVFile: require('./TilemapCSVFile'),\r\n    TilemapImpactFile: require('./TilemapImpactFile'),\r\n    TilemapJSONFile: require('./TilemapJSONFile'),\r\n    UnityAtlasFile: require('./UnityAtlasFile'),\r\n    VideoFile: require('./VideoFile'),\r\n    XMLFile: require('./XMLFile')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Loader\r\n */\r\n\r\nvar Loader = {\r\n\r\n    Events: require('./events'),\r\n\r\n    FileTypes: require('./filetypes'),\r\n\r\n    File: require('./File'),\r\n    FileTypesManager: require('./FileTypesManager'),\r\n    GetURL: require('./GetURL'),\r\n    LoaderPlugin: require('./LoaderPlugin'),\r\n    MergeXHRSettings: require('./MergeXHRSettings'),\r\n    MultiFile: require('./MultiFile'),\r\n    XHRLoader: require('./XHRLoader'),\r\n    XHRSettings: require('./XHRSettings')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nLoader = Extend(false, Loader, CONST);\r\n\r\nmodule.exports = Loader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachSetCallback<E>\r\n *\r\n * @param {E} entry - The Set entry.\r\n * @param {number} index - The index of the entry within the Set.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Set is a collection of unique elements.\r\n *\r\n * @class Set\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [elements]\r\n *\r\n * @param {Array.<*>} [elements] - An optional array of elements to insert into this Set.\r\n */\r\nvar Set = new Class({\r\n\r\n    initialize:\r\n\r\n    function Set (elements)\r\n    {\r\n        /**\r\n         * The entries of this Set. Stored internally as an array.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Set#entries\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = [];\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.\r\n     *\r\n     * @method Phaser.Structs.Set#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to insert into this Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    set: function (value)\r\n    {\r\n        if (this.entries.indexOf(value) === -1)\r\n        {\r\n            this.entries.push(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.\r\n     * If no elements of this Set satisfy the condition then this method will return `null`.\r\n     *\r\n     * @method Phaser.Structs.Set#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value,$return]\r\n     *\r\n     * @param {string} property - The property name to check on the elements of this Set.\r\n     * @param {*} value - The value to check for.\r\n     *\r\n     * @return {*} The first element of this Set that meets the required condition, or `null` if this Set contains no elements that meet the condition.\r\n     */\r\n    get: function (property, value)\r\n    {\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            if (entry[property] === value)\r\n            {\r\n                return entry;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all the values in this Set.\r\n     *\r\n     * @method Phaser.Structs.Set#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array containing all the values in this Set.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        return this.entries.slice(0);\r\n    },\r\n\r\n    /**\r\n     * Removes the given value from this Set if this Set contains that value.\r\n     *\r\n     * @method Phaser.Structs.Set#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to remove from the Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    delete: function (value)\r\n    {\r\n        var index = this.entries.indexOf(value);\r\n\r\n        if (index > -1)\r\n        {\r\n            this.entries.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Set to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Set#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.group('Set');\r\n\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n            console.log(entry);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.\r\n     *\r\n     * @method Phaser.Structs.Set#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    each: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var temp = this.entries.slice();\r\n        var len = temp.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * For when you absolutely know this Set won't be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#iterate\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterate: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var len = this.entries.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.\r\n     *\r\n     * @method Phaser.Structs.Set#iterateLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {string} callbackKey - The key of the function to be invoked on each Set entry.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterateLocal: function (callbackKey)\r\n    {\r\n        var i;\r\n        var args = [];\r\n\r\n        for (i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        var len = this.entries.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            entry[callbackKey].apply(entry, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears this Set so that it no longer contains any values.\r\n     *\r\n     * @method Phaser.Structs.Set#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.entries.length = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if this Set contains the given value, otherwise returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Set#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {*} value - The value to check for in this Set.\r\n     *\r\n     * @return {boolean} `true` if the given value was found in this Set, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        return (this.entries.indexOf(value) > -1);\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.\r\n     *\r\n     * @method Phaser.Structs.Set#union\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the union with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set and the Set provided as an argument.\r\n     */\r\n    union: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        set.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#intersect\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to intersect this set with.\r\n     *\r\n     * @return {Phaser.Structs.Set} The result of the intersection, as a new Set.\r\n     */\r\n    intersect: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all the values in this Set which are *not* also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#difference\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the difference with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set that are not also in the Set provided as an argument to this method.\r\n     */\r\n    difference: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (!set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * The size of this Set. This is the number of entries within it.\r\n     * Changing the size will truncate the Set if the given value is smaller than the current size.\r\n     * Increasing the size larger than the current size has no effect.\r\n     *\r\n     * @name Phaser.Structs.Set#size\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    size: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.entries.length;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value < this.entries.length)\r\n            {\r\n                return this.entries.length = value;\r\n            }\r\n            else\r\n            {\r\n                return this.entries.length;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Set;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @ignore\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @ignore\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n"],"names":["has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","event","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","concat","listeners","handlers","i","l","length","ee","Array","listenerCount","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","module","exports","red","green","blue","BaseShader","initialize","key","fragmentSrc","vertexSrc","uniforms","join","data","xml","window","DOMParser","parseFromString","ActiveXObject","loadXML","e","documentElement","getElementsByTagName","getValue","node","attribute","parseInt","getAttribute","frame","xSpacing","ySpacing","texture","textureX","cutX","textureY","cutY","textureWidth","source","width","textureHeight","height","sourceIndex","info","common","font","size","lineHeight","chars","letters","adjustForTrim","trimmed","top","left","charCode","letter","String","fromCharCode","gx","gy","gw","gh","x","y","u0","v0","u1","v1","centerX","Math","floor","centerY","xOffset","yOffset","xAdvance","kerning","charFrame","add","setUVs","kernings","kern","first","second","amount","flip","defaultModelName","currentGroup","currentMaterial","currentModel","result","models","faces","textureCoords","vertexNormals","vertices","parseObject","lineItems","modelName","parseGroup","parseVertexCoords","parseFloat","z","parseTextureCoords","u","v","w","isNaN","parseVertexNormal","parsePolygon","totalVertices","face","group","material","vertexValues","split","vvLen","vertexIndex","textureCoordsIndex","vertexNormalIndex","parseMtlLib","materialLibraries","parseUseMtl","flipUV","line","idx","materials","lines","indexOf","substring","replace","trim","toLowerCase","GetColor","mtl","output","r","g","b","Class","CONST","GetFastValue","GetURL","MergeXHRSettings","XHRLoader","XHRSettings","File","loader","fileConfig","cache","type","loadKey","Error","url","path","match","src","xhrSettings","xhrLoader","state","FILE_POPULATED","FILE_PENDING","bytesTotal","bytesLoaded","percentComplete","crossOrigin","config","multiFile","linkFile","setLink","fileB","resetXHR","onload","onerror","onprogress","load","nextFile","FILE_LOADING","baseURL","console","warn","xhr","onLoad","localFileOk","responseURL","target","status","success","readyState","FILE_LOADED","onError","onProgress","lengthComputable","loaded","total","min","FILE_PROGRESS","onProcess","FILE_PROCESSING","onProcessComplete","FILE_COMPLETE","onFileComplete","fileProcessComplete","onProcessError","FILE_ERRORED","onFileFailed","hasCacheConflict","exists","addToCache","pendingDestroy","FILE_KEY_COMPLETE","flagForRemoval","destroy","createObjectURL","image","blob","defaultType","URL","reader","FileReader","removeAttribute","readAsDataURL","revokeObjectURL","types","FileTypesManager","install","register","factoryFunction","file","CustomSet","PluginCache","SceneEvents","LoaderPlugin","Extends","scene","gameConfig","sys","game","sceneConfig","settings","systems","cacheManager","textureManager","textures","sceneManager","setBaseURL","loaderBaseURL","setPath","loaderPath","setPrefix","loaderPrefix","maxParallelDownloads","loaderMaxParallelDownloads","loaderResponseType","loaderAsync","loaderUser","loaderPassword","loaderTimeout","loaderWithCredentials","loaderCrossOrigin","totalToLoad","progress","list","inflight","queue","_deleteQueue","totalFailed","totalComplete","LOADER_IDLE","multiKeyIndex","BOOT","boot","START","pluginStart","DESTROY","SHUTDOWN","shutdown","substr","setCORS","addFile","isArray","item","keyExists","set","ADD","isLoading","updateProgress","keyConflict","iterate","addPack","pack","packKey","currentBaseURL","currentPath","currentPrefix","files","LOADER_LOADING","LOADER_PROCESSING","isReady","LOADER_COMPLETE","start","loadComplete","clear","checkLoadQueue","UPDATE","update","PROGRESS","each","delete","FILE_LOAD","FILE_LOAD_ERROR","isReadyToProcess","POST_PROCESS","iterateLocal","COMPLETE","saveJSON","filename","save","JSON","stringify","filetype","Blob","a","document","createElement","download","textContent","href","click","reset","LOADER_SHUTDOWN","LOADER_DESTROYED","Extend","global","local","setting","MultiFile","finalFiles","forEach","complete","pending","failed","addToMultiFile","globalXHRSettings","XMLHttpRequest","open","async","user","password","responseType","timeout","headers","setRequestHeader","header","headerValue","requestedWith","overrideMimeType","withCredentials","bind","send","FILE_FAILED","FILE_DESTROYED","JSONFile","LoaderEvents","AnimationJSONFile","dataKey","onLoadComplete","anims","fromJSON","ImageFile","IsPlainObject","AsepriteFile","textureURL","atlasURL","textureXhrSettings","atlasXhrSettings","extension","normalMap","json","addAtlas","multifile","AtlasJSONFile","XMLFile","AtlasXMLFile","addAtlasXML","HTML5AudioFile","AudioFile","urlConfig","audioContext","audio","_this","decodeAudioData","response","audioBuffer","error","message","urls","audioConfig","deviceAudio","device","getAudioURL","webAudio","disableWebAudio","sound","audioType","audioFile","noAudio","audioData","AudioSpriteFile","jsonURL","audioURL","audioXhrSettings","jsonXhrSettings","resourceLoad","resources","fileA","gameAudioConfig","BinaryFile","dataType","binary","ctor","ParseXMLBitmapFont","BitmapFontFile","fontDataURL","fontDataXhrSettings","get","getFrame","bitmapFont","CSSFile","defer","innerHTML","responseText","head","appendChild","Shader","GLSLFile","shaderType","shader","block","extractBlock","getShaderName","getShaderType","getShaderUniforms","shaderSrc","offset","headerSource","pos","parse","headerStart","headerEnd","blockEnd","headerOpen","captureSource","shaderSource","locked","filesLoaded","filesTotal","oncanplaythrough","instances","Audio","dataset","used","preload","setTimeout","HTMLFile","html","HTMLTextureFile","h","svg","Image","addImage","frameConfig","normalMapURL","GetValue","MultiAtlasFile","fileJSON","images","normalMaps","t","addAtlasJSONArray","ScriptFile","MultiScriptFile","scriptFile","toString","language","text","ParseObj","ParseObjMaterial","TextFile","OBJFile","objURL","matURL","obj","mat","objData","flipUVs","PackFile","PluginFile","mapping","pluginManager","plugins","plugin","SVGFile","svgConfig","scale","resize","svgXML","hasViewBox","hasAttribute","svgWidth","svgHeight","setAttribute","viewBox","XMLSerializer","serializeToString","retry","encodeURIComponent","SceneFile","code","eval2","eval","ScenePluginFile","systemKey","sceneKey","installScenePlugin","SpriteSheetFile","addSpriteSheet","TILEMAP_FORMATS","TilemapCSVFile","tilemap","tilemapFormat","CSV","tiledata","format","TilemapImpactFile","WELTMEISTER","TilemapJSONFile","TILED_JSON","UnityAtlasFile","addUnityAtlas","VideoFile","loadEvent","asBlob","video","onLoadCallback","onVideoLoadHandler","onErrorCallback","onVideoErrorHandler","createVideoElement","onloadeddata","controls","muted","defaultMuted","removeEventListener","addEventListener","getVideoURL","videoType","videoFile","ParseXML","Loader","FileTypes","corePlugins","customPlugins","custom","Set","elements","entries","value","property","entry","getArray","index","splice","dump","log","groupEnd","callback","callbackScope","temp","callbackKey","contains","union","newSet","intersect","difference","ARRAY_2D","getProperty","definition","k","isClassDescriptor","def","getOwnPropertyDescriptor","hasGetterOrSetter","enumerable","configurable","hasNonConfigurable","prop","extend","ignoreFinals","defineProperty","mixin","myClass","mixins","base","constructor","Mixins","defaultValue","keys","parent"],"sourceRoot":""}