{"version":3,"file":"js/345.3293277b1385b1bfe732.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/Animation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/AnimationFrame.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ADD_ANIMATION_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_COMPLETE_KEY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_REPEAT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_RESTART_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_STOP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/ANIMATION_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/PAUSE_ALL_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/REMOVE_ANIMATION_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/RESUME_ALL_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/animations/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Map.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/FindClosestInSorted.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/SortByDigits.js"],"sourcesContent":["/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Clamp = require('../math/Clamp');\nvar Class = require('../utils/Class');\nvar Events = require('./events');\nvar FindClosestInSorted = require('../utils/array/FindClosestInSorted');\nvar Frame = require('./AnimationFrame');\nvar GetValue = require('../utils/object/GetValue');\nvar SortByDigits = require('../utils/array/SortByDigits');\n\n/**\n * @classdesc\n * A Frame based Animation.\n *\n * Animations in Phaser consist of a sequence of `AnimationFrame` objects, which are managed by\n * this class, along with properties that impact playback, such as the animations frame rate\n * or delay.\n *\n * This class contains all of the properties and methods needed to handle playback of the animation\n * directly to an `AnimationState` instance, which is owned by a Sprite, or similar Game Object.\n *\n * You don't typically create an instance of this class directly, but instead go via\n * either the `AnimationManager` or the `AnimationState` and use their `create` methods,\n * depending on if you need a global animation, or local to a specific Sprite.\n *\n * @class Animation\n * @memberof Phaser.Animations\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Animations.AnimationManager} manager - A reference to the global Animation Manager\n * @param {string} key - The unique identifying string for this animation.\n * @param {Phaser.Types.Animations.Animation} config - The Animation configuration.\n */\nvar Animation = new Class({\n\n    initialize:\n\n    function Animation (manager, key, config)\n    {\n        /**\n         * A reference to the global Animation Manager.\n         *\n         * @name Phaser.Animations.Animation#manager\n         * @type {Phaser.Animations.AnimationManager}\n         * @since 3.0.0\n         */\n        this.manager = manager;\n\n        /**\n         * The unique identifying string for this animation.\n         *\n         * @name Phaser.Animations.Animation#key\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.key = key;\n\n        /**\n         * A frame based animation (as opposed to a bone based animation)\n         *\n         * @name Phaser.Animations.Animation#type\n         * @type {string}\n         * @default frame\n         * @since 3.0.0\n         */\n        this.type = 'frame';\n\n        /**\n         * Extract all the frame data into the frames array.\n         *\n         * @name Phaser.Animations.Animation#frames\n         * @type {Phaser.Animations.AnimationFrame[]}\n         * @since 3.0.0\n         */\n        this.frames = this.getFrames(\n            manager.textureManager,\n            GetValue(config, 'frames', []),\n            GetValue(config, 'defaultTextureKey', null),\n            GetValue(config, 'sortFrames', true)\n        );\n\n        /**\n         * The frame rate of playback in frames per second (default 24 if duration is null)\n         *\n         * @name Phaser.Animations.Animation#frameRate\n         * @type {number}\n         * @default 24\n         * @since 3.0.0\n         */\n        this.frameRate = GetValue(config, 'frameRate', null);\n\n        /**\n         * How long the animation should play for, in milliseconds.\n         * If the `frameRate` property has been set then it overrides this value,\n         * otherwise the `frameRate` is derived from `duration`.\n         *\n         * @name Phaser.Animations.Animation#duration\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.duration = GetValue(config, 'duration', null);\n\n        /**\n         * How many ms per frame, not including frame specific modifiers.\n         *\n         * @name Phaser.Animations.Animation#msPerFrame\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.msPerFrame;\n\n        /**\n         * Skip frames if the time lags, or always advanced anyway?\n         *\n         * @name Phaser.Animations.Animation#skipMissedFrames\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.skipMissedFrames = GetValue(config, 'skipMissedFrames', true);\n\n        /**\n         * The delay in ms before the playback will begin.\n         *\n         * @name Phaser.Animations.Animation#delay\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.delay = GetValue(config, 'delay', 0);\n\n        /**\n         * Number of times to repeat the animation. Set to -1 to repeat forever.\n         *\n         * @name Phaser.Animations.Animation#repeat\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.repeat = GetValue(config, 'repeat', 0);\n\n        /**\n         * The delay in ms before the a repeat play starts.\n         *\n         * @name Phaser.Animations.Animation#repeatDelay\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.repeatDelay = GetValue(config, 'repeatDelay', 0);\n\n        /**\n         * Should the animation yoyo (reverse back down to the start) before repeating?\n         *\n         * @name Phaser.Animations.Animation#yoyo\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.yoyo = GetValue(config, 'yoyo', false);\n\n        /**\n         * Should the GameObject's `visible` property be set to `true` when the animation starts to play?\n         *\n         * @name Phaser.Animations.Animation#showOnStart\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.showOnStart = GetValue(config, 'showOnStart', false);\n\n        /**\n         * Should the GameObject's `visible` property be set to `false` when the animation finishes?\n         *\n         * @name Phaser.Animations.Animation#hideOnComplete\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.hideOnComplete = GetValue(config, 'hideOnComplete', false);\n\n        /**\n         * Global pause. All Game Objects using this Animation instance are impacted by this property.\n         *\n         * @name Phaser.Animations.Animation#paused\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.paused = false;\n\n        this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate);\n\n        if (this.manager.on)\n        {\n            this.manager.on(Events.PAUSE_ALL, this.pause, this);\n            this.manager.on(Events.RESUME_ALL, this.resume, this);\n        }\n    },\n\n    /**\n     * Gets the total number of frames in this animation.\n     *\n     * @method Phaser.Animations.Animation#getTotalFrames\n     * @since 3.50.0\n     *\n     * @return {number} The total number of frames in this animation.\n     */\n    getTotalFrames: function ()\n    {\n        return this.frames.length;\n    },\n\n    /**\n     * Calculates the duration, frame rate and msPerFrame values.\n     *\n     * @method Phaser.Animations.Animation#calculateDuration\n     * @since 3.50.0\n     *\n     * @param {Phaser.Animations.Animation} target - The target to set the values on.\n     * @param {number} totalFrames - The total number of frames in the animation.\n     * @param {number} duration - The duration to calculate the frame rate from.\n     * @param {number} frameRate - The frame ate to calculate the duration from.\n     */\n    calculateDuration: function (target, totalFrames, duration, frameRate)\n    {\n        if (duration === null && frameRate === null)\n        {\n            //  No duration or frameRate given, use default frameRate of 24fps\n            target.frameRate = 24;\n            target.duration = (24 / totalFrames) * 1000;\n        }\n        else if (duration && frameRate === null)\n        {\n            //  Duration given but no frameRate, so set the frameRate based on duration\n            //  I.e. 12 frames in the animation, duration = 4000 ms\n            //  So frameRate is 12 / (4000 / 1000) = 3 fps\n            target.duration = duration;\n            target.frameRate = totalFrames / (duration / 1000);\n        }\n        else\n        {\n            //  frameRate given, derive duration from it (even if duration also specified)\n            //  I.e. 15 frames in the animation, frameRate = 30 fps\n            //  So duration is 15 / 30 = 0.5 * 1000 (half a second, or 500ms)\n            target.frameRate = frameRate;\n            target.duration = (totalFrames / frameRate) * 1000;\n        }\n\n        target.msPerFrame = 1000 / target.frameRate;\n    },\n\n    /**\n     * Add frames to the end of the animation.\n     *\n     * @method Phaser.Animations.Animation#addFrame\n     * @since 3.0.0\n     *\n     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} config - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.\n     *\n     * @return {this} This Animation object.\n     */\n    addFrame: function (config)\n    {\n        return this.addFrameAt(this.frames.length, config);\n    },\n\n    /**\n     * Add frame/s into the animation.\n     *\n     * @method Phaser.Animations.Animation#addFrameAt\n     * @since 3.0.0\n     *\n     * @param {number} index - The index to insert the frame at within the animation.\n     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} config - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.\n     *\n     * @return {this} This Animation object.\n     */\n    addFrameAt: function (index, config)\n    {\n        var newFrames = this.getFrames(this.manager.textureManager, config);\n\n        if (newFrames.length > 0)\n        {\n            if (index === 0)\n            {\n                this.frames = newFrames.concat(this.frames);\n            }\n            else if (index === this.frames.length)\n            {\n                this.frames = this.frames.concat(newFrames);\n            }\n            else\n            {\n                var pre = this.frames.slice(0, index);\n                var post = this.frames.slice(index);\n\n                this.frames = pre.concat(newFrames, post);\n            }\n\n            this.updateFrameSequence();\n        }\n\n        return this;\n    },\n\n    /**\n     * Check if the given frame index is valid.\n     *\n     * @method Phaser.Animations.Animation#checkFrame\n     * @since 3.0.0\n     *\n     * @param {number} index - The index to be checked.\n     *\n     * @return {boolean} `true` if the index is valid, otherwise `false`.\n     */\n    checkFrame: function (index)\n    {\n        return (index >= 0 && index < this.frames.length);\n    },\n\n    /**\n     * Called internally when this Animation first starts to play.\n     * Sets the accumulator and nextTick properties.\n     *\n     * @method Phaser.Animations.Animation#getFirstTick\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State belonging to the Game Object invoking this call.\n     */\n    getFirstTick: function (state)\n    {\n        //  When is the first update due?\n        state.accumulator = 0;\n\n        state.nextTick = state.msPerFrame + state.currentFrame.duration;\n    },\n\n    /**\n     * Returns the AnimationFrame at the provided index\n     *\n     * @method Phaser.Animations.Animation#getFrameAt\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} index - The index in the AnimationFrame array\n     *\n     * @return {Phaser.Animations.AnimationFrame} The frame at the index provided from the animation sequence\n     */\n    getFrameAt: function (index)\n    {\n        return this.frames[index];\n    },\n\n    /**\n     * Creates AnimationFrame instances based on the given frame data.\n     *\n     * @method Phaser.Animations.Animation#getFrames\n     * @since 3.0.0\n     *\n     * @param {Phaser.Textures.TextureManager} textureManager - A reference to the global Texture Manager.\n     * @param {(string|Phaser.Types.Animations.AnimationFrame[])} frames - Either a string, in which case it will use all frames from a texture with the matching key, or an array of Animation Frame configuration objects.\n     * @param {string} [defaultTextureKey] - The key to use if no key is set in the frame configuration object.\n     *\n     * @return {Phaser.Animations.AnimationFrame[]} An array of newly created AnimationFrame instances.\n     */\n    getFrames: function (textureManager, frames, defaultTextureKey, sortFrames)\n    {\n        if (sortFrames === undefined) { sortFrames = true; }\n\n        var out = [];\n        var prev;\n        var animationFrame;\n        var index = 1;\n        var i;\n        var textureKey;\n\n        //  if frames is a string, we'll get all the frames from the texture manager as if it's a sprite sheet\n        if (typeof frames === 'string')\n        {\n            textureKey = frames;\n\n            var texture = textureManager.get(textureKey);\n            var frameKeys = texture.getFrameNames();\n\n            if (sortFrames)\n            {\n                SortByDigits(frameKeys);\n            }\n\n            frames = [];\n\n            frameKeys.forEach(function (value)\n            {\n                frames.push({ key: textureKey, frame: value });\n            });\n        }\n\n        if (!Array.isArray(frames) || frames.length === 0)\n        {\n            return out;\n        }\n\n        for (i = 0; i < frames.length; i++)\n        {\n            var item = frames[i];\n\n            var key = GetValue(item, 'key', defaultTextureKey);\n\n            if (!key)\n            {\n                continue;\n            }\n\n            //  Could be an integer or a string\n            var frame = GetValue(item, 'frame', 0);\n\n            //  The actual texture frame\n            var textureFrame = textureManager.getFrame(key, frame);\n\n            animationFrame = new Frame(key, frame, index, textureFrame);\n\n            animationFrame.duration = GetValue(item, 'duration', 0);\n\n            animationFrame.isFirst = (!prev);\n\n            //  The previously created animationFrame\n            if (prev)\n            {\n                prev.nextFrame = animationFrame;\n\n                animationFrame.prevFrame = prev;\n            }\n\n            out.push(animationFrame);\n\n            prev = animationFrame;\n\n            index++;\n        }\n\n        if (out.length > 0)\n        {\n            animationFrame.isLast = true;\n\n            //  Link them end-to-end, so they loop\n            animationFrame.nextFrame = out[0];\n\n            out[0].prevFrame = animationFrame;\n\n            //  Generate the progress data\n\n            var slice = 1 / (out.length - 1);\n\n            for (i = 0; i < out.length; i++)\n            {\n                out[i].progress = i * slice;\n            }\n        }\n\n        return out;\n    },\n\n    /**\n     * Called internally. Sets the accumulator and nextTick values of the current Animation.\n     *\n     * @method Phaser.Animations.Animation#getNextTick\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State belonging to the Game Object invoking this call.\n     */\n    getNextTick: function (state)\n    {\n        state.accumulator -= state.nextTick;\n\n        state.nextTick = state.msPerFrame + state.currentFrame.duration;\n    },\n\n    /**\n     * Returns the frame closest to the given progress value between 0 and 1.\n     *\n     * @method Phaser.Animations.Animation#getFrameByProgress\n     * @since 3.4.0\n     *\n     * @param {number} value - A value between 0 and 1.\n     *\n     * @return {Phaser.Animations.AnimationFrame} The frame closest to the given progress value.\n     */\n    getFrameByProgress: function (value)\n    {\n        value = Clamp(value, 0, 1);\n\n        return FindClosestInSorted(value, this.frames, 'progress');\n    },\n\n    /**\n     * Advance the animation frame.\n     *\n     * @method Phaser.Animations.Animation#nextFrame\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State to advance.\n     */\n    nextFrame: function (state)\n    {\n        var frame = state.currentFrame;\n\n        if (frame.isLast)\n        {\n            //  We're at the end of the animation\n\n            //  Yoyo? (happens before repeat)\n            if (state.yoyo)\n            {\n                this.handleYoyoFrame(state, false);\n            }\n            else if (state.repeatCounter > 0)\n            {\n                //  Repeat (happens before complete)\n\n                if (state.inReverse && state.forward)\n                {\n                    state.forward = false;\n                }\n                else\n                {\n                    this.repeatAnimation(state);\n                }\n            }\n            else\n            {\n                state.complete();\n            }\n        }\n        else\n        {\n            this.updateAndGetNextTick(state, frame.nextFrame);\n        }\n    },\n\n    /**\n     * Handle the yoyo functionality in nextFrame and previousFrame methods.\n     *\n     * @method Phaser.Animations.Animation#handleYoyoFrame\n     * @private\n     * @since 3.12.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State to advance.\n     * @param {boolean} isReverse - Is animation in reverse mode? (Default: false)\n     */\n    handleYoyoFrame: function (state, isReverse)\n    {\n        if (!isReverse) { isReverse = false; }\n\n        if (state.inReverse === !isReverse && state.repeatCounter > 0)\n        {\n            if (state.repeatDelay === 0 || state.pendingRepeat)\n            {\n                state.forward = isReverse;\n            }\n\n            this.repeatAnimation(state);\n\n            return;\n        }\n\n        if (state.inReverse !== isReverse && state.repeatCounter === 0)\n        {\n            state.complete();\n\n            return;\n        }\n\n        state.forward = isReverse;\n\n        var frame = (isReverse) ? state.currentFrame.nextFrame : state.currentFrame.prevFrame;\n\n        this.updateAndGetNextTick(state, frame);\n    },\n\n    /**\n     * Returns the animation last frame.\n     *\n     * @method Phaser.Animations.Animation#getLastFrame\n     * @since 3.12.0\n     *\n     * @return {Phaser.Animations.AnimationFrame} The last Animation Frame.\n     */\n    getLastFrame: function ()\n    {\n        return this.frames[this.frames.length - 1];\n    },\n\n    /**\n     * Called internally when the Animation is playing backwards.\n     * Sets the previous frame, causing a yoyo, repeat, complete or update, accordingly.\n     *\n     * @method Phaser.Animations.Animation#previousFrame\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State belonging to the Game Object invoking this call.\n     */\n    previousFrame: function (state)\n    {\n        var frame = state.currentFrame;\n\n        if (frame.isFirst)\n        {\n            //  We're at the start of the animation\n            if (state.yoyo)\n            {\n                this.handleYoyoFrame(state, true);\n            }\n            else if (state.repeatCounter > 0)\n            {\n                if (state.inReverse && !state.forward)\n                {\n                    this.repeatAnimation(state);\n                }\n                else\n                {\n                    //  Repeat (happens before complete)\n                    state.forward = true;\n\n                    this.repeatAnimation(state);\n                }\n            }\n            else\n            {\n                state.complete();\n            }\n        }\n        else\n        {\n            this.updateAndGetNextTick(state, frame.prevFrame);\n        }\n    },\n\n    /**\n     * Update Frame and Wait next tick.\n     *\n     * @method Phaser.Animations.Animation#updateAndGetNextTick\n     * @private\n     * @since 3.12.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State.\n     * @param {Phaser.Animations.AnimationFrame} frame - An Animation frame.\n     */\n    updateAndGetNextTick: function (state, frame)\n    {\n        state.setCurrentFrame(frame);\n\n        this.getNextTick(state);\n    },\n\n    /**\n     * Removes the given AnimationFrame from this Animation instance.\n     * This is a global action. Any Game Object using this Animation will be impacted by this change.\n     *\n     * @method Phaser.Animations.Animation#removeFrame\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationFrame} frame - The AnimationFrame to be removed.\n     *\n     * @return {this} This Animation object.\n     */\n    removeFrame: function (frame)\n    {\n        var index = this.frames.indexOf(frame);\n\n        if (index !== -1)\n        {\n            this.removeFrameAt(index);\n        }\n\n        return this;\n    },\n\n    /**\n     * Removes a frame from the AnimationFrame array at the provided index\n     * and updates the animation accordingly.\n     *\n     * @method Phaser.Animations.Animation#removeFrameAt\n     * @since 3.0.0\n     *\n     * @param {number} index - The index in the AnimationFrame array\n     *\n     * @return {this} This Animation object.\n     */\n    removeFrameAt: function (index)\n    {\n        this.frames.splice(index, 1);\n\n        this.updateFrameSequence();\n\n        return this;\n    },\n\n    /**\n     * Called internally during playback. Forces the animation to repeat, providing there are enough counts left\n     * in the repeat counter.\n     *\n     * @method Phaser.Animations.Animation#repeatAnimation\n     * @fires Phaser.Animations.Events#ANIMATION_REPEAT\n     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_REPEAT\n     * @fires Phaser.Animations.Events#SPRITE_ANIMATION_KEY_REPEAT\n     * @since 3.0.0\n     *\n     * @param {Phaser.Animations.AnimationState} state - The Animation State belonging to the Game Object invoking this call.\n     */\n    repeatAnimation: function (state)\n    {\n        if (state._pendingStop === 2)\n        {\n            if (state._pendingStopValue === 0)\n            {\n                return state.stop();\n            }\n            else\n            {\n                state._pendingStopValue--;\n            }\n        }\n\n        if (state.repeatDelay > 0 && !state.pendingRepeat)\n        {\n            state.pendingRepeat = true;\n            state.accumulator -= state.nextTick;\n            state.nextTick += state.repeatDelay;\n        }\n        else\n        {\n            state.repeatCounter--;\n\n            if (state.forward)\n            {\n                state.setCurrentFrame(state.currentFrame.nextFrame);\n            }\n            else\n            {\n                state.setCurrentFrame(state.currentFrame.prevFrame);\n            }\n\n            if (state.isPlaying)\n            {\n                this.getNextTick(state);\n\n                state.handleRepeat();\n            }\n        }\n    },\n\n    /**\n     * Converts the animation data to JSON.\n     *\n     * @method Phaser.Animations.Animation#toJSON\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.Animations.JSONAnimation} The resulting JSONAnimation formatted object.\n     */\n    toJSON: function ()\n    {\n        var output = {\n            key: this.key,\n            type: this.type,\n            frames: [],\n            frameRate: this.frameRate,\n            duration: this.duration,\n            skipMissedFrames: this.skipMissedFrames,\n            delay: this.delay,\n            repeat: this.repeat,\n            repeatDelay: this.repeatDelay,\n            yoyo: this.yoyo,\n            showOnStart: this.showOnStart,\n            hideOnComplete: this.hideOnComplete\n        };\n\n        this.frames.forEach(function (frame)\n        {\n            output.frames.push(frame.toJSON());\n        });\n\n        return output;\n    },\n\n    /**\n     * Called internally whenever frames are added to, or removed from, this Animation.\n     *\n     * @method Phaser.Animations.Animation#updateFrameSequence\n     * @since 3.0.0\n     *\n     * @return {this} This Animation object.\n     */\n    updateFrameSequence: function ()\n    {\n        var len = this.frames.length;\n        var slice = 1 / (len - 1);\n\n        var frame;\n\n        for (var i = 0; i < len; i++)\n        {\n            frame = this.frames[i];\n\n            frame.index = i + 1;\n            frame.isFirst = false;\n            frame.isLast = false;\n            frame.progress = i * slice;\n\n            if (i === 0)\n            {\n                frame.isFirst = true;\n\n                if (len === 1)\n                {\n                    frame.isLast = true;\n                    frame.nextFrame = frame;\n                    frame.prevFrame = frame;\n                }\n                else\n                {\n                    frame.isLast = false;\n                    frame.prevFrame = this.frames[len - 1];\n                    frame.nextFrame = this.frames[i + 1];\n                }\n            }\n            else if (i === len - 1 && len > 1)\n            {\n                frame.isLast = true;\n                frame.prevFrame = this.frames[len - 2];\n                frame.nextFrame = this.frames[0];\n            }\n            else if (len > 1)\n            {\n                frame.prevFrame = this.frames[i - 1];\n                frame.nextFrame = this.frames[i + 1];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Pauses playback of this Animation. The paused state is set immediately.\n     *\n     * @method Phaser.Animations.Animation#pause\n     * @since 3.0.0\n     *\n     * @return {this} This Animation object.\n     */\n    pause: function ()\n    {\n        this.paused = true;\n\n        return this;\n    },\n\n    /**\n     * Resumes playback of this Animation. The paused state is reset immediately.\n     *\n     * @method Phaser.Animations.Animation#resume\n     * @since 3.0.0\n     *\n     * @return {this} This Animation object.\n     */\n    resume: function ()\n    {\n        this.paused = false;\n\n        return this;\n    },\n\n    /**\n     * Destroys this Animation instance. It will remove all event listeners,\n     * remove this animation and its key from the global Animation Manager,\n     * and then destroy all Animation Frames in turn.\n     *\n     * @method Phaser.Animations.Animation#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        if (this.manager.off)\n        {\n            this.manager.off(Events.PAUSE_ALL, this.pause, this);\n            this.manager.off(Events.RESUME_ALL, this.resume, this);\n        }\n\n        this.manager.remove(this.key);\n\n        for (var i = 0; i < this.frames.length; i++)\n        {\n            this.frames[i].destroy();\n        }\n\n        this.frames = [];\n\n        this.manager = null;\n    }\n\n});\n\nmodule.exports = Animation;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A single frame in an Animation sequence.\r\n *\r\n * An AnimationFrame consists of a reference to the Texture it uses for rendering, references to other\r\n * frames in the animation, and index data. It also has the ability to modify the animation timing.\r\n *\r\n * AnimationFrames are generated automatically by the Animation class.\r\n *\r\n * @class AnimationFrame\r\n * @memberof Phaser.Animations\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} textureKey - The key of the Texture this AnimationFrame uses.\r\n * @param {(string|number)} textureFrame - The key of the Frame within the Texture that this AnimationFrame uses.\r\n * @param {number} index - The index of this AnimationFrame within the Animation sequence.\r\n * @param {Phaser.Textures.Frame} frame - A reference to the Texture Frame this AnimationFrame uses for rendering.\r\n * @param {boolean} [isKeyFrame=false] - Is this Frame a Keyframe within the Animation?\r\n */\r\nvar AnimationFrame = new Class({\r\n\r\n    initialize:\r\n\r\n    function AnimationFrame (textureKey, textureFrame, index, frame, isKeyFrame)\r\n    {\r\n        if (isKeyFrame === undefined) { isKeyFrame = false; }\r\n\r\n        /**\r\n         * The key of the Texture this AnimationFrame uses.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#textureKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.textureKey = textureKey;\r\n\r\n        /**\r\n         * The key of the Frame within the Texture that this AnimationFrame uses.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#textureFrame\r\n         * @type {(string|number)}\r\n         * @since 3.0.0\r\n         */\r\n        this.textureFrame = textureFrame;\r\n\r\n        /**\r\n         * The index of this AnimationFrame within the Animation sequence.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * A reference to the Texture Frame this AnimationFrame uses for rendering.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = frame;\r\n\r\n        /**\r\n         * Is this the first frame in an animation sequence?\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#isFirst\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.isFirst = false;\r\n\r\n        /**\r\n         * Is this the last frame in an animation sequence?\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#isLast\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.isLast = false;\r\n\r\n        /**\r\n         * A reference to the AnimationFrame that comes before this one in the animation, if any.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#prevFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.prevFrame = null;\r\n\r\n        /**\r\n         * A reference to the AnimationFrame that comes after this one in the animation, if any.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#nextFrame\r\n         * @type {?Phaser.Animations.AnimationFrame}\r\n         * @default null\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.nextFrame = null;\r\n\r\n        /**\r\n         * Additional time (in ms) that this frame should appear for during playback.\r\n         * The value is added onto the msPerFrame set by the animation.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * What % through the animation does this frame come?\r\n         * This value is generated when the animation is created and cached here.\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Is this Frame a KeyFrame within the Animation?\r\n         *\r\n         * @name Phaser.Animations.AnimationFrame#isKeyFrame\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.isKeyFrame = isKeyFrame;\r\n    },\r\n\r\n    /**\r\n     * Generates a JavaScript object suitable for converting to JSON.\r\n     *\r\n     * @method Phaser.Animations.AnimationFrame#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Animations.JSONAnimationFrame} The AnimationFrame data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            key: this.textureKey,\r\n            frame: this.textureFrame,\r\n            duration: this.duration,\r\n            keyframe: this.isKeyFrame\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Destroys this object by removing references to external resources and callbacks.\r\n     *\r\n     * @method Phaser.Animations.AnimationFrame#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.frame = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = AnimationFrame;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Add Animation Event.\r\n * \r\n * This event is dispatched when a new animation is added to the global Animation Manager.\r\n * \r\n * This can happen either as a result of an animation instance being added to the Animation Manager,\r\n * or the Animation Manager creating a new animation directly.\r\n *\r\n * @event Phaser.Animations.Events#ADD_ANIMATION\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Animation that was added to the global Animation Manager.\r\n * @param {Phaser.Animations.Animation} animation - An instance of the newly created Animation.\r\n */\r\nmodule.exports = 'add';\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Complete Event.\n *\n * This event is dispatched by a Sprite when an animation playing on it completes playback.\n * This happens when the animation gets to the end of its sequence, factoring in any delays\n * or repeats it may have to process.\n *\n * An animation that is set to loop, or repeat forever, will never fire this event, because\n * it never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\n * event instead, as this is emitted when the animation is stopped directly.\n *\n * Listen for it on the Sprite using `sprite.on('animationcomplete', listener)`\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_COMPLETE\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that completed.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation updated.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationcomplete';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Complete Dynamic Key Event.\n *\n * This event is dispatched by a Sprite when an animation playing on it completes playback.\n * This happens when the animation gets to the end of its sequence, factoring in any delays\n * or repeats it may have to process.\n *\n * An animation that is set to loop, or repeat forever, will never fire this event, because\n * it never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\n * event instead, as this is emitted when the animation is stopped directly.\n *\n * The difference between this and the `ANIMATION_COMPLETE` event is that this one has a\n * dynamic event name that contains the name of the animation within it. For example,\n * if you had an animation called `explode` you could listen for the completion of that\n * specific animation by using: `sprite.on('animationcomplete-explode', listener)`. Or, if you\n * wish to use types: `sprite.on(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + 'explode', listener)`.\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_COMPLETE_KEY\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that completed.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation updated.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationcomplete-';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Repeat Event.\n *\n * This event is dispatched by a Sprite when an animation repeats playing on it.\n * This happens if the animation was created, or played, with a `repeat` value specified.\n *\n * An animation will repeat when it reaches the end of its sequence.\n *\n * Listen for it on the Sprite using `sprite.on('animationrepeat', listener)`\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_REPEAT\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has repeated.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation repeated.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationrepeat';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Restart Event.\n *\n * This event is dispatched by a Sprite when an animation restarts playing on it.\n * This only happens when the `Sprite.anims.restart` method is called.\n *\n * Listen for it on the Sprite using `sprite.on('animationrestart', listener)`\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_RESTART\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has restarted.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation restarted.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationrestart';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Start Event.\n *\n * This event is dispatched by a Sprite when an animation starts playing on it.\n * This happens when the animation is played, factoring in any delay that may have been specified.\n * This event happens after the delay has expired and prior to the first update event.\n *\n * Listen for it on the Sprite using `sprite.on('animationstart', listener)`\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_START\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has started.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation started.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationstart';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Stop Event.\n *\n * This event is dispatched by a Sprite when an animation is stopped on it. An animation\n * will only be stopeed if a method such as `Sprite.stop` or `Sprite.anims.stopAfterDelay`\n * is called. It can also be emitted if a new animation is started before the current one completes.\n *\n * Listen for it on the Sprite using `sprite.on('animationstop', listener)`\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_STOP\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has stopped.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation stopped.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationstop';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Animation Update Event.\n *\n * This event is dispatched by a Sprite when an animation playing on it updates. This happens when the animation changes frame.\n * An animation will change frame based on the frme rate and other factors like `timeScale` and `delay`. It can also change\n * frame when stopped or restarted.\n *\n * Listen for it on the Sprite using `sprite.on('animationupdate', listener)`\n *\n * If an animation is playing faster than the game frame-rate can handle, it's entirely possible for it to emit several\n * update events in a single game frame, so please be aware of this in your code. The **final** event received that frame\n * is the one that is rendered to the game.\n *\n * The animation event flow is as follows:\n *\n * 1. `ANIMATION_START`\n * 2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n * 3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n * 4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n * 5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n *\n * If the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n *\n * If the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.\n *\n * @event Phaser.Animations.Events#ANIMATION_UPDATE\n * @since 3.50.0\n *\n * @param {Phaser.Animations.Animation} animation - A reference to the Animation that has updated.\n * @param {Phaser.Animations.AnimationFrame} frame - The current Animation Frame of the Animation.\n * @param {Phaser.GameObjects.Sprite} gameObject - A reference to the Game Object on which the animation updated.\n * @param {string} frameKey - The unique key of the Animation Frame within the Animation.\n */\nmodule.exports = 'animationupdate';\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Pause All Animations Event.\r\n * \r\n * This event is dispatched when the global Animation Manager is told to pause.\r\n * \r\n * When this happens all current animations will stop updating, although it doesn't necessarily mean\r\n * that the game has paused as well.\r\n *\r\n * @event Phaser.Animations.Events#PAUSE_ALL\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'pauseall';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Remove Animation Event.\r\n * \r\n * This event is dispatched when an animation is removed from the global Animation Manager.\r\n *\r\n * @event Phaser.Animations.Events#REMOVE_ANIMATION\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Animation that was removed from the global Animation Manager.\r\n * @param {Phaser.Animations.Animation} animation - An instance of the removed Animation.\r\n */\r\nmodule.exports = 'remove';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Resume All Animations Event.\r\n * \r\n * This event is dispatched when the global Animation Manager resumes, having been previously paused.\r\n * \r\n * When this happens all current animations will continue updating again.\r\n *\r\n * @event Phaser.Animations.Events#RESUME_ALL\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'resumeall';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Animations.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD_ANIMATION: require('./ADD_ANIMATION_EVENT'),\r\n    ANIMATION_COMPLETE: require('./ANIMATION_COMPLETE_EVENT'),\r\n    ANIMATION_COMPLETE_KEY: require('./ANIMATION_COMPLETE_KEY_EVENT'),\r\n    ANIMATION_REPEAT: require('./ANIMATION_REPEAT_EVENT'),\r\n    ANIMATION_RESTART: require('./ANIMATION_RESTART_EVENT'),\r\n    ANIMATION_START: require('./ANIMATION_START_EVENT'),\r\n    ANIMATION_STOP: require('./ANIMATION_STOP_EVENT'),\r\n    ANIMATION_UPDATE: require('./ANIMATION_UPDATE_EVENT'),\r\n    PAUSE_ALL: require('./PAUSE_ALL_EVENT'),\r\n    REMOVE_ANIMATION: require('./REMOVE_ANIMATION_EVENT'),\r\n    RESUME_ALL: require('./RESUME_ALL_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachMapCallback<E>\r\n *\r\n * @param {string} key - The key of the Map entry.\r\n * @param {E} entry - The value of the Map entry.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The keys of a Map can be arbitrary values.\r\n *\r\n * ```javascript\r\n * var map = new Map([\r\n *    [ 1, 'one' ],\r\n *    [ 2, 'two' ],\r\n *    [ 3, 'three' ]\r\n * ]);\r\n * ```\r\n *\r\n * @class Map\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic K\r\n * @generic V\r\n * @genericUse {V[]} - [elements]\r\n *\r\n * @param {Array.<*>} elements - An optional array of key-value pairs to populate this Map with.\r\n */\r\nvar Map = new Class({\r\n\r\n    initialize:\r\n\r\n    function Map (elements)\r\n    {\r\n        /**\r\n         * The entries in this Map.\r\n         *\r\n         * @genericUse {Object.<string, V>} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Map#entries\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = {};\r\n\r\n        /**\r\n         * The number of key / value pairs in this Map.\r\n         *\r\n         * @name Phaser.Structs.Map#size\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.size = 0;\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i][0], elements[i][1]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an element with a specified `key` and `value` to this Map.\r\n     * If the `key` already exists, the value will be replaced.\r\n     *\r\n     * @method Phaser.Structs.Map#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [value]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to be added to this Map.\r\n     * @param {*} value - The value of the element to be added to this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    set: function (key, value)\r\n    {\r\n        if (!this.has(key))\r\n        {\r\n            this.size++;\r\n        }\r\n\r\n        this.entries[key] = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the value associated to the `key`, or `undefined` if there is none.\r\n     *\r\n     * @method Phaser.Structs.Map#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to return from the `Map` object.\r\n     *\r\n     * @return {*} The element associated with the specified key or `undefined` if the key can't be found in this Map object.\r\n     */\r\n    get: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            return this.entries[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all the values stored in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array of the values stored in this Map.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element with the specified key exists or not.\r\n     *\r\n     * @method Phaser.Structs.Map#has\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     *\r\n     * @param {string} key - The key of the element to test for presence of in this Map.\r\n     *\r\n     * @return {boolean} Returns `true` if an element with the specified key exists in this Map, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return (this.entries.hasOwnProperty(key));\r\n    },\r\n\r\n    /**\r\n     * Delete the specified element from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to delete from this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    delete: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            delete this.entries[key];\r\n            this.size--;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all entries from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        Object.keys(this.entries).forEach(function (prop)\r\n        {\r\n            delete this.entries[prop];\r\n\r\n        }, this);\r\n\r\n        this.size = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns all entries keys in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#keys\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K[]} - [$return]\r\n     *\r\n     * @return {string[]} Array containing entries' keys.\r\n     */\r\n    keys: function ()\r\n    {\r\n        return Object.keys(this.entries);\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all entries.\r\n     *\r\n     * @method Phaser.Structs.Map#values\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An `Array` of entries.\r\n     */\r\n    values: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Map to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Map#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var entries = this.entries;\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.group('Map');\r\n\r\n        for (var key in entries)\r\n        {\r\n            console.log(key, entries[key]);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Iterates through all entries in this Map, passing each one to the given callback.\r\n     *\r\n     * If the callback returns `false`, the iteration will break.\r\n     *\r\n     * @method Phaser.Structs.Map#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachMapCallback.<V>} - [callback]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {EachMapCallback} callback - The callback which will receive the keys and entries held in this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    each: function (callback)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (callback(key, entries[key]) === false)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the value exists within this Map. Otherwise, returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Map#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V} - [value]\r\n     *\r\n     * @param {*} value - The value to search for.\r\n     *\r\n     * @return {boolean} `true` if the value is found, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (entries[key] === value)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Merges all new keys from the given Map into this one.\r\n     * If it encounters a key that already exists it will be skipped unless override is set to `true`.\r\n     *\r\n     * @method Phaser.Structs.Map#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]\r\n     *\r\n     * @param {Phaser.Structs.Map} map - The Map to merge in to this Map.\r\n     * @param {boolean} [override=false] - Set to `true` to replace values in this Map with those from the source map, or `false` to skip them.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    merge: function (map, override)\r\n    {\r\n        if (override === undefined) { override = false; }\r\n\r\n        var local = this.entries;\r\n        var source = map.entries;\r\n\r\n        for (var key in source)\r\n        {\r\n            if (local.hasOwnProperty(key) && override)\r\n            {\r\n                local[key] = source[key];\r\n            }\r\n            else\r\n            {\r\n                this.set(key, source[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Map;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Searches a pre-sorted array for the closet value to the given number.\r\n *\r\n * If the `key` argument is given it will assume the array contains objects that all have the required `key` property name,\r\n * and will check for the closest value of those to the given number.\r\n *\r\n * @function Phaser.Utils.Array.FindClosestInSorted\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to search for in the array.\r\n * @param {array} array - The array to search, which must be sorted.\r\n * @param {string} [key] - An optional property key. If specified the array elements property will be checked against value.\r\n *\r\n * @return {(number|any)} The nearest value found in the array, or if a `key` was given, the nearest object with the matching property value.\r\n */\r\nvar FindClosestInSorted = function (value, array, key)\r\n{\r\n    if (!array.length)\r\n    {\r\n        return NaN;\r\n    }\r\n    else if (array.length === 1)\r\n    {\r\n        return array[0];\r\n    }\r\n\r\n    var i = 1;\r\n    var low;\r\n    var high;\r\n\r\n    if (key)\r\n    {\r\n        if (value < array[0][key])\r\n        {\r\n            return array[0];\r\n        }\r\n\r\n        while (array[i][key] < value)\r\n        {\r\n            i++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        while (array[i] < value)\r\n        {\r\n            i++;\r\n        }\r\n    }\r\n\r\n    if (i > array.length)\r\n    {\r\n        i = array.length;\r\n    }\r\n\r\n    if (key)\r\n    {\r\n        low = array[i - 1][key];\r\n        high = array[i][key];\r\n\r\n        return ((high - value) <= (value - low)) ? array[i] : array[i - 1];\r\n    }\r\n    else\r\n    {\r\n        low = array[i - 1];\r\n        high = array[i];\r\n\r\n        return ((high - value) <= (value - low)) ? high : low;\r\n    }\r\n};\r\n\r\nmodule.exports = FindClosestInSorted;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Takes the given array and runs a numeric sort on it, ignoring any non-digits that\n * may be in the entries.\n *\n * You should only run this on arrays containing strings.\n *\n * @function Phaser.Utils.Array.SortByDigits\n * @since 3.50.0\n *\n * @param {string[]} array - The input array of strings.\n *\n * @return {string[]} The sorted input array.\n */\nvar SortByDigits = function (array)\n{\n    var re = /\\D/g;\n\n    array.sort(function (a, b)\n    {\n        return (parseInt(a.replace(re, ''), 10) - parseInt(b.replace(re, ''), 10));\n    });\n\n    return array;\n};\n\nmodule.exports = SortByDigits;\n"],"names":["Clamp","Class","Events","FindClosestInSorted","Frame","GetValue","SortByDigits","Animation","initialize","manager","key","config","this","type","frames","getFrames","textureManager","frameRate","duration","msPerFrame","skipMissedFrames","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","paused","calculateDuration","getTotalFrames","on","PAUSE_ALL","pause","RESUME_ALL","resume","length","target","totalFrames","addFrame","addFrameAt","index","newFrames","concat","pre","slice","post","updateFrameSequence","checkFrame","getFirstTick","state","accumulator","nextTick","currentFrame","getFrameAt","defaultTextureKey","sortFrames","undefined","prev","animationFrame","i","textureKey","out","frameKeys","get","getFrameNames","forEach","value","push","frame","Array","isArray","item","textureFrame","getFrame","isFirst","nextFrame","prevFrame","isLast","progress","getNextTick","getFrameByProgress","handleYoyoFrame","repeatCounter","inReverse","forward","repeatAnimation","complete","updateAndGetNextTick","isReverse","pendingRepeat","getLastFrame","previousFrame","setCurrentFrame","removeFrame","indexOf","removeFrameAt","splice","_pendingStop","_pendingStopValue","stop","isPlaying","handleRepeat","toJSON","output","len","destroy","off","remove","module","exports","AnimationFrame","isKeyFrame","keyframe","ADD_ANIMATION","ANIMATION_COMPLETE","ANIMATION_COMPLETE_KEY","ANIMATION_REPEAT","ANIMATION_RESTART","ANIMATION_START","ANIMATION_STOP","ANIMATION_UPDATE","REMOVE_ANIMATION","Map","elements","entries","size","set","has","getArray","hasOwnProperty","delete","clear","Object","keys","prop","values","dump","console","group","log","groupEnd","each","callback","contains","merge","map","override","local","source","array","NaN","low","high","re","sort","a","b","parseInt","replace"],"sourceRoot":""}