{"version":3,"file":"js/phaser-gameobjects-factories-sprite3d.4af80d9640395f3294ac.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3D.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3DFactory.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/GameObjectFactory.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/DegToRad.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Vector4.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Wrap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js"],"sourcesContent":["/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar Class = require('../../../../src/utils/Class');\nvar GameObject = require('../../../../src/gameobjects/GameObject');\nvar Sprite = require('../../../../src/gameobjects/sprite/Sprite');\nvar Vector2 = require('../../../../src/math/Vector2');\nvar Vector4 = require('../../../../src/math/Vector4');\n\n/**\n * @classdesc\n * A Sprite 3D Game Object.\n *\n * The Sprite 3D object is an encapsulation of a standard Sprite object, with additional methods to allow\n * it to be rendered by a 3D Camera. The Sprite can be positioned anywhere within 3D space.\n *\n * @class Sprite3D\n * @extends Phaser.GameObjects.Sprite\n * @memberOf Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The x position of this Game Object.\n * @param {number} y - The y position of this Game Object.\n * @param {number} z - The z position of this Game Object.\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Sprite3D = new Class({\n\n    Extends: GameObject,\n\n    initialize:\n\n    function Sprite3D (scene, x, y, z, texture, frame)\n    {\n        GameObject.call(this, scene, 'Sprite3D');\n\n        /**\n         * The encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#gameObject\n         * @type {Phaser.GameObjects.GameObject}\n         * @since 3.0.0\n         */\n        this.gameObject = new Sprite(scene, 0, 0, texture, frame);\n\n        /**\n         * The position of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#position\n         * @type {Phaser.Math.Vector4}\n         * @since 3.0.0\n         */\n        this.position = new Vector4(x, y, z);\n\n        /**\n         * The 2D size of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#size\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.size = new Vector2(this.gameObject.width, this.gameObject.height);\n\n        /**\n         * The 2D scale of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#scale\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.scale = new Vector2(1, 1);\n\n        /**\n         * Whether to automatically set the horizontal scale of the encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleX\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.adjustScaleX = true;\n\n        /**\n         * Whether to automatically set the vertical scale of the encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleY\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.adjustScaleY = true;\n\n        /**\n         * The visible state of the Game Object.\n         *\n         * @name Phaser.GameObjects.Sprite3D#_visible\n         * @type {boolean}\n         * @default true\n         * @private\n         * @since 3.0.0\n         */\n        this._visible = true;\n    },\n\n    /**\n     * Project this Sprite onto the given 3D Camera.\n     *\n     * @method Phaser.GameObjects.Sprite3D#project\n     * @since 3.0.0\n     *\n     * @param {Phaser.Cameras.Sprite3D.Camera} camera - The 3D Camera onto which to project this Sprite.\n     */\n    project: function (camera)\n    {\n        var pos = this.position;\n\n        var gameObject = this.gameObject;\n\n        camera.project(pos, gameObject);\n\n        camera.getPointSize(pos, this.size, this.scale);\n\n        if (this.scale.x <= 0 || this.scale.y <= 0)\n        {\n            gameObject.setVisible(false);\n        }\n        else\n        {\n            if (!gameObject.visible)\n            {\n                gameObject.setVisible(true);\n            }\n\n            if (this.adjustScaleX)\n            {\n                gameObject.scaleX = this.scale.x;\n            }\n\n            if (this.adjustScaleY)\n            {\n                gameObject.scaleY = this.scale.y;\n            }\n\n            gameObject.setDepth(gameObject.z * -1);\n        }\n    },\n\n    /**\n     * Set the visible state of the Game Object.\n     *\n     * @method Phaser.GameObjects.Sprite3D#setVisible\n     * @since 3.0.0\n     *\n     * @param {boolean} value - The visible state of the Game Object.\n     *\n     * @return {Phaser.GameObjects.Sprite3D} This Sprite3D Object.\n     */\n    setVisible: function (value)\n    {\n        this.visible = value;\n\n        return this;\n    },\n\n    /**\n     * The visible state of the Game Object.\n     *\n     * An invisible Game Object will skip rendering, but will still process update logic.\n     *\n     * @name Phaser.GameObjects.Sprite3D#visible\n     * @type {boolean}\n     * @since 3.0.0\n     */\n    visible: {\n\n        get: function ()\n        {\n            return this._visible;\n        },\n\n        set: function (value)\n        {\n            this._visible = value;\n            this.gameObject.visible = value;\n        }\n\n    },\n\n    /**\n     * The x position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#x\n     * @type {number}\n     * @since 3.0.0\n     */\n    x: {\n\n        get: function ()\n        {\n            return this.position.x;\n        },\n\n        set: function (value)\n        {\n            this.position.x = value;\n        }\n\n    },\n\n    /**\n     * The y position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#y\n     * @type {number}\n     * @since 3.0.0\n     */\n    y: {\n\n        get: function ()\n        {\n            return this.position.y;\n        },\n\n        set: function (value)\n        {\n            this.position.y = value;\n        }\n\n    },\n\n    /**\n     * The z position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#z\n     * @type {number}\n     * @since 3.0.0\n     */\n    z: {\n\n        get: function ()\n        {\n            return this.position.z;\n        },\n\n        set: function (value)\n        {\n            this.position.z = value;\n        }\n\n    }\n\n});\n\nmodule.exports = Sprite3D;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Sprite3D = require('./Sprite3D');\r\nvar GameObjectFactory = require('../../../../src/gameobjects/GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Sprite3D Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#sprite3D\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object.\r\n * @param {number} y - The vertical position of this Game Object.\r\n * @param {number} z - The z position of this Game Object.\r\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('sprite3D', function (x, y, z, key, frame)\r\n{\r\n    var sprite = new Sprite3D(this.scene, x, y, z, key, frame);\r\n\r\n    this.displayList.add(sprite.gameObject);\r\n    this.updateList.add(sprite.gameObject);\r\n\r\n    return sprite;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Game Object Factory is a Scene plugin that allows you to quickly create many common\r\n * types of Game Objects and have them automatically registered with the Scene.\r\n *\r\n * Game Objects directly register themselves with the Factory and inject their own creation\r\n * methods into the class.\r\n *\r\n * @class GameObjectFactory\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object Factory belongs.\r\n */\r\nvar GameObjectFactory = new Class({\r\n\r\n    initialize:\r\n\r\n    function GameObjectFactory (scene)\r\n    {\r\n        /**\r\n         * The Scene to which this Game Object Factory belongs.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene.Systems.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @protected\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        /**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Update List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.updateList;\r\n\r\n        this.events.once(SceneEvents.BOOT, this.boot, this);\r\n        this.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.displayList = this.systems.displayList;\r\n        this.updateList = this.systems.updateList;\r\n\r\n        this.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Game Object to this Scene.\r\n     *\r\n     * If the Game Object renders, it will be added to the Display List.\r\n     * If it has a `preUpdate` method, it will be added to the Update List.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {(Phaser.GameObjects.GameObject|Phaser.GameObjects.Group|Phaser.GameObjects.Layer)} G - [child,$return]\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.Group|Phaser.GameObjects.Layer)} child - The child to be added to this Scene.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that was added.\r\n     */\r\n    existing: function (child)\r\n    {\r\n        if (child.renderCanvas || child.renderWebGL)\r\n        {\r\n            this.displayList.add(child);\r\n        }\r\n\r\n        //  For when custom objects have overridden `preUpdate` but don't hook into the ADDED_TO_SCENE event:\r\n        //  Adding to the list multiple times is safe, as it won't add duplicates into the list anyway.\r\n        if (child.preUpdate)\r\n        {\r\n            this.updateList.add(child);\r\n        }\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.events = null;\r\n\r\n        this.displayList = null;\r\n        this.updateList = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method called directly by the Game Object factory functions.\r\n * With this method you can register a custom GameObject factory in the GameObjectFactory,\r\n * providing a name (`factoryType`) and the constructor (`factoryFunction`) in order\r\n * to be called when you call to Phaser.Scene.add[ factoryType ] method.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory.register\r\n * @static\r\n * @since 3.0.0\r\n *\r\n * @param {string} factoryType - The key of the factory that you will use to call to Phaser.Scene.add[ factoryType ] method.\r\n * @param {function} factoryFunction - The constructor function to be called when you invoke to the Phaser.Scene.add method.\r\n */\r\nGameObjectFactory.register = function (factoryType, factoryFunction)\r\n{\r\n    if (!GameObjectFactory.prototype.hasOwnProperty(factoryType))\r\n    {\r\n        GameObjectFactory.prototype[factoryType] = factoryFunction;\r\n    }\r\n};\r\n\r\n/**\r\n * Static method called directly by the Game Object factory functions.\r\n * With this method you can remove a custom GameObject factory registered in the GameObjectFactory,\r\n * providing a its `factoryType`.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory.remove\r\n * @static\r\n * @since 3.0.0\r\n *\r\n * @param {string} factoryType - The key of the factory that you want to remove from the GameObjectFactory.\r\n */\r\nGameObjectFactory.remove = function (factoryType)\r\n{\r\n    if (GameObjectFactory.prototype.hasOwnProperty(factoryType))\r\n    {\r\n        delete GameObjectFactory.prototype[factoryType];\r\n    }\r\n};\r\n\r\nPluginCache.register('GameObjectFactory', GameObjectFactory, 'add');\r\n\r\nmodule.exports = GameObjectFactory;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {number} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 4D space.\r\n *\r\n * A four-component vector.\r\n *\r\n * @class Vector4\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n * @param {number} [w] - The w component.\r\n */\r\nvar Vector4 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector4 (x, y, z, w)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The z component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#z\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.z = 0;\r\n\r\n        /**\r\n         * The w component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector4#w\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.w = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector4.\r\n     *\r\n     * @method Phaser.Math.Vector4#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} A clone of this Vector4.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x;\r\n        this.y = src.y;\r\n        this.z = src.z || 0;\r\n        this.w = src.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict quality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector4#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The vector to check equality with.\r\n     *\r\n     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));\r\n    },\r\n\r\n    /**\r\n     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.\r\n     *\r\n     * @method Phaser.Math.Vector4#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.\r\n     * @param {number} y - The y value to set for this Vector.\r\n     * @param {number} z - The z value to set for this Vector.\r\n     * @param {number} w - The z value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    set: function (x, y, z, w)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n            this.z = x.z || 0;\r\n            this.w = x.w || 0;\r\n        }\r\n        else\r\n        {\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n            this.z = z || 0;\r\n            this.w = w || 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    add: function (v)\r\n    {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z || 0;\r\n        this.w += v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector4#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    subtract: function (v)\r\n    {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        this.z -= v.z || 0;\r\n        this.w -= v.w || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector4#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} scale - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    scale: function (scale)\r\n    {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return Math.sqrt(x * x + y * y + z * z + w * w);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n\r\n        return x * x + y * y + z * z + w * w;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector4#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var len = x * x + y * y + z * z + w * w;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n            this.z = z * len;\r\n            this.w = w * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (v)\r\n    {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    lerp: function (v, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n        var az = this.z;\r\n        var aw = this.w;\r\n\r\n        this.x = ax + t * (v.x - ax);\r\n        this.y = ay + t * (v.y - ay);\r\n        this.z = az + t * (v.z - az);\r\n        this.w = aw + t * (v.w - aw);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    multiply: function (v)\r\n    {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z || 1;\r\n        this.w *= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    divide: function (v)\r\n    {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        this.z /= v.z || 1;\r\n        this.w /= v.w || 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector4#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (v)\r\n    {\r\n        var dx = v.x - this.x;\r\n        var dy = v.y - this.y;\r\n        var dz = v.z - this.z || 0;\r\n        var dw = v.w - this.w || 0;\r\n\r\n        return dx * dx + dy * dy + dz * dz + dw * dw;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x`, `y`, `z` and `w` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector4#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        this.w = -this.w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var w = this.w;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Quaternion.\r\n     *\r\n     * @method Phaser.Math.Vector4#transformQuat\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    transformQuat: function (q)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var z = this.z;\r\n        var qx = q.x;\r\n        var qy = q.y;\r\n        var qz = q.z;\r\n        var qw = q.w;\r\n\r\n        // calculate quat * vec\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n\r\n        // calculate result * inverse quat\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0, 0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector4#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector4} This Vector4.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.w = 0;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nVector4.prototype.sub = Vector4.prototype.subtract;\r\nVector4.prototype.mul = Vector4.prototype.multiply;\r\nVector4.prototype.div = Vector4.prototype.divide;\r\nVector4.prototype.dist = Vector4.prototype.distance;\r\nVector4.prototype.distSq = Vector4.prototype.distanceSq;\r\nVector4.prototype.len = Vector4.prototype.length;\r\nVector4.prototype.lenSq = Vector4.prototype.lengthSq;\r\n\r\nmodule.exports = Vector4;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n"],"names":["Class","GameObject","Sprite","Vector2","Vector4","Sprite3D","Extends","initialize","scene","x","y","z","texture","frame","call","this","gameObject","position","size","width","height","scale","adjustScaleX","adjustScaleY","_visible","project","camera","pos","getPointSize","setVisible","visible","scaleX","scaleY","setDepth","value","get","set","module","exports","register","key","sprite","displayList","add","updateList","PluginCache","SceneEvents","GameObjectFactory","systems","sys","events","once","BOOT","boot","on","START","start","DESTROY","destroy","SHUTDOWN","shutdown","existing","child","renderCanvas","renderWebGL","preUpdate","off","factoryType","factoryFunction","prototype","hasOwnProperty","remove","min","max","Math","CONST","degrees","DEG_TO_RAD","w","clone","copy","src","equals","v","subtract","length","sqrt","lengthSq","normalize","len","dot","lerp","t","undefined","ax","ay","az","aw","multiply","divide","distance","dx","dy","dz","dw","distanceSq","negate","transformMat4","mat","m","val","transformQuat","q","qx","qy","qz","qw","ix","iy","iz","iw","reset","sub","mul","div","dist","distSq","lenSq","range","corePlugins","customPlugins","plugin","mapping","custom","data"],"sourceRoot":""}