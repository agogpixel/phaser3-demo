{"version":3,"file":"js/7389.78ab5a17f6d962ad4352.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Circumference.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/CircumferencePoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Contains.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Ellipse.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/GetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/GetPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Contains.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/GetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/GetPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Triangle.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the circumference of the given Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Circumference\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference of.\r\n *\r\n * @return {number} The circumference of th Ellipse.\r\n */\r\nvar Circumference = function (ellipse)\r\n{\r\n    var rx = ellipse.width / 2;\r\n    var ry = ellipse.height / 2;\r\n    var h = Math.pow((rx - ry), 2) / Math.pow((rx + ry), 2);\r\n\r\n    return (Math.PI * (rx + ry)) * (1 + ((3 * h) / (10 + Math.sqrt(4 - (3 * h)))));\r\n};\r\n\r\nmodule.exports = Circumference;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse based on the given angle.\r\n *\r\n * @function Phaser.Geom.Ellipse.CircumferencePoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference point on.\r\n * @param {number} angle - The angle from the center of the Ellipse to the circumference to return the point from. Given in radians.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point, or point-like object, to store the results in. If not given a Point will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object where the `x` and `y` properties are the point on the circumference.\r\n */\r\nvar CircumferencePoint = function (ellipse, angle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var halfWidth = ellipse.width / 2;\r\n    var halfHeight = ellipse.height / 2;\r\n\r\n    out.x = ellipse.x + halfWidth * Math.cos(angle);\r\n    out.y = ellipse.y + halfHeight * Math.sin(angle);\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = CircumferencePoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check to see if the Ellipse contains the given x / y coordinates.\r\n *\r\n * @function Phaser.Geom.Ellipse.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to check.\r\n * @param {number} x - The x coordinate to check within the ellipse.\r\n * @param {number} y - The y coordinate to check within the ellipse.\r\n *\r\n * @return {boolean} True if the coordinates are within the ellipse, otherwise false.\r\n */\r\nvar Contains = function (ellipse, x, y)\r\n{\r\n    if (ellipse.width <= 0 || ellipse.height <= 0)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5\r\n    var normx = ((x - ellipse.x) / ellipse.width);\r\n    var normy = ((y - ellipse.y) / ellipse.height);\r\n\r\n    normx *= normx;\r\n    normy *= normy;\r\n\r\n    return (normx + normy < 0.25);\r\n};\r\n\r\nmodule.exports = Contains;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Contains = require('./Contains');\r\nvar GetPoint = require('./GetPoint');\r\nvar GetPoints = require('./GetPoints');\r\nvar GEOM_CONST = require('../const');\r\nvar Random = require('./Random');\r\n\r\n/**\r\n * @classdesc\r\n * An Ellipse object.\r\n *\r\n * This is a geometry object, containing numerical values and related methods to inspect and modify them.\r\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\r\n * To render an Ellipse you should look at the capabilities of the Graphics class.\r\n *\r\n * @class Ellipse\r\n * @memberof Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The x position of the center of the ellipse.\r\n * @param {number} [y=0] - The y position of the center of the ellipse.\r\n * @param {number} [width=0] - The width of the ellipse.\r\n * @param {number} [height=0] - The height of the ellipse.\r\n */\r\nvar Ellipse = new Class({\r\n\r\n    initialize:\r\n\r\n    function Ellipse (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 0; }\r\n        if (height === undefined) { height = 0; }\r\n\r\n        /**\r\n         * The geometry constant type of this object: `GEOM_CONST.ELLIPSE`.\r\n         * Used for fast type comparisons.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#type\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.type = GEOM_CONST.ELLIPSE;\r\n\r\n        /**\r\n         * The x position of the center of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y position of the center of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#width\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the ellipse.\r\n         *\r\n         * @name Phaser.Geom.Ellipse#height\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n    },\r\n\r\n    /**\r\n     * Check to see if the Ellipse contains the given x / y coordinates.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check within the ellipse.\r\n     * @param {number} y - The y coordinate to check within the ellipse.\r\n     *\r\n     * @return {boolean} True if the coordinates are within the ellipse, otherwise false.\r\n     */\r\n    contains: function (x, y)\r\n    {\r\n        return Contains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse\r\n     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n     * at 180 degrees around the circle.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [out,$return]\r\n     *\r\n     * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.\r\n     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.\r\n     */\r\n    getPoint: function (position, point)\r\n    {\r\n        return GetPoint(this, position, point);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,\r\n     * based on the given quantity or stepRate values.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the ellipse.\r\n     */\r\n    getPoints: function (quantity, stepRate, output)\r\n    {\r\n        return GetPoints(this, quantity, stepRate, output);\r\n    },\r\n\r\n    /**\r\n     * Returns a uniformly distributed random point from anywhere within the given Ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n     */\r\n    getRandomPoint: function (point)\r\n    {\r\n        return Random(this, point);\r\n    },\r\n\r\n    /**\r\n     * Sets the x, y, width and height of this ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the center of the ellipse.\r\n     * @param {number} y - The y position of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     *\r\n     * @return {this} This Ellipse object.\r\n     */\r\n    setTo: function (x, y, width, height)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Ellipse to be empty with a width and height of zero.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Ellipse object.\r\n     */\r\n    setEmpty: function ()\r\n    {\r\n        this.width = 0;\r\n        this.height = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Ellipse.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the center of the ellipse.\r\n     * @param {number} y - The y position of the center of the ellipse.\r\n     *\r\n     * @return {this} This Ellipse object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Ellipse.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} [height=width] - The height of the ellipse.\r\n     *\r\n     * @return {this} This Ellipse object.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the Ellipse is empty: has a width or height equal to zero.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#isEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the Ellipse is empty, otherwise false.\r\n     */\r\n    isEmpty: function ()\r\n    {\r\n        return (this.width <= 0 || this.height <= 0);\r\n    },\r\n\r\n    /**\r\n     * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getMinorRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The minor radius.\r\n     */\r\n    getMinorRadius: function ()\r\n    {\r\n        return Math.min(this.width, this.height) / 2;\r\n    },\r\n\r\n    /**\r\n     * Returns the major radius of the ellipse. Also known as the Semi Major Axis.\r\n     *\r\n     * @method Phaser.Geom.Ellipse#getMajorRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The major radius.\r\n     */\r\n    getMajorRadius: function ()\r\n    {\r\n        return Math.max(this.width, this.height) / 2;\r\n    },\r\n\r\n    /**\r\n     * The left position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.x - (this.width / 2);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.x = value + (this.width / 2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.x + (this.width / 2);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.x = value - (this.width / 2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The top position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.y - (this.height / 2);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.y = value + (this.height / 2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The bottom position of the Ellipse.\r\n     *\r\n     * @name Phaser.Geom.Ellipse#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.y + (this.height / 2);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.y = value - (this.height / 2);\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Ellipse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CircumferencePoint = require('./CircumferencePoint');\r\nvar FromPercent = require('../../math/FromPercent');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse\r\n * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n * at 180 degrees around the circle.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the circumference point on.\r\n * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the ellipse.\r\n */\r\nvar GetPoint = function (ellipse, position, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var angle = FromPercent(position, 0, MATH_CONST.PI2);\r\n\r\n    return CircumferencePoint(ellipse, angle, out);\r\n};\r\n\r\nmodule.exports = GetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circumference = require('./Circumference');\r\nvar CircumferencePoint = require('./CircumferencePoint');\r\nvar FromPercent = require('../../math/FromPercent');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Ellipse.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get the points from.\r\n * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.\r\n * @param {(array|Phaser.Geom.Point[])} [out] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the ellipse.\r\n */\r\nvar GetPoints = function (ellipse, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity && stepRate > 0)\r\n    {\r\n        quantity = Circumference(ellipse) / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);\r\n\r\n        out.push(CircumferencePoint(ellipse, angle));\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  http://www.blackpawn.com/texts/pointinpoly/\r\n\r\n/**\r\n * Checks if a point (as a pair of coordinates) is inside a Triangle's bounds.\r\n *\r\n * @function Phaser.Geom.Triangle.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to check.\r\n * @param {number} x - The X coordinate of the point to check.\r\n * @param {number} y - The Y coordinate of the point to check.\r\n *\r\n * @return {boolean} `true` if the point is inside the Triangle, otherwise `false`.\r\n */\r\nvar Contains = function (triangle, x, y)\r\n{\r\n    var v0x = triangle.x3 - triangle.x1;\r\n    var v0y = triangle.y3 - triangle.y1;\r\n\r\n    var v1x = triangle.x2 - triangle.x1;\r\n    var v1y = triangle.y2 - triangle.y1;\r\n\r\n    var v2x = x - triangle.x1;\r\n    var v2y = y - triangle.y1;\r\n\r\n    var dot00 = (v0x * v0x) + (v0y * v0y);\r\n    var dot01 = (v0x * v1x) + (v0y * v1y);\r\n    var dot02 = (v0x * v2x) + (v0y * v2y);\r\n    var dot11 = (v1x * v1x) + (v1y * v1y);\r\n    var dot12 = (v1x * v2x) + (v1y * v2y);\r\n\r\n    // Compute barycentric coordinates\r\n    var b = ((dot00 * dot11) - (dot01 * dot01));\r\n    var inv = (b === 0) ? 0 : (1 / b);\r\n    var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;\r\n    var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;\r\n\r\n    return (u >= 0 && v >= 0 && (u + v < 1));\r\n};\r\n\r\nmodule.exports = Contains;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\nvar Length = require('../line/Length');\r\n\r\n/**\r\n * Returns a Point from around the perimeter of a Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the point on its perimeter from.\r\n * @param {number} position - The position along the perimeter of the triangle. A value between 0 and 1.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An option Point, or Point-like object to store the value in. If not given a new Point will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object containing the given position from the perimeter of the triangle.\r\n */\r\nvar GetPoint = function (triangle, position, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var line1 = triangle.getLineA();\r\n    var line2 = triangle.getLineB();\r\n    var line3 = triangle.getLineC();\r\n\r\n    if (position <= 0 || position >= 1)\r\n    {\r\n        out.x = line1.x1;\r\n        out.y = line1.y1;\r\n\r\n        return out;\r\n    }\r\n\r\n    var length1 = Length(line1);\r\n    var length2 = Length(line2);\r\n    var length3 = Length(line3);\r\n\r\n    var perimeter = length1 + length2 + length3;\r\n\r\n    var p = perimeter * position;\r\n    var localPosition = 0;\r\n\r\n    //  Which line is it on?\r\n\r\n    if (p < length1)\r\n    {\r\n        //  Line 1\r\n        localPosition = p / length1;\r\n\r\n        out.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;\r\n        out.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;\r\n    }\r\n    else if (p > length1 + length2)\r\n    {\r\n        //  Line 3\r\n        p -= length1 + length2;\r\n        localPosition = p / length3;\r\n\r\n        out.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;\r\n        out.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;\r\n    }\r\n    else\r\n    {\r\n        //  Line 2\r\n        p -= length1;\r\n        localPosition = p / length2;\r\n\r\n        out.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;\r\n        out.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns an array of evenly spaced points on the perimeter of a Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get the points from.\r\n * @param {number} quantity - The number of evenly spaced points to return. Set to 0 to return an arbitrary number of points based on the `stepRate`.\r\n * @param {number} stepRate - If `quantity` is 0, the distance between each returned point.\r\n * @param {(array|Phaser.Geom.Point[])} [out] - An array to which the points should be appended.\r\n *\r\n * @return {(array|Phaser.Geom.Point[])} The modified `out` array, or a new array if none was provided.\r\n */\r\nvar GetPoints = function (triangle, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    var line1 = triangle.getLineA();\r\n    var line2 = triangle.getLineB();\r\n    var line3 = triangle.getLineC();\r\n\r\n    var length1 = Length(line1);\r\n    var length2 = Length(line2);\r\n    var length3 = Length(line3);\r\n\r\n    var perimeter = length1 + length2 + length3;\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity && stepRate > 0)\r\n    {\r\n        quantity = perimeter / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var p = perimeter * (i / quantity);\r\n        var localPosition = 0;\r\n\r\n        var point = new Point();\r\n\r\n        //  Which line is it on?\r\n\r\n        if (p < length1)\r\n        {\r\n            //  Line 1\r\n            localPosition = p / length1;\r\n\r\n            point.x = line1.x1 + (line1.x2 - line1.x1) * localPosition;\r\n            point.y = line1.y1 + (line1.y2 - line1.y1) * localPosition;\r\n        }\r\n        else if (p > length1 + length2)\r\n        {\r\n            //  Line 3\r\n            p -= length1 + length2;\r\n            localPosition = p / length3;\r\n\r\n            point.x = line3.x1 + (line3.x2 - line3.x1) * localPosition;\r\n            point.y = line3.y1 + (line3.y2 - line3.y1) * localPosition;\r\n        }\r\n        else\r\n        {\r\n            //  Line 2\r\n            p -= length1;\r\n            localPosition = p / length2;\r\n\r\n            point.x = line2.x1 + (line2.x2 - line2.x1) * localPosition;\r\n            point.y = line2.y1 + (line2.y2 - line2.y1) * localPosition;\r\n        }\r\n\r\n        out.push(point);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Contains = require('./Contains');\r\nvar GetPoint = require('./GetPoint');\r\nvar GetPoints = require('./GetPoints');\r\nvar GEOM_CONST = require('../const');\r\nvar Line = require('../line/Line');\r\nvar Random = require('./Random');\r\n\r\n/**\r\n * @classdesc\r\n * A triangle is a plane created by connecting three points.\r\n * The first two arguments specify the first point, the middle two arguments\r\n * specify the second point, and the last two arguments specify the third point.\r\n *\r\n * @class Triangle\r\n * @memberof Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x1=0] - `x` coordinate of the first point.\r\n * @param {number} [y1=0] - `y` coordinate of the first point.\r\n * @param {number} [x2=0] - `x` coordinate of the second point.\r\n * @param {number} [y2=0] - `y` coordinate of the second point.\r\n * @param {number} [x3=0] - `x` coordinate of the third point.\r\n * @param {number} [y3=0] - `y` coordinate of the third point.\r\n */\r\nvar Triangle = new Class({\r\n\r\n    initialize:\r\n\r\n    function Triangle (x1, y1, x2, y2, x3, y3)\r\n    {\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 0; }\r\n        if (x2 === undefined) { x2 = 0; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n        if (x3 === undefined) { x3 = 0; }\r\n        if (y3 === undefined) { y3 = 0; }\r\n\r\n        /**\r\n         * The geometry constant type of this object: `GEOM_CONST.TRIANGLE`.\r\n         * Used for fast type comparisons.\r\n         *\r\n         * @name Phaser.Geom.Triangle#type\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.type = GEOM_CONST.TRIANGLE;\r\n\r\n        /**\r\n         * `x` coordinate of the first point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#x1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x1 = x1;\r\n\r\n        /**\r\n         * `y` coordinate of the first point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#y1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y1 = y1;\r\n\r\n        /**\r\n         * `x` coordinate of the second point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#x2\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x2 = x2;\r\n\r\n        /**\r\n         * `y` coordinate of the second point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#y2\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y2 = y2;\r\n\r\n        /**\r\n         * `x` coordinate of the third point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#x3\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x3 = x3;\r\n\r\n        /**\r\n         * `y` coordinate of the third point.\r\n         *\r\n         * @name Phaser.Geom.Triangle#y3\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y3 = y3;\r\n    },\r\n\r\n    /**\r\n     * Checks whether a given points lies within the triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point to check.\r\n     * @param {number} y - The y coordinate of the point to check.\r\n     *\r\n     * @return {boolean} `true` if the coordinate pair is within the triangle, otherwise `false`.\r\n     */\r\n    contains: function (x, y)\r\n    {\r\n        return Contains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * Returns a specific point  on the triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [output,$return]\r\n     *\r\n     * @param {number} position - Position as float within `0` and `1`. `0` equals the first point.\r\n     * @param {(Phaser.Geom.Point|object)} [output] - Optional Point, or point-like object, that the calculated point will be written to.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} Calculated `Point` that represents the requested position. It is the same as `output` when this parameter has been given.\r\n     */\r\n    getPoint: function (position, output)\r\n    {\r\n        return GetPoint(this, position, output);\r\n    },\r\n\r\n    /**\r\n     * Calculates a list of evenly distributed points on the triangle. It is either possible to pass an amount of points to be generated (`quantity`) or the distance between two points (`stepRate`).\r\n     *\r\n     * @method Phaser.Geom.Triangle#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {number} quantity - Number of points to be generated. Can be falsey when `stepRate` should be used. All points have the same distance along the triangle.\r\n     * @param {number} [stepRate] - Distance between two points. Will only be used when `quantity` is falsey.\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - Optional Array for writing the calculated points into. Otherwise a new array will be created.\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} Returns a list of calculated `Point` instances or the filled array passed as parameter `output`.\r\n     */\r\n    getPoints: function (quantity, stepRate, output)\r\n    {\r\n        return GetPoints(this, quantity, stepRate, output);\r\n    },\r\n\r\n    /**\r\n     * Returns a random point along the triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {Phaser.Geom.Point} [point] - Optional `Point` that should be modified. Otherwise a new one will be created.\r\n     *\r\n     * @return {Phaser.Geom.Point} Random `Point`. When parameter `point` has been provided it will be returned.\r\n     */\r\n    getRandomPoint: function (point)\r\n    {\r\n        return Random(this, point);\r\n    },\r\n\r\n    /**\r\n     * Sets all three points of the triangle. Leaving out any coordinate sets it to be `0`.\r\n     *\r\n     * @method Phaser.Geom.Triangle#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x1=0] - `x` coordinate of the first point.\r\n     * @param {number} [y1=0] - `y` coordinate of the first point.\r\n     * @param {number} [x2=0] - `x` coordinate of the second point.\r\n     * @param {number} [y2=0] - `y` coordinate of the second point.\r\n     * @param {number} [x3=0] - `x` coordinate of the third point.\r\n     * @param {number} [y3=0] - `y` coordinate of the third point.\r\n     *\r\n     * @return {this} This Triangle object.\r\n     */\r\n    setTo: function (x1, y1, x2, y2, x3, y3)\r\n    {\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 0; }\r\n        if (x2 === undefined) { x2 = 0; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n        if (x3 === undefined) { x3 = 0; }\r\n        if (y3 === undefined) { y3 = 0; }\r\n\r\n        this.x1 = x1;\r\n        this.y1 = y1;\r\n\r\n        this.x2 = x2;\r\n        this.y2 = y2;\r\n\r\n        this.x3 = x3;\r\n        this.y3 = y3;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a Line object that corresponds to Line A of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineA\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line A of this Triangle.\r\n     */\r\n    getLineA: function (line)\r\n    {\r\n        if (line === undefined) { line = new Line(); }\r\n\r\n        line.setTo(this.x1, this.y1, this.x2, this.y2);\r\n\r\n        return line;\r\n    },\r\n\r\n    /**\r\n     * Returns a Line object that corresponds to Line B of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineB\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line B of this Triangle.\r\n     */\r\n    getLineB: function (line)\r\n    {\r\n        if (line === undefined) { line = new Line(); }\r\n\r\n        line.setTo(this.x2, this.y2, this.x3, this.y3);\r\n\r\n        return line;\r\n    },\r\n\r\n    /**\r\n     * Returns a Line object that corresponds to Line C of this Triangle.\r\n     *\r\n     * @method Phaser.Geom.Triangle#getLineC\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Line} O - [line,$return]\r\n     *\r\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\r\n     *\r\n     * @return {Phaser.Geom.Line} A Line object that corresponds to line C of this Triangle.\r\n     */\r\n    getLineC: function (line)\r\n    {\r\n        if (line === undefined) { line = new Line(); }\r\n\r\n        line.setTo(this.x3, this.y3, this.x1, this.y1);\r\n\r\n        return line;\r\n    },\r\n\r\n    /**\r\n     * Left most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.\r\n     *\r\n     * @name Phaser.Geom.Triangle#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.min(this.x1, this.x2, this.x3);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var diff = 0;\r\n\r\n            if (this.x1 <= this.x2 && this.x1 <= this.x3)\r\n            {\r\n                diff = this.x1 - value;\r\n            }\r\n            else if (this.x2 <= this.x1 && this.x2 <= this.x3)\r\n            {\r\n                diff = this.x2 - value;\r\n            }\r\n            else\r\n            {\r\n                diff = this.x3 - value;\r\n            }\r\n\r\n            this.x1 -= diff;\r\n            this.x2 -= diff;\r\n            this.x3 -= diff;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Right most X coordinate of the triangle. Setting it moves the triangle on the X axis accordingly.\r\n     *\r\n     * @name Phaser.Geom.Triangle#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.max(this.x1, this.x2, this.x3);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var diff = 0;\r\n\r\n            if (this.x1 >= this.x2 && this.x1 >= this.x3)\r\n            {\r\n                diff = this.x1 - value;\r\n            }\r\n            else if (this.x2 >= this.x1 && this.x2 >= this.x3)\r\n            {\r\n                diff = this.x2 - value;\r\n            }\r\n            else\r\n            {\r\n                diff = this.x3 - value;\r\n            }\r\n\r\n            this.x1 -= diff;\r\n            this.x2 -= diff;\r\n            this.x3 -= diff;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Top most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.\r\n     *\r\n     * @name Phaser.Geom.Triangle#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.min(this.y1, this.y2, this.y3);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var diff = 0;\r\n\r\n            if (this.y1 <= this.y2 && this.y1 <= this.y3)\r\n            {\r\n                diff = this.y1 - value;\r\n            }\r\n            else if (this.y2 <= this.y1 && this.y2 <= this.y3)\r\n            {\r\n                diff = this.y2 - value;\r\n            }\r\n            else\r\n            {\r\n                diff = this.y3 - value;\r\n            }\r\n\r\n            this.y1 -= diff;\r\n            this.y2 -= diff;\r\n            this.y3 -= diff;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Bottom most Y coordinate of the triangle. Setting it moves the triangle on the Y axis accordingly.\r\n     *\r\n     * @name Phaser.Geom.Triangle#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.max(this.y1, this.y2, this.y3);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var diff = 0;\r\n\r\n            if (this.y1 >= this.y2 && this.y1 >= this.y3)\r\n            {\r\n                diff = this.y1 - value;\r\n            }\r\n            else if (this.y2 >= this.y1 && this.y2 >= this.y3)\r\n            {\r\n                diff = this.y2 - value;\r\n            }\r\n            else\r\n            {\r\n                diff = this.y3 - value;\r\n            }\r\n\r\n            this.y1 -= diff;\r\n            this.y2 -= diff;\r\n            this.y3 -= diff;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Triangle;\r\n"],"names":["module","exports","ellipse","rx","width","ry","height","h","Math","pow","PI","sqrt","Point","angle","out","undefined","halfWidth","halfHeight","x","cos","y","sin","normx","normy","Class","Contains","GetPoint","GetPoints","GEOM_CONST","Random","Ellipse","initialize","this","type","ELLIPSE","contains","getPoint","position","point","getPoints","quantity","stepRate","output","getRandomPoint","setTo","setEmpty","setPosition","setSize","isEmpty","getMinorRadius","min","getMajorRadius","max","left","get","set","value","right","top","bottom","CircumferencePoint","FromPercent","MATH_CONST","PI2","Circumference","i","push","triangle","v0x","x3","x1","v0y","y3","y1","v1x","x2","v1y","y2","v2x","v2y","dot00","dot01","dot02","dot11","dot12","b","inv","u","v","Length","line1","getLineA","line2","getLineB","line3","getLineC","length1","length2","length3","p","localPosition","perimeter","Line","Triangle","TRIANGLE","line","diff"],"sourceRoot":""}