{"version":3,"file":"js/9506.cc028549e0b6323ec20d.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Alpha.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/AlphaSingle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/BlendMode.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/ComputedSize.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Crop.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Depth.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Flip.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/GetBounds.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Mask.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Origin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/PathFollower.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Pipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/ScrollFactor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Size.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Texture.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/TextureCrop.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Tint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/ToJSON.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Transform.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/Visible.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/components/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RotateAround.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/TransformXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Wrap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/WrapDegrees.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tweens/builders/GetBoolean.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tweens/tween/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/DeepCopy.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetValue.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../math/Clamp');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 2; // 0010\r\n\r\n/**\r\n * Provides methods used for setting the alpha properties of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Alpha\r\n * @since 3.0.0\r\n */\r\n\r\nvar Alpha = {\r\n\r\n    /**\r\n     * Private internal value. Holds the global alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alpha\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alpha: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the top-left alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTL\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaTL: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the top-right alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaTR\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaTR: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the bottom-left alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBL\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaBL: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the bottom-right alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#_alphaBR\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alphaBR: 1,\r\n\r\n    /**\r\n     * Clears all alpha values associated with this Game Object.\r\n     *\r\n     * Immediately sets the alpha levels back to 1 (fully opaque).\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#clearAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    clearAlpha: function ()\r\n    {\r\n        return this.setAlpha(1);\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * If your game is running under WebGL you can optionally specify four different alpha values, each of which\r\n     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Alpha#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [topLeft=1] - The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object.\r\n     * @param {number} [topRight] - The alpha value used for the top-right of the Game Object. WebGL only.\r\n     * @param {number} [bottomLeft] - The alpha value used for the bottom-left of the Game Object. WebGL only.\r\n     * @param {number} [bottomRight] - The alpha value used for the bottom-right of the Game Object. WebGL only.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlpha: function (topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (topLeft === undefined) { topLeft = 1; }\r\n\r\n        //  Treat as if there is only one alpha value for the whole Game Object\r\n        if (topRight === undefined)\r\n        {\r\n            this.alpha = topLeft;\r\n        }\r\n        else\r\n        {\r\n            this._alphaTL = Clamp(topLeft, 0, 1);\r\n            this._alphaTR = Clamp(topRight, 0, 1);\r\n            this._alphaBL = Clamp(bottomLeft, 0, 1);\r\n            this._alphaBR = Clamp(bottomRight, 0, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Game Object.\r\n     *\r\n     * This is a global value, impacting the entire Game Object, not just a region of it.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alpha;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alpha = v;\r\n            this._alphaTL = v;\r\n            this._alphaTR = v;\r\n            this._alphaBL = v;\r\n            this._alphaBR = v;\r\n\r\n            if (v === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the top-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopLeft\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaTopLeft: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaTL;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaTL = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the top-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaTopRight\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaTopRight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaTR;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaTR = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the bottom-left of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomLeft\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaBottomLeft: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaBL;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaBL = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value starting from the bottom-right of the Game Object.\r\n     * This value is interpolated from the corner to the center of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Alpha#alphaBottomRight\r\n     * @type {number}\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    alphaBottomRight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alphaBR;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alphaBR = v;\r\n\r\n            if (v !== 0)\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Alpha;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../../math/Clamp');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 2; // 0010\r\n\r\n/**\r\n * Provides methods used for setting the alpha property of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.AlphaSingle\r\n * @since 3.22.0\r\n */\r\n\r\nvar AlphaSingle = {\r\n\r\n    /**\r\n     * Private internal value. Holds the global alpha value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.AlphaSingle#_alpha\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _alpha: 1,\r\n\r\n    /**\r\n     * Clears all alpha values associated with this Game Object.\r\n     *\r\n     * Immediately sets the alpha levels back to 1 (fully opaque).\r\n     *\r\n     * @method Phaser.GameObjects.Components.AlphaSingle#clearAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    clearAlpha: function ()\r\n    {\r\n        return this.setAlpha(1);\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * @method Phaser.GameObjects.Components.AlphaSingle#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=1] - The alpha value applied across the whole Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlpha: function (value)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        this.alpha = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Game Object.\r\n     *\r\n     * This is a global value, impacting the entire Game Object, not just a region of it.\r\n     *\r\n     * @name Phaser.GameObjects.Components.AlphaSingle#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alpha;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var v = Clamp(value, 0, 1);\r\n\r\n            this._alpha = v;\r\n\r\n            if (v === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = AlphaSingle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\n\r\n/**\r\n * Provides methods used for setting the blend mode of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.BlendMode\r\n * @since 3.0.0\r\n */\r\n\r\nvar BlendMode = {\r\n\r\n    /**\r\n     * Private internal value. Holds the current blend mode.\r\n     * \r\n     * @name Phaser.GameObjects.Components.BlendMode#_blendMode\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _blendMode: BlendModes.NORMAL,\r\n\r\n    /**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     * * ERASE\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency of which blend modes\r\n     * are used.\r\n     *\r\n     * @name Phaser.GameObjects.Components.BlendMode#blendMode\r\n     * @type {(Phaser.BlendModes|string)}\r\n     * @since 3.0.0\r\n     */\r\n    blendMode: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._blendMode;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (typeof value === 'string')\r\n            {\r\n                value = BlendModes[value];\r\n            }\r\n\r\n            value |= 0;\r\n\r\n            if (value >= -1)\r\n            {\r\n                this._blendMode = value;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the Blend Mode being used by this Game Object.\r\n     *\r\n     * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)\r\n     *\r\n     * Under WebGL only the following Blend Modes are available:\r\n     *\r\n     * * ADD\r\n     * * MULTIPLY\r\n     * * SCREEN\r\n     * * ERASE (only works when rendering to a framebuffer, like a Render Texture)\r\n     *\r\n     * Canvas has more available depending on browser support.\r\n     *\r\n     * You can also create your own custom Blend Modes in WebGL.\r\n     *\r\n     * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending\r\n     * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these\r\n     * reasons try to be careful about the construction of your Scene and the frequency in which blend modes\r\n     * are used.\r\n     *\r\n     * @method Phaser.GameObjects.Components.BlendMode#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.BlendModes)} value - The BlendMode value. Either a string or a CONST.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setBlendMode: function (value)\r\n    {\r\n        this.blendMode = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = BlendMode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for calculating and setting the size of a non-Frame based Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.ComputedSize\r\n * @since 3.0.0\r\n */\r\n\r\nvar ComputedSize = {\r\n\r\n    /**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayWidth` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    width: 0,\r\n\r\n    /**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayHeight` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    height: 0,\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     * \r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     * \r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setSize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Game Object.\r\n     * \r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ComputedSize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the texture of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Crop\r\n * @since 3.12.0\r\n */\r\n\r\nvar Crop = {\r\n\r\n    /**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Crop#texture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @since 3.0.0\r\n     */\r\n    texture: null,\r\n\r\n    /**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Crop#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */\r\n    frame: null,\r\n\r\n    /**\r\n     * A boolean flag indicating if this Game Object is being cropped or not.\r\n     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.\r\n     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Crop#isCropped\r\n     * @type {boolean}\r\n     * @since 3.11.0\r\n     */\r\n    isCropped: false,\r\n\r\n    /**\r\n     * Applies a crop to a texture based Game Object, such as a Sprite or Image.\r\n     * \r\n     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.\r\n     * \r\n     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just\r\n     * changes what is shown when rendered.\r\n     * \r\n     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.\r\n     * \r\n     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left\r\n     * half of it, you could call `setCrop(0, 0, 400, 600)`.\r\n     * \r\n     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop\r\n     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.\r\n     * \r\n     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.\r\n     * \r\n     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.\r\n     * \r\n     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow\r\n     * the renderer to skip several internal calculations.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Crop#setCrop\r\n     * @since 3.11.0\r\n     *\r\n     * @param {(number|Phaser.Geom.Rectangle)} [x] - The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.\r\n     * @param {number} [y] - The y coordinate to start the crop from.\r\n     * @param {number} [width] - The width of the crop rectangle in pixels.\r\n     * @param {number} [height] - The height of the crop rectangle in pixels.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setCrop: function (x, y, width, height)\r\n    {\r\n        if (x === undefined)\r\n        {\r\n            this.isCropped = false;\r\n        }\r\n        else if (this.frame)\r\n        {\r\n            if (typeof x === 'number')\r\n            {\r\n                this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);\r\n            }\r\n            else\r\n            {\r\n                var rect = x;\r\n\r\n                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);\r\n            }\r\n\r\n            this.isCropped = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that returns a blank, well-formed crop object for use by a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Crop#resetCropObject\r\n     * @private\r\n     * @since 3.12.0\r\n     * \r\n     * @return {object} The crop object.\r\n     */\r\n    resetCropObject: function ()\r\n    {\r\n        return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Crop;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the depth of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Depth\r\n * @since 3.0.0\r\n */\r\n\r\nvar Depth = {\r\n\r\n    /**\r\n     * Private internal value. Holds the depth of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Depth#_depth\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _depth: 0,\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     *\r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The default depth is zero. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Depth#depth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    depth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._depth;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (this.displayList)\r\n            {\r\n                this.displayList.queueDepthSort();\r\n            }\r\n\r\n            this._depth = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The depth of this Game Object within the Scene.\r\n     *\r\n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\r\n     * of Game Objects, without actually moving their position in the display list.\r\n     *\r\n     * The default depth is zero. A Game Object with a higher depth\r\n     * value will always render in front of one with a lower value.\r\n     *\r\n     * Setting the depth will queue a depth sort event within the Scene.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Depth#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The depth of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDepth: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.depth = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Depth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for visually flipping a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Flip\r\n * @since 3.0.0\r\n */\r\n\r\nvar Flip = {\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipX: false,\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     * \r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Flip#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    flipY: false,\r\n\r\n    /**\r\n     * Toggles the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipX: function ()\r\n    {\r\n        this.flipX = !this.flipX;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    toggleFlipY: function ()\r\n    {\r\n        this.flipY = !this.flipY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Game Object.\r\n     * \r\n     * A Game Object that is flipped will render inversed on the flipped axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Flip#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Flip;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RotateAround = require('../../math/RotateAround');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Provides methods used for obtaining the bounds of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.GetBounds\r\n * @since 3.0.0\r\n */\r\n\r\nvar GetBounds = {\r\n\r\n    /**\r\n     * Processes the bounds output vector before returning it.\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#prepareBoundsOutput\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} output - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    prepareBoundsOutput: function (output, includeParent)\r\n    {\r\n        if (includeParent === undefined) { includeParent = false; }\r\n\r\n        if (this.rotation !== 0)\r\n        {\r\n            RotateAround(output, this.x, this.y, this.rotation);\r\n        }\r\n\r\n        if (includeParent && this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getCenter\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getCenter: function (output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX) + (this.displayWidth / 2);\r\n        output.y = this.y - (this.displayHeight * this.originY) + (this.displayHeight / 2);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the top-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopLeft: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the top-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the top-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getTopRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getTopRight: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = this.y - (this.displayHeight * this.originY);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the left-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getLeftCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getLeftCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the right-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getRightCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getRightCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + (this.displayHeight / 2);\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomLeft: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = this.x - (this.displayWidth * this.originX);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-center coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomCenter\r\n     * @since 3.18.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomCenter: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + (this.displayWidth / 2);\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.\r\n     * The returned point is calculated in local space and does not factor in any parent containers\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBottomRight\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Math.Vector2|object)} [output] - An object to store the values in. If not provided a new Vector2 will be created.\r\n     * @param {boolean} [includeParent=false] - If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector?\r\n     *\r\n     * @return {(Phaser.Math.Vector2|object)} The values stored in the output object.\r\n     */\r\n    getBottomRight: function (output, includeParent)\r\n    {\r\n        if (!output) { output = new Vector2(); }\r\n\r\n        output.x = (this.x - (this.displayWidth * this.originX)) + this.displayWidth;\r\n        output.y = (this.y - (this.displayHeight * this.originY)) + this.displayHeight;\r\n\r\n        return this.prepareBoundsOutput(output, includeParent);\r\n    },\r\n\r\n    /**\r\n     * Gets the bounds of this Game Object, regardless of origin.\r\n     * The values are stored and returned in a Rectangle, or Rectangle-like, object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.GetBounds#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Rectangle} O - [output,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Rectangle|object)} [output] - An object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The values stored in the output object.\r\n     */\r\n    getBounds: function (output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        //  We can use the output object to temporarily store the x/y coords in:\r\n\r\n        var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy;\r\n\r\n        // Instead of doing a check if parent container is \r\n        // defined per corner we only do it once.\r\n        if (this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n\r\n            this.getTopLeft(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            TLx = output.x;\r\n            TLy = output.y;\r\n\r\n            this.getTopRight(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            TRx = output.x;\r\n            TRy = output.y;\r\n\r\n            this.getBottomLeft(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            BLx = output.x;\r\n            BLy = output.y;\r\n\r\n            this.getBottomRight(output);\r\n            parentMatrix.transformPoint(output.x, output.y, output);\r\n\r\n            BRx = output.x;\r\n            BRy = output.y;\r\n        }\r\n        else\r\n        {\r\n            this.getTopLeft(output);\r\n\r\n            TLx = output.x;\r\n            TLy = output.y;\r\n\r\n            this.getTopRight(output);\r\n\r\n            TRx = output.x;\r\n            TRy = output.y;\r\n\r\n            this.getBottomLeft(output);\r\n\r\n            BLx = output.x;\r\n            BLy = output.y;\r\n\r\n            this.getBottomRight(output);\r\n\r\n            BRx = output.x;\r\n            BRy = output.y;\r\n        }\r\n\r\n        output.x = Math.min(TLx, TRx, BLx, BRx);\r\n        output.y = Math.min(TLy, TRy, BLy, BRy);\r\n        output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;\r\n        output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;\r\n\r\n        return output;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = GetBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapMask = require('../../display/mask/BitmapMask');\r\nvar GeometryMask = require('../../display/mask/GeometryMask');\r\n\r\n/**\r\n * Provides methods used for getting and setting the mask of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Mask\r\n * @since 3.0.0\r\n */\r\n\r\nvar Mask = {\r\n\r\n    /**\r\n     * The Mask this Game Object is using during render.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Mask#mask\r\n     * @type {Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask}\r\n     * @since 3.0.0\r\n     */\r\n    mask: null,\r\n\r\n    /**\r\n     * Sets the mask that this Game Object will use to render with.\r\n     *\r\n     * The mask must have been previously created and can be either a GeometryMask or a BitmapMask.\r\n     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.\r\n     *\r\n     * If a mask is already set on this Game Object it will be immediately replaced.\r\n     *\r\n     * Masks are positioned in global space and are not relative to the Game Object to which they\r\n     * are applied. The reason for this is that multiple Game Objects can all share the same mask.\r\n     *\r\n     * Masks have no impact on physics or input detection. They are purely a rendering component\r\n     * that allows you to limit what is visible during the render pass.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Mask#setMask\r\n     * @since 3.6.2\r\n     *\r\n     * @param {Phaser.Display.Masks.BitmapMask|Phaser.Display.Masks.GeometryMask} mask - The mask this Game Object will use when rendering.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setMask: function (mask)\r\n    {\r\n        this.mask = mask;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the mask that this Game Object was using.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Mask#clearMask\r\n     * @since 3.6.2\r\n     *\r\n     * @param {boolean} [destroyMask=false] - Destroy the mask before clearing it?\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    clearMask: function (destroyMask)\r\n    {\r\n        if (destroyMask === undefined) { destroyMask = false; }\r\n\r\n        if (destroyMask && this.mask)\r\n        {\r\n            this.mask.destroy();\r\n        }\r\n\r\n        this.mask = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns a Bitmap Mask. This mask can be used by any Game Object,\r\n     * including this one.\r\n     *\r\n     * Note: Bitmap Masks only work on WebGL. Geometry Masks work on both WebGL and Canvas.\r\n     *\r\n     * To create the mask you need to pass in a reference to a renderable Game Object.\r\n     * A renderable Game Object is one that uses a texture to render with, such as an\r\n     * Image, Sprite, Render Texture or BitmapText.\r\n     *\r\n     * If you do not provide a renderable object, and this Game Object has a texture,\r\n     * it will use itself as the object. This means you can call this method to create\r\n     * a Bitmap Mask from any renderable Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Mask#createBitmapMask\r\n     * @since 3.6.2\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [renderable] - A renderable Game Object that uses a texture, such as a Sprite.\r\n     *\r\n     * @return {Phaser.Display.Masks.BitmapMask} This Bitmap Mask that was created.\r\n     */\r\n    createBitmapMask: function (renderable)\r\n    {\r\n        if (renderable === undefined && (this.texture || this.shader))\r\n        {\r\n            // eslint-disable-next-line consistent-this\r\n            renderable = this;\r\n        }\r\n\r\n        return new BitmapMask(this.scene, renderable);\r\n    },\r\n\r\n    /**\r\n     * Creates and returns a Geometry Mask. This mask can be used by any Game Object,\r\n     * including this one.\r\n     *\r\n     * To create the mask you need to pass in a reference to a Graphics Game Object.\r\n     *\r\n     * If you do not provide a graphics object, and this Game Object is an instance\r\n     * of a Graphics object, then it will use itself to create the mask.\r\n     *\r\n     * This means you can call this method to create a Geometry Mask from any Graphics Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Mask#createGeometryMask\r\n     * @since 3.6.2\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphics] - A Graphics Game Object. The geometry within it will be used as the mask.\r\n     *\r\n     * @return {Phaser.Display.Masks.GeometryMask} This Geometry Mask that was created.\r\n     */\r\n    createGeometryMask: function (graphics)\r\n    {\r\n        if (graphics === undefined && this.type === 'Graphics')\r\n        {\r\n            // eslint-disable-next-line consistent-this\r\n            graphics = this;\r\n        }\r\n\r\n        return new GeometryMask(this.scene, graphics);\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Mask;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the origin of a Game Object.\r\n * Values are normalized, given in the range 0 to 1.\r\n * Display values contain the calculated pixel values.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Origin\r\n * @since 3.0.0\r\n */\r\n\r\nvar Origin = {\r\n\r\n    /**\r\n     * A property indicating that a Game Object has this component.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#_originComponent\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.2.0\r\n     */\r\n    _originComponent: true,\r\n\r\n    /**\r\n     * The horizontal origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#originX\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.0.0\r\n     */\r\n    originX: 0.5,\r\n\r\n    /**\r\n     * The vertical origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#originY\r\n     * @type {number}\r\n     * @default 0.5\r\n     * @since 3.0.0\r\n     */\r\n    originY: 0.5,\r\n\r\n    //  private + read only\r\n    _displayOriginX: 0,\r\n    _displayOriginY: 0,\r\n\r\n    /**\r\n     * The horizontal display origin of this Game Object.\r\n     * The origin is a normalized value between 0 and 1.\r\n     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#displayOriginX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._displayOriginX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._displayOriginX = value;\r\n            this.originX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical display origin of this Game Object.\r\n     * The origin is a normalized value between 0 and 1.\r\n     * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Origin#displayOriginY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._displayOriginY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._displayOriginY = value;\r\n            this.originY = value / this.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the origin of this Game Object.\r\n     *\r\n     * The values are given in the range 0 to 1.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0.5] - The horizontal origin value.\r\n     * @param {number} [y=x] - The vertical origin value. If not defined it will be set to the value of `x`.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setOrigin: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0.5; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.originX = x;\r\n        this.originY = y;\r\n\r\n        return this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the origin of this Game Object based on the Pivot values in its Frame.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setOriginFromFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setOriginFromFrame: function ()\r\n    {\r\n        if (!this.frame || !this.frame.customPivot)\r\n        {\r\n            return this.setOrigin();\r\n        }\r\n        else\r\n        {\r\n            this.originX = this.frame.pivotX;\r\n            this.originY = this.frame.pivotY;\r\n        }\r\n\r\n        return this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the display origin of this Game Object.\r\n     * The difference between this and setting the origin is that you can use pixel values for setting the display origin.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#setDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal display origin value.\r\n     * @param {number} [y=x] - The vertical display origin value. If not defined it will be set to the value of `x`.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDisplayOrigin: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.displayOriginX = x;\r\n        this.displayOriginY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the Display Origin cached values internally stored on this Game Object.\r\n     * You don't usually call this directly, but it is exposed for edge-cases where you may.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Origin#updateDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateDisplayOrigin: function ()\r\n    {\r\n        this._displayOriginX = this.originX * this.width;\r\n        this._displayOriginY = this.originY * this.height;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Origin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar GetBoolean = require('../../tweens/builders/GetBoolean');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar TWEEN_CONST = require('../../tweens/tween/const');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Provides methods used for managing a Game Object following a Path.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.GameObjects.Components.PathFollower\r\n * @since 3.17.0\r\n */\r\n\r\nvar PathFollower = {\r\n\r\n    /**\r\n     * The Path this PathFollower is following. It can only follow one Path at a time.\r\n     *\r\n     * @name Phaser.GameObjects.Components.PathFollower#path\r\n     * @type {Phaser.Curves.Path}\r\n     * @since 3.0.0\r\n     */\r\n    path: null,\r\n\r\n    /**\r\n     * Should the PathFollower automatically rotate to point in the direction of the Path?\r\n     *\r\n     * @name Phaser.GameObjects.Components.PathFollower#rotateToPath\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.0.0\r\n     */\r\n    rotateToPath: false,\r\n\r\n    /**\r\n     * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)\r\n     * this value is added to the rotation value. This allows you to rotate objects to a path but control\r\n     * the angle of the rotation as well.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathRotationOffset\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    pathRotationOffset: 0,\r\n\r\n    /**\r\n     * An additional vector to add to the PathFollowers position, allowing you to offset it from the\r\n     * Path coordinates.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathOffset\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\r\n    pathOffset: null,\r\n\r\n    /**\r\n     * A Vector2 that stores the current point of the path the follower is on.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathVector\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.0.0\r\n     */\r\n    pathVector: null,\r\n\r\n    /**\r\n     * The distance the follower has traveled from the previous point to the current one, at the last update.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathDelta\r\n     * @type {Phaser.Math.Vector2}\r\n     * @since 3.23.0\r\n     */\r\n    pathDelta: null,\r\n\r\n    /**\r\n     * The Tween used for following the Path.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathTween\r\n     * @type {Phaser.Tweens.Tween}\r\n     * @since 3.0.0\r\n     */\r\n    pathTween: null,\r\n\r\n    /**\r\n     * Settings for the PathFollower.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#pathConfig\r\n     * @type {?Phaser.Types.GameObjects.PathFollower.PathConfig}\r\n     * @default null\r\n     * @since 3.0.0\r\n     */\r\n    pathConfig: null,\r\n\r\n    /**\r\n     * Records the direction of the follower so it can change direction.\r\n     *\r\n     * @name Phaser.GameObjects.PathFollower#_prevDirection\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    _prevDirection: TWEEN_CONST.PLAYING_FORWARD,\r\n\r\n    /**\r\n     * Set the Path that this PathFollower should follow.\r\n     *\r\n     * Optionally accepts {@link Phaser.Types.GameObjects.PathFollower.PathConfig} settings.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\r\n     * @param {(number|Phaser.Types.GameObjects.PathFollower.PathConfig|Phaser.Types.Tweens.NumberTweenBuilderConfig)} [config] - Settings for the PathFollower.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setPath: function (path, config)\r\n    {\r\n        if (config === undefined) { config = this.pathConfig; }\r\n\r\n        var tween = this.pathTween;\r\n\r\n        if (tween && tween.isPlaying())\r\n        {\r\n            tween.stop();\r\n        }\r\n\r\n        this.path = path;\r\n\r\n        if (config)\r\n        {\r\n            this.startFollow(config);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set whether the PathFollower should automatically rotate to point in the direction of the Path.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#setRotateToPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Whether the PathFollower should automatically rotate to point in the direction of the Path.\r\n     * @param {number} [offset=0] - Rotation offset in degrees.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setRotateToPath: function (value, offset)\r\n    {\r\n        if (offset === undefined) { offset = 0; }\r\n\r\n        this.rotateToPath = value;\r\n\r\n        this.pathRotationOffset = offset;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Is this PathFollower actively following a Path or not?\r\n     *\r\n     * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#isFollowing\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` is this PathFollower is actively following a Path, otherwise `false`.\r\n     */\r\n    isFollowing: function ()\r\n    {\r\n        var tween = this.pathTween;\r\n\r\n        return (tween && tween.isPlaying());\r\n    },\r\n\r\n    /**\r\n     * Starts this PathFollower following its given Path.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#startFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.PathFollower.PathConfig|Phaser.Types.Tweens.NumberTweenBuilderConfig)} [config={}] - The duration of the follow, or a PathFollower config object.\r\n     * @param {number} [startAt=0] - Optional start position of the follow, between 0 and 1.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    startFollow: function (config, startAt)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n        if (startAt === undefined) { startAt = 0; }\r\n\r\n        var tween = this.pathTween;\r\n\r\n        if (tween && tween.isPlaying())\r\n        {\r\n            tween.stop();\r\n        }\r\n\r\n        if (typeof config === 'number')\r\n        {\r\n            config = { duration: config };\r\n        }\r\n\r\n        //  Override in case they've been specified in the config\r\n        config.from = GetValue(config, 'from', 0);\r\n        config.to = GetValue(config, 'to', 1);\r\n\r\n        var positionOnPath = GetBoolean(config, 'positionOnPath', false);\r\n\r\n        this.rotateToPath = GetBoolean(config, 'rotateToPath', false);\r\n        this.pathRotationOffset = GetValue(config, 'rotationOffset', 0);\r\n\r\n        //  This works, but it's not an ideal way of doing it as the follower jumps position\r\n        var seek = GetValue(config, 'startAt', startAt);\r\n\r\n        if (seek)\r\n        {\r\n            config.onStart = function (tween)\r\n            {\r\n                var tweenData = tween.data[0];\r\n                tweenData.progress = seek;\r\n                tweenData.elapsed = tweenData.duration * seek;\r\n                var v = tweenData.ease(tweenData.progress);\r\n                tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);\r\n                tweenData.target[tweenData.key] = tweenData.current;\r\n            };\r\n        }\r\n\r\n        if (!this.pathOffset)\r\n        {\r\n            this.pathOffset = new Vector2(this.x, this.y);\r\n        }\r\n\r\n        if (!this.pathVector)\r\n        {\r\n            this.pathVector = new Vector2();\r\n        }\r\n\r\n        if (!this.pathDelta)\r\n        {\r\n            this.pathDelta = new Vector2();\r\n        }\r\n\r\n        this.pathDelta.reset();\r\n\r\n        this.pathTween = this.scene.sys.tweens.addCounter(config);\r\n\r\n        //  The starting point of the path, relative to this follower\r\n        this.path.getStartPoint(this.pathOffset);\r\n\r\n        if (positionOnPath)\r\n        {\r\n            this.x = this.pathOffset.x;\r\n            this.y = this.pathOffset.y;\r\n        }\r\n\r\n        this.pathOffset.x = this.x - this.pathOffset.x;\r\n        this.pathOffset.y = this.y - this.pathOffset.y;\r\n\r\n        this._prevDirection = TWEEN_CONST.PLAYING_FORWARD;\r\n\r\n        if (this.rotateToPath)\r\n        {\r\n            //  Set the rotation now (in case the tween has a delay on it, etc)\r\n            var nextPoint = this.path.getPoint(0.1);\r\n\r\n            this.rotation = Math.atan2(nextPoint.y - this.y, nextPoint.x - this.x) + DegToRad(this.pathRotationOffset);\r\n        }\r\n\r\n        this.pathConfig = config;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the\r\n     * point on the Path at which you paused it.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#pauseFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    pauseFollow: function ()\r\n    {\r\n        var tween = this.pathTween;\r\n\r\n        if (tween && tween.isPlaying())\r\n        {\r\n            tween.pause();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes a previously paused PathFollower.\r\n     *\r\n     * If the PathFollower was not paused this has no effect.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#resumeFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    resumeFollow: function ()\r\n    {\r\n        var tween = this.pathTween;\r\n\r\n        if (tween && tween.isPaused())\r\n        {\r\n            tween.resume();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops this PathFollower from following the path any longer.\r\n     *\r\n     * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#stopFollow\r\n     * @since 3.3.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stopFollow: function ()\r\n    {\r\n        var tween = this.pathTween;\r\n\r\n        if (tween && tween.isPlaying())\r\n        {\r\n            tween.stop();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler that advances this PathFollower along the path.\r\n     *\r\n     * Called automatically by the Scene step, should not typically be called directly.\r\n     *\r\n     * @method Phaser.GameObjects.Components.PathFollower#pathUpdate\r\n     * @since 3.17.0\r\n     */\r\n    pathUpdate: function ()\r\n    {\r\n        var tween = this.pathTween;\r\n\r\n        if (tween)\r\n        {\r\n            var tweenData = tween.data[0];\r\n            var pathDelta = this.pathDelta;\r\n            var pathVector = this.pathVector;\r\n\r\n            pathDelta.copy(pathVector).negate();\r\n\r\n            if (tweenData.state === TWEEN_CONST.COMPLETE)\r\n            {\r\n                this.path.getPoint(1, pathVector);\r\n\r\n                pathDelta.add(pathVector);\r\n                pathVector.add(this.pathOffset);\r\n\r\n                this.setPosition(pathVector.x, pathVector.y);\r\n\r\n                return;\r\n            }\r\n            else if (tweenData.state !== TWEEN_CONST.PLAYING_FORWARD && tweenData.state !== TWEEN_CONST.PLAYING_BACKWARD)\r\n            {\r\n                //  If delayed, etc then bail out\r\n                return;\r\n            }\r\n\r\n            this.path.getPoint(tween.getValue(), pathVector);\r\n\r\n            pathDelta.add(pathVector);\r\n            pathVector.add(this.pathOffset);\r\n\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n\r\n            this.setPosition(pathVector.x, pathVector.y);\r\n\r\n            var speedX = this.x - oldX;\r\n            var speedY = this.y - oldY;\r\n\r\n            if (speedX === 0 && speedY === 0)\r\n            {\r\n                //  Bail out early\r\n                return;\r\n            }\r\n\r\n            if (tweenData.state !== this._prevDirection)\r\n            {\r\n                //  We've changed direction, so don't do a rotate this frame\r\n                this._prevDirection = tweenData.state;\r\n\r\n                return;\r\n            }\r\n\r\n            if (this.rotateToPath)\r\n            {\r\n                this.rotation = Math.atan2(speedY, speedX) + DegToRad(this.pathRotationOffset);\r\n            }\r\n        }\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = PathFollower;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DeepCopy = require('../../utils/object/DeepCopy');\r\nvar PIPELINE_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar SpliceOne = require('../../utils/array/SpliceOne');\r\n\r\n/**\r\n * Provides methods used for setting the WebGL rendering pipeline of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Pipeline\r\n * @webglOnly\r\n * @since 3.0.0\r\n */\r\n\r\nvar Pipeline = {\r\n\r\n    /**\r\n     * The initial WebGL pipeline of this Game Object.\r\n     *\r\n     * If you call `resetPipeline` on this Game Object, the pipeline is reset to this default.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Pipeline#defaultPipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    defaultPipeline: null,\r\n\r\n    /**\r\n     * The current WebGL pipeline of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Pipeline#pipeline\r\n     * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n     * @default null\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     */\r\n    pipeline: null,\r\n\r\n    /**\r\n     * Does this Game Object have any Post Pipelines set?\r\n     *\r\n     * @name Phaser.GameObjects.Components.Pipeline#hasPostPipeline\r\n     * @type {boolean}\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     */\r\n    hasPostPipeline: false,\r\n\r\n    /**\r\n     * The WebGL Post FX Pipelines this Game Object uses for post-render effects.\r\n     *\r\n     * The pipelines are processed in the order in which they appear in this array.\r\n     *\r\n     * If you modify this array directly, be sure to set the\r\n     * `hasPostPipeline` property accordingly.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Pipeline#postPipelines\r\n     * @type {Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[]}\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     */\r\n    postPipelines: null,\r\n\r\n    /**\r\n     * An object to store pipeline specific data in, to be read by the pipelines this Game Object uses.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Pipeline#pipelineData\r\n     * @type {object}\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     */\r\n    pipelineData: null,\r\n\r\n    /**\r\n     * Sets the initial WebGL Pipeline of this Game Object.\r\n     *\r\n     * This should only be called during the instantiation of the Game Object. After that, use `setPipeline`.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#initPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} pipeline - Either the string-based name of the pipeline, or a pipeline instance to set.\r\n     *\r\n     * @return {boolean} `true` if the pipeline was set successfully, otherwise `false`.\r\n     */\r\n    initPipeline: function (pipeline)\r\n    {\r\n        if (pipeline === undefined) { pipeline = PIPELINE_CONST.MULTI_PIPELINE; }\r\n\r\n        var renderer = this.scene.sys.renderer;\r\n\r\n        if (!renderer)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pipelines = renderer.pipelines;\r\n\r\n        this.postPipelines = [];\r\n        this.pipelineData = {};\r\n\r\n        if (pipelines)\r\n        {\r\n            var instance = pipelines.get(pipeline);\r\n\r\n            if (instance)\r\n            {\r\n                this.defaultPipeline = instance;\r\n                this.pipeline = instance;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Sets the main WebGL Pipeline of this Game Object.\r\n     *\r\n     * Also sets the `pipelineData` property, if the parameter is given.\r\n     *\r\n     * Both the pipeline and post pipelines share the same pipeline data object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#setPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} pipeline - Either the string-based name of the pipeline, or a pipeline instance to set.\r\n     * @param {object} [pipelineData] - Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.\r\n     * @param {boolean} [copyData=true] - Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPipeline: function (pipeline, pipelineData, copyData)\r\n    {\r\n        var renderer = this.scene.sys.renderer;\r\n\r\n        if (!renderer)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var pipelines = renderer.pipelines;\r\n\r\n        if (pipelines)\r\n        {\r\n            var instance = pipelines.get(pipeline);\r\n\r\n            if (instance)\r\n            {\r\n                this.pipeline = instance;\r\n            }\r\n\r\n            if (pipelineData)\r\n            {\r\n                this.pipelineData = (copyData) ? DeepCopy(pipelineData) : pipelineData;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets one, or more, Post Pipelines on this Game Object.\r\n     *\r\n     * Post Pipelines are invoked after this Game Object has rendered to its target and\r\n     * are commonly used for post-fx.\r\n     *\r\n     * The post pipelines are appended to the `postPipelines` array belonging to this\r\n     * Game Object. When the renderer processes this Game Object, it iterates through the post\r\n     * pipelines in the order in which they appear in the array. If you are stacking together\r\n     * multiple effects, be aware that the order is important.\r\n     *\r\n     * If you call this method multiple times, the new pipelines will be appended to any existing\r\n     * post pipelines already set. Use the `resetPostPipeline` method to clear them first, if required.\r\n     *\r\n     * You can optionally also sets the `pipelineData` property, if the parameter is given.\r\n     *\r\n     * Both the pipeline and post pipelines share the pipeline data object together.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#setPostPipeline\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[]|function|function[]|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[])} pipelines - Either the string-based name of the pipeline, or a pipeline instance, or class, or an array of them.\r\n     * @param {object} [pipelineData] - Optional pipeline data object that is _deep copied_ into the `pipelineData` property of this Game Object.\r\n     * @param {boolean} [copyData=true] - Should the pipeline data object be _deep copied_ into the `pipelineData` property of this Game Object? If `false` it will be set by reference instead.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPostPipeline: function (pipelines, pipelineData, copyData)\r\n    {\r\n        var renderer = this.scene.sys.renderer;\r\n\r\n        if (!renderer)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var pipelineManager = renderer.pipelines;\r\n\r\n        if (pipelineManager)\r\n        {\r\n            if (!Array.isArray(pipelines))\r\n            {\r\n                pipelines = [ pipelines ];\r\n            }\r\n\r\n            for (var i = 0; i < pipelines.length; i++)\r\n            {\r\n                var instance = pipelineManager.getPostPipeline(pipelines[i], this);\r\n\r\n                if (instance)\r\n                {\r\n                    this.postPipelines.push(instance);\r\n                }\r\n            }\r\n\r\n            if (pipelineData)\r\n            {\r\n                this.pipelineData = (copyData) ? DeepCopy(pipelineData) : pipelineData;\r\n            }\r\n        }\r\n\r\n        this.hasPostPipeline = (this.postPipelines.length > 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an entry to the `pipelineData` object belonging to this Game Object.\r\n     *\r\n     * If the 'key' already exists, its value is updated. If it doesn't exist, it is created.\r\n     *\r\n     * If `value` is undefined, and `key` exists, `key` is removed from the data object.\r\n     *\r\n     * Both the pipeline and post pipelines share the pipeline data object together.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#setPipelineData\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the pipeline data to set, update, or delete.\r\n     * @param {any} [value] - The value to be set with the key. If `undefined` then `key` will be deleted from the object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPipelineData: function (key, value)\r\n    {\r\n        var data = this.pipelineData;\r\n\r\n        if (value === undefined)\r\n        {\r\n            delete data[key];\r\n        }\r\n        else\r\n        {\r\n            data[key] = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a Post Pipeline instance from this Game Object, based on the given name, and returns it.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#getPostPipeline\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|function|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline)} pipeline - The string-based name of the pipeline, or a pipeline class.\r\n     *\r\n     * @return {(Phaser.Renderer.WebGL.Pipelines.PostFXPipeline|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline[])} The Post Pipeline/s matching the name, or undefined if no match. If more than one match they are returned in an array.\r\n     */\r\n    getPostPipeline: function (pipeline)\r\n    {\r\n        var pipelines = this.postPipelines;\r\n\r\n        var results = [];\r\n\r\n        for (var i = 0; i < pipelines.length; i++)\r\n        {\r\n            var instance = pipelines[i];\r\n\r\n            if ((typeof pipeline === 'string' && instance.name === pipeline) || instance instanceof pipeline)\r\n            {\r\n                results.push(instance);\r\n            }\r\n        }\r\n\r\n        return (results.length === 1) ? results[0] : results;\r\n    },\r\n\r\n    /**\r\n     * Resets the WebGL Pipeline of this Game Object back to the default it was created with.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#resetPipeline\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [resetPostPipelines=false] - Reset all of the post pipelines?\r\n     * @param {boolean} [resetData=false] - Reset the `pipelineData` object to being an empty object?\r\n     *\r\n     * @return {boolean} `true` if the pipeline was reset successfully, otherwise `false`.\r\n     */\r\n    resetPipeline: function (resetPostPipelines, resetData)\r\n    {\r\n        if (resetPostPipelines === undefined) { resetPostPipelines = false; }\r\n        if (resetData === undefined) { resetData = false; }\r\n\r\n        this.pipeline = this.defaultPipeline;\r\n\r\n        if (resetPostPipelines)\r\n        {\r\n            this.postPipelines = [];\r\n            this.hasPostPipeline = false;\r\n        }\r\n\r\n        if (resetData)\r\n        {\r\n            this.pipelineData = {};\r\n        }\r\n\r\n        return (this.pipeline !== null);\r\n    },\r\n\r\n    /**\r\n     * Resets the WebGL Post Pipelines of this Game Object. It does this by calling\r\n     * the `destroy` method on each post pipeline and then clearing the local array.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#resetPostPipeline\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [resetData=false] - Reset the `pipelineData` object to being an empty object?\r\n     */\r\n    resetPostPipeline: function (resetData)\r\n    {\r\n        if (resetData === undefined) { resetData = false; }\r\n\r\n        var pipelines = this.postPipelines;\r\n\r\n        for (var i = 0; i < pipelines.length; i++)\r\n        {\r\n            pipelines[i].destroy();\r\n        }\r\n\r\n        this.postPipelines = [];\r\n        this.hasPostPipeline = false;\r\n\r\n        if (resetData)\r\n        {\r\n            this.pipelineData = {};\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes a type of Post Pipeline instances from this Game Object, based on the given name, and destroys them.\r\n     *\r\n     * If you wish to remove all Post Pipelines use the `resetPostPipeline` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#removePostPipeline\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline} pipeline - The string-based name of the pipeline, or a pipeline class.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    removePostPipeline: function (pipeline)\r\n    {\r\n        var pipelines = this.postPipelines;\r\n\r\n        for (var i = pipelines.length - 1; i >= 0; i--)\r\n        {\r\n            var instance = pipelines[i];\r\n\r\n            if (\r\n                (typeof pipeline === 'string' && instance.name === pipeline) ||\r\n                (typeof pipeline !== 'string' && instance instanceof pipeline))\r\n            {\r\n                instance.destroy();\r\n\r\n                SpliceOne(pipelines, i);\r\n            }\r\n        }\r\n\r\n        this.hasPostPipeline = (this.postPipelines.length > 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the name of the WebGL Pipeline this Game Object is currently using.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Pipeline#getPipelineName\r\n     * @webglOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} The string-based name of the pipeline being used by this Game Object.\r\n     */\r\n    getPipelineName: function ()\r\n    {\r\n        return this.pipeline.name;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Pipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.ScrollFactor\r\n * @since 3.0.0\r\n */\r\n\r\nvar ScrollFactor = {\r\n\r\n    /**\r\n     * The horizontal scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorX: 1,\r\n\r\n    /**\r\n     * The vertical scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scrollFactorY: 1,\r\n\r\n    /**\r\n     * Sets the scroll factor of this Game Object.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     * \r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = ScrollFactor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for getting and setting the size of a Game Object.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Size\r\n * @since 3.0.0\r\n */\r\n\r\nvar Size = {\r\n\r\n    /**\r\n     * A property indicating that a Game Object has this component.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#_sizeComponent\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.2.0\r\n     */\r\n    _sizeComponent: true,\r\n\r\n    /**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayWidth` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#width\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    width: 0,\r\n\r\n    /**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * Changing this value will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n     * the `displayHeight` property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#height\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    height: 0,\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.abs(this.scaleX * this.frame.realWidth);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.frame.realWidth;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     * \r\n     * This value takes into account the scale factor.\r\n     * \r\n     * Setting this value will adjust the Game Object's scale property.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Size#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.abs(this.scaleY * this.frame.realHeight);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.frame.realHeight;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object to be that of the given Frame.\r\n     * \r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     * \r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setSizeToFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} frame - The frame to base the size of this Game Object on.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSizeToFrame: function (frame)\r\n    {\r\n        if (frame === undefined) { frame = this.frame; }\r\n\r\n        this.width = frame.realWidth;\r\n        this.height = frame.realHeight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     * \r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     * \r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Game Object.\r\n     * \r\n     * Calling this will adjust the scale.\r\n     * \r\n     * @method Phaser.GameObjects.Components.Size#setDisplaySize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Size;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 8; // 1000\r\n\r\n/**\r\n * Provides methods used for getting and setting the texture of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Texture\r\n * @since 3.0.0\r\n */\r\n\r\nvar Texture = {\r\n\r\n    /**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Texture#texture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @since 3.0.0\r\n     */\r\n    texture: null,\r\n\r\n    /**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Texture#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */\r\n    frame: null,\r\n\r\n    /**\r\n     * Internal flag. Not to be set by this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Texture#isCropped\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    isCropped: false,\r\n\r\n    /**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Texture#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Textures.Texture)} key - The key of the texture to be used, as stored in the Texture Manager, or a Texture instance.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.texture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.\r\n     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Texture#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} frame - The name or index of the frame within the Texture.\r\n     * @param {boolean} [updateSize=true] - Should this call adjust the size of the Game Object?\r\n     * @param {boolean} [updateOrigin=true] - Should this call adjust the origin of the Game Object?\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFrame: function (frame, updateSize, updateOrigin)\r\n    {\r\n        if (updateSize === undefined) { updateSize = true; }\r\n        if (updateOrigin === undefined) { updateOrigin = true; }\r\n\r\n        this.frame = this.texture.get(frame);\r\n\r\n        if (!this.frame.cutWidth || !this.frame.cutHeight)\r\n        {\r\n            this.renderFlags &= ~_FLAG;\r\n        }\r\n        else\r\n        {\r\n            this.renderFlags |= _FLAG;\r\n        }\r\n\r\n        if (this._sizeComponent && updateSize)\r\n        {\r\n            this.setSizeToFrame();\r\n        }\r\n\r\n        if (this._originComponent && updateOrigin)\r\n        {\r\n            if (this.frame.customPivot)\r\n            {\r\n                this.setOrigin(this.frame.pivotX, this.frame.pivotY);\r\n            }\r\n            else\r\n            {\r\n                this.updateDisplayOrigin();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Texture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 8; // 1000\r\n\r\n/**\r\n * Provides methods used for getting and setting the texture of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.TextureCrop\r\n * @since 3.0.0\r\n */\r\n\r\nvar TextureCrop = {\r\n\r\n    /**\r\n     * The Texture this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TextureCrop#texture\r\n     * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n     * @since 3.0.0\r\n     */\r\n    texture: null,\r\n\r\n    /**\r\n     * The Texture Frame this Game Object is using to render with.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TextureCrop#frame\r\n     * @type {Phaser.Textures.Frame}\r\n     * @since 3.0.0\r\n     */\r\n    frame: null,\r\n\r\n    /**\r\n     * A boolean flag indicating if this Game Object is being cropped or not.\r\n     * You can toggle this at any time after `setCrop` has been called, to turn cropping on or off.\r\n     * Equally, calling `setCrop` with no arguments will reset the crop and disable it.\r\n     *\r\n     * @name Phaser.GameObjects.Components.TextureCrop#isCropped\r\n     * @type {boolean}\r\n     * @since 3.11.0\r\n     */\r\n    isCropped: false,\r\n\r\n    /**\r\n     * Applies a crop to a texture based Game Object, such as a Sprite or Image.\r\n     *\r\n     * The crop is a rectangle that limits the area of the texture frame that is visible during rendering.\r\n     *\r\n     * Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just\r\n     * changes what is shown when rendered.\r\n     *\r\n     * The crop coordinates are relative to the texture frame, not the Game Object, meaning 0 x 0 is the top-left.\r\n     *\r\n     * Therefore, if you had a Game Object that had an 800x600 sized texture, and you wanted to show only the left\r\n     * half of it, you could call `setCrop(0, 0, 400, 600)`.\r\n     *\r\n     * It is also scaled to match the Game Object scale automatically. Therefore a crop rect of 100x50 would crop\r\n     * an area of 200x100 when applied to a Game Object that had a scale factor of 2.\r\n     *\r\n     * You can either pass in numeric values directly, or you can provide a single Rectangle object as the first argument.\r\n     *\r\n     * Call this method with no arguments at all to reset the crop, or toggle the property `isCropped` to `false`.\r\n     *\r\n     * You should do this if the crop rectangle becomes the same size as the frame itself, as it will allow\r\n     * the renderer to skip several internal calculations.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextureCrop#setCrop\r\n     * @since 3.11.0\r\n     *\r\n     * @param {(number|Phaser.Geom.Rectangle)} [x] - The x coordinate to start the crop from. Or a Phaser.Geom.Rectangle object, in which case the rest of the arguments are ignored.\r\n     * @param {number} [y] - The y coordinate to start the crop from.\r\n     * @param {number} [width] - The width of the crop rectangle in pixels.\r\n     * @param {number} [height] - The height of the crop rectangle in pixels.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setCrop: function (x, y, width, height)\r\n    {\r\n        if (x === undefined)\r\n        {\r\n            this.isCropped = false;\r\n        }\r\n        else if (this.frame)\r\n        {\r\n            if (typeof x === 'number')\r\n            {\r\n                this.frame.setCropUVs(this._crop, x, y, width, height, this.flipX, this.flipY);\r\n            }\r\n            else\r\n            {\r\n                var rect = x;\r\n\r\n                this.frame.setCropUVs(this._crop, rect.x, rect.y, rect.width, rect.height, this.flipX, this.flipY);\r\n            }\r\n\r\n            this.isCropped = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextureCrop#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.texture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.\r\n     * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextureCrop#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} frame - The name or index of the frame within the Texture.\r\n     * @param {boolean} [updateSize=true] - Should this call adjust the size of the Game Object?\r\n     * @param {boolean} [updateOrigin=true] - Should this call adjust the origin of the Game Object?\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFrame: function (frame, updateSize, updateOrigin)\r\n    {\r\n        if (updateSize === undefined) { updateSize = true; }\r\n        if (updateOrigin === undefined) { updateOrigin = true; }\r\n\r\n        this.frame = this.texture.get(frame);\r\n\r\n        if (!this.frame.cutWidth || !this.frame.cutHeight)\r\n        {\r\n            this.renderFlags &= ~_FLAG;\r\n        }\r\n        else\r\n        {\r\n            this.renderFlags |= _FLAG;\r\n        }\r\n\r\n        if (this._sizeComponent && updateSize)\r\n        {\r\n            this.setSizeToFrame();\r\n        }\r\n\r\n        if (this._originComponent && updateOrigin)\r\n        {\r\n            if (this.frame.customPivot)\r\n            {\r\n                this.setOrigin(this.frame.pivotX, this.frame.pivotY);\r\n            }\r\n            else\r\n            {\r\n                this.updateDisplayOrigin();\r\n            }\r\n        }\r\n\r\n        if (this.isCropped)\r\n        {\r\n            this.frame.updateCropUVs(this._crop, this.flipX, this.flipY);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that returns a blank, well-formed crop object for use by a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.TextureCrop#resetCropObject\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @return {object} The crop object.\r\n     */\r\n    resetCropObject: function ()\r\n    {\r\n        return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: false, flipY: false, cx: 0, cy: 0, cw: 0, ch: 0 };\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = TextureCrop;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods used for setting the tint of a Game Object.\n * Should be applied as a mixin and not used directly.\n *\n * @namespace Phaser.GameObjects.Components.Tint\n * @webglOnly\n * @since 3.0.0\n */\n\nvar Tint = {\n\n    /**\n     * The tint value being applied to the top-left vertice of the Game Object.\n     * This value is interpolated from the corner to the center of the Game Object.\n     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tintTopLeft\n     * @type {number}\n     * @default 0xffffff\n     * @since 3.0.0\n     */\n    tintTopLeft: 0xffffff,\n\n    /**\n     * The tint value being applied to the top-right vertice of the Game Object.\n     * This value is interpolated from the corner to the center of the Game Object.\n     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tintTopRight\n     * @type {number}\n     * @default 0xffffff\n     * @since 3.0.0\n     */\n    tintTopRight: 0xffffff,\n\n    /**\n     * The tint value being applied to the bottom-left vertice of the Game Object.\n     * This value is interpolated from the corner to the center of the Game Object.\n     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tintBottomLeft\n     * @type {number}\n     * @default 0xffffff\n     * @since 3.0.0\n     */\n    tintBottomLeft: 0xffffff,\n\n    /**\n     * The tint value being applied to the bottom-right vertice of the Game Object.\n     * This value is interpolated from the corner to the center of the Game Object.\n     * The value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tintBottomRight\n     * @type {number}\n     * @default 0xffffff\n     * @since 3.0.0\n     */\n    tintBottomRight: 0xffffff,\n\n    /**\n     * The tint fill mode.\n     *\n     * `false` = An additive tint (the default), where vertices colors are blended with the texture.\n     * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tintFill\n     * @type {boolean}\n     * @default false\n     * @since 3.11.0\n     */\n    tintFill: false,\n\n    /**\n     * Clears all tint values associated with this Game Object.\n     *\n     * Immediately sets the color values back to 0xffffff and the tint type to 'additive',\n     * which results in no visible change to the texture.\n     *\n     * @method Phaser.GameObjects.Components.Tint#clearTint\n     * @webglOnly\n     * @since 3.0.0\n     *\n     * @return {this} This Game Object instance.\n     */\n    clearTint: function ()\n    {\n        this.setTint(0xffffff);\n\n        return this;\n    },\n\n    /**\n     * Sets an additive tint on this Game Object.\n     *\n     * The tint works by taking the pixel color values from the Game Objects texture, and then\n     * multiplying it by the color value of the tint. You can provide either one color value,\n     * in which case the whole Game Object will be tinted in that color. Or you can provide a color\n     * per corner. The colors are blended together across the extent of the Game Object.\n     *\n     * To modify the tint color once set, either call this method again with new values or use the\n     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,\n     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.\n     *\n     * To remove a tint call `clearTint`.\n     *\n     * To swap this from being an additive tint to a fill based tint set the property `tintFill` to `true`.\n     *\n     * @method Phaser.GameObjects.Components.Tint#setTint\n     * @webglOnly\n     * @since 3.0.0\n     *\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object.\n     * @param {number} [topRight] - The tint being applied to the top-right of the Game Object.\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the Game Object.\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setTint: function (topLeft, topRight, bottomLeft, bottomRight)\n    {\n        if (topLeft === undefined) { topLeft = 0xffffff; }\n\n        if (topRight === undefined)\n        {\n            topRight = topLeft;\n            bottomLeft = topLeft;\n            bottomRight = topLeft;\n        }\n\n        this.tintTopLeft = topLeft;\n        this.tintTopRight = topRight;\n        this.tintBottomLeft = bottomLeft;\n        this.tintBottomRight = bottomRight;\n\n        this.tintFill = false;\n\n        return this;\n    },\n\n    /**\n     * Sets a fill-based tint on this Game Object.\n     *\n     * Unlike an additive tint, a fill-tint literally replaces the pixel colors from the texture\n     * with those in the tint. You can use this for effects such as making a player flash 'white'\n     * if hit by something. You can provide either one color value, in which case the whole\n     * Game Object will be rendered in that color. Or you can provide a color per corner. The colors\n     * are blended together across the extent of the Game Object.\n     *\n     * To modify the tint color once set, either call this method again with new values or use the\n     * `tint` property to set all colors at once. Or, use the properties `tintTopLeft`, `tintTopRight,\n     * `tintBottomLeft` and `tintBottomRight` to set the corner color values independently.\n     *\n     * To remove a tint call `clearTint`.\n     *\n     * To swap this from being a fill-tint to an additive tint set the property `tintFill` to `false`.\n     *\n     * @method Phaser.GameObjects.Components.Tint#setTintFill\n     * @webglOnly\n     * @since 3.11.0\n     *\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object.\n     * @param {number} [topRight] - The tint being applied to the top-right of the Game Object.\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the Game Object.\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setTintFill: function (topLeft, topRight, bottomLeft, bottomRight)\n    {\n        this.setTint(topLeft, topRight, bottomLeft, bottomRight);\n\n        this.tintFill = true;\n\n        return this;\n    },\n\n    /**\n     * The tint value being applied to the whole of the Game Object.\n     * This property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.\n     *\n     * @name Phaser.GameObjects.Components.Tint#tint\n     * @type {number}\n     * @webglOnly\n     * @since 3.0.0\n     */\n    tint: {\n\n        set: function (value)\n        {\n            this.setTint(value, value, value, value);\n        }\n    },\n\n    /**\n     * Does this Game Object have a tint applied?\n     *\n     * It checks to see if the 4 tint properties are set to the value 0xffffff\n     * and that the `tintFill` property is `false`. This indicates that a Game Object isn't tinted.\n     *\n     * @name Phaser.GameObjects.Components.Tint#isTinted\n     * @type {boolean}\n     * @webglOnly\n     * @readonly\n     * @since 3.11.0\n     */\n    isTinted: {\n\n        get: function ()\n        {\n            var white = 0xffffff;\n\n            return (\n                this.tintFill ||\n                this.tintTopLeft !== white ||\n                this.tintTopRight !== white ||\n                this.tintBottomLeft !== white ||\n                this.tintBottomRight !== white\n            );\n        }\n\n    }\n\n};\n\nmodule.exports = Tint;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Build a JSON representation of the given Game Object.\r\n *\r\n * This is typically extended further by Game Object specific implementations.\r\n *\r\n * @method Phaser.GameObjects.Components.ToJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to export as JSON.\r\n *\r\n * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n */\r\nvar ToJSON = function (gameObject)\r\n{\r\n    var out = {\r\n        name: gameObject.name,\r\n        type: gameObject.type,\r\n        x: gameObject.x,\r\n        y: gameObject.y,\r\n        depth: gameObject.depth,\r\n        scale: {\r\n            x: gameObject.scaleX,\r\n            y: gameObject.scaleY\r\n        },\r\n        origin: {\r\n            x: gameObject.originX,\r\n            y: gameObject.originY\r\n        },\r\n        flipX: gameObject.flipX,\r\n        flipY: gameObject.flipY,\r\n        rotation: gameObject.rotation,\r\n        alpha: gameObject.alpha,\r\n        visible: gameObject.visible,\r\n        blendMode: gameObject.blendMode,\r\n        textureKey: '',\r\n        frameKey: '',\r\n        data: {}\r\n    };\r\n\r\n    if (gameObject.texture)\r\n    {\r\n        out.textureKey = gameObject.texture.key;\r\n        out.frameKey = gameObject.frame.name;\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = ToJSON;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../../math/const');\r\nvar TransformMatrix = require('./TransformMatrix');\r\nvar TransformXY = require('../../math/TransformXY');\r\nvar WrapAngle = require('../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.GameObjects.Components.Transform\r\n * @since 3.0.0\r\n */\r\n\r\nvar Transform = {\r\n\r\n    /**\r\n     * Private internal value. Holds the horizontal scale value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_scaleX\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleX: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the vertical scale value.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_scaleY\r\n     * @type {number}\r\n     * @private\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    _scaleY: 1,\r\n\r\n    /**\r\n     * Private internal value. Holds the rotation value in radians.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#_rotation\r\n     * @type {number}\r\n     * @private\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    _rotation: 0,\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#x\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    x: 0,\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#y\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    y: 0,\r\n\r\n    /**\r\n     * The z position of this Game Object.\r\n     *\r\n     * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n     * {@link Phaser.GameObjects.Components.Depth#depth} instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#z\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    z: 0,\r\n\r\n    /**\r\n     * The w position of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#w\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    w: 0,\r\n\r\n    /**\r\n     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\r\n     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\r\n     *\r\n     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\r\n     * isn't the case, use the `scaleX` or `scaleY` properties instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scale\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.18.0\r\n     */\r\n    scale: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this._scaleX + this._scaleY) / 2;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleX = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._scaleY = value;\r\n\r\n            if (value === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object as expressed in degrees.\r\n     *\r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\r\n     * and -90 is up.\r\n     *\r\n     * If you prefer to work in radians, see the `rotation` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#angle\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The angle of this Game Object in radians.\r\n     *\r\n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, PI/2 is down, +-PI is left\r\n     * and -PI/2 is up.\r\n     *\r\n     * If you prefer to work in degrees, see the `angle` property instead.\r\n     *\r\n     * @name Phaser.GameObjects.Components.Transform#rotation\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of this Game Object.\r\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\r\n     * @param {number} [z=0] - The z position of this Game Object.\r\n     * @param {number} [w=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPosition: function (x, y, z, w)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n        if (z === undefined) { z = 0; }\r\n        if (w === undefined) { w = 0; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copies an object's coordinates to this Game Object's position.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#copyPosition\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.Types.Math.Vector2Like|Phaser.Types.Math.Vector3Like|Phaser.Types.Math.Vector4Like)} source - An object with numeric 'x', 'y', 'z', or 'w' properties. Undefined values are not copied.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    copyPosition: function (source)\r\n    {\r\n        if (source.x !== undefined) { this.x = source.x; }\r\n        if (source.y !== undefined) { this.y = source.y; }\r\n        if (source.z !== undefined) { this.z = source.z; }\r\n        if (source.w !== undefined) { this.w = source.w; }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Game Object to be a random position within the confines of\r\n     * the given area.\r\n     *\r\n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\r\n     *\r\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\r\n     * guaranteed to be within the area.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\r\n     * @since 3.8.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the top-left of the random area.\r\n     * @param {number} [y=0] - The y position of the top-left of the random area.\r\n     * @param {number} [width] - The width of the random area.\r\n     * @param {number} [height] - The height of the random area.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRandomPosition: function (x, y, width, height)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n\r\n        this.x = x + (Math.random() * width);\r\n        this.y = y + (Math.random() * height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this.rotation = radians;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The x position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The y position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the z position of this Game Object.\r\n     *\r\n     * Note: The z position does not control the rendering order of 2D Game Objects. Use\r\n     * {@link Phaser.GameObjects.Components.Depth#setDepth} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The z position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.z = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the w position of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#setW\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=0] - The w position of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setW: function (value)\r\n    {\r\n        if (value === undefined) { value = 0; }\r\n\r\n        this.w = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the local transform matrix for this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getLocalTransformMatrix: function (tempMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n\r\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n    },\r\n\r\n    /**\r\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\r\n     */\r\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\r\n    {\r\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\r\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        if (!parent)\r\n        {\r\n            return this.getLocalTransformMatrix(tempMatrix);\r\n        }\r\n\r\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\r\n\r\n        while (parent)\r\n        {\r\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\r\n\r\n            parentMatrix.multiply(tempMatrix, tempMatrix);\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return tempMatrix;\r\n    },\r\n\r\n    /**\r\n     * Takes the given `x` and `y` coordinates and converts them into local space for this\r\n     * Game Object, taking into account parent and local transforms, and the Display Origin.\r\n     *\r\n     * The returned Vector2 contains the translated point in its properties.\r\n     *\r\n     * A Camera needs to be provided in order to handle modified scroll factors. If no\r\n     * camera is specified, it will use the `main` camera from the Scene to which this\r\n     * Game Object belongs.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getLocalPoint\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position to translate.\r\n     * @param {number} y - The y position to translate.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2, or point-like object, to store the results in.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera which is being tested against. If not given will use the Scene default camera.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The translated point.\r\n     */\r\n    getLocalPoint: function (x, y, point, camera)\r\n    {\r\n        if (!point) { point = new Vector2(); }\r\n        if (!camera) { camera = this.scene.sys.cameras.main; }\r\n\r\n        var csx = camera.scrollX;\r\n        var csy = camera.scrollY;\r\n\r\n        var px = x + (csx * this.scrollFactorX) - csx;\r\n        var py = y + (csy * this.scrollFactorY) - csy;\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            this.getWorldTransformMatrix().applyInverse(px, py, point);\r\n        }\r\n        else\r\n        {\r\n            TransformXY(px, py, this.x, this.y, this.rotation, this.scaleX, this.scaleY, point);\r\n        }\r\n\r\n        //  Normalize origin\r\n        if (this._originComponent)\r\n        {\r\n            point.x += this._displayOriginX;\r\n            point.y += this._displayOriginY;\r\n        }\r\n\r\n        return point;\r\n    },\r\n\r\n    /**\r\n     * Gets the sum total rotation of all of this Game Objects parent Containers.\r\n     *\r\n     * The returned value is in radians and will be zero if this Game Object has no parent container.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Transform#getParentRotation\r\n     * @since 3.18.0\r\n     *\r\n     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\r\n     */\r\n    getParentRotation: function ()\r\n    {\r\n        var rotation = 0;\r\n\r\n        var parent = this.parentContainer;\r\n\r\n        while (parent)\r\n        {\r\n            rotation += parent.rotation;\r\n\r\n            parent = parent.parentContainer;\r\n        }\r\n\r\n        return rotation;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 1; // 0001\r\n\r\n/**\r\n * Provides methods used for setting the visibility of a Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n * \r\n * @namespace Phaser.GameObjects.Components.Visible\r\n * @since 3.0.0\r\n */\r\n\r\nvar Visible = {\r\n\r\n    /**\r\n     * Private internal value. Holds the visible value.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#_visible\r\n     * @type {boolean}\r\n     * @private\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    _visible: true,\r\n\r\n    /**\r\n     * The visible state of the Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     * \r\n     * @name Phaser.GameObjects.Components.Visible#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value)\r\n            {\r\n                this._visible = true;\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n            else\r\n            {\r\n                this._visible = false;\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Game Object.\r\n     * \r\n     * An invisible Game Object will skip rendering, but will still process update logic.\r\n     *\r\n     * @method Phaser.GameObjects.Components.Visible#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = Visible;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.GameObjects.Components\n */\n\nmodule.exports = {\n\n    Alpha: require('./Alpha'),\n    AlphaSingle: require('./AlphaSingle'),\n    BlendMode: require('./BlendMode'),\n    ComputedSize: require('./ComputedSize'),\n    Crop: require('./Crop'),\n    Depth: require('./Depth'),\n    Flip: require('./Flip'),\n    GetBounds: require('./GetBounds'),\n    Mask: require('./Mask'),\n    Origin: require('./Origin'),\n    PathFollower: require('./PathFollower'),\n    Pipeline: require('./Pipeline'),\n    ScrollFactor: require('./ScrollFactor'),\n    Size: require('./Size'),\n    Texture: require('./Texture'),\n    TextureCrop: require('./TextureCrop'),\n    Tint: require('./Tint'),\n    ToJSON: require('./ToJSON'),\n    Transform: require('./Transform'),\n    TransformMatrix: require('./TransformMatrix'),\n    Visible: require('./Visible')\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` to the given `angle`, at the same distance.\r\n *\r\n * In polar notation, this maps a point from (r, t) to (r, angle), vs. the origin (x, y).\r\n *\r\n * @function Phaser.Math.RotateAround\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Types.Math.Vector2Like} T - [point,$return]\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n *\r\n * @return {Phaser.Types.Math.Vector2Like} The given point.\r\n */\r\nvar RotateAround = function (point, x, y, angle)\r\n{\r\n    var c = Math.cos(angle);\r\n    var s = Math.sin(angle);\r\n\r\n    var tx = point.x - x;\r\n    var ty = point.y - y;\r\n\r\n    point.x = tx * c - ty * s + x;\r\n    point.y = tx * s + ty * c + y;\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAround;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Takes the `x` and `y` coordinates and transforms them into the same space as\r\n * defined by the position, rotation and scale values.\r\n *\r\n * @function Phaser.Math.TransformXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x coordinate to be transformed.\r\n * @param {number} y - The y coordinate to be transformed.\r\n * @param {number} positionX - Horizontal position of the transform point.\r\n * @param {number} positionY - Vertical position of the transform point.\r\n * @param {number} rotation - Rotation of the transform point, in radians.\r\n * @param {number} scaleX - Horizontal scale of the transform point.\r\n * @param {number} scaleY - Vertical scale of the transform point.\r\n * @param {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} [output] - The output vector, point or object for the translated coordinates.\r\n *\r\n * @return {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} The translated point.\r\n */\r\nvar TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output)\r\n{\r\n    if (output === undefined) { output = new Vector2(); }\r\n\r\n    var radianSin = Math.sin(rotation);\r\n    var radianCos = Math.cos(rotation);\r\n\r\n    // Rotate and Scale\r\n    var a = radianCos * scaleX;\r\n    var b = radianSin * scaleX;\r\n    var c = -radianSin * scaleY;\r\n    var d = radianCos * scaleY;\r\n\r\n    //  Invert\r\n    var id = 1 / ((a * d) + (c * -b));\r\n\r\n    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);\r\n    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = TransformXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathWrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle.\r\n *\r\n * Wraps the angle to a value in the range of -PI to PI.\r\n *\r\n * @function Phaser.Math.Angle.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in radians.\r\n *\r\n * @return {number} The wrapped angle, in radians.\r\n */\r\nvar Wrap = function (angle)\r\n{\r\n    return MathWrap(angle, -Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Wrap = require('../Wrap');\r\n\r\n/**\r\n * Wrap an angle in degrees.\r\n *\r\n * Wraps the angle to a value in the range of -180 to 180.\r\n *\r\n * @function Phaser.Math.Angle.WrapDegrees\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to wrap, in degrees.\r\n *\r\n * @return {number} The wrapped angle, in degrees.\r\n */\r\nvar WrapDegrees = function (angle)\r\n{\r\n    return Wrap(angle, -180, 180);\r\n};\r\n\r\nmodule.exports = WrapDegrees;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PIPELINE_CONST = {\r\n\r\n    /**\r\n     * The Bitmap Mask Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BITMAPMASK_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    BITMAPMASK_PIPELINE: 'BitmapMaskPipeline',\r\n\r\n    /**\r\n     * The Light 2D Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.LIGHT_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    LIGHT_PIPELINE: 'Light2D',\r\n\r\n    /**\r\n     * The Point Light Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.POINTLIGHT_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    POINTLIGHT_PIPELINE: 'PointLightPipeline',\r\n\r\n    /**\r\n     * The Single Texture Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.SINGLE_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    SINGLE_PIPELINE: 'SinglePipeline',\r\n\r\n    /**\r\n     * The Multi Texture Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.MULTI_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    MULTI_PIPELINE: 'MultiPipeline',\r\n\r\n    /**\r\n     * The Rope Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.ROPE_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ROPE_PIPELINE: 'RopePipeline',\r\n\r\n    /**\r\n     * The Graphics and Shapes Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.GRAPHICS_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    GRAPHICS_PIPELINE: 'GraphicsPipeline',\r\n\r\n    /**\r\n     * The Post FX Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.POSTFX_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    POSTFX_PIPELINE: 'PostFXPipeline',\r\n\r\n    /**\r\n     * The Utility Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.UTILITY_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    UTILITY_PIPELINE: 'UtilityPipeline'\r\n};\r\n\r\nmodule.exports = PIPELINE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Retrieves the value of the given key from an object.\r\n *\r\n * @function Phaser.Tweens.Builders.GetBoolean\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The key to look for in the `source` object.\r\n * @param {*} defaultValue - The default value to return if the `key` doesn't exist or if no `source` object is provided.\r\n *\r\n * @return {*} The retrieved value.\r\n */\r\nvar GetBoolean = function (source, key, defaultValue)\r\n{\r\n    if (!source)\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetBoolean;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TWEEN_CONST = {\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.CREATED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CREATED: 0,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.INIT\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    INIT: 1,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    DELAY: 2,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.OFFSET_DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    OFFSET_DELAY: 3,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_RENDER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PENDING_RENDER: 4,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PLAYING_FORWARD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PLAYING_FORWARD: 5,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.PLAYING_BACKWARD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PLAYING_BACKWARD: 6,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.HOLD_DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    HOLD_DELAY: 7,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.REPEAT_DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    REPEAT_DELAY: 8,\r\n\r\n    /**\r\n     * TweenData state.\r\n     * \r\n     * @name Phaser.Tweens.COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    COMPLETE: 9,\r\n\r\n    //  Tween specific (starts from 20 to cleanly allow extra TweenData consts in the future)\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_ADD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PENDING_ADD: 20,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PAUSED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PAUSED: 21,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.LOOP_DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOOP_DELAY: 22,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.ACTIVE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ACTIVE: 23,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.COMPLETE_DELAY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    COMPLETE_DELAY: 24,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.PENDING_REMOVE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PENDING_REMOVE: 25,\r\n\r\n    /**\r\n     * Tween state.\r\n     * \r\n     * @name Phaser.Tweens.REMOVED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    REMOVED: 26\r\n\r\n};\r\n\r\nmodule.exports = TWEEN_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Deep Copy the given object or array.\r\n *\r\n * @function Phaser.Utils.Objects.DeepCopy\r\n * @since 3.50.0\r\n *\r\n * @param {object} obj - The object to deep copy.\r\n *\r\n * @return {object} A deep copy of the original object.\r\n */\r\nvar DeepCopy = function (inObject)\r\n{\r\n    var outObject;\r\n    var value;\r\n    var key;\r\n\r\n    if (typeof inObject !== 'object' || inObject === null)\r\n    {\r\n        //  inObject is not an object\r\n        return inObject;\r\n    }\r\n\r\n    //  Create an array or object to hold the values\r\n    outObject = Array.isArray(inObject) ? [] : {};\r\n\r\n    for (key in inObject)\r\n    {\r\n        value = inObject[key];\r\n\r\n        //  Recursively (deep) copy for nested objects, including arrays\r\n        outObject[key] = DeepCopy(value);\r\n    }\r\n\r\n    return outObject;\r\n};\r\n\r\nmodule.exports = DeepCopy;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n"],"names":["Clamp","Alpha","_alpha","_alphaTL","_alphaTR","_alphaBL","_alphaBR","clearAlpha","this","setAlpha","topLeft","topRight","bottomLeft","bottomRight","undefined","alpha","get","set","value","v","renderFlags","alphaTopLeft","alphaTopRight","alphaBottomLeft","alphaBottomRight","module","exports","AlphaSingle","BlendModes","BlendMode","_blendMode","NORMAL","blendMode","setBlendMode","width","height","displayWidth","scaleX","displayHeight","scaleY","setSize","setDisplaySize","texture","frame","isCropped","setCrop","x","y","setCropUVs","_crop","flipX","flipY","rect","resetCropObject","u0","v0","u1","v1","cx","cy","cw","ch","_depth","depth","displayList","queueDepthSort","setDepth","toggleFlipX","toggleFlipY","setFlipX","setFlipY","setFlip","resetFlip","Rectangle","RotateAround","Vector2","GetBounds","prepareBoundsOutput","output","includeParent","rotation","parentContainer","getBoundsTransformMatrix","transformPoint","getCenter","originX","originY","getTopLeft","getTopCenter","getTopRight","getLeftCenter","getRightCenter","getBottomLeft","getBottomCenter","getBottomRight","getBounds","TLx","TLy","TRx","TRy","BLx","BLy","BRx","BRy","parentMatrix","Math","min","max","BitmapMask","GeometryMask","Mask","mask","setMask","clearMask","destroyMask","destroy","createBitmapMask","renderable","shader","scene","createGeometryMask","graphics","type","_originComponent","_displayOriginX","_displayOriginY","displayOriginX","displayOriginY","setOrigin","updateDisplayOrigin","setOriginFromFrame","customPivot","pivotX","pivotY","setDisplayOrigin","DegToRad","GetBoolean","GetValue","TWEEN_CONST","PathFollower","path","rotateToPath","pathRotationOffset","pathOffset","pathVector","pathDelta","pathTween","pathConfig","_prevDirection","PLAYING_FORWARD","setPath","config","tween","isPlaying","stop","startFollow","setRotateToPath","offset","isFollowing","startAt","duration","from","to","positionOnPath","seek","onStart","tweenData","data","progress","elapsed","ease","current","start","end","target","key","reset","sys","tweens","addCounter","getStartPoint","nextPoint","getPoint","atan2","pauseFollow","pause","resumeFollow","isPaused","resume","stopFollow","pathUpdate","copy","negate","state","COMPLETE","add","setPosition","PLAYING_BACKWARD","getValue","oldX","oldY","speedX","speedY","DeepCopy","PIPELINE_CONST","SpliceOne","Pipeline","defaultPipeline","pipeline","hasPostPipeline","postPipelines","pipelineData","initPipeline","MULTI_PIPELINE","renderer","pipelines","instance","setPipeline","copyData","setPostPipeline","pipelineManager","Array","isArray","i","length","getPostPipeline","push","setPipelineData","results","name","resetPipeline","resetPostPipelines","resetData","resetPostPipeline","removePostPipeline","getPipelineName","scrollFactorX","scrollFactorY","setScrollFactor","Size","_sizeComponent","abs","realWidth","realHeight","setSizeToFrame","setTexture","textures","setFrame","updateSize","updateOrigin","cutWidth","cutHeight","updateCropUVs","tintTopLeft","tintTopRight","tintBottomLeft","tintBottomRight","tintFill","clearTint","setTint","setTintFill","tint","isTinted","white","gameObject","out","scale","origin","visible","textureKey","frameKey","MATH_CONST","TransformMatrix","TransformXY","WrapAngle","WrapAngleDegrees","Transform","_scaleX","_scaleY","_rotation","z","w","angle","RAD_TO_DEG","DEG_TO_RAD","copyPosition","source","setRandomPosition","random","setRotation","radians","setAngle","degrees","setScale","setX","setY","setZ","setW","getLocalTransformMatrix","tempMatrix","applyITRS","getWorldTransformMatrix","parent","multiply","getLocalPoint","point","camera","cameras","main","csx","scrollX","csy","scrollY","px","py","applyInverse","getParentRotation","_visible","setVisible","ComputedSize","Crop","Depth","Flip","Origin","ScrollFactor","Texture","TextureCrop","Tint","ToJSON","Visible","c","cos","s","sin","tx","ty","positionX","positionY","radianSin","radianCos","a","b","d","id","MathWrap","PI","Wrap","BITMAPMASK_PIPELINE","LIGHT_PIPELINE","POINTLIGHT_PIPELINE","SINGLE_PIPELINE","ROPE_PIPELINE","GRAPHICS_PIPELINE","POSTFX_PIPELINE","UTILITY_PIPELINE","defaultValue","hasOwnProperty","CREATED","INIT","DELAY","OFFSET_DELAY","PENDING_RENDER","HOLD_DELAY","REPEAT_DELAY","PENDING_ADD","PAUSED","LOOP_DELAY","ACTIVE","COMPLETE_DELAY","PENDING_REMOVE","REMOVED","inObject","outObject","indexOf","keys","split"],"sourceRoot":""}