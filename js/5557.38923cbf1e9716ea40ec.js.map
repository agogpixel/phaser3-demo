{"version":3,"file":"js/5557.38923cbf1e9716ea40ec.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/ProcessQueue.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Set.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/events/PROCESS_QUEUE_ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/events/PROCESS_QUEUE_REMOVE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/events/index.js"],"sourcesContent":["/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../utils/Class');\nvar EventEmitter = require('eventemitter3');\nvar Events = require('./events');\n\n/**\n * @classdesc\n * A Process Queue maintains three internal lists.\n *\n * The `pending` list is a selection of items which are due to be made 'active' in the next update.\n * The `active` list is a selection of items which are considered active and should be updated.\n * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\n *\n * When new items are added to a Process Queue they are put in the pending list, rather than being added\n * immediately the active list. Equally, items that are removed are put into the destroy list, rather than\n * being destroyed immediately. This allows the Process Queue to carefully process each item at a specific, fixed\n * time, rather than at the time of the request from the API.\n *\n * @class ProcessQueue\n * @extends Phaser.Events.EventEmitter\n * @memberof Phaser.Structs\n * @constructor\n * @since 3.0.0\n *\n * @generic T\n */\nvar ProcessQueue = new Class({\n\n    Extends: EventEmitter,\n\n    initialize:\n\n    function ProcessQueue ()\n    {\n        EventEmitter.call(this);\n\n        /**\n         * The `pending` list is a selection of items which are due to be made 'active' in the next update.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_pending\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._pending = [];\n\n        /**\n         * The `active` list is a selection of items which are considered active and should be updated.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_active\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._active = [];\n\n        /**\n         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_destroy\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._destroy = [];\n\n        /**\n         * The total number of items awaiting processing.\n         *\n         * @name Phaser.Structs.ProcessQueue#_toProcess\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.0.0\n         */\n        this._toProcess = 0;\n\n        /**\n         * If `true` only unique objects will be allowed in the queue.\n         *\n         * @name Phaser.Structs.ProcessQueue#checkQueue\n         * @type {boolean}\n         * @since 3.50.0\n         */\n        this.checkQueue = false;\n    },\n\n    /**\n     * Adds a new item to the Process Queue.\n     *\n     * The item is added to the pending list and made active in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#add\n     * @since 3.0.0\n     *\n     * @genericUse {T} - [item]\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\n     *\n     * @param {*} item - The item to add to the queue.\n     *\n     * @return {*} The item that was added.\n     */\n    add: function (item)\n    {\n        this._pending.push(item);\n\n        this._toProcess++;\n\n        return item;\n    },\n\n    /**\n     * Removes an item from the Process Queue.\n     *\n     * The item is added to the pending destroy and fully removed in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#remove\n     * @since 3.0.0\n     *\n     * @genericUse {T} - [item]\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\n     *\n     * @param {*} item - The item to be removed from the queue.\n     *\n     * @return {*} The item that was removed.\n     */\n    remove: function (item)\n    {\n        this._destroy.push(item);\n\n        this._toProcess++;\n\n        return item;\n    },\n\n    /**\n     * Removes all active items from this Process Queue.\n     *\n     * All the items are marked as 'pending destroy' and fully removed in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#removeAll\n     * @since 3.20.0\n     *\n     * @return {this} This Process Queue object.\n     */\n    removeAll: function ()\n    {\n        var list = this._active;\n        var destroy = this._destroy;\n        var i = list.length;\n\n        while (i--)\n        {\n            destroy.push(list[i]);\n\n            this._toProcess++;\n        }\n\n        return this;\n    },\n\n    /**\n     * Update this queue. First it will process any items awaiting destruction, and remove them.\n     *\n     * Then it will check to see if there are any items pending insertion, and move them to an\n     * active state. Finally, it will return a list of active items for further processing.\n     *\n     * @method Phaser.Structs.ProcessQueue#update\n     * @since 3.0.0\n     *\n     * @genericUse {T[]} - [$return]\n     *\n     * @return {Array.<*>} A list of active items.\n     */\n    update: function ()\n    {\n        if (this._toProcess === 0)\n        {\n            //  Quick bail\n            return this._active;\n        }\n\n        var list = this._destroy;\n        var active = this._active;\n        var i;\n        var item;\n\n        //  Clear the 'destroy' list\n        for (i = 0; i < list.length; i++)\n        {\n            item = list[i];\n\n            //  Remove from the 'active' array\n            var idx = active.indexOf(item);\n\n            if (idx !== -1)\n            {\n                active.splice(idx, 1);\n\n                this.emit(Events.PROCESS_QUEUE_REMOVE, item);\n            }\n        }\n\n        list.length = 0;\n\n        //  Process the pending addition list\n        //  This stops callbacks and out of sync events from populating the active array mid-way during an update\n\n        list = this._pending;\n\n        for (i = 0; i < list.length; i++)\n        {\n            item = list[i];\n\n            if (!this.checkQueue || (this.checkQueue && active.indexOf(item) === -1))\n            {\n                active.push(item);\n\n                this.emit(Events.PROCESS_QUEUE_ADD, item);\n            }\n        }\n\n        list.length = 0;\n\n        this._toProcess = 0;\n\n        //  The owner of this queue can now safely do whatever it needs to with the active list\n        return active;\n    },\n\n    /**\n     * Returns the current list of active items.\n     *\n     * This method returns a reference to the active list array, not a copy of it.\n     * Therefore, be careful to not modify this array outside of the ProcessQueue.\n     *\n     * @method Phaser.Structs.ProcessQueue#getActive\n     * @since 3.0.0\n     *\n     * @genericUse {T[]} - [$return]\n     *\n     * @return {Array.<*>} A list of active items.\n     */\n    getActive: function ()\n    {\n        return this._active;\n    },\n\n    /**\n     * The number of entries in the active list.\n     *\n     * @name Phaser.Structs.ProcessQueue#length\n     * @type {number}\n     * @readonly\n     * @since 3.20.0\n     */\n    length: {\n\n        get: function ()\n        {\n            return this._active.length;\n        }\n\n    },\n\n    /**\n     * Immediately destroys this process queue, clearing all of its internal arrays and resetting the process totals.\n     *\n     * @method Phaser.Structs.ProcessQueue#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this._toProcess = 0;\n\n        this._pending = [];\n        this._active = [];\n        this._destroy = [];\n    }\n\n});\n\nmodule.exports = ProcessQueue;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachSetCallback<E>\r\n *\r\n * @param {E} entry - The Set entry.\r\n * @param {number} index - The index of the entry within the Set.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Set is a collection of unique elements.\r\n *\r\n * @class Set\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [elements]\r\n *\r\n * @param {Array.<*>} [elements] - An optional array of elements to insert into this Set.\r\n */\r\nvar Set = new Class({\r\n\r\n    initialize:\r\n\r\n    function Set (elements)\r\n    {\r\n        /**\r\n         * The entries of this Set. Stored internally as an array.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Set#entries\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = [];\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.\r\n     *\r\n     * @method Phaser.Structs.Set#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to insert into this Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    set: function (value)\r\n    {\r\n        if (this.entries.indexOf(value) === -1)\r\n        {\r\n            this.entries.push(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.\r\n     * If no elements of this Set satisfy the condition then this method will return `null`.\r\n     *\r\n     * @method Phaser.Structs.Set#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value,$return]\r\n     *\r\n     * @param {string} property - The property name to check on the elements of this Set.\r\n     * @param {*} value - The value to check for.\r\n     *\r\n     * @return {*} The first element of this Set that meets the required condition, or `null` if this Set contains no elements that meet the condition.\r\n     */\r\n    get: function (property, value)\r\n    {\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            if (entry[property] === value)\r\n            {\r\n                return entry;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all the values in this Set.\r\n     *\r\n     * @method Phaser.Structs.Set#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array containing all the values in this Set.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        return this.entries.slice(0);\r\n    },\r\n\r\n    /**\r\n     * Removes the given value from this Set if this Set contains that value.\r\n     *\r\n     * @method Phaser.Structs.Set#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to remove from the Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    delete: function (value)\r\n    {\r\n        var index = this.entries.indexOf(value);\r\n\r\n        if (index > -1)\r\n        {\r\n            this.entries.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Set to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Set#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.group('Set');\r\n\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n            console.log(entry);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.\r\n     *\r\n     * @method Phaser.Structs.Set#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    each: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var temp = this.entries.slice();\r\n        var len = temp.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * For when you absolutely know this Set won't be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#iterate\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterate: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var len = this.entries.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.\r\n     *\r\n     * @method Phaser.Structs.Set#iterateLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {string} callbackKey - The key of the function to be invoked on each Set entry.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterateLocal: function (callbackKey)\r\n    {\r\n        var i;\r\n        var args = [];\r\n\r\n        for (i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        var len = this.entries.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            entry[callbackKey].apply(entry, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears this Set so that it no longer contains any values.\r\n     *\r\n     * @method Phaser.Structs.Set#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.entries.length = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if this Set contains the given value, otherwise returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Set#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {*} value - The value to check for in this Set.\r\n     *\r\n     * @return {boolean} `true` if the given value was found in this Set, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        return (this.entries.indexOf(value) > -1);\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.\r\n     *\r\n     * @method Phaser.Structs.Set#union\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the union with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set and the Set provided as an argument.\r\n     */\r\n    union: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        set.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#intersect\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to intersect this set with.\r\n     *\r\n     * @return {Phaser.Structs.Set} The result of the intersection, as a new Set.\r\n     */\r\n    intersect: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all the values in this Set which are *not* also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#difference\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the difference with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set that are not also in the Set provided as an argument to this method.\r\n     */\r\n    difference: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (!set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * The size of this Set. This is the number of entries within it.\r\n     * Changing the size will truncate the Set if the given value is smaller than the current size.\r\n     * Increasing the size larger than the current size has no effect.\r\n     *\r\n     * @name Phaser.Structs.Set#size\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    size: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.entries.length;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value < this.entries.length)\r\n            {\r\n                return this.entries.length = value;\r\n            }\r\n            else\r\n            {\r\n                return this.entries.length;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Set;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Process Queue Add Event.\r\n * \r\n * This event is dispatched by a Process Queue when a new item is successfully moved to its active list.\r\n * \r\n * You will most commonly see this used by a Scene's Update List when a new Game Object has been added.\r\n * \r\n * In that instance, listen to this event from within a Scene using: `this.sys.updateList.on('add', listener)`.\r\n *\r\n * @event Phaser.Structs.Events#PROCESS_QUEUE_ADD\r\n * @since 3.20.0\r\n * \r\n * @param {*} item - The item that was added to the Process Queue.\r\n */\r\nmodule.exports = 'add';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Process Queue Remove Event.\r\n * \r\n * This event is dispatched by a Process Queue when a new item is successfully removed from its active list.\r\n * \r\n * You will most commonly see this used by a Scene's Update List when a Game Object has been removed.\r\n * \r\n * In that instance, listen to this event from within a Scene using: `this.sys.updateList.on('remove', listener)`.\r\n *\r\n * @event Phaser.Structs.Events#PROCESS_QUEUE_REMOVE\r\n * @since 3.20.0\r\n * \r\n * @param {*} item - The item that was removed from the Process Queue.\r\n */\r\nmodule.exports = 'remove';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Structs.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    PROCESS_QUEUE_ADD: require('./PROCESS_QUEUE_ADD_EVENT'),\r\n    PROCESS_QUEUE_REMOVE: require('./PROCESS_QUEUE_REMOVE_EVENT')\r\n\r\n};\r\n"],"names":["Class","EventEmitter","Events","ProcessQueue","Extends","initialize","call","this","_pending","_active","_destroy","_toProcess","checkQueue","add","item","push","remove","removeAll","list","destroy","i","length","update","active","idx","indexOf","splice","emit","PROCESS_QUEUE_REMOVE","PROCESS_QUEUE_ADD","getActive","get","module","exports","Set","elements","entries","Array","isArray","set","value","property","entry","getArray","slice","delete","index","dump","console","group","log","groupEnd","each","callback","callbackScope","temp","len","iterate","iterateLocal","callbackKey","args","arguments","apply","clear","contains","union","newSet","forEach","intersect","difference","size"],"sourceRoot":""}