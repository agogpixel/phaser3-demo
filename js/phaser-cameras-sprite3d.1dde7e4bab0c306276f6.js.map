{"version":3,"file":"js/phaser-cameras-sprite3d.1dde7e4bab0c306276f6.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/Camera.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/CameraManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/OrthographicCamera.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/PerspectiveCamera.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/plugins/camera3d/src/sprite3d/Sprite3D.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/DegToRad.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Wrap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Set.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar Matrix4 = require('../../../src/math/Matrix4');\r\nvar RandomXYZ = require('../../../src/math/RandomXYZ');\r\nvar RandomXYZW = require('../../../src/math/RandomXYZW');\r\nvar RotateVec3 = require('../../../src/math/RotateVec3');\r\nvar Set = require('../../../src/structs/Set');\r\nvar Sprite3D = require('./sprite3d/Sprite3D');\r\nvar Vector2 = require('../../../src/math/Vector2');\r\nvar Vector3 = require('../../../src/math/Vector3');\r\nvar Vector4 = require('../../../src/math/Vector4');\r\n\r\n//  Local cache vars\r\nvar tmpVec3 = new Vector3();\r\nvar tmpVec4 = new Vector4();\r\nvar dirvec = new Vector3();\r\nvar rightvec = new Vector3();\r\nvar billboardMatrix = new Matrix4();\r\n\r\n//  @author attribute https://github.com/mattdesl/cam3d/wiki\r\n\r\n/**\r\n * @typedef {object} RayDef\r\n *\r\n * @property {Phaser.Math.Vector3} origin - [description]\r\n * @property {Phaser.Math.Vector3} direction - [description]\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */\r\nvar Camera = new Class({\r\n\r\n    initialize:\r\n\r\n    function Camera (scene)\r\n    {\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList = scene.sys.displayList;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @since 3.0.0\r\n         */\r\n        this.updateList = scene.sys.updateList;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#direction\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */\r\n        this.direction = new Vector3(0, 0, -1);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#up\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */\r\n        this.up = new Vector3(0, 1, 0);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#position\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector3();\r\n\r\n\r\n        /**\r\n         *  The mapping from 3D size units to pixels.\r\n         *  In the default case 1 3D unit = 128 pixels. So a sprite that is\r\n         *  256 x 128 px in size will be 2 x 1 units.\r\n         *  Change to whatever best fits your game assets.\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#pixelScale\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelScale = 128;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#projection\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */\r\n        this.projection = new Matrix4();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#view\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */\r\n        this.view = new Matrix4();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#combined\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */\r\n        this.combined = new Matrix4();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#invProjectionView\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.0.0\r\n         */\r\n        this.invProjectionView = new Matrix4();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#near\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.near = 1;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#far\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.far = 100;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#ray\r\n         * @type {RayDef}\r\n         * @since 3.0.0\r\n         */\r\n        this.ray = {\r\n            origin: new Vector3(),\r\n            direction: new Vector3()\r\n        };\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#viewportWidth\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportWidth = 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#viewportHeight\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportHeight = 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#billboardMatrixDirty\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.billboardMatrixDirty = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new Set();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setPosition: function (x, y, z)\r\n    {\r\n        this.position.set(x, y, z);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setScene: function (scene)\r\n    {\r\n        this.scene = scene;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setPixelScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setPixelScale: function (value)\r\n    {\r\n        this.pixelScale = value;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Sprite3D} sprite3D - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} [description]\r\n     */\r\n    add: function (sprite3D)\r\n    {\r\n        this.children.set(sprite3D);\r\n\r\n        this.displayList.add(sprite3D.gameObject);\r\n        this.updateList.add(sprite3D.gameObject);\r\n\r\n        this.updateChildren();\r\n\r\n        return sprite3D;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    remove: function (child)\r\n    {\r\n        this.displayList.remove(child.gameObject);\r\n        this.updateList.remove(child.gameObject);\r\n\r\n        this.children.delete(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        var children = this.getChildren();\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            this.remove(children[i]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {array} [description]\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.children.entries;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} frame - [description]\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} [description]\r\n     */\r\n    create: function (x, y, z, key, frame, visible)\r\n    {\r\n        if (visible === undefined) { visible = true; }\r\n\r\n        var child = new Sprite3D(this.scene, x, y, z, key, frame);\r\n\r\n        this.displayList.add(child.gameObject);\r\n        this.updateList.add(child.gameObject);\r\n\r\n        child.visible = visible;\r\n\r\n        this.children.set(child);\r\n\r\n        this.updateChildren();\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} quantity - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} frame - [description]\r\n     * @param {boolean} [visible=true] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D[]} [description]\r\n     */\r\n    createMultiple: function (quantity, key, frame, visible)\r\n    {\r\n        if (visible === undefined) { visible = true; }\r\n\r\n        var output = [];\r\n\r\n        for (var i = 0; i < quantity; i++)\r\n        {\r\n            var child = new Sprite3D(this.scene, 0, 0, 0, key, frame);\r\n\r\n            this.displayList.add(child.gameObject);\r\n            this.updateList.add(child.gameObject);\r\n\r\n            child.visible = visible;\r\n\r\n            this.children.set(child);\r\n\r\n            output.push(child);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    //  Create a bunch of Sprite3D objects in a rectangle\r\n    //  size and spacing are Vec3s (or if integers are converted to vec3s)\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#createRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|{x:number,y:number})} size - [description]\r\n     * @param {(number|{x:number,y:number,z:number})} spacing - [description]\r\n     * @param {string} key - [description]\r\n     * @param {(string|number)} [frame] - [description]\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D[]} [description]\r\n     */\r\n    createRect: function (size, spacing, key, frame)\r\n    {\r\n        if (typeof size === 'number') { size = { x: size, y: size, z: size }; }\r\n        if (typeof spacing === 'number') { spacing = { x: spacing, y: spacing, z: spacing }; }\r\n\r\n        var quantity = size.x * size.y * size.z;\r\n\r\n        var sprites = this.createMultiple(quantity, key, frame);\r\n\r\n        var i = 0;\r\n\r\n        for (var z = 0.5 - (size.z / 2); z < (size.z / 2); z++)\r\n        {\r\n            for (var y = 0.5 - (size.y / 2); y < (size.y / 2); y++)\r\n            {\r\n                for (var x = 0.5 - (size.x / 2); x < (size.x / 2); x++)\r\n                {\r\n                    var bx = (x * spacing.x);\r\n                    var by = (y * spacing.y);\r\n                    var bz = (z * spacing.z);\r\n\r\n                    sprites[i].position.set(bx, by, bz);\r\n\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.update();\r\n\r\n        return sprites;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#randomSphere\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radius=1] - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    randomSphere: function (radius, sprites)\r\n    {\r\n        if (sprites === undefined) { sprites = this.getChildren(); }\r\n\r\n        for (var i = 0; i < sprites.length; i++)\r\n        {\r\n            RandomXYZ(sprites[i].position, radius);\r\n        }\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#randomCube\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [scale=1] - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} [sprites] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    randomCube: function (scale, sprites)\r\n    {\r\n        if (sprites === undefined) { sprites = this.getChildren(); }\r\n\r\n        for (var i = 0; i < sprites.length; i++)\r\n        {\r\n            RandomXYZW(sprites[i].position, scale);\r\n        }\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#translateChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} vec3 - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    translateChildren: function (vec3, sprites)\r\n    {\r\n        if (sprites === undefined) { sprites = this.getChildren(); }\r\n\r\n        for (var i = 0; i < sprites.length; i++)\r\n        {\r\n            sprites[i].position.add(vec3);\r\n        }\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#transformChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat4 - [description]\r\n     * @param {Phaser.GameObjects.Sprite3D[]} sprites - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    transformChildren: function (mat4, sprites)\r\n    {\r\n        if (sprites === undefined) { sprites = this.getChildren(); }\r\n\r\n        for (var i = 0; i < sprites.length; i++)\r\n        {\r\n            sprites[i].position.transformMat4(mat4);\r\n        }\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Sets the width and height of the viewport. Does not update any matrices.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setViewport\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setViewport: function (width, height)\r\n    {\r\n        this.viewportWidth = width;\r\n        this.viewportHeight = height;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * Translates this camera by a specified Vector3 object\r\n     * or x, y, z parameters. Any undefined x y z values will\r\n     * default to zero, leaving that component unaffected.\r\n     * If you wish to set the camera position directly call setPosition instead.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#translate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [z] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    translate: function (x, y, z)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            this.position.x += x.x || 0;\r\n            this.position.y += x.y || 0;\r\n            this.position.z += x.z || 0;\r\n        }\r\n        else\r\n        {\r\n            this.position.x += x || 0;\r\n            this.position.y += y || 0;\r\n            this.position.z += z || 0;\r\n        }\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#lookAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|object)} x - [description]\r\n     * @param {number} [y] - [description]\r\n     * @param {number} [z] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    lookAt: function (x, y, z)\r\n    {\r\n        var dir = this.direction;\r\n        var up = this.up;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            dir.copy(x);\r\n        }\r\n        else\r\n        {\r\n            dir.set(x, y, z);\r\n        }\r\n\r\n        dir.subtract(this.position).normalize();\r\n\r\n        //  Calculate right vector\r\n        tmpVec3.copy(dir).cross(up).normalize();\r\n\r\n        //  Calculate up vector\r\n        up.copy(tmpVec3).cross(dir).normalize();\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#rotate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radians - [description]\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    rotate: function (radians, axis)\r\n    {\r\n        RotateVec3(this.direction, axis, radians);\r\n        RotateVec3(this.up, axis, radians);\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#rotateAround\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} point - [description]\r\n     * @param {number} radians - [description]\r\n     * @param {Phaser.Math.Vector3} axis - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    rotateAround: function (point, radians, axis)\r\n    {\r\n        tmpVec3.copy(point).subtract(this.position);\r\n\r\n        this.translate(tmpVec3);\r\n        this.rotate(radians, axis);\r\n        this.translate(tmpVec3.negate());\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#project\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector3} vec - [description]\r\n     * @param {Phaser.Math.Vector4} out - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector4} [description]\r\n     */\r\n    project: function (vec, out)\r\n    {\r\n        if (out === undefined) { out = new Vector4(); }\r\n\r\n        //  TODO: support viewport XY\r\n        var viewportWidth = this.viewportWidth;\r\n        var viewportHeight = this.viewportHeight;\r\n        var n = Camera.NEAR_RANGE;\r\n        var f = Camera.FAR_RANGE;\r\n\r\n        //  For useful Z and W values we should do the usual steps: clip space -> NDC -> window coords\r\n\r\n        //  Implicit 1.0 for w component\r\n        tmpVec4.set(vec.x, vec.y, vec.z, 1.0);\r\n\r\n        //  Transform into clip space\r\n        tmpVec4.transformMat4(this.combined);\r\n\r\n        //  Avoid divide by zero when 0x0x0 camera projects to a 0x0x0 vec3\r\n        if (tmpVec4.w === 0)\r\n        {\r\n            tmpVec4.w = 1;\r\n        }\r\n\r\n        //  Now into NDC\r\n        tmpVec4.x = tmpVec4.x / tmpVec4.w;\r\n        tmpVec4.y = tmpVec4.y / tmpVec4.w;\r\n        tmpVec4.z = tmpVec4.z / tmpVec4.w;\r\n\r\n        //  And finally into window coordinates\r\n        out.x = viewportWidth / 2 * tmpVec4.x + (0 + viewportWidth / 2);\r\n        out.y = viewportHeight / 2 * tmpVec4.y + (0 + viewportHeight / 2);\r\n        out.z = (f - n) / 2 * tmpVec4.z + (f + n) / 2;\r\n\r\n        //  If the out vector has a fourth component, we also store (1/clip.w), same idea as gl_FragCoord.w\r\n        if (out.w === 0 || out.w)\r\n        {\r\n            out.w = 1 / tmpVec4.w;\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#unproject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector4} vec - [description]\r\n     * @param {Phaser.Math.Vector3} out - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector3} [description]\r\n     */\r\n    unproject: function (vec, out)\r\n    {\r\n        if (out === undefined) { out = new Vector3(); }\r\n\r\n        var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);\r\n\r\n        return out.copy(vec).unproject(viewport, this.invProjectionView);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getPickRay\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} [y] - [description]\r\n     *\r\n     * @return {RayDef} [description]\r\n     */\r\n    getPickRay: function (x, y)\r\n    {\r\n        var origin = this.ray.origin.set(x, y, 0);\r\n        var direction = this.ray.direction.set(x, y, 1);\r\n        var viewport = tmpVec4.set(0, 0, this.viewportWidth, this.viewportHeight);\r\n        var mtx = this.invProjectionView;\r\n\r\n        origin.unproject(viewport, mtx);\r\n\r\n        direction.unproject(viewport, mtx);\r\n\r\n        direction.subtract(origin).normalize();\r\n\r\n        return this.ray;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#updateChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    updateChildren: function ()\r\n    {\r\n        var children = this.children.entries;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            children[i].project(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    //  Overridden by subclasses\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    update: function ()\r\n    {\r\n        return this.updateChildren();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#updateBillboardMatrix\r\n     * @since 3.0.0\r\n     */\r\n    updateBillboardMatrix: function ()\r\n    {\r\n        var dir = dirvec.set(this.direction).negate();\r\n\r\n        // Better view-aligned billboards might use this:\r\n        // var dir = tmp.set(camera.position).subtract(p).normalize();\r\n\r\n        var right = rightvec.set(this.up).cross(dir).normalize();\r\n        var up = tmpVec3.set(dir).cross(right).normalize();\r\n\r\n        var out = billboardMatrix.val;\r\n\r\n        out[0] = right.x;\r\n        out[1] = right.y;\r\n        out[2] = right.z;\r\n        out[3] = 0;\r\n\r\n        out[4] = up.x;\r\n        out[5] = up.y;\r\n        out[6] = up.z;\r\n        out[7] = 0;\r\n\r\n        out[8] = dir.x;\r\n        out[9] = dir.y;\r\n        out[10] = dir.z;\r\n        out[11] = 0;\r\n\r\n        out[12] = 0;\r\n        out[13] = 0;\r\n        out[14] = 0;\r\n        out[15] = 1;\r\n\r\n        this.billboardMatrixDirty = false;\r\n    },\r\n\r\n    /**\r\n     * This is a utility function for canvas 3D rendering,\r\n     * which determines the \"point size\" of a camera-facing\r\n     * sprite billboard given its 3D world position\r\n     * (origin at center of sprite) and its world width\r\n     * and height in x/y.\r\n     *\r\n     * We place into the output Vector2 the scaled width\r\n     * and height. If no `out` is specified, a new Vector2\r\n     * will be created for convenience (this should be avoided\r\n     * in tight loops).\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#getPointSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} vec - The position of the 3D Sprite.\r\n     * @param {Phaser.Math.Vector2} size - The x and y dimensions.\r\n     * @param {Phaser.Math.Vector2} out - The result, scaled x and y dimensions.\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getPointSize: function (vec, size, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        // TODO: optimize this with a simple distance calculation:\r\n        // https://developer.valvesoftware.com/wiki/Field_of_View\r\n\r\n        if (this.billboardMatrixDirty)\r\n        {\r\n            this.updateBillboardMatrix();\r\n        }\r\n\r\n        var tmp = tmpVec3;\r\n\r\n        var dx = (size.x / this.pixelScale) / 2;\r\n        var dy = (size.y / this.pixelScale) / 2;\r\n\r\n        tmp.set(-dx, -dy, 0).transformMat4(billboardMatrix).add(vec);\r\n\r\n        this.project(tmp, tmp);\r\n\r\n        var tlx = tmp.x;\r\n        var tly = tmp.y;\r\n\r\n        tmp.set(dx, dy, 0).transformMat4(billboardMatrix).add(vec);\r\n\r\n        this.project(tmp, tmp);\r\n\r\n        var brx = tmp.x;\r\n        var bry = tmp.y;\r\n\r\n        // var w = Math.abs(brx - tlx);\r\n        // var h = Math.abs(bry - tly);\r\n\r\n        //  Allow the projection to get negative ...\r\n        var w = brx - tlx;\r\n        var h = bry - tly;\r\n\r\n        return out.set(w, h);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.children.clear();\r\n\r\n        this.scene = undefined;\r\n        this.children = undefined;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setX: function (value)\r\n    {\r\n        this.position.x = value;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setY: function (value)\r\n    {\r\n        this.position.y = value;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.Camera#setZ\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.Camera} This Camera object.\r\n     */\r\n    setZ: function (value)\r\n    {\r\n        this.position.z = value;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.x = value;\r\n            this.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.y = value;\r\n            this.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.Camera#z\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    z: {\r\n        get: function ()\r\n        {\r\n            return this.position.z;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.z = value;\r\n            this.update();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nCamera.FAR_RANGE = 1.0;\r\nCamera.NEAR_RANGE = 0.0;\r\n\r\nmodule.exports = Camera;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar OrthographicCamera = require('./OrthographicCamera');\r\nvar PerspectiveCamera = require('./PerspectiveCamera');\r\nvar PluginCache = require('../../../src/plugins/PluginCache');\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CameraManager\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n */\r\nvar CameraManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function CameraManager (scene)\r\n    {\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * An Array of the Camera objects being managed by this Camera Manager.\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.CameraManager#cameras\r\n         * @type {Phaser.Cameras.Sprite3D.Camera[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras = [];\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n        scene.sys.events.on('start', this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Cameras.Scene3D.CameraManager#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once('destroy', this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on('update', this.update, this);\r\n        eventEmitter.once('shutdown', this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [fieldOfView=80] - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */\r\n    add: function (fieldOfView, width, height)\r\n    {\r\n        return this.addPerspectiveCamera(fieldOfView, width, height);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#addOrthographicCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */\r\n    addOrthographicCamera: function (width, height)\r\n    {\r\n        var config = this.scene.sys.game.config;\r\n\r\n        if (width === undefined) { width = config.width; }\r\n        if (height === undefined) { height = config.height; }\r\n\r\n        var camera = new OrthographicCamera(this.scene, width, height);\r\n\r\n        this.cameras.push(camera);\r\n\r\n        return camera;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#addPerspectiveCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [fieldOfView=80] - [description]\r\n     * @param {number} [width] - [description]\r\n     * @param {number} [height] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */\r\n    addPerspectiveCamera: function (fieldOfView, width, height)\r\n    {\r\n        var config = this.scene.sys.game.config;\r\n\r\n        if (fieldOfView === undefined) { fieldOfView = 80; }\r\n        if (width === undefined) { width = config.width; }\r\n        if (height === undefined) { height = config.height; }\r\n\r\n        var camera = new PerspectiveCamera(this.scene, fieldOfView, width, height);\r\n\r\n        this.cameras.push(camera);\r\n\r\n        return camera;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#getCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - [description]\r\n     *\r\n     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]\r\n     */\r\n    getCamera: function (name)\r\n    {\r\n        for (var i = 0; i < this.cameras.length; i++)\r\n        {\r\n            if (this.cameras[i].name === name)\r\n            {\r\n                return this.cameras[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#removeCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} camera - [description]\r\n     */\r\n    removeCamera: function (camera)\r\n    {\r\n        var cameraIndex = this.cameras.indexOf(camera);\r\n\r\n        if (cameraIndex !== -1)\r\n        {\r\n            this.cameras.splice(cameraIndex, 1);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#removeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {(Phaser.Cameras.Sprite3D.OrthographicCamera|Phaser.Cameras.Sprite3D.PerspectiveCamera)} [description]\r\n     */\r\n    removeAll: function ()\r\n    {\r\n        while (this.cameras.length > 0)\r\n        {\r\n            var camera = this.cameras.pop();\r\n\r\n            camera.destroy();\r\n        }\r\n\r\n        return this.main;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestep - [description]\r\n     * @param {number} delta - [description]\r\n     */\r\n    update: function (timestep, delta)\r\n    {\r\n        for (var i = 0, l = this.cameras.length; i < l; ++i)\r\n        {\r\n            this.cameras[i].update(timestep, delta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('update', this.update, this);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n\r\n        this.removeAll();\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.CameraManager#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off('start', this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('CameraManager3D', CameraManager, 'cameras3d');\r\n\r\nmodule.exports = CameraManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Camera = require('./Camera');\r\nvar Class = require('../../../src/utils/Class');\r\nvar Vector3 = require('../../../src/math/Vector3');\r\n\r\n//  Local cache vars\r\nvar tmpVec3 = new Vector3();\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class OrthographicCamera\r\n * @extends Phaser.Cameras.Sprite3D.Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {integer} [viewportWidth=0] - [description]\r\n * @param {integer} [viewportHeight=0] - [description]\r\n */\r\nvar OrthographicCamera = new Class({\r\n\r\n    Extends: Camera,\r\n\r\n    initialize:\r\n\r\n    function OrthographicCamera (scene, viewportWidth, viewportHeight)\r\n    {\r\n        if (viewportWidth === undefined) { viewportWidth = 0; }\r\n        if (viewportHeight === undefined) { viewportHeight = 0; }\r\n\r\n        Camera.call(this, scene);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportWidth = viewportWidth;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#viewportHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportHeight = viewportHeight;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#_zoom\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._zoom = 1.0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.OrthographicCamera#near\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.near = 0;\r\n\r\n        this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#setToOrtho\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} yDown - [description]\r\n     * @param {number} [viewportWidth] - [description]\r\n     * @param {number} [viewportHeight] - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */\r\n    setToOrtho: function (yDown, viewportWidth, viewportHeight)\r\n    {\r\n        if (viewportWidth === undefined) { viewportWidth = this.viewportWidth; }\r\n        if (viewportHeight === undefined) { viewportHeight = this.viewportHeight; }\r\n\r\n        var zoom = this.zoom;\r\n\r\n        this.up.set(0, (yDown) ? -1 : 1, 0);\r\n        this.direction.set(0, 0, (yDown) ? 1 : -1);\r\n        this.position.set(zoom * viewportWidth / 2, zoom * viewportHeight / 2, 0);\r\n\r\n        this.viewportWidth = viewportWidth;\r\n        this.viewportHeight = viewportHeight;\r\n\r\n        return this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.OrthographicCamera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.OrthographicCamera} [description]\r\n     */\r\n    update: function ()\r\n    {\r\n        var w = this.viewportWidth;\r\n        var h = this.viewportHeight;\r\n        var near = Math.abs(this.near);\r\n        var far = Math.abs(this.far);\r\n        var zoom = this.zoom;\r\n\r\n        if (w === 0 || h === 0)\r\n        {\r\n            //  What to do here... hmm?\r\n            return this;\r\n        }\r\n\r\n        this.projection.ortho(\r\n            zoom * -w / 2, zoom * w / 2,\r\n            zoom * -h / 2, zoom * h / 2,\r\n            near,\r\n            far\r\n        );\r\n\r\n        //  Build the view matrix\r\n        tmpVec3.copy(this.position).add(this.direction);\r\n\r\n        this.view.lookAt(this.position, tmpVec3, this.up);\r\n\r\n        //  Projection * view matrix\r\n        this.combined.copy(this.projection).multiply(this.view);\r\n\r\n        //  Invert combined matrix, used for unproject\r\n        this.invProjectionView.copy(this.combined).invert();\r\n\r\n        this.billboardMatrixDirty = true;\r\n\r\n        this.updateChildren();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @name Phaser.Cameras.Sprite3D.OrthographicCamera#zoom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    zoom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._zoom;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._zoom = value;\r\n            this.update();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = OrthographicCamera;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Camera = require('./Camera');\r\nvar Class = require('../../../src/utils/Class');\r\nvar Vector3 = require('../../../src/math/Vector3');\r\n\r\n//  Local cache vars\r\nvar tmpVec3 = new Vector3();\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class PerspectiveCamera\r\n * @extends Phaser.Cameras.Sprite3D.Camera\r\n * @memberOf Phaser.Cameras.Sprite3D\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - [description]\r\n * @param {integer} [fieldOfView=80] - [description]\r\n * @param {integer} [viewportWidth=0] - [description]\r\n * @param {integer} [viewportHeight=0] - [description]\r\n */\r\nvar PerspectiveCamera = new Class({\r\n\r\n    Extends: Camera,\r\n\r\n    //  FOV is converted to radians automatically\r\n    initialize:\r\n\r\n    function PerspectiveCamera (scene, fieldOfView, viewportWidth, viewportHeight)\r\n    {\r\n        if (fieldOfView === undefined) { fieldOfView = 80; }\r\n        if (viewportWidth === undefined) { viewportWidth = 0; }\r\n        if (viewportHeight === undefined) { viewportHeight = 0; }\r\n\r\n        Camera.call(this, scene);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportWidth\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportWidth = viewportWidth;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#viewportHeight\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.viewportHeight = viewportHeight;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Cameras.Sprite3D.PerspectiveCamera#fieldOfView\r\n         * @type {integer}\r\n         * @default 80\r\n         * @since 3.0.0\r\n         */\r\n        this.fieldOfView = fieldOfView * Math.PI / 180;\r\n\r\n        this.update();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#setFOV\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - [description]\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */\r\n    setFOV: function (value)\r\n    {\r\n        this.fieldOfView = value * Math.PI / 180;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Cameras.Sprite3D.PerspectiveCamera#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Cameras.Sprite3D.PerspectiveCamera} [description]\r\n     */\r\n    update: function ()\r\n    {\r\n        var aspect = this.viewportWidth / this.viewportHeight;\r\n\r\n        //  Create a perspective matrix for our camera\r\n        this.projection.perspective(\r\n            this.fieldOfView,\r\n            aspect,\r\n            Math.abs(this.near),\r\n            Math.abs(this.far)\r\n        );\r\n\r\n        //  Build the view matrix\r\n        tmpVec3.copy(this.position).add(this.direction);\r\n\r\n        this.view.lookAt(this.position, tmpVec3, this.up);\r\n\r\n        //  Projection * view matrix\r\n        this.combined.copy(this.projection).multiply(this.view);\r\n\r\n        //  Invert combined matrix, used for unproject\r\n        this.invProjectionView.copy(this.combined).invert();\r\n\r\n        this.billboardMatrixDirty = true;\r\n\r\n        this.updateChildren();\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PerspectiveCamera;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Cameras.Sprite3D\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Camera: require('./Camera'),\r\n    CameraManager: require('./CameraManager'),\r\n    OrthographicCamera: require('./OrthographicCamera'),\r\n    PerspectiveCamera: require('./PerspectiveCamera')\r\n\r\n};\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar Class = require('../../../../src/utils/Class');\nvar GameObject = require('../../../../src/gameobjects/GameObject');\nvar Sprite = require('../../../../src/gameobjects/sprite/Sprite');\nvar Vector2 = require('../../../../src/math/Vector2');\nvar Vector4 = require('../../../../src/math/Vector4');\n\n/**\n * @classdesc\n * A Sprite 3D Game Object.\n *\n * The Sprite 3D object is an encapsulation of a standard Sprite object, with additional methods to allow\n * it to be rendered by a 3D Camera. The Sprite can be positioned anywhere within 3D space.\n *\n * @class Sprite3D\n * @extends Phaser.GameObjects.Sprite\n * @memberOf Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The x position of this Game Object.\n * @param {number} y - The y position of this Game Object.\n * @param {number} z - The z position of this Game Object.\n * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Sprite3D = new Class({\n\n    Extends: GameObject,\n\n    initialize:\n\n    function Sprite3D (scene, x, y, z, texture, frame)\n    {\n        GameObject.call(this, scene, 'Sprite3D');\n\n        /**\n         * The encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#gameObject\n         * @type {Phaser.GameObjects.GameObject}\n         * @since 3.0.0\n         */\n        this.gameObject = new Sprite(scene, 0, 0, texture, frame);\n\n        /**\n         * The position of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#position\n         * @type {Phaser.Math.Vector4}\n         * @since 3.0.0\n         */\n        this.position = new Vector4(x, y, z);\n\n        /**\n         * The 2D size of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#size\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.size = new Vector2(this.gameObject.width, this.gameObject.height);\n\n        /**\n         * The 2D scale of the Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#scale\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.scale = new Vector2(1, 1);\n\n        /**\n         * Whether to automatically set the horizontal scale of the encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleX\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.adjustScaleX = true;\n\n        /**\n         * Whether to automatically set the vertical scale of the encapsulated Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite3D#adjustScaleY\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.adjustScaleY = true;\n\n        /**\n         * The visible state of the Game Object.\n         *\n         * @name Phaser.GameObjects.Sprite3D#_visible\n         * @type {boolean}\n         * @default true\n         * @private\n         * @since 3.0.0\n         */\n        this._visible = true;\n    },\n\n    /**\n     * Project this Sprite onto the given 3D Camera.\n     *\n     * @method Phaser.GameObjects.Sprite3D#project\n     * @since 3.0.0\n     *\n     * @param {Phaser.Cameras.Sprite3D.Camera} camera - The 3D Camera onto which to project this Sprite.\n     */\n    project: function (camera)\n    {\n        var pos = this.position;\n\n        var gameObject = this.gameObject;\n\n        camera.project(pos, gameObject);\n\n        camera.getPointSize(pos, this.size, this.scale);\n\n        if (this.scale.x <= 0 || this.scale.y <= 0)\n        {\n            gameObject.setVisible(false);\n        }\n        else\n        {\n            if (!gameObject.visible)\n            {\n                gameObject.setVisible(true);\n            }\n\n            if (this.adjustScaleX)\n            {\n                gameObject.scaleX = this.scale.x;\n            }\n\n            if (this.adjustScaleY)\n            {\n                gameObject.scaleY = this.scale.y;\n            }\n\n            gameObject.setDepth(gameObject.z * -1);\n        }\n    },\n\n    /**\n     * Set the visible state of the Game Object.\n     *\n     * @method Phaser.GameObjects.Sprite3D#setVisible\n     * @since 3.0.0\n     *\n     * @param {boolean} value - The visible state of the Game Object.\n     *\n     * @return {Phaser.GameObjects.Sprite3D} This Sprite3D Object.\n     */\n    setVisible: function (value)\n    {\n        this.visible = value;\n\n        return this;\n    },\n\n    /**\n     * The visible state of the Game Object.\n     *\n     * An invisible Game Object will skip rendering, but will still process update logic.\n     *\n     * @name Phaser.GameObjects.Sprite3D#visible\n     * @type {boolean}\n     * @since 3.0.0\n     */\n    visible: {\n\n        get: function ()\n        {\n            return this._visible;\n        },\n\n        set: function (value)\n        {\n            this._visible = value;\n            this.gameObject.visible = value;\n        }\n\n    },\n\n    /**\n     * The x position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#x\n     * @type {number}\n     * @since 3.0.0\n     */\n    x: {\n\n        get: function ()\n        {\n            return this.position.x;\n        },\n\n        set: function (value)\n        {\n            this.position.x = value;\n        }\n\n    },\n\n    /**\n     * The y position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#y\n     * @type {number}\n     * @since 3.0.0\n     */\n    y: {\n\n        get: function ()\n        {\n            return this.position.y;\n        },\n\n        set: function (value)\n        {\n            this.position.y = value;\n        }\n\n    },\n\n    /**\n     * The z position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Sprite3D#z\n     * @type {number}\n     * @since 3.0.0\n     */\n    z: {\n\n        get: function ()\n        {\n            return this.position.z;\n        },\n\n        set: function (value)\n        {\n            this.position.z = value;\n        }\n\n    }\n\n});\n\nmodule.exports = Sprite3D;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {number} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachSetCallback<E>\r\n *\r\n * @param {E} entry - The Set entry.\r\n * @param {number} index - The index of the entry within the Set.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Set is a collection of unique elements.\r\n *\r\n * @class Set\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [elements]\r\n *\r\n * @param {Array.<*>} [elements] - An optional array of elements to insert into this Set.\r\n */\r\nvar Set = new Class({\r\n\r\n    initialize:\r\n\r\n    function Set (elements)\r\n    {\r\n        /**\r\n         * The entries of this Set. Stored internally as an array.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Set#entries\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = [];\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Inserts the provided value into this Set. If the value is already contained in this Set this method will have no effect.\r\n     *\r\n     * @method Phaser.Structs.Set#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to insert into this Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    set: function (value)\r\n    {\r\n        if (this.entries.indexOf(value) === -1)\r\n        {\r\n            this.entries.push(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get an element of this Set which has a property of the specified name, if that property is equal to the specified value.\r\n     * If no elements of this Set satisfy the condition then this method will return `null`.\r\n     *\r\n     * @method Phaser.Structs.Set#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value,$return]\r\n     *\r\n     * @param {string} property - The property name to check on the elements of this Set.\r\n     * @param {*} value - The value to check for.\r\n     *\r\n     * @return {*} The first element of this Set that meets the required condition, or `null` if this Set contains no elements that meet the condition.\r\n     */\r\n    get: function (property, value)\r\n    {\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            if (entry[property] === value)\r\n            {\r\n                return entry;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing all the values in this Set.\r\n     *\r\n     * @method Phaser.Structs.Set#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array containing all the values in this Set.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        return this.entries.slice(0);\r\n    },\r\n\r\n    /**\r\n     * Removes the given value from this Set if this Set contains that value.\r\n     *\r\n     * @method Phaser.Structs.Set#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {*} value - The value to remove from the Set.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    delete: function (value)\r\n    {\r\n        var index = this.entries.indexOf(value);\r\n\r\n        if (index > -1)\r\n        {\r\n            this.entries.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Set to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Set#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.group('Set');\r\n\r\n        for (var i = 0; i < this.entries.length; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n            console.log(entry);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * Use this function when you know this Set will be modified during the iteration, otherwise use `iterate`.\r\n     *\r\n     * @method Phaser.Structs.Set#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    each: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var temp = this.entries.slice();\r\n        var len = temp.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(temp[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes each value in this Set to the given callback.\r\n     * For when you absolutely know this Set won't be modified during the iteration.\r\n     *\r\n     * @method Phaser.Structs.Set#iterate\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachSetCallback.<T>} - [callback]\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {EachSetCallback} callback - The callback to be invoked and passed each value this Set contains.\r\n     * @param {*} [callbackScope] - The scope of the callback.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterate: function (callback, callbackScope)\r\n    {\r\n        var i;\r\n        var len = this.entries.length;\r\n\r\n        if (callbackScope)\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback.call(callbackScope, this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                if (callback(this.entries[i], i) === false)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Goes through each entry in this Set and invokes the given function on them, passing in the arguments.\r\n     *\r\n     * @method Phaser.Structs.Set#iterateLocal\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @param {string} callbackKey - The key of the function to be invoked on each Set entry.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    iterateLocal: function (callbackKey)\r\n    {\r\n        var i;\r\n        var args = [];\r\n\r\n        for (i = 1; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        var len = this.entries.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            var entry = this.entries[i];\r\n\r\n            entry[callbackKey].apply(entry, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears this Set so that it no longer contains any values.\r\n     *\r\n     * @method Phaser.Structs.Set#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Set} This Set object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.entries.length = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if this Set contains the given value, otherwise returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Set#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {*} value - The value to check for in this Set.\r\n     *\r\n     * @return {boolean} `true` if the given value was found in this Set, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        return (this.entries.indexOf(value) > -1);\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all values that are either in this Set or in the Set provided as an argument.\r\n     *\r\n     * @method Phaser.Structs.Set#union\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the union with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set and the Set provided as an argument.\r\n     */\r\n    union: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        set.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            newSet.set(value);\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set that contains only the values which are in this Set and that are also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#intersect\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to intersect this set with.\r\n     *\r\n     * @return {Phaser.Structs.Set} The result of the intersection, as a new Set.\r\n     */\r\n    intersect: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * Returns a new Set containing all the values in this Set which are *not* also in the given Set.\r\n     *\r\n     * @method Phaser.Structs.Set#difference\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Set.<T>} - [set,$return]\r\n     *\r\n     * @param {Phaser.Structs.Set} set - The Set to perform the difference with.\r\n     *\r\n     * @return {Phaser.Structs.Set} A new Set containing all the values in this Set that are not also in the Set provided as an argument to this method.\r\n     */\r\n    difference: function (set)\r\n    {\r\n        var newSet = new Set();\r\n\r\n        this.entries.forEach(function (value)\r\n        {\r\n            if (!set.contains(value))\r\n            {\r\n                newSet.set(value);\r\n            }\r\n        });\r\n\r\n        return newSet;\r\n    },\r\n\r\n    /**\r\n     * The size of this Set. This is the number of entries within it.\r\n     * Changing the size will truncate the Set if the given value is smaller than the current size.\r\n     * Increasing the size larger than the current size has no effect.\r\n     *\r\n     * @name Phaser.Structs.Set#size\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    size: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.entries.length;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            if (value < this.entries.length)\r\n            {\r\n                return this.entries.length = value;\r\n            }\r\n            else\r\n            {\r\n                return this.entries.length;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Set;\r\n"],"names":["Class","Matrix4","RandomXYZ","RandomXYZW","RotateVec3","Set","Sprite3D","Vector2","Vector3","Vector4","tmpVec3","tmpVec4","dirvec","rightvec","billboardMatrix","Camera","initialize","scene","this","displayList","sys","updateList","name","direction","up","position","pixelScale","projection","view","combined","invProjectionView","near","far","ray","origin","viewportWidth","viewportHeight","billboardMatrixDirty","children","setPosition","x","y","z","set","update","setScene","setPixelScale","value","add","sprite3D","gameObject","updateChildren","remove","child","delete","clear","getChildren","i","length","entries","create","key","frame","visible","undefined","createMultiple","quantity","output","push","createRect","size","spacing","sprites","bx","by","bz","randomSphere","radius","randomCube","scale","translateChildren","vec3","transformChildren","mat4","transformMat4","setViewport","width","height","translate","lookAt","dir","copy","subtract","normalize","cross","rotate","radians","axis","rotateAround","point","negate","project","vec","out","n","NEAR_RANGE","f","FAR_RANGE","w","unproject","viewport","getPickRay","mtx","updateBillboardMatrix","right","val","getPointSize","tmp","dx","dy","tlx","tly","h","destroy","setX","setY","setZ","get","module","exports","OrthographicCamera","PerspectiveCamera","PluginCache","CameraManager","systems","cameras","events","once","boot","on","start","eventEmitter","shutdown","fieldOfView","addPerspectiveCamera","addOrthographicCamera","config","game","camera","getCamera","removeCamera","cameraIndex","indexOf","splice","removeAll","pop","main","timestep","delta","l","off","register","Extends","call","_zoom","setToOrtho","yDown","zoom","Math","abs","ortho","multiply","invert","PI","setFOV","aspect","perspective","GameObject","Sprite","texture","adjustScaleX","adjustScaleY","_visible","pos","setVisible","scaleX","scaleY","setDepth","min","max","CONST","degrees","DEG_TO_RAD","range","corePlugins","customPlugins","plugin","mapping","custom","data","hasOwnProperty","elements","Array","isArray","property","entry","getArray","slice","index","dump","console","group","log","groupEnd","each","callback","callbackScope","temp","len","iterate","iterateLocal","callbackKey","args","arguments","apply","contains","union","newSet","forEach","intersect","difference"],"sourceRoot":""}