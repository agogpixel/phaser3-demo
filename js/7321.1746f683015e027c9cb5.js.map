{"version":3,"file":"js/7321.1746f683015e027c9cb5.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Vector2.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/Equal.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/Class.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\r\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\r\n\r\nvar Class = require('../utils/Class');\r\nvar FuzzyEqual = require('../math/fuzzy/Equal');\r\n\r\n/**\r\n * @classdesc\r\n * A representation of a vector in 2D space.\r\n *\r\n * A two-component vector.\r\n *\r\n * @class Vector2\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\r\n * @param {number} [y] - The y component.\r\n */\r\nvar Vector2 = new Class({\r\n\r\n    initialize:\r\n\r\n    function Vector2 (x, y)\r\n    {\r\n        /**\r\n         * The x component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y component of this Vector.\r\n         *\r\n         * @name Phaser.Math.Vector2#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.x = x.x || 0;\r\n            this.y = x.y || 0;\r\n        }\r\n        else\r\n        {\r\n            if (y === undefined) { y = x; }\r\n\r\n            this.x = x || 0;\r\n            this.y = y || 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Make a clone of this Vector2.\r\n     *\r\n     * @method Phaser.Math.Vector2#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\r\n     */\r\n    clone: function ()\r\n    {\r\n        return new Vector2(this.x, this.y);\r\n    },\r\n\r\n    /**\r\n     * Copy the components of a given Vector into this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to copy the components from.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    copy: function (src)\r\n    {\r\n        this.x = src.x || 0;\r\n        this.y = src.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the component values of this Vector from a given Vector2Like object.\r\n     *\r\n     * @method Phaser.Math.Vector2#setFromObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setFromObject: function (obj)\r\n    {\r\n        this.x = obj.x || 0;\r\n        this.y = obj.y || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\r\n     *\r\n     * @method Phaser.Math.Vector2#set\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    set: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is an alias for `Vector2.set`.\r\n     *\r\n     * @method Phaser.Math.Vector2#setTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The x value to set for this Vector.\r\n     * @param {number} [y=x] - The y value to set for this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setTo: function (x, y)\r\n    {\r\n        return this.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\r\n     *\r\n     * @method Phaser.Math.Vector2#setToPolar\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} azimuth - The angular coordinate, in radians.\r\n     * @param {number} [radius=1] - The radial coordinate (length).\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setToPolar: function (azimuth, radius)\r\n    {\r\n        if (radius == null) { radius = 1; }\r\n\r\n        this.x = Math.cos(azimuth) * radius;\r\n        this.y = Math.sin(azimuth) * radius;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is equal to a given Vector.\r\n     *\r\n     * Performs a strict equality check against each Vector's components.\r\n     *\r\n     * @method Phaser.Math.Vector2#equals\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.\r\n     *\r\n     * @return {boolean} Whether the given Vector is equal to this Vector.\r\n     */\r\n    equals: function (v)\r\n    {\r\n        return ((this.x === v.x) && (this.y === v.y));\r\n    },\r\n\r\n    /**\r\n     * Check whether this Vector is approximately equal to a given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#fuzzyEquals\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.\r\n     * @param {number} [epsilon=0.0001] - The tolerance value.\r\n     *\r\n     * @return {boolean} Whether both absolute differences of the x and y components are smaller than `epsilon`.\r\n     */\r\n    fuzzyEquals: function (v, epsilon)\r\n    {\r\n        return (FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon));\r\n    },\r\n\r\n    /**\r\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\r\n     *\r\n     * @method Phaser.Math.Vector2#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\r\n     */\r\n    angle: function ()\r\n    {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n\r\n        var angle = Math.atan2(this.y, this.x);\r\n\r\n        if (angle < 0)\r\n        {\r\n            angle += 2 * Math.PI;\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Set the angle of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#setAngle\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} angle - The angle, in radians.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setAngle: function (angle)\r\n    {\r\n        return this.setToPolar(angle, this.length());\r\n    },\r\n\r\n    /**\r\n     * Add a given Vector to this Vector. Addition is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to add to this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    add: function (src)\r\n    {\r\n        this.x += src.x;\r\n        this.y += src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\r\n     *\r\n     * @method Phaser.Math.Vector2#subtract\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to subtract from this Vector.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    subtract: function (src)\r\n    {\r\n        this.x -= src.x;\r\n        this.y -= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise multiplication between this Vector and the given Vector.\r\n     *\r\n     * Multiplies this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#multiply\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to multiply this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    multiply: function (src)\r\n    {\r\n        this.x *= src.x;\r\n        this.y *= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scale this Vector by the given value.\r\n     *\r\n     * @method Phaser.Math.Vector2#scale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to scale this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    scale: function (value)\r\n    {\r\n        if (isFinite(value))\r\n        {\r\n            this.x *= value;\r\n            this.y *= value;\r\n        }\r\n        else\r\n        {\r\n            this.x = 0;\r\n            this.y = 0;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Perform a component-wise division between this Vector and the given Vector.\r\n     *\r\n     * Divides this Vector by the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#divide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to divide this Vector by.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    divide: function (src)\r\n    {\r\n        this.x /= src.x;\r\n        this.y /= src.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Negate the `x` and `y` components of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#negate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    negate: function ()\r\n    {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#distance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector.\r\n     */\r\n    distance: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Calculate the distance between this Vector and the given Vector, squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#distanceSq\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.\r\n     *\r\n     * @return {number} The distance from this Vector to the given Vector, squared.\r\n     */\r\n    distanceSq: function (src)\r\n    {\r\n        var dx = src.x - this.x;\r\n        var dy = src.y - this.y;\r\n\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    /**\r\n     * Calculate the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#length\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector.\r\n     */\r\n    length: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return Math.sqrt(x * x + y * y);\r\n    },\r\n\r\n    /**\r\n     * Set the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#setLength\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} length\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    setLength: function (length)\r\n    {\r\n        return this.normalize().scale(length);\r\n    },\r\n\r\n    /**\r\n     * Calculate the length of this Vector squared.\r\n     *\r\n     * @method Phaser.Math.Vector2#lengthSq\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this Vector, squared.\r\n     */\r\n    lengthSq: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n\r\n        return x * x + y * y;\r\n    },\r\n\r\n    /**\r\n     * Normalize this Vector.\r\n     *\r\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalize\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalize: function ()\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var len = x * x + y * y;\r\n\r\n        if (len > 0)\r\n        {\r\n            len = 1 / Math.sqrt(len);\r\n\r\n            this.x = x * len;\r\n            this.y = y * len;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Vector to its perpendicular, in the positive direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeRightHand\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeRightHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y * -1;\r\n        this.y = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotate this Vector to its perpendicular, in the negative direction.\r\n     *\r\n     * @method Phaser.Math.Vector2#normalizeLeftHand\r\n     * @since 3.23.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    normalizeLeftHand: function ()\r\n    {\r\n        var x = this.x;\r\n\r\n        this.x = this.y;\r\n        this.y = x * -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the dot product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#dot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to dot product with this Vector2.\r\n     *\r\n     * @return {number} The dot product of this Vector and the given Vector.\r\n     */\r\n    dot: function (src)\r\n    {\r\n        return this.x * src.x + this.y * src.y;\r\n    },\r\n\r\n    /**\r\n     * Calculate the cross product of this Vector and the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#cross\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to cross with this Vector2.\r\n     *\r\n     * @return {number} The cross product of this Vector and the given Vector.\r\n     */\r\n    cross: function (src)\r\n    {\r\n        return this.x * src.y - this.y * src.x;\r\n    },\r\n\r\n    /**\r\n     * Linearly interpolate between this Vector and the given Vector.\r\n     *\r\n     * Interpolates this Vector towards the given Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#lerp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to interpolate towards.\r\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    lerp: function (src, t)\r\n    {\r\n        if (t === undefined) { t = 0; }\r\n\r\n        var ax = this.x;\r\n        var ay = this.y;\r\n\r\n        this.x = ax + t * (src.x - ax);\r\n        this.y = ay + t * (src.y - ay);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat3: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[3] * y + m[6];\r\n        this.y = m[1] * x + m[4] * y + m[7];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Transform this Vector with the given Matrix.\r\n     *\r\n     * @method Phaser.Math.Vector2#transformMat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    transformMat4: function (mat)\r\n    {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var m = mat.val;\r\n\r\n        this.x = m[0] * x + m[4] * y + m[12];\r\n        this.y = m[1] * x + m[5] * y + m[13];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Make this Vector the zero vector (0, 0).\r\n     *\r\n     * @method Phaser.Math.Vector2#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Limit the length (or magnitude) of this Vector.\r\n     *\r\n     * @method Phaser.Math.Vector2#limit\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} max - The maximum length.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    limit: function (max)\r\n    {\r\n        var len = this.length();\r\n\r\n        if (len && len > max)\r\n        {\r\n            this.scale(max / len);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reflect this Vector off a line defined by a normal.\r\n     *\r\n     * @method Phaser.Math.Vector2#reflect\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} normal - A vector perpendicular to the line.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    reflect: function (normal)\r\n    {\r\n        normal = normal.clone().normalize();\r\n\r\n        return this.subtract(normal.scale(2 * this.dot(normal)));\r\n    },\r\n\r\n    /**\r\n     * Reflect this Vector across another.\r\n     *\r\n     * @method Phaser.Math.Vector2#mirror\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} axis - A vector to reflect across.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    mirror: function (axis)\r\n    {\r\n        return this.reflect(axis).negate();\r\n    },\r\n\r\n    /**\r\n     * Rotate this Vector by an angle amount.\r\n     *\r\n     * @method Phaser.Math.Vector2#rotate\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} delta - The angle to rotate by, in radians.\r\n     *\r\n     * @return {Phaser.Math.Vector2} This Vector2.\r\n     */\r\n    rotate: function (delta)\r\n    {\r\n        var cos = Math.cos(delta);\r\n        var sin = Math.sin(delta);\r\n\r\n        return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A static zero Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ZERO\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.1.0\r\n */\r\nVector2.ZERO = new Vector2();\r\n\r\n/**\r\n * A static right Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.RIGHT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.RIGHT = new Vector2(1, 0);\r\n\r\n/**\r\n * A static left Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.LEFT\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.LEFT = new Vector2(-1, 0);\r\n\r\n/**\r\n * A static up Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.UP\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.UP = new Vector2(0, -1);\r\n\r\n/**\r\n * A static down Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.DOWN\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.DOWN = new Vector2(0, 1);\r\n\r\n/**\r\n * A static one Vector2 for use by reference.\r\n *\r\n * This constant is meant for comparison operations and should not be modified directly.\r\n *\r\n * @constant\r\n * @name Phaser.Math.Vector2.ONE\r\n * @type {Phaser.Math.Vector2}\r\n * @since 3.16.0\r\n */\r\nVector2.ONE = new Vector2(1, 1);\r\n\r\nmodule.exports = Vector2;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether the given values are fuzzily equal.\r\n *\r\n * Two numbers are fuzzily equal if their difference is less than `epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.Equal\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if the values are fuzzily equal, otherwise `false`.\r\n */\r\nvar Equal = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.abs(a - b) < epsilon;\r\n};\r\n\r\nmodule.exports = Equal;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @ignore\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @ignore\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n"],"names":["Class","FuzzyEqual","Vector2","initialize","x","y","this","undefined","clone","copy","src","setFromObject","obj","set","setTo","setToPolar","azimuth","radius","Math","cos","sin","equals","v","fuzzyEquals","epsilon","angle","atan2","PI","setAngle","length","add","subtract","multiply","scale","value","isFinite","divide","negate","distance","dx","dy","sqrt","distanceSq","setLength","normalize","lengthSq","len","normalizeRightHand","normalizeLeftHand","dot","cross","lerp","t","ax","ay","transformMat3","mat","m","val","transformMat4","reset","limit","max","reflect","normal","mirror","axis","rotate","delta","ZERO","RIGHT","LEFT","UP","DOWN","ONE","module","exports","a","b","abs","getProperty","definition","k","isClassDescriptor","def","Object","getOwnPropertyDescriptor","get","hasGetterOrSetter","enumerable","configurable","hasNonConfigurable","prop","extend","ctor","hasOwnProperty","prototype","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","Extends","base","apply","arguments","create","constructor","Mixins"],"sourceRoot":""}