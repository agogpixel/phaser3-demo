{"version":3,"file":"js/2286.d56b458c3c9cdf9a2578.js","mappings":";sHAMA,IAuBQA,EACAC,EAEAC,EA1BJC,EAAa,EAAQ,OAcrBC,EAAiB,CAEjBC,qBAAqB,EACrBC,sBAAsB,GAoF1BC,EAAOC,SAT0B,mBAAlBC,oBAA6CC,IAAbC,WAEvCP,EAAeE,sBAvEfN,EAAU,iFACVC,EAAS,oDAETC,EAAU,IAAIU,OAEVC,OAAS,WAEb,IAAIC,EAAS,IAAIF,MAEjBE,EAAOD,OAAS,WAEZ,IACIE,EADSZ,EAAWa,OAAOF,EAAQ,EAAG,GACrBG,WAAW,MAOhC,GALAF,EAAQG,yBAA2B,WAEnCH,EAAQI,UAAUjB,EAAS,EAAG,GAC9Ba,EAAQI,UAAUL,EAAQ,EAAG,IAExBC,EAAQK,aAAa,EAAG,EAAG,EAAG,GAE/B,OAAO,EAGX,IAAIC,EAAON,EAAQK,aAAa,EAAG,EAAG,EAAG,GAAGC,KAE5ClB,EAAWmB,OAAOR,GAElBV,EAAeE,qBAAoC,MAAZe,EAAK,IAA0B,IAAZA,EAAK,IAAwB,IAAZA,EAAK,IAGpFP,EAAOS,IAAMvB,EAAU,WAAaC,GAGxCC,EAAQqB,IAAMvB,EAAU,WAAaC,GAE9B,GAoCHG,EAAeC,oBAjCvB,WAEI,IACIU,EADSZ,EAAWa,OAAOQ,KAAM,EAAG,GACnBP,WAAW,MAEhCF,EAAQU,UAAY,wBAGpBV,EAAQW,SAAS,EAAG,EAAG,EAAG,GAG1B,IAAIC,EAAKZ,EAAQK,aAAa,EAAG,EAAG,EAAG,GAEvC,GAAW,OAAPO,EAEA,OAAO,EAIXZ,EAAQa,aAAaD,EAAI,EAAG,GAG5B,IAAIE,EAAKd,EAAQK,aAAa,EAAG,EAAG,EAAG,GAGvC,OAAQS,EAAGR,KAAK,KAAOM,EAAGN,KAAK,IAAMQ,EAAGR,KAAK,KAAOM,EAAGN,KAAK,IAAMQ,EAAGR,KAAK,KAAOM,EAAGN,KAAK,IAAMQ,EAAGR,KAAK,KAAOM,EAAGN,KAAK,GAQ7ES,IAGlC1B,I,gBCjGX,IAAI2B,EAAe,EAAQ,OACvBC,EAAiB,EAAQ,OACzBC,EAAQ,EAAQ,OAChBC,EAAQ,EAAQ,OAChBC,EAAe,EAAQ,OACvBC,EAAS,EAAQ,OACjBC,EAAgB,EAAQ,OACxBC,EAAc,EAAQ,OACtBC,EAAgB,EAAQ,OACxBC,EAAkB,EAAQ,MAiB1BC,EAAiB,IAAIR,EAAM,CAE3BS,QAASP,EAETQ,WAEA,SAAyBC,GAErBT,EAAaU,KAAKrB,MAElB,IAAIsB,EAAaF,EAAKG,OAStBvB,KAAKuB,OAAS,CACVC,kBAAmBF,EAAWE,kBAC9BC,gBAAiBH,EAAWG,gBAC5BC,UAAWJ,EAAWI,UACtBC,YAAaL,EAAWK,aAU5B3B,KAAKoB,KAAOA,EASZpB,KAAK4B,KAAOlB,EAAMmB,OAUlB7B,KAAK8B,UAAY,EASjB9B,KAAK+B,MAAQ,EASb/B,KAAKgC,OAAS,EASdhC,KAAKiC,WAAab,EAAKc,OAEvB,IAAIC,EAAiB,CACjBC,MAAOhB,EAAKG,OAAOc,YACnBC,eAAgBlB,EAAKG,OAAOe,gBAUhCtC,KAAKuC,YAAejB,EAAkB,QAAIA,EAAW/B,QAAUS,KAAKiC,WAAWxC,WAAW,KAAM0C,GAShGnC,KAAKwC,eAAiBxC,KAAKuC,YAS3BvC,KAAK0B,UAAYN,EAAKG,OAAOG,UAW7B1B,KAAKyC,WAAa5B,IAWlBb,KAAK0C,cAAgB,CACjBC,EAAG,EACHC,EAAG,EACHb,MAAO,EACPC,OAAQ,EACRa,UAAU,EACVC,SAAU,KACVlB,KAAM,YACNmB,QAAS,KAWb/C,KAAKgD,aAAe,IAAIhC,EAUxBhB,KAAKiD,aAAe,IAAIjC,EAUxBhB,KAAKkD,aAAe,IAAIlC,EASxBhB,KAAKmD,UAAW,EAEhBnD,KAAKoD,QASTA,KAAM,WAEFpD,KAAKoB,KAAKiC,SAASC,KAAKvC,EAAcwC,MAAOvD,KAAKwD,KAAMxD,OAU5DwD,KAAM,WAEF,IAAIpC,EAAOpB,KAAKoB,KAEZqC,EAAWrC,EAAKsC,MAAMD,SAE1BzD,KAAK+B,MAAQ0B,EAAS1B,MACtB/B,KAAKgC,OAASyB,EAASzB,OAEvBhC,KAAKmD,UAAW,EAEhB/B,EAAKsC,MAAMC,GAAG7C,EAAY8C,OAAQ5D,KAAK6D,SAAU7D,MAEjDA,KAAK8D,OAAOL,EAAS1B,MAAO0B,EAASzB,SAYzC6B,SAAU,SAAUE,EAAUN,GAGtBA,EAAS1B,QAAU/B,KAAK+B,OAAS0B,EAASzB,SAAWhC,KAAKgC,QAE1DhC,KAAK8D,OAAOL,EAAS1B,MAAO0B,EAASzB,SAc7C8B,OAAQ,SAAU/B,EAAOC,GAErBhC,KAAK+B,MAAQA,EACb/B,KAAKgC,OAASA,EAEdhC,KAAKgE,KAAKpD,EAAOgD,OAAQ7B,EAAOC,IASpCiC,eAAgB,WAEZjE,KAAKwC,eAAe0B,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,IAapDC,aAAc,SAAUC,GAIpB,OAFApE,KAAKwC,eAAe9C,yBAA2B0E,EAExCpE,MAaXqE,WAAY,SAAUC,GAIlB,OAFAtE,KAAKwC,eAAiB,GAAcxC,KAAKuC,YAElCvC,MAaXuE,SAAU,SAAUnC,GAIhB,OAFApC,KAAKwC,eAAegC,YAAcpC,EAE3BpC,MAUXyE,UAAW,WAEP,IAAIH,EAAMtE,KAAKuC,YACXhB,EAASvB,KAAKuB,OAEdQ,EAAQ/B,KAAK+B,MACbC,EAAShC,KAAKgC,OAElBsC,EAAIE,YAAc,EAClBF,EAAI5E,yBAA2B,cAC/B4E,EAAIJ,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GAE5B3C,EAAOC,oBAEP8C,EAAII,UAAU,EAAG,EAAG3C,EAAOC,GAEtBT,EAAOc,cAERiC,EAAIrE,UAAYsB,EAAOE,gBAAgBkD,KACvCL,EAAIpE,SAAS,EAAG,EAAG6B,EAAOC,KAIlCsC,EAAIM,OAEJ5E,KAAK8B,UAAY,EAEjB9B,KAAKgE,KAAKpD,EAAOiE,aAqBrBC,OAAQ,SAAUC,EAAOC,EAAUC,GAE/B,IAAIC,EAAaF,EAASG,OAE1BnF,KAAKgE,KAAKpD,EAAOwE,OAAQL,EAAOE,GAEhC,IAAII,EAAKJ,EAAOtC,EACZ2C,EAAKL,EAAOrC,EACZ2C,EAAKN,EAAOlD,MACZyD,EAAKP,EAAOjD,OAEZsC,EAAOW,EAAsB,gBAAIA,EAAO1F,QAAUwF,EAAMU,IAAIlG,QAGhE+E,EAAIM,OAEA5E,KAAKoB,KAAK2D,MAAMW,kBAEhBpB,EAAIqB,YACJrB,EAAIsB,KAAKP,EAAIC,EAAIC,EAAIC,GACrBlB,EAAIuB,QAGR7F,KAAKwC,eAAiB8B,EAEtB,IAAIwB,EAAOb,EAAOa,KAEdA,GAEAA,EAAKC,gBAAgB/F,KAAM,KAAMiF,EAAOe,aAGvCf,EAAO5C,cAERiC,EAAIrE,UAAYgF,EAAOxD,gBAAgBkD,KACvCL,EAAIpE,SAASmF,EAAIC,EAAIC,EAAIC,IAG7BlB,EAAIE,YAAcS,EAAO7C,MAEzBkC,EAAI5E,yBAA2B,cAE/BM,KAAK8B,WAAaoD,EAEdD,EAAOgB,iBAEPhB,EAAOjB,KAAKzD,EAAasE,WAAYI,GAGzCA,EAAOiB,OAAOC,cAAc7B,GAE5B,IAAK,IAAI8B,EAAI,EAAGA,EAAIlB,EAAYkB,IAChC,CACI,IAAIC,EAAQrB,EAASoB,GAEjBC,EAAMP,MAENO,EAAMP,KAAKC,gBAAgB/F,KAAMqG,EAAOpB,GAG5CoB,EAAMC,aAAatG,KAAMqG,EAAOpB,GAE5BoB,EAAMP,MAENO,EAAMP,KAAKS,iBAAiBvG,KAAMqG,EAAOpB,GAIjDX,EAAIJ,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GAChCI,EAAI5E,yBAA2B,cAC/B4E,EAAIE,YAAc,EAElBS,EAAOuB,YAAYD,iBAAiBjC,GACpCW,EAAOwB,WAAWF,iBAAiBjC,GAEnCW,EAAOyB,OAAQ,EAEXZ,GAEAA,EAAKS,iBAAiBvG,MAI1BsE,EAAIqC,UAEA1B,EAAOgB,kBAEPhB,EAAOjB,KAAKzD,EAAaqG,YAAa3B,GAElCA,EAAO4B,cAEP9B,EAAMU,IAAIlG,QAAQI,UAAUsF,EAAO/C,OAAQmD,EAAIC,KAc3DwB,WAAY,WAEE9G,KAAKuC,YAEXoE,UAEJ3G,KAAKgE,KAAKpD,EAAOgG,aAEjB,IAAIG,EAAQ/G,KAAK0C,cAEbqE,EAAMjE,WAENtC,EAAeR,KAAKiC,WAAY8E,GAEhCA,EAAMjE,SAAW,OA2BzBkE,eAAgB,SAAU9E,EAAQY,EAAUD,EAAUF,EAAGC,EAAGb,EAAOC,EAAQJ,EAAMqF,QAE5D/H,IAAb2D,IAA0BA,GAAW,GAEzC7C,KAAKkH,aAAavE,EAAGC,EAAGb,EAAOC,EAAQc,EAAUlB,EAAMqF,GAEvD,IAAIF,EAAQ/G,KAAK0C,cAQjB,OANAqE,EAAMlE,SAAWA,EAEjBrC,EAAeR,KAAKkC,OAAQ6E,GAE5BA,EAAMjE,SAAW,KAEV9C,MAuBXmH,SAAU,SAAUrE,EAAUlB,EAAMqF,GAEhC,OAAOjH,KAAKkH,aAAa,EAAG,EAAGlH,KAAKiC,WAAWF,MAAO/B,KAAKiC,WAAWD,OAAQc,EAAUlB,EAAMqF,IA2BlGC,aAAc,SAAUvE,EAAGC,EAAGb,EAAOC,EAAQc,EAAUlB,EAAMqF,GAEzD,IAAIF,EAAQ/G,KAAK0C,cAWjB,OATAqE,EAAMjE,SAAWA,EACjBiE,EAAMnF,KAAOA,EACbmF,EAAMhE,QAAUkE,EAChBF,EAAMlE,UAAW,EACjBkE,EAAMpE,EAAIA,EACVoE,EAAMnE,EAAIA,EACVmE,EAAMhF,MAAQqF,KAAKC,IAAItF,EAAO/B,KAAKiC,WAAWF,OAC9CgF,EAAM/E,OAASoF,KAAKC,IAAIrF,EAAQhC,KAAKiC,WAAWD,QAEzChC,MAwBXsH,cAAe,SAAU3E,EAAGC,EAAGE,GAM3B,OAJA9C,KAAKkH,aAAavE,EAAGC,EAAG,EAAG,EAAGE,GAE9B9C,KAAK0C,cAAcG,UAAW,EAEvB7C,MAcXuH,YAAa,SAAUC,EAAQC,EAAOxC,EAAQyC,GAE1C,IAAItF,EAAQ6C,EAAO7C,MAAQoF,EAAOpF,MAElC,GAAc,IAAVA,EAAJ,CAMA,IAAIkC,EAAMtE,KAAKwC,eAEXmF,EAAY3H,KAAKgD,aACjB4E,EAAe5H,KAAKiD,aAEpB4E,EAAKJ,EAAMK,WAEXC,EAASF,EAAGlF,EACZqF,EAASH,EAAGjF,EACZqF,EAAaR,EAAMS,SACnBC,EAAcV,EAAMW,UACpBC,EAAcZ,EAAMY,YAEpBC,EAAMb,EAAMc,OAAOC,WAEnBC,EAAiBjB,EAAOiB,eACxBC,EAAiBlB,EAAOkB,eAExB/F,GAAK8F,EAAiBhB,EAAM9E,EAC5BC,GAAK8F,EAAiBjB,EAAM7E,EAEhC,GAAI4E,EAAOmB,UACX,CACI,IAAIC,EAAOpB,EAAOqB,MAEdD,EAAKE,QAAUtB,EAAOsB,OAASF,EAAKG,QAAUvB,EAAOuB,OAErDtB,EAAMuB,cAAcJ,EAAMpB,EAAOsB,MAAOtB,EAAOuB,OAGnDd,EAAaW,EAAKrD,GAClB4C,EAAcS,EAAKpD,GAEnBuC,EAASa,EAAKvD,GACd2C,EAASY,EAAKtD,GAEd3C,GAAK8F,EAAiBG,EAAKjG,EAC3BC,GAAK8F,EAAiBE,EAAKhG,EAEvB4E,EAAOsB,QAEHnG,GAAK,EAELA,IAAMA,EAAIsF,GAELtF,EAAI,IAETA,EAAKyE,KAAK6B,IAAItG,GAAKsF,IAIvBT,EAAOuB,QAEHnG,GAAK,EAELA,IAAMA,EAAIuF,GAELvF,EAAI,IAETA,EAAKwE,KAAK6B,IAAIrG,GAAKuF,IAK/B,IAAIW,EAAQ,EACRC,EAAQ,EAERvB,EAAOsB,QAEFT,IAED1F,IAAO8E,EAAMyB,UAA8B,EAAjBT,GAG9BK,GAAS,GAITtB,EAAOuB,QAEFV,IAEDzF,IAAO6E,EAAM0B,WAA+B,EAAjBT,GAG/BK,GAAS,GAGbnB,EAAawB,UAAU5B,EAAO7E,EAAG6E,EAAO5E,EAAG4E,EAAO6B,SAAU7B,EAAO8B,OAASR,EAAOtB,EAAO+B,OAASR,GAEnGpB,EAAU6B,SAASvE,EAAOiB,QAEtBwB,GAGAC,EAAU8B,mBAAmB/B,GAAwBzC,EAAOyE,QAAUlC,EAAOmC,eAAgB1E,EAAO2E,QAAUpC,EAAOqC,eAGrHjC,EAAakC,EAAItC,EAAO7E,EACxBiF,EAAamC,EAAIvC,EAAO5E,IAIxBgF,EAAakC,GAAK7E,EAAOyE,QAAUlC,EAAOmC,cAC1C/B,EAAamC,GAAK9E,EAAO2E,QAAUpC,EAAOqC,eAI9ClC,EAAUqC,SAASpC,GAEnBtD,EAAIM,OAEJ+C,EAAUsC,aAAa3F,GAEvBA,EAAI5E,yBAA2BM,KAAKyC,WAAW+E,EAAOpD,WAEtDE,EAAIE,YAAcpC,EAElBkC,EAAI4F,yBAA2BlK,KAAK0B,WAAa+F,EAAMc,OAAO4B,WAE1D3C,EAAO1B,MAEP0B,EAAO1B,KAAKC,gBAAgB/F,KAAMwH,EAAQvC,GAG9CX,EAAI3E,UAAU8H,EAAMc,OAAO6B,MAAOrC,EAAQC,EAAQC,EAAYE,EAAaxF,EAAGC,EAAGqF,EAAaK,EAAKH,EAAcG,GAE7Gd,EAAO1B,MAEP0B,EAAO1B,KAAKS,iBAAiBvG,KAAMwH,EAAQvC,GAG/CX,EAAIqC,YASR0D,QAAS,WAELrK,KAAKsK,qBAELtK,KAAKoB,KAAO,KACZpB,KAAKiC,WAAa,KAClBjC,KAAKuC,YAAc,QAK3BxD,EAAOC,QAAUiC,G,gBC/zBjB,IAAIsJ,EAAQ,EAAQ,OAChB3L,EAAiB,EAAQ,OAkD7BG,EAAOC,QAtCa,WAEhB,IAAIwL,EAAS,GACTC,EAAS7L,EAAeE,qBACxB4L,EAAK,cA+BT,OA7BAF,EAAOD,EAAMI,QAAUD,EACvBF,EAAOD,EAAMK,KAAO,UACpBJ,EAAOD,EAAMM,UAAY,EAAW,WAAaH,EACjDF,EAAOD,EAAMO,QAAU,EAAW,SAAWJ,EAC7CF,EAAOD,EAAMQ,SAAW,EAAW,UAAYL,EAC/CF,EAAOD,EAAMS,QAAU,EAAW,SAAWN,EAC7CF,EAAOD,EAAMU,SAAW,EAAW,UAAYP,EAC/CF,EAAOD,EAAMW,aAAe,EAAW,cAAgBR,EACvDF,EAAOD,EAAMY,YAAc,EAAW,aAAeT,EACrDF,EAAOD,EAAMa,YAAc,EAAW,aAAeV,EACrDF,EAAOD,EAAMc,YAAc,EAAW,aAAeX,EACrDF,EAAOD,EAAMe,YAAc,EAAW,aAAeZ,EACrDF,EAAOD,EAAMgB,WAAa,EAAW,YAAcb,EACnDF,EAAOD,EAAMiB,KAAO,EAAW,MAAQd,EACvCF,EAAOD,EAAMkB,YAAc,EAAW,aAAef,EACrDF,EAAOD,EAAMmB,OAAS,EAAW,QAAUhB,EAC3CF,EAAOD,EAAMoB,YAAc,EAAW,aAAejB,EACrDF,EAAOD,EAAMqB,OAAS,kBACtBpB,EAAOD,EAAMsB,WAAa,YAC1BrB,EAAOD,EAAMuB,YAAc,aAC3BtB,EAAOD,EAAMwB,aAAe,cAC5BvB,EAAOD,EAAMyB,kBAAoB,mBACjCxB,EAAOD,EAAM0B,gBAAkB,iBAC/BzB,EAAOD,EAAM2B,iBAAmB,kBAChC1B,EAAOD,EAAM4B,kBAAoB,mBACjC3B,EAAOD,EAAM6B,SAAW,UACxB5B,EAAOD,EAAM8B,MAAQ,OACrB7B,EAAOD,EAAM+B,KAAO,MAEb9B,I,UCvCXzL,EAAOC,QAAU,c,SCCjBD,EAAOC,QAAU,a,SCGjBD,EAAOC,QAAU,U,UCDjBD,EAAOC,QAAU,U,gBCRjBD,EAAOC,QAAU,CAEb4H,YAAa,EAAQ,OACrB/B,WAAY,EAAQ,MACpBO,OAAQ,EAAQ,MAChBxB,OAAQ,EAAQ,S,gBCTpB,IAAIjF,EAAa,EAAQ,OACrB4N,EAAQ,EAAQ,OAChBC,EAAe,EAAQ,OA8E3BzN,EAAOC,QAhEc,SAAUkD,EAAQX,GAEnC,IAAIuB,EAAW0J,EAAajL,EAAQ,YAChCK,EAAO4K,EAAajL,EAAQ,OAAQ,aACpC0F,EAAiBuF,EAAajL,EAAQ,UAAW,KACjDoB,EAAIyE,KAAK6B,IAAI7B,KAAKqF,MAAMD,EAAajL,EAAQ,IAAK,KAClDqB,EAAIwE,KAAK6B,IAAI7B,KAAKqF,MAAMD,EAAajL,EAAQ,IAAK,KAClDQ,EAAQyK,EAAajL,EAAQ,QAASW,EAAOH,OAC7CC,EAASwK,EAAajL,EAAQ,SAAUW,EAAOF,QAGnD,GAFewK,EAAajL,EAAQ,YAAY,GAGhD,CACI,IAEI1B,EAFUqC,EAAOzC,WAAW,MACRG,aAAa+C,EAAGC,EAAG,EAAG,GACzB/C,KAErBiD,EAASzB,KAAK,KAAM,IAAIkL,EAAM1M,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAK,WAElE,GAAU,IAAN8C,GAAiB,IAANC,GAAWb,IAAUG,EAAOH,OAASC,IAAWE,EAAOF,OAC3E,CAEI,IAAI0K,EAAa/N,EAAWgO,YAAY3M,KAAM+B,EAAOC,GAC3C0K,EAAWjN,WAAW,MAE5BE,UAAUuC,EAAQS,EAAGC,EAAGb,EAAOC,EAAQ,EAAG,EAAGD,EAAOC,GAExD,IAAI4K,EAAS,IAAIxN,MAEjBwN,EAAOC,QAAU,WAEb/J,EAASzB,KAAK,MAEd1C,EAAWmB,OAAO4M,IAGtBE,EAAOvN,OAAS,WAEZyD,EAASzB,KAAK,KAAMuL,GAEpBjO,EAAWmB,OAAO4M,IAGtBE,EAAO7M,IAAM2M,EAAWI,UAAUlL,EAAMqF,OAG5C,CAEI,IAAI8F,EAAS,IAAI3N,MAEjB2N,EAAOF,QAAU,WAEb/J,EAASzB,KAAK,OAGlB0L,EAAO1N,OAAS,WAEZyD,EAASzB,KAAK,KAAM0L,IAGxBA,EAAOhN,IAAMmC,EAAO4K,UAAUlL,EAAMqF,M,gBC5E5C,IAAItI,EAAa,EAAQ,OACrB4N,EAAQ,EAAQ,OAChBC,EAAe,EAAQ,OAiG3BzN,EAAOC,QAnFa,SAAUgO,EAAczL,GAExC,IAAI0L,EAAKD,EAAavN,WAAW,sBAE7BqD,EAAW0J,EAAajL,EAAQ,YAChCK,EAAO4K,EAAajL,EAAQ,OAAQ,aACpC0F,EAAiBuF,EAAajL,EAAQ,UAAW,KACjDoB,EAAI6J,EAAajL,EAAQ,IAAK,GAC9BqB,EAAI4J,EAAajL,EAAQ,IAAK,GAE9BsB,EAAW2J,EAAajL,EAAQ,YAAY,GAE5C2L,EAAgBV,EAAajL,EAAQ,iBAAiB,GAEtD4L,EAAc,EAAkBX,EAAajL,EAAQ,cAAe,GAAK0L,EAAGG,mBAC5EC,EAAe,EAAkBb,EAAajL,EAAQ,eAAgB,GAAK0L,EAAGK,oBAElF,GAAIzK,EACJ,CACI,IAAI0K,EAAQ,IAAIC,WAAW,GAEvBC,EAAQ,EAAkB7K,EAAIyK,EAAezK,EAEjDqK,EAAGS,WAAW/K,EAAG8K,EAAO,EAAG,EAAGR,EAAGU,KAAMV,EAAGW,cAAeL,GAEzDzK,EAASzB,KAAK,KAAM,IAAIkL,EAAMgB,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAK,UAG3E,CACI,IAAIxL,EAAQyK,EAAajL,EAAQ,QAAS4L,GACtCnL,EAASwK,EAAajL,EAAQ,SAAU8L,GAIxCQ,EAAS,IAAIL,WAFLzL,EAAQC,EAAS,GAI7BiL,EAAGS,WAAW/K,EAAG0K,EAAezK,EAAIZ,EAAQD,EAAOC,EAAQiL,EAAGU,KAAMV,EAAGW,cAAeC,GAWtF,IATA,IAAI3L,EAASvD,EAAWgO,YAAY3M,KAAM+B,EAAOC,GAC7CsC,EAAMpC,EAAOzC,WAAW,MAExBqO,EAAYxJ,EAAI1E,aAAa,EAAG,EAAGmC,EAAOC,GAE1CnC,EAAOiO,EAAUjO,KAIZkO,EAAK,EAAGA,EAAK/L,EAAQ+L,IAE1B,IAAK,IAAIC,EAAK,EAAGA,EAAKjM,EAAOiM,IAC7B,CACI,IAAIC,EAAiD,IAAjCjM,EAAS+L,EAAK,GAAKhM,EAAQiM,GAC3CE,EAAgC,GAAnBH,EAAKhM,EAAQiM,GAE9BnO,EAAKqO,EAAY,GAAKL,EAAOI,EAAc,GAC3CpO,EAAKqO,EAAY,GAAKL,EAAOI,EAAc,GAC3CpO,EAAKqO,EAAY,GAAKL,EAAOI,EAAc,GAC3CpO,EAAKqO,EAAY,GAAKL,EAAOI,EAAc,GAInD3J,EAAIlE,aAAa0N,EAAW,EAAG,GAE/B,IAAI1D,EAAQ,IAAIhL,MAEhBgL,EAAMyC,QAAU,WAEZ/J,EAASzB,KAAK,MAEd1C,EAAWmB,OAAOoC,IAGtBkI,EAAM/K,OAAS,WAEXyD,EAASzB,KAAK,KAAM+I,GAEpBzL,EAAWmB,OAAOoC,IAGtBkI,EAAMrK,IAAMmC,EAAO4K,UAAUlL,EAAMqF,M,gBC/F3C,IAAIxG,EAAQ,EAAQ,OAChBC,EAAQ,EAAQ,OAChByN,EAAY,EAAQ,OAGpBC,EAAqB,EAAQ,OAC7BC,EAAmB,EAAQ,OAC3BC,EAAgB,EAAQ,OACxBC,EAAgB,EAAQ,OACxBC,EAAqB,EAAQ,OAC7BC,EAAe,EAAQ,OACvBC,EAAiB,EAAQ,OACzBC,EAAkB,EAAQ,OA+B1BC,EAAkB,IAAInO,EAAM,CAE5BU,WAEA,SAA0B0N,GAStB7O,KAAKoB,KAAOyN,EAASzN,KASrBpB,KAAK6O,SAAWA,EAWhB7O,KAAK8O,QAAU,IAAIX,EAAU,CACzB,CAAEzN,EAAMqO,iBAAkBJ,GAC1B,CAAEjO,EAAMsO,eAAgBT,GACxB,CAAE7N,EAAMuO,oBAAqBb,GAC7B,CAAE1N,EAAMwO,gBAAiBR,GACzB,CAAEhO,EAAMyO,cAAeV,GACvB,CAAE/N,EAAM0O,eAAgBd,GACxB,CAAE5N,EAAM2O,oBAAqBb,GAC7B,CAAE9N,EAAM4O,kBAAmBjB,KAU/BrO,KAAKuP,oBAAsB,IAAIpB,EAW/BnO,KAAKwP,UAAY,IAAIrB,EAUrBnO,KAAKyP,QAAU,KAYfzP,KAAK0P,SAAW,KAahB1P,KAAKgP,eAAiB,KAatBhP,KAAKiP,oBAAsB,KAU3BjP,KAAK+O,iBAAmB,KAgBxB/O,KAAK2P,WAgBL3P,KAAK4P,WAgBL5P,KAAK6P,WAgBL7P,KAAK8P,YAgBTtM,KAAM,SAAUuM,GAIZ,IAAIC,EACAC,EAEAC,EAAQlQ,KACRoB,EAAOpB,KAAKoB,KAwBhB,GAtBApB,KAAK8O,QAAQqB,MAAK,SAAUF,EAAcG,GAEtCJ,EAAWE,EAAMG,IAAIJ,EAAc,IAAIG,EAAS,CAAEhP,KAAMA,KAEpD6O,IAAiBvP,EAAMqO,mBAEvBmB,EAAMnB,iBAAmBiB,EAGzBE,EAAMP,WAAaK,EAASL,WAC5BO,EAAMN,WAAaI,EAASJ,WAC5BM,EAAML,WAAaG,EAASH,WAC5BK,EAAMJ,WAAaE,EAASF,eAKpC9P,KAAKgP,eAAiBhP,KAAKsQ,IAAI5P,EAAMsO,gBACrChP,KAAKiP,oBAAsBjP,KAAKsQ,IAAI5P,EAAMuO,qBAItCc,EAEA,IAAKE,KAAgBF,EACrB,CACI,IAAIQ,EAAgBR,EAAeE,IAEnCD,EAAW,IAAIO,EAAcnP,IAEhBoP,SAETxQ,KAAKuP,oBAAoBkB,IAAIR,EAAcM,GAErCvQ,KAAK0Q,IAAIT,KAEfjQ,KAAK8O,QAAQ2B,IAAIR,EAAcM,GAE/BvQ,KAAKqQ,IAAIJ,EAAcD,MAmCvCK,IAAK,SAAUM,EAAMP,GAEjB,IAAIA,EAASI,SAAb,CAOA,IAAIhB,EAAYxP,KAAKwP,UACjBX,EAAW7O,KAAK6O,SAwBpB,OAtBKW,EAAUkB,IAAIC,GASfC,QAAQC,KAAK,oBAAsBF,IAPnCP,EAASO,KAAOA,EAChBP,EAASU,QAAU9Q,KAEnBwP,EAAUiB,IAAIE,EAAMP,IAOnBA,EAASW,WAEVX,EAAS5M,OAGU,IAAnBqL,EAAS9M,OAAmC,IAApB8M,EAAS7M,QAEjCoO,EAAStM,OAAO+K,EAAS9M,MAAO8M,EAAS7M,QAGtCoO,EA9BHQ,QAAQC,KAAKF,EAAO,uDA4D5BK,gBAAiB,SAAUL,EAAMP,GAExBpQ,KAAKuP,oBAAoBmB,IAAIC,IAE9B3Q,KAAKuP,oBAAoBkB,IAAIE,EAAMP,IAU3Ca,MAAO,WAECjR,KAAKyP,SAELzP,KAAKyP,QAAQwB,SAcrBP,IAAK,SAAUN,GAEX,IAAIZ,EAAYxP,KAAKwP,UAErB,MAAwB,iBAAbY,EAEAZ,EAAUkB,IAAIN,KAEhBZ,EAAU0B,SAASd,IAoBhCE,IAAK,SAAUF,GAEX,IAAIZ,EAAYxP,KAAKwP,UAErB,MAAwB,iBAAbY,EAEAZ,EAAUc,IAAIF,GAEhBZ,EAAU0B,SAASd,GAEjBA,OAFN,GAmBTe,gBAAiB,SAAUf,EAAUgB,GAEjC,IAEIpB,EAFAqB,EAAkBrR,KAAKuP,oBAsB3B,GAlBwB,iBAAba,EAEPJ,EAAWqB,EAAgBf,IAAIF,GAEN,mBAAbA,EAGRiB,EAAgBH,SAASd,KAEzBJ,EAAWI,GAGU,iBAAbA,IAGZJ,EAAWqB,EAAgBf,IAAIF,EAASO,OAGxCX,EACJ,CACI,IAAIsB,EAAc,IAAItB,EAAShQ,KAAKoB,MAOpC,OALIgQ,IAEAE,EAAYF,WAAaA,GAGtBE,IAmBfxR,OAAQ,SAAU6Q,EAAMY,EAAaC,QAEbtS,IAAhBqS,IAA6BA,GAAc,QACfrS,IAA5BsS,IAAyCA,GAA0B,GAEvExR,KAAKwP,UAAUiC,OAAOd,GAElBY,GAEAvR,KAAK8O,QAAQ2C,OAAOd,GAGpBa,GAEAxR,KAAKuP,oBAAoBkC,OAAOd,IAuBxCF,IAAK,SAAUL,EAAUgB,EAAYM,GAEjC,IAAItB,EAASI,SAuBb,OAlBKxQ,KAAK2R,UAAUvB,EAAUsB,KAE1B1R,KAAKiR,QAEDjR,KAAKyP,SAELzP,KAAKyP,QAAQmC,SAGjB5R,KAAKyP,QAAUW,EAEfA,EAASyB,KAAKH,IAGlBtB,EAAS0B,yBAET1B,EAAS2B,OAAOX,GAEThB,GAcX4B,SAAU,SAAUZ,GAEhB,GAAIA,EAAWa,gBACf,CACIjS,KAAKiR,QAKL,IAHA,IAAIzB,EAAY4B,EAAWc,cAGlB9L,EAAIoJ,EAAUrK,OAAS,EAAGiB,GAAK,EAAGA,IAC3C,CACI,IAAIgK,EAAWZ,EAAUpJ,GAErBgK,EAAS+B,QAET/B,EAAS4B,SAASZ,MAiBlCgB,UAAW,SAAUhB,GAEjB,GAAIA,EAAWa,gBACf,CACIjS,KAAKiR,QAIL,IAFA,IAAIzB,EAAY4B,EAAWc,cAElB9L,EAAI,EAAGA,EAAIoJ,EAAUrK,OAAQiB,IACtC,CACI,IAAIgK,EAAWZ,EAAUpJ,GAErBgK,EAAS+B,QAET/B,EAASgC,UAAUhB,MAiBnCiB,eAAgB,SAAUpN,GAEtB,GAAIA,EAAOgN,gBACX,CACIjS,KAAKiR,QAKL,IAHA,IAAIzB,EAAYvK,EAAOiN,cAGd9L,EAAIoJ,EAAUrK,OAAS,EAAGiB,GAAK,EAAGA,IAC3C,CACI,IAAIgK,EAAWZ,EAAUpJ,GAErBgK,EAAS+B,QAET/B,EAAS4B,SAAS/M,MAiBlCqN,gBAAiB,SAAUrN,GAEvB,GAAIA,EAAOgN,gBACX,CACIjS,KAAKiR,QAIL,IAFA,IAAIzB,EAAYvK,EAAOiN,cAEd9L,EAAI,EAAGA,EAAIoJ,EAAUrK,OAAQiB,IACtC,CACI,IAAIgK,EAAWZ,EAAUpJ,GAErBgK,EAAS+B,QAET/B,EAASgC,UAAUnN,MAkBnC0M,UAAW,SAAUvB,EAAUsB,GAE3B,IAAI7C,EAAW7O,KAAK6O,SAChBY,EAAUzP,KAAKyP,QAOnB,OALIA,IAAYiC,IAEZA,EAAgBjC,EAAQiC,iBAGnBjC,IAAYW,GAAYsB,EAAca,UAAY1D,EAAS2D,iBAyBxEC,UAAW,SAAUlK,EAAQmK,EAAQC,EAAYC,EAAOC,GAIpD,OAFA7S,KAAK8S,WAAW9S,KAAK+O,iBAAiBgE,YAAYN,UAAUlK,EAAQmK,EAAQC,EAAYC,EAAOC,GAExF7S,MAkBXgT,WAAY,SAAUzK,GAIlB,OAFAvI,KAAK8S,WAAW9S,KAAK+O,iBAAiBgE,YAAYC,WAAWzK,GAEtDvI,MAwBXiT,UAAW,SAAU1K,EAAQmK,EAAQG,EAAYK,GAI7C,OAFAlT,KAAK8S,WAAW9S,KAAK+O,iBAAiBoE,mBAAmBF,UAAU1K,EAAQmK,EAAQG,EAAYK,GAExFlT,MAoBXoT,YAAa,SAAUC,EAASC,EAASZ,EAAQa,EAAUV,GAIvD,OAFA7S,KAAK8S,WAAW9S,KAAK+O,iBAAiByE,cAAcJ,YAAYC,EAASC,EAASZ,EAAQa,EAAUV,GAE7F7S,MAoBXyT,oBAAqB,SAAUJ,EAASC,EAASZ,EAAQa,EAAUV,GAI/D,OAFA7S,KAAK8S,WAAW9S,KAAK+O,iBAAiB2E,WAAWD,oBAAoBJ,EAASC,EAASZ,EAAQa,EAAUV,GAElG7S,MAcX2T,WAAY,SAAUjB,EAAQG,GAI1B,OAFA7S,KAAK+O,iBAAiB4E,WAAWjB,EAAQG,GAElC7S,MAwBX4T,UAAW,SAAUrL,EAAQmK,EAAQC,EAAYC,EAAOC,EAAYgB,GAIhE,OAFA7T,KAAK8S,WAAW9S,KAAK+O,iBAAiBgE,YAAYa,UAAUrL,EAAQmK,EAAQC,EAAYC,EAAOC,EAAYgB,GAEpG7T,MA0BX8T,cAAe,SAAUvL,EAAQmK,EAAQ/P,EAAGC,EAAGb,EAAOC,EAAQ4Q,EAAOC,GAIjE,OAFA7S,KAAK+O,iBAAiB+E,cAAcvL,EAAQmK,EAAQ/P,EAAGC,EAAGb,EAAOC,EAAQ4Q,EAAOC,GAEzE7S,MAWX+T,UAAW,WAEP,OAAQ/T,KAAKyP,SAAWzP,KAAKyP,QAAQsE,WAazCC,SAAU,WAEN,OAAOhU,KAAKyQ,IAAIzQ,KAAKgP,iBAazB8D,WAAY,SAAUpB,GAElB,OAAO1R,KAAK+O,iBAAiB8C,KAAKH,IAuBtCuC,OAAQ,SAAU7D,QAEGlR,IAAbkR,GAA0BpQ,KAAK0P,WAE/BU,EAAWpQ,KAAK0P,UAGpB,IAAIb,EAAW7O,KAAK6O,SAChB5B,EAAK4B,EAAS5B,GAElBA,EAAGiH,QAAQjH,EAAGkH,YACdlH,EAAGiH,QAAQjH,EAAGmH,WAEVvF,EAASwF,uBAETpH,EAAG2F,MAAM3F,EAAGqH,mBAKZrH,EAAGiH,QAAQjH,EAAGsH,cACdtH,EAAG2F,MAAM3F,EAAGqH,iBAAmBrH,EAAGuH,qBAGtCvH,EAAGwH,SAAS,EAAG,EAAG5F,EAAS9M,MAAO8M,EAAS7M,QAE3C6M,EAAS2D,eAAiB,KAE1B3D,EAAS1K,aAAa,GAAG,GAEzB,IAAIuQ,EAAU1U,KAAKwP,UAAUkF,QAE7B,IAAK,IAAIC,KAAOD,EAEZA,EAAQC,GAAKC,SAAU,EAGvBxE,IAEApQ,KAAKyP,QAAUW,EAEfA,EAAS6D,UAGbpF,EAASgG,iBAebjC,MAAO,WAEH,IAAI/D,EAAW7O,KAAK6O,SAEpB7O,KAAKiR,QAEDjR,KAAKyP,SAELzP,KAAKyP,QAAQmC,SACb5R,KAAK0P,SAAW1P,KAAKyP,QACrBzP,KAAKyP,QAAU,MAIfzP,KAAK0P,SAAW,KAGpBb,EAAS2D,eAAiB,KAE1B3D,EAAS1K,aAAa,GAAG,IAS7BkG,QAAS,WAELrK,KAAKiR,QAELjR,KAAK8O,QAAQ8D,QACb5S,KAAKuP,oBAAoBqD,QACzB5S,KAAKwP,UAAUoD,QAEf5S,KAAK6O,SAAW,KAChB7O,KAAKoB,KAAO,KACZpB,KAAK8O,QAAU,KACf9O,KAAKuP,oBAAsB,KAC3BvP,KAAKwP,UAAY,KACjBxP,KAAKyP,QAAU,KACfzP,KAAK0P,SAAW,QAKxB3Q,EAAOC,QAAU4P,G,gBC7lCjB,IAAInO,EAAQ,EAAQ,OAChBqU,EAAW,EAAQ,OACnBnU,EAAe,EAAQ,OACvBC,EAAS,EAAQ,OACjB4L,EAAe,EAAQ,OACvBuI,EAAU,EAAQ,OAClBC,EAAiB,EAAQ,OACzBC,EAAe,EAAQ,OACvBC,EAAQ,EAAQ,OAChBC,EAAc,EAAQ,OAmCtBC,EAAgB,IAAI3U,EAAM,CAE1BS,QAASP,EAETQ,WAEA,SAAwBI,GAEpBZ,EAAaU,KAAKrB,MAElB,IAAIoB,EAAOG,EAAOH,KACdyN,EAAWzN,EAAKyN,SAChB5B,EAAK4B,EAAS5B,GASlBjN,KAAK2Q,KAAOnE,EAAajL,EAAQ,OAAQ,iBASzCvB,KAAKoB,KAAOA,EASZpB,KAAK6O,SAAWA,EAYhB7O,KAAK8Q,QASL9Q,KAAKiN,GAAKA,EASVjN,KAAKqV,KAAOjU,EAAKc,OASjBlC,KAAK+B,MAAQ,EASb/B,KAAKgC,OAAS,EAUdhC,KAAKsV,YAAc,EAWnBtV,KAAKuV,eAAiB,EAatBvV,KAAKwV,WAaLxV,KAAKyV,aAWLzV,KAAK0V,SAAWlJ,EAAajL,EAAQ,WAAY0L,EAAG0I,WASpD3V,KAAK4V,MASL5V,KAAK6V,cASL7V,KAAK8V,cAWL9V,KAAKmS,QAAS,EAWdnS,KAAK+V,YAAc,EAWnB/V,KAAK+T,UAAYvH,EAAajL,EAAQ,aAAa,GAanDvB,KAAK+Q,WAAY,EAUjB/Q,KAAKwQ,UAAW,EAShBxQ,KAAKgW,cAAgB,GASrBhW,KAAKiW,oBAeLjW,KAAKkW,QAAU,GAYflW,KAAK0R,cASL1R,KAAKmW,iBASLnW,KAAKoW,gBAAkB,EASvBpW,KAAKqW,iBAAmB,EAaxBrW,KAAKuB,OAASA,EAadvB,KAAK4U,SAAU,GAanBpR,KAAM,WAEF,IAAI4C,EACA6G,EAAKjN,KAAKiN,GACV1L,EAASvB,KAAKuB,OACdsN,EAAW7O,KAAK6O,SAEf7O,KAAKwQ,WAENxQ,KAAKmW,kBAAmB,IAAIpB,GAAUuB,YAK1C,IAAIN,EAAgBhW,KAAKgW,cAErBO,EAAU/J,EAAajL,EAAQ,gBAAgB,GAG3B,kBAAd,GAA2BgV,IAEjCA,EAAU,GAGd,IAAIxU,EAAQ8M,EAAS9M,MACjBC,EAAS6M,EAAS7M,OAEtB,GAAwB,iBAAd,EAGN,IAAKoE,EAAI,EAAGA,EAAImQ,EAASnQ,IAErB4P,EAAcQ,KAAK,IAAIvB,EAAapG,EAAU9M,EAAOC,EAAQ,EAAG,GAAG,SAGtE,GAAIyU,MAAMC,QAAQH,GAEnB,IAAKnQ,EAAI,EAAGA,EAAImQ,EAAQpR,OAAQiB,IAChC,CACI,IAAI1C,EAAQ8I,EAAa+J,EAAQnQ,GAAI,QAAS,GAC1CuQ,EAAYnK,EAAa+J,EAAQnQ,GAAI,YAAa,GAClDwQ,EAAYpK,EAAa+J,EAAQnQ,GAAI,YAAa,GAEtD4P,EAAcQ,KAAK,IAAIvB,EAAapG,EAAU9M,EAAOC,EAAQ0B,EAAOiT,EAAWC,IAInFZ,EAAc7Q,SAGdnF,KAAKiW,oBAAsBD,EAAc,IAK7ChW,KAAK6W,qBAAqBtV,GAG1B,IAAI2U,EAAUlW,KAAKkW,QACfY,EAAa,EAEjB,IAAK1Q,EAAI,EAAGA,EAAI8P,EAAQ/Q,OAAQiB,IAExB8P,EAAQ9P,GAAG0Q,WAAaA,IAExBA,EAAaZ,EAAQ9P,GAAG0Q,YAIhC,IAAIC,EAAYvK,EAAajL,EAAQ,YAAasN,EAAStN,OAAOwV,WAIlE/W,KAAKuV,eAA6B,EAAZwB,EAEtB,IAAIlX,EAAO,IAAImX,YAAYhX,KAAKuV,eAAiBuB,GAEjD9W,KAAKwV,WAAa3V,EAClBG,KAAK4V,MAAQ,IAAIpI,WAAW3N,GAC5BG,KAAK6V,cAAgB,IAAIoB,aAAapX,GACtCG,KAAK8V,cAAgB,IAAIoB,YAAYrX,GAErC,IAAIsX,EAAc3K,EAAajL,EAAQ,WAAY,MAiBnD,IAfI4V,GAEAnX,KAAK6V,cAAcpF,IAAI0G,GAEvBnX,KAAKyV,aAAe5G,EAASuI,mBAAmBvX,EAAMoN,EAAGoK,cAIzDrX,KAAKyV,aAAe5G,EAASuI,mBAAmBvX,EAAKyX,WAAYrK,EAAGsK,cAKxEvX,KAAKwX,kBAEApR,EAAI8P,EAAQ/Q,OAAS,EAAGiB,GAAK,EAAGA,IAEjC8P,EAAQ9P,GAAG6N,SAGfjU,KAAK+Q,WAAY,EAEjBlC,EAASlL,GAAGqR,EAAepR,OAAQ5D,KAAK8D,OAAQ9D,MAChD6O,EAASlL,GAAGqR,EAAenQ,WAAY7E,KAAKyX,YAAazX,MACzD6O,EAASlL,GAAGqR,EAAe5P,OAAQpF,KAAK0X,SAAU1X,MAClD6O,EAASlL,GAAGqR,EAAepO,YAAa5G,KAAK2X,aAAc3X,MAE3DA,KAAKgE,KAAKpD,EAAOgX,KAAM5X,MAEvBA,KAAK6X,UAWTA,OAAQ,aAgBRhU,SAAU,aAeViU,UAAW,SAAUC,EAAQC,GAEzB,IAAInJ,EAAW7O,KAAK6O,SAoBpB,OAlBIkJ,IAAW/X,KAAK0R,eAAiB7C,EAAS2D,iBAAmBxS,KAAK0R,cAAca,UAEhFvS,KAAKiR,QAELpC,EAASgG,gBAEM7U,KAAKwX,oBAEHQ,IAEbA,GAAgB,GAGpBD,EAAOlG,KAAKmG,GAAe,GAE3BhY,KAAK0R,cAAgBqG,GAGlB/X,MAaXiY,gBAAiB,SAAUtH,GAIvB,IAFA,IAAIuF,EAAUlW,KAAKkW,QAEV9P,EAAI,EAAGA,EAAI8P,EAAQ/Q,OAAQiB,IAEhC,GAAI8P,EAAQ9P,GAAGuK,OAASA,EAEpB,OAAOuF,EAAQ9P,IAmB3ByQ,qBAAsB,SAAUtV,GAE5B,IAAI6E,EACA8P,EAAUlW,KAAKkW,QACfrH,EAAW7O,KAAK6O,SAEpB,IAAKzI,EAAI,EAAGA,EAAI8P,EAAQ/Q,OAAQiB,IAE5B8P,EAAQ9P,GAAGiE,UAGf,IAAI6N,EAAQ,aACRC,EAAQ,aACRC,EAAQ,aAERC,EAAoB7L,EAAajL,EAAQ2W,EAAO,MAChDI,EAAoBpD,EAAMqD,+BAA+B/L,EAAajL,EAAQ4W,EAAO,MAAOtJ,EAAS2J,aACrGC,EAAiBjM,EAAajL,EAAQ6W,EAAO,MAE7CM,EAAgBlM,EAAajL,EAAQ,UAAW,IAEhDoX,EAAMD,EAAcvT,OAExB,GAAY,IAARwT,EAEIN,GAAqBC,IAErBtY,KAAKkW,QAAU,CAAE,IAAIf,EAAYnV,KAAM,UAAWqY,EAAmBC,EAAmBxD,EAAS2D,UAIzG,CACI,IAAIG,EAAa,GAEjB,IAAKxS,EAAI,EAAGA,EAAIuS,EAAKvS,IACrB,CACI,IAAIyS,EAAcH,EAActS,GAE5BuK,EAAOnE,EAAaqM,EAAa,OAAQ,WAEzCC,EAAatM,EAAaqM,EAAaX,EAAOG,GAC9CU,EAAa7D,EAAMqD,+BAA+B/L,EAAaqM,EAAaV,EAAOG,GAAoBzJ,EAAS2J,aAChHQ,EAAaxM,EAAaqM,EAAaT,EAAOK,GAE9CK,GAAcC,GAEdH,EAAWpC,KAAK,IAAIrB,EAAYnV,KAAM2Q,EAAMmI,EAAYC,EAAYjE,EAASkE,KAIrFhZ,KAAKkW,QAAU0C,EAYnB,OAT4B,IAAxB5Y,KAAKkW,QAAQ/Q,OAEbyL,QAAQC,KAAK,aAAe7Q,KAAK2Q,KAAO,4BAIxC3Q,KAAK0R,cAAgB1R,KAAKkW,QAAQ,GAG/BlW,MAeXiZ,cAAe,SAAU7H,EAAY3J,GAMjC,YAJcvI,IAAVuI,IAAuBA,EAAQ2J,EAAW3J,OAE9CzH,KAAK+V,YAAc/V,KAAK6O,SAASqK,iBAAiBzR,EAAMc,QAEjDvI,KAAK+V,aAiBhBoD,YAAa,SAAUC,GAInB,YAFela,IAAXka,IAAwBA,EAAS,GAE7BpZ,KAAKsV,YAAc8D,EAASpZ,KAAKuV,gBAiB7CzR,OAAQ,SAAU/B,EAAOC,GAEjBD,IAAU/B,KAAK+B,OAASC,IAAWhC,KAAKgC,QAExChC,KAAKiR,QAGTjR,KAAK+B,MAAQA,EACb/B,KAAKgC,OAASA,EAId,IAFA,IAAIuU,EAAUvW,KAAKgW,cAEV5P,EAAI,EAAGA,EAAImQ,EAAQpR,OAAQiB,IAEhCmQ,EAAQnQ,GAAGtC,OAAO/B,EAAOC,GAS7B,OANAhC,KAAKqZ,oBAAoBtX,EAAOC,GAEhChC,KAAKgE,KAAKpD,EAAOgD,OAAQ7B,EAAOC,EAAQhC,MAExCA,KAAK6D,SAAS9B,EAAOC,GAEdhC,MAiBXqZ,oBAAqB,SAAUtX,EAAOC,GAElC,IAAImU,EAAmBnW,KAAKmW,iBAG5B,IAAKA,EAED,OAAOnW,KAGXA,KAAKoW,gBAAkBrU,EACvB/B,KAAKqW,iBAAmBrU,EAExBmU,EAAiBmD,MAAM,EAAGvX,EAAOC,EAAQ,GAAI,IAAM,KAMnD,IAJA,IAAIkU,EAAUlW,KAAKkW,QAEfvF,EAAO,oBAEFvK,EAAI,EAAGA,EAAI8P,EAAQ/Q,OAAQiB,IACpC,CACI,IAAI2R,EAAS7B,EAAQ9P,GAEjB2R,EAAOwB,WAAW5I,KAElBoH,EAAOyB,aAAa7I,GAEpBoH,EAAO0B,aAAa9I,GAAM,EAAOwF,EAAiBuD,IAAK3B,IAI/D,OAAO/X,MAaX8R,uBAAwB,WAEpB,GAAI9R,KAAKmW,iBACT,CACI,IAAIwD,EAAc3Z,KAAK6O,SAASuH,gBAC5BwD,EAAe5Z,KAAK6O,SAASwH,iBAE7BrW,KAAKoW,kBAAoBuD,GAAe3Z,KAAKqW,mBAAqBuD,GAElE5Z,KAAKqZ,oBAAoBM,EAAaC,KAmBlD/H,KAAM,SAAUH,GAIZ,QAFsBxS,IAAlBwS,IAA+BA,EAAgB1R,KAAK0R,eAEpD1R,KAAK4U,QAEL,OAAO5U,KAAKiU,OAAOvC,GAGvB,IAAImI,EAAW7Z,KAAKwX,kBAUpB,OARA9F,EAAcG,KAAKgI,GAEnB7Z,KAAK0R,cAAgBA,EAErB1R,KAAKgE,KAAKpD,EAAOkZ,KAAM9Z,KAAM0R,GAE7B1R,KAAK+Z,SAASrI,GAEP1R,MAgBXiU,OAAQ,SAAUvC,GAEd1R,KAAKwX,kBAKL,IAHA,IAAItB,EAAUlW,KAAKkW,QAGV9P,EAAI8P,EAAQ/Q,OAAS,EAAGiB,GAAK,EAAGA,IACzC,CACI,IAAI2R,EAAS7B,EAAQ9P,GAAG6N,SAEnBvC,GAAiBqG,IAAWrG,IAE7B1R,KAAK0R,cAAgBqG,GAY7B,OARA/X,KAAKgE,KAAKpD,EAAOoZ,OAAQha,KAAK0R,eAE9B1R,KAAK+Z,SAAS/Z,KAAK0R,eAEnB1R,KAAKia,WAELja,KAAK4U,SAAU,EAER5U,MAcXwX,gBAAiB,WAEb,IAAIvK,EAAKjN,KAAKiN,GACViN,EAASla,KAAKyV,aAElB,OAAIxI,EAAGkN,aAAalN,EAAGmN,wBAA0BF,IAE7CjN,EAAGoN,WAAWpN,EAAGqN,aAAcJ,IAExB,IAmBflI,SAAU,SAAUZ,GAShB,OAPIpR,KAAKiW,qBAELjW,KAAKiW,oBAAoBpE,OAG7B7R,KAAKua,WAAWnJ,GAETpR,MAkBXoS,UAAW,SAAUhB,GAMjB,OAJApR,KAAKwa,OAAOxa,KAAKiW,qBAEjBjW,KAAKya,YAAYrJ,GAEVpR,MAkBXwa,OAAQ,aAWR5I,OAAQ,WAEA5R,KAAKiW,qBAELjW,KAAKiW,oBAAoBrE,UAgBjCX,MAAO,SAAUyJ,GAIb,QAFoBxb,IAAhBwb,IAA6BA,GAAc,GAE3C1a,KAAKsV,YAAc,EACvB,CACItV,KAAKgE,KAAKpD,EAAO+Z,aAAc3a,KAAM0a,GAErC1a,KAAK4a,cAAcF,GAEnB,IAAIzN,EAAKjN,KAAKiN,GACVqI,EAActV,KAAKsV,YACnBwB,EAAa9W,KAAK0R,cAAcoF,WAEhC9W,KAAKmS,SAELnS,KAAKwX,kBAEDlC,IAAgBtV,KAAKuV,eAErBtI,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGsK,cAInDtK,EAAG6N,cAAc7N,EAAGqN,aAAc,EAAGta,KAAK4V,MAAMmF,SAAS,EAAGzF,EAAcwB,IAG9E7J,EAAG+N,WAAWhb,KAAK0V,SAAU,EAAGJ,IAGpCtV,KAAKsV,YAAc,EAEnBtV,KAAKgE,KAAKpD,EAAOqa,YAAajb,KAAM0a,GAEpC1a,KAAKkb,aAAaR,GAGtB,OAAO1a,MAoBX+Z,SAAU,aAmBVhI,OAAQ,aAcRkI,SAAU,aAqBVkB,QAAS,aAcTZ,WAAY,aAcZE,YAAa,aAabhD,YAAa,aAiBbC,SAAU,aAeVC,aAAc,aAiBdiD,cAAe,aAqBfM,aAAc,aAwBdE,UAAW,SAAUzY,EAAGC,EAAGyY,EAAGC,EAAGC,EAAMC,EAAYC,GAE/C,IAAI5F,EAAgB7V,KAAK6V,cACrBC,EAAgB9V,KAAK8V,cAErB4F,EAAgB1b,KAAKsV,YAActV,KAAK0R,cAAciK,qBAAwB,EAElF9F,IAAgB6F,GAAgB/Y,EAChCkT,IAAgB6F,GAAgB9Y,EAChCiT,IAAgB6F,GAAgBL,EAChCxF,IAAgB6F,GAAgBJ,EAChCzF,IAAgB6F,GAAgBH,EAChC1F,IAAgB6F,GAAgBF,EAChC1F,IAAgB4F,GAAgBD,EAEhCzb,KAAKsV,eA8CTsG,UAAW,SAAUxK,EAAYyK,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAQC,EAAQC,EAAQC,EAAQpB,EAAYqB,EAAStB,QAErHrc,IAATqc,IAAsBA,EAAOvb,KAAK+V,aAEtC,IAAI+G,GAAa,EAoBjB,OAlBI9c,KAAKmZ,YAAY,KAEjBnZ,KAAKiR,QAEL6L,GAAa,EAEbvB,EAAOvb,KAAK+c,aAAaF,IAG7B7c,KAAKob,UAAUS,EAAIC,EAAIO,EAAIC,EAAIf,EAAMC,EAAYiB,GACjDzc,KAAKob,UAAUW,EAAIC,EAAIK,EAAIG,EAAIjB,EAAMC,EAAYmB,GACjD3c,KAAKob,UAAUa,EAAIC,EAAIK,EAAIC,EAAIjB,EAAMC,EAAYoB,GACjD5c,KAAKob,UAAUS,EAAIC,EAAIO,EAAIC,EAAIf,EAAMC,EAAYiB,GACjDzc,KAAKob,UAAUa,EAAIC,EAAIK,EAAIC,EAAIjB,EAAMC,EAAYoB,GACjD5c,KAAKob,UAAUe,EAAIC,EAAIG,EAAID,EAAIf,EAAMC,EAAYkB,GAEjD1c,KAAKmb,QAAQ/J,GAEN0L,GAyCXE,SAAU,SAAU5L,EAAYyK,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIG,EAAIC,EAAIC,EAAIC,EAAIC,EAAQC,EAAQC,EAAQnB,EAAYqB,EAAStB,QAEpGrc,IAATqc,IAAsBA,EAAOvb,KAAK+V,aAEtC,IAAI+G,GAAa,EAiBjB,OAfI9c,KAAKmZ,YAAY,KAEjBnZ,KAAKiR,QAEL6L,GAAa,EAEbvB,EAAOvb,KAAK+c,aAAaF,IAG7B7c,KAAKob,UAAUS,EAAIC,EAAIO,EAAIC,EAAIf,EAAMC,EAAYiB,GACjDzc,KAAKob,UAAUW,EAAIC,EAAIK,EAAIG,EAAIjB,EAAMC,EAAYkB,GACjD1c,KAAKob,UAAUa,EAAIC,EAAIK,EAAIC,EAAIjB,EAAMC,EAAYmB,GAEjD3c,KAAKmb,QAAQ/J,GAEN0L,GAwBXG,aAAc,SAAUta,EAAGC,EAAGb,EAAOC,EAAQkb,EAAO9a,EAAOya,EAASM,QAEhDje,IAAZ2d,IAAyBA,EAAU7c,KAAK6O,SAASuO,aAAaC,gBACnDne,IAAXie,IAAwBA,GAAS,GAErCxa,EAAIyE,KAAKkW,MAAM3a,GACfC,EAAIwE,KAAKkW,MAAM1a,GAEf,IAAI2a,EAAKnW,KAAKkW,MAAM3a,EAAIZ,GACpByb,EAAKpW,KAAKkW,MAAM1a,EAAIZ,GAEpBuZ,EAAOvb,KAAK+c,aAAaF,GAEzBpB,EAAOvG,EAAMuI,+BAA+BP,EAAO9a,GAGnDka,EAAK,EAELE,EAAK,EAELW,IAEAb,EAAK,EACLE,EAAK,GAGTxc,KAAK4b,UAAU,KAAMjZ,EAAGC,EAAGD,EAAG6a,EAAID,EAAIC,EAAID,EAAI3a,EAXrC,EAW4C0Z,EAT5C,EASoDE,EAAIf,EAAMA,EAAMA,EAAMA,EAAM,EAAGoB,EAAStB,IAczGwB,aAAc,SAAUF,GAMpB,YAJgB3d,IAAZ2d,IAAyBA,EAAU7c,KAAK6O,SAASuO,aAAaC,WAElErd,KAAK+V,YAAc/V,KAAK6O,SAASkO,aAAaF,GAEvC7c,KAAK+V,aAchB2H,YAAa,SAAUb,EAAStB,QAEfrc,IAATqc,IAAsBA,EAAO,GAEjC,IAAItO,EAAKjN,KAAKiN,GAMd,OAJAA,EAAG0Q,cAAc1Q,EAAG2Q,SAAWrC,GAE/BtO,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAEvB7c,MAeX8d,iBAAkB,SAAUpL,EAAQ6I,GAEhC,OAAOvb,KAAK0d,YAAYhL,EAAOmK,QAAStB,IAe5CwC,QAAS,SAAUC,GAIf,OAFAhe,KAAKie,MAAMD,EAAShe,KAAKoB,KAAK8c,KAAKC,eAE5Bne,MAqBXie,MAAO,SAAUtN,EAAMhO,EAAGoV,GAMtB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOkG,MAAMtN,EAAMhO,GAEZ3C,MAsBXoe,MAAO,SAAUzN,EAAMhO,EAAGC,EAAGmV,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOqG,MAAMzN,EAAMhO,EAAGC,GAEf5C,MAuBXqe,MAAO,SAAU1N,EAAMhO,EAAGC,EAAG0b,EAAGvG,GAM5B,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOsG,MAAM1N,EAAMhO,EAAGC,EAAG0b,GAElBte,MAwBXue,MAAO,SAAU5N,EAAMhO,EAAGC,EAAG0b,EAAGE,EAAGzG,GAM/B,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOwG,MAAM5N,EAAMhO,EAAGC,EAAG0b,EAAGE,GAErBxe,MAqBXye,OAAQ,SAAU9N,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO0G,OAAO9N,EAAM+N,GAEb1e,MAqBX2e,OAAQ,SAAUhO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO4G,OAAOhO,EAAM+N,GAEb1e,MAqBX4e,OAAQ,SAAUjO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO6G,OAAOjO,EAAM+N,GAEb1e,MAqBX6e,OAAQ,SAAUlO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO8G,OAAOlO,EAAM+N,GAEb1e,MAqBX8e,OAAQ,SAAUnO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO+G,OAAOnO,EAAM+N,GAEb1e,MAqBX+e,OAAQ,SAAUpO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOgH,OAAOpO,EAAM+N,GAEb1e,MAqBXgf,OAAQ,SAAUrO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOiH,OAAOrO,EAAM+N,GAEb1e,MAqBXif,OAAQ,SAAUtO,EAAM+N,EAAK3G,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOkH,OAAOtO,EAAM+N,GAEb1e,MAqBXkf,MAAO,SAAUvO,EAAMhO,EAAGoV,GAMtB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOmH,MAAMvO,EAAMhO,GAEZ3C,MAsBXmf,MAAO,SAAUxO,EAAMhO,EAAGC,EAAGmV,GAMzB,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOoH,MAAMxO,EAAMhO,EAAGC,GAEf5C,MAuBXof,MAAO,SAAUzO,EAAMhO,EAAGC,EAAG0b,EAAGvG,GAM5B,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOqH,MAAMzO,EAAMhO,EAAGC,EAAG0b,GAElBte,MAwBXqf,MAAO,SAAU1O,EAAMhO,EAAGC,EAAG0b,EAAGE,EAAGzG,GAM/B,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOsH,MAAM1O,EAAMhO,EAAGC,EAAG0b,EAAGE,GAErBxe,MAsBXsf,aAAc,SAAU3O,EAAM4O,EAAWrZ,EAAQ6R,GAM7C,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOuH,aAAa3O,EAAM4O,EAAWrZ,GAE9BlG,MAsBXwf,aAAc,SAAU7O,EAAM4O,EAAWrZ,EAAQ6R,GAM7C,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAOyH,aAAa7O,EAAM4O,EAAWrZ,GAE9BlG,MAsBXyZ,aAAc,SAAU9I,EAAM4O,EAAWrZ,EAAQ6R,GAM7C,YAJe7Y,IAAX6Y,IAAwBA,EAAS/X,KAAK0R,eAE1CqG,EAAO0B,aAAa9I,EAAM4O,EAAWrZ,GAE9BlG,MAYXqK,QAAS,WAIL,IAAIjE,EAFJpG,KAAKgE,KAAKpD,EAAO6e,QAASzf,MAI1B,IAAIkW,EAAUlW,KAAKkW,QAEnB,IAAK9P,EAAI,EAAGA,EAAI8P,EAAQ/Q,OAAQiB,IAE5B8P,EAAQ9P,GAAGiE,UAGf,IAAIkM,EAAUvW,KAAKgW,cAEnB,IAAK5P,EAAI,EAAGA,EAAImQ,EAAQpR,OAAQiB,IAE5BmQ,EAAQnQ,GAAGiE,UAGfrK,KAAKiN,GAAGyS,aAAa1f,KAAKyV,cAE1B,IAAI5G,EAAW7O,KAAK6O,SAwBpB,OAtBAA,EAAS8Q,IAAI3K,EAAepR,OAAQ5D,KAAK8D,OAAQ9D,MACjD6O,EAAS8Q,IAAI3K,EAAenQ,WAAY7E,KAAKyX,YAAazX,MAC1D6O,EAAS8Q,IAAI3K,EAAe5P,OAAQpF,KAAK0X,SAAU1X,MACnD6O,EAAS8Q,IAAI3K,EAAepO,YAAa5G,KAAK2X,aAAc3X,MAE5DA,KAAKsK,qBAELtK,KAAKoB,KAAO,KACZpB,KAAK6O,SAAW,KAChB7O,KAAK8Q,QAAU,KACf9Q,KAAKiN,GAAK,KACVjN,KAAKqV,KAAO,KACZrV,KAAKkW,QAAU,KACflW,KAAKgW,cAAgB,KACrBhW,KAAK4V,MAAQ,KACb5V,KAAK6V,cAAgB,KACrB7V,KAAK8V,cAAgB,KACrB9V,KAAKwV,WAAa,KAClBxV,KAAKyV,aAAe,KACpBzV,KAAK0R,cAAgB,KACrB1R,KAAKiW,oBAAsB,KAEpBjW,QAKfjB,EAAOC,QAAUoW,G,gBCllEjB,IAAIwK,EAAc,EAAQ,OACtBrf,EAAe,EAAQ,OACvBE,EAAQ,EAAQ,OAChBC,EAAQ,EAAQ,OAChBC,EAAe,EAAQ,OACvBC,EAAS,EAAQ,OACjBif,EAAa,EAAQ,OACrBC,EAAmB,EAAQ,OAC3B/K,EAAU,EAAQ,OAClBgL,EAAO,EAAQ,OACfnR,EAAkB,EAAQ,OAC1BqG,EAAe,EAAQ,OACvBnU,EAAc,EAAQ,OACtBC,EAAgB,EAAQ,OACxBmU,EAAQ,EAAQ,OAChB8K,EAAgB,EAAQ,OA0BxBC,EAAgB,IAAIxf,EAAM,CAE1BS,QAASP,EAETQ,WAEA,SAAwBC,GAEpBT,EAAaU,KAAKrB,MAElB,IAAIsB,EAAaF,EAAKG,OAElB2e,EAAwB,CACxB9d,MAAOd,EAAWe,YAClBC,eAAgBhB,EAAWgB,eAC3B6d,OAAO,EACPze,UAAWJ,EAAW8e,YACtBC,mBAAoB/e,EAAW+e,mBAC/BC,SAAS,EACTC,6BAA8Bjf,EAAWif,6BACzCC,gBAAiBlf,EAAWkf,gBAC5BC,sBAAuBnf,EAAWmf,uBAUtCzgB,KAAKuB,OAAS,CACVC,kBAAmBF,EAAWE,kBAC9BE,UAAWJ,EAAWI,UACtBD,gBAAiBH,EAAWG,gBAC5Bif,gBAAiBR,EACjBve,YAAaL,EAAWK,YACxB6W,YAAalX,EAAWkX,YACxBmI,eAAgBrf,EAAWqf,eAC3B5J,UAAWzV,EAAWyV,UACtB6J,UAAWtf,EAAWsf,UACtBC,aAAcvf,EAAWuf,cAU7B7gB,KAAKoB,KAAOA,EASZpB,KAAK4B,KAAOlB,EAAMogB,MAiBlB9gB,KAAKwP,UAAY,KAUjBxP,KAAK+B,MAAQ,EAUb/B,KAAKgC,OAAS,EASdhC,KAAKkC,OAASd,EAAKc,OAYnBlC,KAAKyC,WAAa,GAUlBzC,KAAK+gB,aAAc,EAWnB/gB,KAAK0C,cAAgB,CACjBC,EAAG,EACHC,EAAG,EACHb,MAAO,EACPC,OAAQ,EACRa,UAAU,EACVC,SAAU,KACVlB,KAAM,YACNmB,QAAS,IACTmK,eAAe,EACfC,YAAa,EACbE,aAAc,GAUlBrN,KAAKghB,qBAAuB,EAU5BhhB,KAAKihB,mBAAqB,EAU1BjhB,KAAKwY,YAAc,EAWnBxY,KAAKkhB,eAWLlhB,KAAKmhB,aASLnhB,KAAKohB,YASLphB,KAAKqhB,cAULrhB,KAAKshB,mBAAqB,KAS1BthB,KAAKuhB,SAAW,GAUhBvhB,KAAKwS,eAAiB,KAStBxS,KAAKwhB,iBAAmBC,EAAAA,EAUxBzhB,KAAK0hB,uBAAwB,EAS7B1hB,KAAK2hB,eAAiB,KAStB3hB,KAAK4hB,aAAe,GAUpB5hB,KAAK6hB,mBAAqB9B,EAU1B/f,KAAK8hB,uBAAyB/B,EAU9B/f,KAAKiN,GAAK,KAWVjN,KAAK+hB,oBAAsB,KAW3B/hB,KAAKgiB,yBAA2B,KAWhChiB,KAAKiiB,aAAe,KAUpBjiB,KAAKkiB,WAAa,GAUlBliB,KAAKmiB,UAAY,GASjBniB,KAAKoiB,YAAc,CACfC,MAAM,EACNC,OAAO,EACPC,MAAM,GAWVviB,KAAKsN,oBAAsB,EAW3BtN,KAAKwiB,aAAe,KAWpBxiB,KAAKod,aAAe,KASpBpd,KAAKyiB,UAAY,EASjBziB,KAAK0iB,UAAY,GASjB1iB,KAAK2iB,YAAc,CAAE7c,KAAM,KAAMb,OAAQ,MASzCjF,KAAK4iB,kBAAoB,CAAE9c,KAAM,KAAMb,OAAQ,MAU/CjF,KAAK6iB,UAAY,KAUjB7iB,KAAK8iB,YAAc,GAUnB9iB,KAAK+iB,SAAU,EAUf/iB,KAAKgjB,eAAgB,EASrBhjB,KAAKijB,WAAY,EA0BjBjjB,KAAK6gB,aAAe,KASpB7gB,KAAKkjB,aAAe,EAWpBljB,KAAKmjB,gBAAiB,EAUtBnjB,KAAKojB,eAAiB,CAAE,EAAG,EAAG,EAAG,GASjCpjB,KAAKmD,UAAW,EAWhBnD,KAAKqjB,aAAe,KASpBrjB,KAAKmW,iBASLnW,KAAKoW,gBAAkB,EASvBpW,KAAKqW,iBAAmB,EAExBrW,KAAKoD,KAAKpD,KAAKuB,SAanB6B,KAAM,SAAU7B,GAEZ,IAAI0L,EACA7L,EAAOpB,KAAKoB,KACZc,EAASlC,KAAKkC,OACdohB,EAAa/hB,EAAOE,gBAYxB,KAPIwL,EAFA7L,EAAKG,OAAOhC,QAEP6B,EAAKG,OAAOhC,QAIZ2C,EAAOzC,WAAW,QAAS8B,EAAOmf,kBAAoBxe,EAAOzC,WAAW,qBAAsB8B,EAAOmf,mBAGnGzT,EAAGsW,gBAIV,MAFAvjB,KAAK+gB,aAAc,EAEb,IAAIyC,MAAM,qBAGpBxjB,KAAKiN,GAAKA,EAEV,IAAIiD,EAAQlQ,KAEZA,KAAK6hB,mBAAqB,SAAU4B,GAEhCvT,EAAM6Q,aAAc,EAEpB7Q,EAAM9O,KAAKsiB,OAAO1f,KAAK6b,EAAW8D,aAAczT,GAEhDuT,EAAMG,kBAGV5jB,KAAK8hB,uBAAyB,WAE1B5R,EAAM6Q,aAAc,EAEpB7Q,EAAM9M,KAAK8M,EAAM3O,QAEjB2O,EAAM9O,KAAKsiB,OAAO1f,KAAK6b,EAAWgE,iBAAkB3T,IAGxDhO,EAAO4hB,iBAAiB,mBAAoB9jB,KAAK6hB,oBAAoB,GACrE3f,EAAO4hB,iBAAiB,uBAAwB9jB,KAAK8hB,wBAAwB,GAG7E1gB,EAAK7B,QAAU0N,EAEf,IAAK,IAAI7G,EAAI,EAAGA,GAAK,GAAIA,IAErBpG,KAAKyC,WAAW+T,KAAK,CAAEuN,KAAM,CAAE9W,EAAG+W,IAAK/W,EAAGgX,qBAAuBC,SAAUjX,EAAGkX,WAIlFnkB,KAAKyC,WAAW,GAAGshB,KAAO,CAAE9W,EAAG+W,IAAK/W,EAAGmX,WAGvCpkB,KAAKyC,WAAW,GAAGshB,KAAO,CAAE9W,EAAGoX,UAAWpX,EAAGgX,qBAG7CjkB,KAAKyC,WAAW,GAAGshB,KAAO,CAAE9W,EAAG+W,IAAK/W,EAAGqX,qBAGvCtkB,KAAKyC,WAAW,IAAM,CAAEshB,KAAM,CAAE9W,EAAGsX,KAAMtX,EAAGgX,qBAAuBC,SAAUjX,EAAGuX,uBAEhFxkB,KAAKmiB,UAAU,GAAKlV,EAAGwX,KACvBzkB,KAAKmiB,UAAU,GAAKlV,EAAGyX,MACvB1kB,KAAKmiB,UAAU,GAAKlV,EAAGW,cACvB5N,KAAKmiB,UAAU,GAAKlV,EAAG0X,eACvB3kB,KAAKmiB,UAAU,GAAKlV,EAAG2X,MAGvB5kB,KAAK6iB,UAAY,CAEbgC,KAAM,CAAEd,KAAM9W,EAAG6X,iBAAkB3f,OAAQ,EAAGe,QAAQ,GACtD6e,KAAM,CAAEhB,KAAM9W,EAAG+X,iBAAkB7f,OAAQ,EAAGe,QAAQ,GACtD+e,KAAM,CAAElB,KAAM9W,EAAGiY,iBAAkB/f,OAAQ,EAAGe,QAAQ,GAEtD,KAAM,CAAE6d,KAAM9W,EAAGkY,UAAWhgB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAGmY,WAAYjgB,OAAQ,GACtC,KAAM,CAAE4e,KAAM9W,EAAGoY,UAAWlgB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAGqY,WAAYngB,OAAQ,GAEtC,KAAM,CAAE4e,KAAM9W,EAAGsY,UAAWpgB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAGuY,WAAYrgB,OAAQ,GACtC,KAAM,CAAE4e,KAAM9W,EAAGwY,UAAWtgB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAGyY,WAAYvgB,OAAQ,GAEtC,KAAM,CAAE4e,KAAM9W,EAAG0Y,UAAWxgB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAG2Y,WAAYzgB,OAAQ,GACtC,KAAM,CAAE4e,KAAM9W,EAAG4Y,UAAW1gB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAG6Y,WAAY3gB,OAAQ,GAEtC,KAAM,CAAE4e,KAAM9W,EAAG8Y,UAAW5gB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAG+Y,WAAY7gB,OAAQ,GACtC,KAAM,CAAE4e,KAAM9W,EAAGgZ,UAAW9gB,OAAQ,GACpC,MAAO,CAAE4e,KAAM9W,EAAGiZ,WAAY/gB,OAAQ,IAK1C,IAAIghB,EAAOlZ,EAAGmZ,yBAET7kB,EAAOiX,cAAuC,IAAxBjX,EAAOiX,cAE9BjX,EAAOiX,YAAcvL,EAAGkN,aAAalN,EAAGoZ,0BAGvC9kB,EAAOof,iBAERpf,EAAOof,eAAiB1T,EAAGkN,aAAalN,EAAGqZ,mBAG/C,IAAIC,EAAY,4BACZC,EAAc,UAAYD,EAE9BvmB,KAAKoiB,YAAYC,KAAOpV,EAAGwZ,aAAaF,EAAY,SAAWtZ,EAAGwZ,aAAaD,EAAc,QAC7FxmB,KAAKoiB,YAAYE,MAAQrV,EAAGwZ,aAAaF,EAAY,UAAYtZ,EAAGwZ,aAAaD,EAAc,SAC/FxmB,KAAKoiB,YAAYG,KAAOtV,EAAGwZ,aAAaF,EAAY,SAAWtZ,EAAGwZ,aAAaD,EAAc,QAE7FxmB,KAAK+hB,oBAAsBoE,EAE3B,IAAIO,EAAc,yBAElB1mB,KAAKgiB,yBAA4BmE,EAAKQ,QAAQD,IAAgB,EAAKzZ,EAAGwZ,aAAaC,GAAe,KAElG,IAAIE,EAAY,0BAEhB5mB,KAAKiiB,aAAgBkE,EAAKQ,QAAQC,IAAc,EAAK3Z,EAAGwZ,aAAaG,GAAa,KAGlF3Z,EAAGiH,QAAQjH,EAAGkH,YACdlH,EAAGiH,QAAQjH,EAAGmH,WAEdnH,EAAG4Z,OAAO5Z,EAAG6Z,OAEb7Z,EAAGqW,WAAWA,EAAWyD,MAAOzD,EAAW0D,QAAS1D,EAAW2D,OAAQ3D,EAAW4D,SAGlFlnB,KAAK6gB,aAAe5T,EAAG1L,EAAOsf,cAG9B7gB,KAAKwY,YAActD,EAAMiS,eAAela,EAAI1L,EAAOiX,aAEnDxY,KAAKkhB,eAAiB,GAGtB,IAAIC,EAAenhB,KAAKmhB,aAExB,GAAI1K,MAAMC,QAAQyK,GAEd,IAAK,IAAIiG,EAAI,EAAGhhB,EAAIpG,KAAKwY,YAAa4O,IAElCna,EAAGoa,cAAclG,EAAaiG,SAKlCjG,EAAe,IAAI1K,MAAMzW,KAAKwY,aAIlC,IAAK,IAAI8O,EAAQ,EAAGA,EAAQtnB,KAAKwY,YAAa8O,IAC9C,CACI,IAAIC,EAActa,EAAGua,gBAErBva,EAAG0Q,cAAc1Q,EAAG2Q,SAAW0J,GAE/Bra,EAAGyQ,YAAYzQ,EAAG4Q,WAAY0J,GAE9Bta,EAAGwa,WAAWxa,EAAG4Q,WAAY,EAAG5Q,EAAGU,KAAM,EAAG,EAAG,EAAGV,EAAGU,KAAMV,EAAGW,cAAe,IAAIJ,WAAW,CAAE,EAAG,EAAG,IAAK,OAEzG2T,EAAamG,GAASC,EAEtBvnB,KAAKkhB,eAAe1K,KAAK8Q,GAkB7B,OAfAtnB,KAAKmhB,aAAeA,EAGpBnhB,KAAKghB,qBAAuB,EAC5BhhB,KAAKihB,qBACLhU,EAAG0Q,cAAc1Q,EAAGya,UAEpB1nB,KAAKwP,UAAY,IAAIZ,EAAgB5O,MAErCA,KAAKmE,aAAazD,EAAMinB,WAAWhd,QAEnC3K,KAAKmW,kBAAmB,IAAIpB,GAAUuB,WAEtClV,EAAKiC,SAASC,KAAKvC,EAAcwC,MAAOvD,KAAKwD,KAAMxD,MAE5CA,MAUXwD,KAAM,WAEF,IAAIpC,EAAOpB,KAAKoB,KACZwmB,EAAkB5nB,KAAKwP,UAEvB/L,EAAWrC,EAAKsC,MAAMD,SAE1BzD,KAAK+B,MAAQ0B,EAAS1B,MACtB/B,KAAKgC,OAASyB,EAASzB,OAEvBhC,KAAKmD,UAAW,EAEhBnD,KAAKqjB,aAAe,IAAIpO,EAAajV,KAAMA,KAAK+B,MAAO/B,KAAKgC,OAAQ,EAAG,GAAG,GAAM,GAIhF4lB,EAAgBpkB,KAAKpC,EAAKG,OAAO6O,UAIjCpQ,KAAKwiB,aAAephB,EAAKiC,SAASwkB,SAAS,aAC3C7nB,KAAKod,aAAehc,EAAKiC,SAASwkB,SAAS,WAE3C,IAAI5a,EAAKjN,KAAKiN,GAEdA,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MAEnC9a,EAAG4Z,OAAO5Z,EAAG+a,cAEb5mB,EAAKsC,MAAMC,GAAG7C,EAAY8C,OAAQ5D,KAAK6D,SAAU7D,MAEjDA,KAAK8D,OAAOL,EAAS1B,MAAO0B,EAASzB,SAYzC6B,SAAU,SAAUE,EAAUN,GAGtBA,EAAS1B,QAAU/B,KAAK+B,OAAS0B,EAASzB,SAAWhC,KAAKgC,QAE1DhC,KAAK8D,OAAOL,EAAS1B,MAAO0B,EAASzB,SAe7CimB,aAAc,SAAUlmB,EAAOC,QAEb9C,IAAV6C,IAAuBA,EAAQ/B,KAAK+B,YACzB7C,IAAX8C,IAAwBA,EAAShC,KAAKgC,QAE1ChC,KAAKqjB,aAAaxR,MAAK,EAAM9P,EAAOC,GAEpChC,KAAKqZ,oBAAoBtX,EAAOC,GAEhChC,KAAK6U,iBAcTqT,WAAY,WAMR,OAJAloB,KAAKqjB,aAAazR,QAAO,GAEzB5R,KAAKmoB,wBAEEnoB,KAAKqjB,cAehBvf,OAAQ,SAAU/B,EAAOC,GAErB,IAAIiL,EAAKjN,KAAKiN,GAkBd,OAhBAjN,KAAK+B,MAAQA,EACb/B,KAAKgC,OAASA,EAEdhC,KAAKqZ,oBAAoBtX,EAAOC,GAEhCiL,EAAGwH,SAAS,EAAG,EAAG1S,EAAOC,GAEzBhC,KAAKsN,oBAAsBL,EAAGK,oBAE9BL,EAAGmb,QAAQ,EAAInb,EAAGK,oBAAsBtL,EAASD,EAAOC,GAExDhC,KAAKojB,eAAe,GAAKrhB,EACzB/B,KAAKojB,eAAe,GAAKphB,EAEzBhC,KAAKgE,KAAKpD,EAAOgD,OAAQ7B,EAAOC,GAEzBhC,MAWXqoB,eAAgB,WAEZ,OAAOroB,KAAK+B,MAAQ/B,KAAKgC,QAc7BqX,oBAAqB,SAAUtX,EAAOC,GAUlC,OARID,IAAU/B,KAAKoW,iBAAmBpU,IAAWhC,KAAKqW,mBAElDrW,KAAKoW,gBAAkBrU,EACvB/B,KAAKqW,iBAAmBrU,EAExBhC,KAAKmW,iBAAiBmD,MAAM,EAAGvX,EAAOC,EAAQ,GAAI,IAAM,MAGrDhC,MAYXmoB,sBAAuB,WAEnBnoB,KAAKoW,gBAAkBpW,KAAK+B,MAC5B/B,KAAKqW,iBAAmBrW,KAAKgC,OAE7BhC,KAAKmW,iBAAiBmD,MAAM,EAAGtZ,KAAK+B,MAAO/B,KAAKgC,OAAQ,GAAI,IAAM,MAatEsmB,aAAc,SAAUC,GAEpB,QAAOvoB,KAAK+hB,qBAAsB/hB,KAAK+hB,oBAAoB4E,QAAQ4B,IAavE9B,aAAc,SAAU8B,GAEpB,OAAKvoB,KAAKsoB,aAAaC,IAEjBA,KAAiBvoB,KAAKkiB,aAExBliB,KAAKkiB,WAAWqG,GAAiBvoB,KAAKiN,GAAGwZ,aAAa8B,IAGnDvoB,KAAKkiB,WAAWqG,IAPyB,MAgBpDtX,MAAO,WAEHjR,KAAKwP,UAAUyB,SAiBnBuX,YAAa,SAAU7lB,EAAGC,EAAGb,EAAOC,EAAQsL,QAEZpO,IAAxBoO,IAAqCA,EAAsBtN,KAAKsN,qBAEpE,IAEI8a,EAAU,CAAEzlB,EAAGC,EAAGb,EAAOC,GAQ7B,OAVmBhC,KAAK4hB,aAIXpL,KAAK4R,GAElBpoB,KAAKyoB,WAAW9lB,EAAGC,EAAGb,EAAOC,EAAQsL,GAErCtN,KAAK2hB,eAAiByG,EAEfA,GAeXK,WAAY,SAAU9lB,EAAGC,EAAGb,EAAOC,EAAQsL,QAEXpO,IAAxBoO,IAAqCA,EAAsBtN,KAAKsN,qBAEpE,IAAIL,EAAKjN,KAAKiN,GAEVwC,EAAUzP,KAAK2hB,eAEf8G,EAAc1mB,EAAQ,GAAKC,EAAS,EAExC,GAAIyN,GAAWgZ,EACf,CACI,IAAIpjB,EAAKoK,EAAQ,GACbnK,EAAKmK,EAAQ,GACblK,EAAKkK,EAAQ,GACbjK,EAAKiK,EAAQ,GAEjBgZ,EAAcpjB,IAAO1C,GAAK2C,IAAO1C,GAAK2C,IAAOxD,GAASyD,IAAOxD,EAG7DymB,IAEAzoB,KAAKiR,QAGLhE,EAAGmb,QAAQzlB,EAAI2K,EAAsB1K,EAAIZ,EAASD,EAAOC,KAWjE0mB,aAAc,WAEV,IAAIzb,EAAKjN,KAAKiN,GAEdA,EAAG4Z,OAAO5Z,EAAG+a,cAEb,IAAIvY,EAAUzP,KAAK2hB,eAEnB,GAAIlS,EACJ,CACI,IAAI9M,EAAI8M,EAAQ,GACZ7M,EAAI6M,EAAQ,GACZ1N,EAAQ0N,EAAQ,GAChBzN,EAASyN,EAAQ,GAEjB1N,EAAQ,GAAKC,EAAS,GAEtBiL,EAAGmb,QAAQzlB,EAAI3C,KAAKsN,oBAAsB1K,EAAIZ,EAASD,EAAOC,KAW1E2mB,WAAY,WAER,IAAI/G,EAAe5hB,KAAK4hB,aAGxBA,EAAagH,MAGb,IAAIR,EAAUxG,EAAaA,EAAazc,OAAS,GAE7CijB,GAEApoB,KAAKyoB,WAAWL,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IAGhEpoB,KAAK2hB,eAAiByG,GAW1B/T,qBAAsB,WAElB,IAAIvO,EAAO9F,KAAK2iB,YAAY7c,KACxB+iB,EAAU7oB,KAAK4iB,kBAAkB9c,KAErC,OAASA,GAAQA,EAAKgjB,WAAeD,GAAWA,EAAQC,WAS5DC,cAAe,WAEX,IAAI9b,EAAKjN,KAAKiN,GAEdA,EAAGwH,SAAS,EAAG,EAAGzU,KAAK+B,MAAO/B,KAAKgC,QAEnChC,KAAKsN,oBAAsBL,EAAGK,qBAiBlCnJ,aAAc,SAAU6kB,EAAaC,QAEnB/pB,IAAV+pB,IAAuBA,GAAQ,GAEnC,IAAIhc,EAAKjN,KAAKiN,GACV7I,EAAYpE,KAAKyC,WAAWumB,GAEhC,SAAIC,GAAUD,IAAgBtoB,EAAMinB,WAAWuB,YAAclpB,KAAKwhB,mBAAqBwH,KAEnFhpB,KAAKiR,QAELhE,EAAG4Z,OAAO5Z,EAAG6Z,OACb7Z,EAAGkc,cAAc/kB,EAAU8f,UAEvB9f,EAAU2f,KAAK5e,OAAS,EAExB8H,EAAGmc,kBAAkBhlB,EAAU2f,KAAK,GAAI3f,EAAU2f,KAAK,GAAI3f,EAAU2f,KAAK,GAAI3f,EAAU2f,KAAK,IAI7F9W,EAAGoc,UAAUjlB,EAAU2f,KAAK,GAAI3f,EAAU2f,KAAK,IAGnD/jB,KAAKwhB,iBAAmBwH,GAEjB,IAmBfM,aAAc,SAAUvF,EAAMG,GAI1B,OAFYlkB,KAAKyC,WAAW+T,KAAK,CAAEuN,KAAMA,EAAMG,SAAUA,IAE1C,GAenBqF,gBAAiB,SAAUjC,EAAOvD,EAAMG,GAYpC,OAVIlkB,KAAKyC,WAAW6kB,KAEhBtnB,KAAKyC,WAAW6kB,GAAOvD,KAAOA,EAE1BG,IAEAlkB,KAAKyC,WAAW6kB,GAAOpD,SAAWA,IAInClkB,MAcXwpB,gBAAiB,SAAUlC,GAOvB,OALIA,EAAQ,IAAMtnB,KAAKyC,WAAW6kB,IAE9BtnB,KAAKyC,WAAWgnB,OAAOnC,EAAO,GAG3BtnB,MAWX0pB,gBAAiB,WAEb1pB,KAAK+c,aAAa/c,KAAKwiB,aAAanF,YAcxCnE,iBAAkB,SAAUyQ,GAExB,GAAI3pB,KAAKwP,UAAUuE,YAIf,OAFA/T,KAAK4pB,eAAeD,EAActM,WAAW,GAEtC,EAGX,IAAIpQ,EAAKjN,KAAKiN,GACV+T,EAAuBhhB,KAAKghB,qBAqChC,OAnCI2I,EAAcE,eAAiB7pB,KAAKihB,qBAEpC0I,EAAcE,eAAiB7pB,KAAKihB,mBAEhCD,EAAuBhhB,KAAKwY,aAE5BmR,EAAcG,QAAU9I,EAExB/T,EAAG0Q,cAAc1Q,EAAG2Q,SAAWoD,GAC/B/T,EAAGyQ,YAAYzQ,EAAG4Q,WAAY8L,EAActM,WAE5Crd,KAAKghB,yBAKLhhB,KAAKiR,QAELjR,KAAKihB,qBAELjhB,KAAKkjB,eAELyG,EAAcE,eAAiB7pB,KAAKihB,mBAEpC0I,EAAcG,QAAU,EAExB7c,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAY8L,EAActM,WAE5Crd,KAAKghB,qBAAuB,IAIpChhB,KAAKmjB,gBAAiB,EAEfwG,EAAcG,SAczBC,eAAgB,SAAUlN,EAASmN,GAE/B,OAAQhqB,KAAKohB,cAAgBvE,GAAW7c,KAAKqhB,gBAAkB2I,GAcnEJ,eAAgB,SAAU/M,EAAS5L,GAE/B,GAAIjR,KAAKohB,cAAgBvE,EACzB,CACQ5L,GAEAjR,KAAKiR,QAGT,IAAIhE,EAAKjN,KAAKiN,GAEdA,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B7c,KAAKohB,YAAcvE,IAU3BoN,iBAAkB,WAEdjqB,KAAKohB,YAAc,MAavB8I,aAAc,SAAUrN,GAEpB,GAAI7c,KAAKqhB,gBAAkBxE,EAC3B,CACI,IAAI5P,EAAKjN,KAAKiN,GAEdA,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B7c,KAAKqhB,cAAgBxE,EAEa,IAA9B7c,KAAKghB,uBAELhhB,KAAKghB,qBAAuB,KAYxCmJ,eAAgB,WAEZnqB,KAAKqhB,cAAgB,KACrBrhB,KAAKihB,qBACLjhB,KAAKghB,qBAAuB,EAE5BhhB,KAAKkjB,gBAWTkH,eAAgB,WAKZ,IAHA,IAAInd,EAAKjN,KAAKiN,GACVod,EAAOrqB,KAAKmhB,aAEP/a,EAAI,EAAGA,EAAIikB,EAAKllB,OAAQiB,IAE7B6G,EAAG0Q,cAAc1Q,EAAG2Q,SAAWxX,GAC/B6G,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,MAGlC7d,KAAKqhB,cAAgB,KACrBrhB,KAAKohB,YAAc,KAEnBphB,KAAKghB,qBAAuB,EAC5BhhB,KAAKihB,qBAELjhB,KAAKkjB,gBAaTrO,cAAe,SAAUyV,GAIrB,QAFYprB,IAARorB,IAAqBA,GAAM,IAE3BtqB,KAAKmjB,eAAT,CAMAnjB,KAAKiR,QAEL,IAAIhE,EAAKjN,KAAKiN,GACVod,EAAOrqB,KAAKmhB,aAEhB,GAAImJ,EACJ,CACI,IAAK,IAAIlkB,EAAI,EAAGA,EAAIikB,EAAKllB,OAAQiB,IAE7B6G,EAAG0Q,cAAc1Q,EAAG2Q,SAAWxX,GAC/B6G,EAAGyQ,YAAYzQ,EAAG4Q,WAAYwM,EAAKjkB,IAGvC6G,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAYwM,EAAK,IAEnCrqB,KAAKmjB,gBAAiB,OAItBlW,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYwM,EAAK,IAEnCpd,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAYwM,EAAK,IAGvCrqB,KAAKqhB,cAAgB,KACrBrhB,KAAKohB,YAAc,KAEnBphB,KAAKghB,qBAAuB,EAC5BhhB,KAAKihB,qBAELjhB,KAAKkjB,iBAeTnG,aAAc,SAAUF,GAEpB,GAAI7c,KAAKwP,UAAUuE,YAIf,OAFA/T,KAAK4pB,eAAe/M,GAAS,GAEtB,EAGX,IAAI5P,EAAKjN,KAAKiN,GACV+T,EAAuBhhB,KAAKghB,qBAqChC,OAnCInE,EAAQgN,eAAiB7pB,KAAKihB,qBAE9BpE,EAAQgN,eAAiB7pB,KAAKihB,mBAE1BD,EAAuBhhB,KAAKwY,aAE5BqE,EAAQiN,QAAU9I,EAElB/T,EAAG0Q,cAAc1Q,EAAG2Q,SAAWoD,GAC/B/T,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B7c,KAAKghB,yBAKLhhB,KAAKiR,QAELjR,KAAKihB,qBAELjhB,KAAKkjB,eAELrG,EAAQgN,eAAiB7pB,KAAKihB,mBAE9BpE,EAAQiN,QAAU,EAElB7c,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B7c,KAAKghB,qBAAuB,IAIpChhB,KAAKmjB,gBAAiB,EAEftG,EAAQiN,SAoBnBS,gBAAiB,SAAUC,EAAaC,EAAe5V,EAAe6V,GAElE,OAAIF,IAAgBxqB,KAAKshB,mBAEdthB,MAGXA,KAAKuhB,SAAS/K,KAAKgU,GAEZxqB,KAAK2qB,eAAeH,EAAaC,EAAe5V,EAAe6V,KAoB1EC,eAAgB,SAAUH,EAAaC,EAAe5V,EAAe6V,GAMjE,QAJsBxrB,IAAlBurB,IAA+BA,GAAgB,QAC7BvrB,IAAlB2V,IAA+BA,GAAgB,QAC/B3V,IAAhBwrB,IAA6BA,GAAc,GAE3CF,IAAgBxqB,KAAKshB,mBAErB,OAAOthB,KAGX,IAAIiN,EAAKjN,KAAKiN,GAEVlL,EAAQ/B,KAAK+B,MACbC,EAAShC,KAAKgC,OA0ClB,OAxCIwoB,GAAeA,EAAYI,eAAiBF,GAE5C3oB,EAAQyoB,EAAYI,cAAc7oB,MAClCC,EAASwoB,EAAYI,cAAc5oB,QAInChC,KAAKiR,QAGThE,EAAG6a,gBAAgB7a,EAAG8a,YAAayC,GAE/BE,GAEAzd,EAAGwH,SAAS,EAAG,EAAG1S,EAAOC,GAGzByoB,IAEID,GAEAxqB,KAAKsN,oBAAsBtL,EAE3BhC,KAAKwoB,YAAY,EAAG,EAAGzmB,EAAOC,KAI9BhC,KAAKsN,oBAAsBtN,KAAKgC,OAEhChC,KAAK2oB,eAIb3oB,KAAKshB,mBAAqBkJ,EAEtB3V,GAEA7U,KAAK6U,gBAGF7U,MAeX6qB,eAAgB,SAAUJ,EAAe5V,EAAe6V,QAE9BxrB,IAAlBurB,IAA+BA,GAAgB,QAC7BvrB,IAAlB2V,IAA+BA,GAAgB,QAC/B3V,IAAhBwrB,IAA6BA,GAAc,GAE/C,IAAInJ,EAAWvhB,KAAKuhB,SAGpBA,EAASqH,MAGT,IAAI4B,EAAcjJ,EAASA,EAASpc,OAAS,GAS7C,OAPKqlB,IAEDA,EAAc,MAGlBxqB,KAAK2qB,eAAeH,EAAaC,EAAe5V,EAAe6V,GAExDF,GAkBXM,WAAY,SAAUvY,GAElB,OAAIA,IAAYvS,KAAKwS,iBAEjBxS,KAAKiR,QAELjR,KAAKiN,GAAG8d,WAAWxY,GAEnBvS,KAAKwS,eAAiBD,GAEf,IAefyY,aAAc,WAIV,OAFAhrB,KAAKiN,GAAG8d,WAAW/qB,KAAKwS,gBAEjBxS,MAgBXirB,wBAAyB,SAAU1iB,EAAQxG,EAAOC,EAAQmI,GAEtD,IAAI8C,EAAKjN,KAAKiN,GACV0J,EAAY1J,EAAGie,QACfC,EAAYle,EAAGie,QACfE,EAAOne,EAAGoe,cAGdtpB,EAAQwG,EAASA,EAAOxG,MAAQA,EAChCC,EAASuG,EAASA,EAAOvG,OAASA,EAElC,IAAIspB,EAAMxL,EAAiB/d,EAAOC,GAsBlC,OApBIspB,IAEAF,EAAOne,EAAGse,QAGVphB,IAAczJ,EAAM8qB,WAAWC,QAAUzrB,KAAKuB,OAAOG,YAErDiV,EAAY,EAAQ3W,KAAK6gB,aAAe5T,EAAGwe,OAC3CN,EAAYle,EAAGwe,QAGdljB,GAA2B,iBAAVxG,GAAwC,iBAAXC,EAMrChC,KAAK0rB,gBAAgB,EAAG/U,EAAWwU,EAAWC,EAAMA,EAAMne,EAAGU,KAAMpF,GAJnEvI,KAAK0rB,gBAAgB,EAAG/U,EAAWwU,EAAWC,EAAMA,EAAMne,EAAGU,KAAM,KAAM5L,EAAOC,IA+BlG0pB,gBAAiB,SAAUC,EAAUhV,EAAWwU,EAAWS,EAAOC,EAAOC,EAAQje,EAAQ9L,EAAOC,EAAQ+pB,EAAKC,EAAWjjB,GAEpHgjB,EAAM,MAACA,GAA4CA,OACjC7sB,IAAd8sB,IAA2BA,GAAY,QAC7B9sB,IAAV6J,IAAuBA,GAAQ,GAEnC,IAAIkE,EAAKjN,KAAKiN,GACV4P,EAAU5P,EAAGua,gBAEjBva,EAAG0Q,cAAc1Q,EAAG2Q,UAEpB,IAAIqO,EAAiBhf,EAAGkN,aAAalN,EAAGif,oBA4CxC,OA1CAjf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B5P,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGmf,mBAAoBzV,GACvD1J,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGof,mBAAoBlB,GACvDle,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGqf,eAAgBT,GACnD5e,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGsf,eAAgBX,GAEnD3e,EAAGuf,YAAYvf,EAAGwf,+BAAgCV,GAClD9e,EAAGuf,YAAYvf,EAAGyf,oBAAqB3jB,GAEnC8E,MAAAA,EAEAZ,EAAGwa,WAAWxa,EAAG4Q,WAAY8N,EAAUG,EAAQ/pB,EAAOC,EAAQ,EAAG8pB,EAAQ7e,EAAGW,cAAe,OAItFoe,IAEDjqB,EAAQ8L,EAAO9L,MACfC,EAAS6L,EAAO7L,QAGpBiL,EAAGwa,WAAWxa,EAAG4Q,WAAY8N,EAAUG,EAAQA,EAAQ7e,EAAGW,cAAeC,IAGzEiS,EAAiB/d,EAAOC,IAExBiL,EAAG0f,eAAe1f,EAAG4Q,YAGrBoO,GAEAhf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYoO,GAGlCpP,EAAQ+P,qBAAuBb,EAC/BlP,EAAQgQ,iBAAkB,EAC1BhQ,EAAQ9a,MAAQA,EAChB8a,EAAQ7a,OAASA,EACjB6a,EAAQiN,QAAU,EAClBjN,EAAQgN,gBAAkB,EAEnBhN,GAgBXiQ,kBAAmB,SAAU/qB,EAAOC,EAAQ4oB,EAAemC,GAEvD,IAEIC,EAFA/f,EAAKjN,KAAKiN,GACVud,EAAcvd,EAAG6f,oBAKrB,GAFA9sB,KAAK2qB,eAAeH,GAEhBuC,EACJ,CACI,IAAIE,EAAqBhgB,EAAGigB,qBAE5BjgB,EAAGkgB,iBAAiBlgB,EAAGmgB,aAAcH,GACrChgB,EAAGogB,oBAAoBpgB,EAAGmgB,aAAcngB,EAAGqgB,cAAevrB,EAAOC,GACjEiL,EAAGsgB,wBAAwBtgB,EAAG8a,YAAa9a,EAAGugB,yBAA0BvgB,EAAGmgB,aAAcH,GAU7F,GAPArC,EAAciC,iBAAkB,EAChCjC,EAAcgC,sBAAuB,EAErC3f,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAY+M,EAAe,IAE5FoC,EAAW/f,EAAG0gB,uBAAuB1gB,EAAG8a,gBAEvB9a,EAAG2gB,qBAShB,MAAM,IAAIpK,MAAM,uBAPH,CACT,MAAO,wBACP,MAAO,qBACP,MAAO,wBACP,MAAO,2BAGqCwJ,IASpD,OANAxC,EAAYI,cAAgBA,EAE5B5qB,KAAK2qB,eAAe,MAEpB3qB,KAAK6U,gBAEE2V,GAgBXqD,cAAe,SAAUC,EAAcC,GAEnC,IAAI9gB,EAAKjN,KAAKiN,GACVsF,EAAUtF,EAAG4gB,gBACbG,EAAK/gB,EAAGghB,aAAahhB,EAAGihB,eACxBC,EAAKlhB,EAAGghB,aAAahhB,EAAGmhB,iBAO5B,GALAnhB,EAAGohB,aAAaL,EAAIF,GACpB7gB,EAAGohB,aAAaF,EAAIJ,GACpB9gB,EAAGqhB,cAAcN,GACjB/gB,EAAGqhB,cAAcH,IAEZlhB,EAAGshB,mBAAmBP,EAAI/gB,EAAGuhB,gBAE9B,MAAM,IAAIhL,MAAM,0BAA4BvW,EAAGwhB,iBAAiBT,IAGpE,IAAK/gB,EAAGshB,mBAAmBJ,EAAIlhB,EAAGuhB,gBAE9B,MAAM,IAAIhL,MAAM,4BAA8BvW,EAAGwhB,iBAAiBN,IAOtE,GAJAlhB,EAAGyhB,aAAanc,EAASyb,GACzB/gB,EAAGyhB,aAAanc,EAAS4b,GACzBlhB,EAAG0hB,YAAYpc,IAEVtF,EAAG2hB,oBAAoBrc,EAAStF,EAAG4hB,aAEpC,MAAM,IAAIrL,MAAM,yBAA2BvW,EAAG6hB,kBAAkBvc,IAKpE,OAFAtF,EAAG8d,WAAWxY,GAEPA,GAcX6E,mBAAoB,SAAU2X,EAAmBC,GAE7C,IAAI/hB,EAAKjN,KAAKiN,GACVwI,EAAexI,EAAGgiB,eAMtB,OAJAhiB,EAAGoN,WAAWpN,EAAGqN,aAAc7E,GAC/BxI,EAAG4N,WAAW5N,EAAGqN,aAAcyU,EAAmBC,GAClD/hB,EAAGoN,WAAWpN,EAAGqN,aAAc,MAExB7E,GAcXyZ,kBAAmB,SAAUH,EAAmBC,GAE5C,IAAI/hB,EAAKjN,KAAKiN,GACVkiB,EAAcliB,EAAGgiB,eAMrB,OAJAhiB,EAAGoN,WAAWpN,EAAGmiB,qBAAsBD,GACvCliB,EAAG4N,WAAW5N,EAAGmiB,qBAAsBL,EAAmBC,GAC1D/hB,EAAGoN,WAAWpN,EAAGmiB,qBAAsB,MAEhCD,GAeX9H,cAAe,SAAUxK,EAASwS,GAY9B,OAVIA,GAEArvB,KAAK6U,eAAc,GAGnBgI,GAEA7c,KAAKiN,GAAGoa,cAAcxK,GAGnB7c,MAaXsvB,kBAAmB,SAAU9E,GAczB,OAZIA,IAEAxqB,KAAKiN,GAAGqiB,kBAAkB9E,GAE1B5K,EAAY5f,KAAKuhB,SAAUiJ,GAEvBxqB,KAAKshB,qBAAuBkJ,IAE5BxqB,KAAKshB,mBAAqB,OAI3BthB,MAaXuvB,cAAe,SAAUhd,GAOrB,OALIA,GAEAvS,KAAKiN,GAAGsiB,cAAchd,GAGnBvS,MAaX0f,aAAc,SAAUxF,GAIpB,OAFAla,KAAKiN,GAAGyS,aAAaxF,GAEdla,MAYXwvB,gBAAiB,SAAUvqB,GAEvB,IAAII,EAAKJ,EAAOtC,EACZ2C,EAAKL,EAAOrC,EACZ2C,EAAKN,EAAOlD,MACZyD,EAAKP,EAAOjD,OAEZkb,EAAQjY,EAAOxD,gBAEnBwD,EAAOjB,KAAKzD,EAAasE,WAAYI,GAErCjF,KAAKwP,UAAU6C,eAAepN,GAE9BjF,KAAKwoB,YAAYnjB,EAAIC,EAAIC,EAAIC,GAEzBP,EAAOa,OAEP9F,KAAK4iB,kBAAkB9c,KAAOb,EAAOa,KACrC9F,KAAK4iB,kBAAkB3d,OAASA,EAAOe,YAEvCf,EAAOa,KAAK2pB,eAAezvB,KAAMiF,EAAQA,EAAOe,cAGhDkX,EAAMgK,QAAU,GAEDlnB,KAAKwP,UAAUwE,WAErBiJ,aACL5X,EAAIC,EAAIC,EAAIC,EACZ0P,EAAMwa,kBAAkBxS,EAAM+J,OAAQ/J,EAAM8J,QAAS9J,EAAM6J,MAAO,GAClE7J,EAAMgK,UAYlByI,sBAAuB,WAEnB,IAAIC,EAAO,KACPC,EAAQ7vB,KAAK0iB,UACboN,EAAa9vB,KAAK4iB,kBAWtB,OATIiN,EAAM1qB,OAAS,EAEfyqB,EAAOC,EAAMA,EAAM1qB,OAAS,GAEvB2qB,EAAWhqB,MAAQgqB,EAAWhqB,KAAKgjB,YAExC8G,EAAOE,GAGJF,GAaXG,iBAAkB,SAAU9qB,GAExB,IAAIuB,EAAcvB,EAAOuB,YACrBC,EAAaxB,EAAOwB,WAExB,GAAID,EAAYwpB,WAAcvpB,EAAWupB,WAAavpB,EAAWwpB,WACjE,CACI,IAAI7f,EAAWpQ,KAAKwP,UAAUwE,WAE9BxN,EAAY0pB,gBAAgB9f,EAAU8E,EAAMwa,mBAC5CjpB,EAAWypB,gBAAgB9f,EAAU8E,EAAMwa,mBAG/CzqB,EAAOyB,OAAQ,EAEf1G,KAAK2oB,aAED1jB,EAAOa,OAEP9F,KAAK4iB,kBAAkB9c,KAAO,KAE9Bb,EAAOa,KAAKoqB,gBAAgBlwB,KAAMiF,EAAOe,cAG7ChG,KAAKwP,UAAU8C,gBAAgBrN,GAE/BA,EAAOjB,KAAKzD,EAAaqG,YAAa3B,IAU1CR,UAAW,WAEP,IAAIzE,KAAK+gB,YAAT,CAEA,IAAI9T,EAAKjN,KAAKiN,GAKd,GAFAA,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MAE/B/nB,KAAKuB,OAAOC,kBAChB,CACI,IAAI8hB,EAAatjB,KAAKuB,OAAOE,gBAE7BwL,EAAGqW,WAAWA,EAAWyD,MAAOzD,EAAW0D,QAAS1D,EAAW2D,OAAQ3D,EAAW4D,SAElFja,EAAG2F,MAAM3F,EAAGkjB,iBAAmBljB,EAAGqH,iBAAmBrH,EAAGuH,oBAG5DvH,EAAG4Z,OAAO5Z,EAAG+a,cAEbhoB,KAAK2hB,eAAiB3hB,KAAKojB,eAE3BpjB,KAAK4hB,aAAazc,OAAS,EAC3BnF,KAAK4hB,aAAapL,KAAKxW,KAAK2hB,gBAExB3hB,KAAKoB,KAAK2D,MAAMW,iBAEhBuH,EAAGmb,QAAQ,EAAIpoB,KAAKsN,oBAAsBtN,KAAKgC,OAAShC,KAAK+B,MAAO/B,KAAKgC,QAG7EhC,KAAK2iB,YAAY7c,KAAO,KACxB9F,KAAK4iB,kBAAkB9c,KAAO,KAC9B9F,KAAK0iB,UAAUvd,OAAS,EAExBnF,KAAKkjB,aAAe,EAEpBljB,KAAKgE,KAAKpD,EAAOiE,cAqBrBC,OAAQ,SAAUC,EAAOC,EAAUC,GAE/B,IAAIjF,KAAK+gB,YAAT,CAEA,IAAI7b,EAAaF,EAASG,OAQ1B,GANAnF,KAAKgE,KAAKpD,EAAOwE,OAAQL,EAAOE,GAGhCjF,KAAKwvB,gBAAgBvqB,GAGF,IAAfC,EAOA,OALAlF,KAAKmE,aAAazD,EAAMinB,WAAWhd,aAGnC3K,KAAK+vB,iBAAiB9qB,GAM1BjF,KAAK8iB,YAAc,GAInB,IAFA,IAAIrT,EAAUzP,KAAK2iB,YAEVvc,EAAI,EAAGA,EAAIlB,EAAYkB,IAChC,CACIpG,KAAKijB,UAAa7c,IAAMlB,EAAa,EAErC,IAAImB,EAAQrB,EAASoB,GAEjBN,EAAOO,EAAMP,MAEjB2J,EAAUzP,KAAK2iB,aAEH7c,MAAQ2J,EAAQ3J,OAASA,GAGjC2J,EAAQ3J,KAAKoqB,gBAAgBlwB,KAAMyP,EAAQxK,QAG3Ca,GAAQ2J,EAAQ3J,OAASA,GAEzBA,EAAK2pB,eAAezvB,KAAMqG,EAAOpB,GAGjCoB,EAAMjC,YAAcpE,KAAKwhB,kBAEzBxhB,KAAKmE,aAAakC,EAAMjC,WAG5B,IAAIxC,EAAOyE,EAAMzE,KAEbA,IAAS5B,KAAK8iB,cAEd9iB,KAAK+iB,SAAU,EACf/iB,KAAK8iB,YAAclhB,GAGlB5B,KAAKijB,UAMNjjB,KAAKgjB,eAAgB,EAJrBhjB,KAAKgjB,cAAiBhe,EAASoB,EAAI,GAAGxE,OAAS5B,KAAK8iB,YAOxDzc,EAAM+pB,YAAYpwB,KAAMqG,EAAOpB,GAE/BjF,KAAK+iB,SAAU,GAGnBtT,EAAUzP,KAAK2iB,aAEH7c,MAGR2J,EAAQ3J,KAAKoqB,gBAAgBlwB,KAAMyP,EAAQxK,QAG/CjF,KAAKmE,aAAazD,EAAMinB,WAAWhd,QAGnC3K,KAAK+vB,iBAAiB9qB,KAU1B6B,WAAY,WAER,IAAI9G,KAAK+gB,YAAT,CAEA/gB,KAAKiR,QAELjR,KAAKgE,KAAKpD,EAAOgG,aAEjB,IAAIG,EAAQ/G,KAAK0C,cAEbqE,EAAMjE,WAENkd,EAAchgB,KAAKkC,OAAQ6E,GAE3BA,EAAMjE,SAAW,MAGjB9C,KAAKkjB,aAAe,IAEpBljB,KAAKihB,qBACLjhB,KAAKghB,qBAAuB,KA0BpC7Z,SAAU,SAAUrE,EAAUlB,EAAMqF,GAEhC,OAAOjH,KAAKkH,aAAa,EAAG,EAAGlH,KAAKiN,GAAGG,mBAAoBpN,KAAKiN,GAAGK,oBAAqBxK,EAAUlB,EAAMqF,IA6B5GC,aAAc,SAAUvE,EAAGC,EAAGb,EAAOC,EAAQc,EAAUlB,EAAMqF,GAEzD,IAAIF,EAAQ/G,KAAK0C,cAWjB,OATAqE,EAAMjE,SAAWA,EACjBiE,EAAMnF,KAAOA,EACbmF,EAAMhE,QAAUkE,EAChBF,EAAMlE,UAAW,EACjBkE,EAAMpE,EAAIA,EACVoE,EAAMnE,EAAIA,EACVmE,EAAMhF,MAAQqF,KAAKC,IAAItF,EAAO/B,KAAKiN,GAAGG,oBACtCrG,EAAM/E,OAASoF,KAAKC,IAAIrF,EAAQhC,KAAKiN,GAAGK,qBAEjCtN,MAwBXsH,cAAe,SAAU3E,EAAGC,EAAGE,GAM3B,OAJA9C,KAAKkH,aAAavE,EAAGC,EAAG,EAAG,EAAGE,GAE9B9C,KAAK0C,cAAcG,UAAW,EAEvB7C,MA8BXqwB,oBAAqB,SAAU7F,EAAard,EAAaE,EAAcvK,EAAUD,EAAUF,EAAGC,EAAGb,EAAOC,EAAQJ,EAAMqF,QAEjG/H,IAAb2D,IAA0BA,GAAW,QAC/B3D,IAANyD,IAAmBA,EAAI,QACjBzD,IAAN0D,IAAmBA,EAAI,QACb1D,IAAV6C,IAAuBA,EAAQoL,QACpBjO,IAAX8C,IAAwBA,EAASqL,GAErC,IAAIiU,EAAqBthB,KAAKshB,mBAE9BthB,KAAKkH,aAAavE,EAAGC,EAAGb,EAAOC,EAAQc,EAAUlB,EAAMqF,GAEvD,IAAIF,EAAQ/G,KAAK0C,cAiBjB,OAfAqE,EAAMlE,SAAWA,EAEjBkE,EAAMmG,eAAgB,EACtBnG,EAAMoG,YAAcA,EACpBpG,EAAMsG,aAAeA,EAErBrN,KAAK2qB,eAAeH,GAEpBxK,EAAchgB,KAAKkC,OAAQ6E,GAE3B/G,KAAK2qB,eAAerJ,GAEpBva,EAAMjE,SAAW,KACjBiE,EAAMmG,eAAgB,EAEflN,MAkBXswB,gBAAiB,SAAUC,EAAWC,EAAYC,EAAU1nB,GAKxD,YAHiB7J,IAAbuxB,IAA0BA,GAAW,QAC3BvxB,IAAV6J,IAAuBA,GAAQ,GAE9BynB,EAMMxwB,KAAK0wB,oBAAoBH,EAAWC,EAAYznB,GAJhD/I,KAAK2wB,oBAAoBJ,EAAWE,EAAU1nB,IAoB7D4nB,oBAAqB,SAAUJ,EAAWE,EAAU1nB,QAE/B7J,IAAbuxB,IAA0BA,GAAW,QAC3BvxB,IAAV6J,IAAuBA,GAAQ,GAEnC,IAAIkE,EAAKjN,KAAKiN,GACV0J,EAAY1J,EAAGie,QACfC,EAAYle,EAAGie,QAEfnpB,EAAQwuB,EAAUxuB,MAClBC,EAASuuB,EAAUvuB,OAEnB4uB,EAAW3jB,EAAGoe,cAEdC,EAAMxL,EAAiB/d,EAAOC,GAalC,OAXKyuB,GAAYnF,IAEbsF,EAAW3jB,EAAGse,QAGdvrB,KAAKuB,OAAOG,YAEZiV,EAAY,EAAQ3W,KAAK6gB,aAAe5T,EAAGwe,OAC3CN,EAAYle,EAAGwe,QAGZzrB,KAAK0rB,gBAAgB,EAAG/U,EAAWwU,EAAWyF,EAAUA,EAAU3jB,EAAGU,KAAM4iB,EAAWxuB,EAAOC,GAAQ,GAAM,EAAO+G,IAe7H2nB,oBAAqB,SAAUH,EAAWC,EAAYznB,QAEpC7J,IAAV6J,IAAuBA,GAAQ,GAEnC,IAAIkE,EAAKjN,KAAKiN,GAEVlL,EAAQwuB,EAAUxuB,MAClBC,EAASuuB,EAAUvuB,OAEvB,GAAID,EAAQ,GAAKC,EAAS,EAC1B,CACIiL,EAAG0Q,cAAc1Q,EAAG2Q,UACpB,IAAIqO,EAAiBhf,EAAGkN,aAAalN,EAAGif,oBACxCjf,EAAGyQ,YAAYzQ,EAAG4Q,WAAY2S,GAE9BvjB,EAAGuf,YAAYvf,EAAGyf,oBAAqB3jB,GACvCkE,EAAGuf,YAAYvf,EAAGwf,gCAAgC,GAElDxf,EAAGwa,WAAWxa,EAAG4Q,WAAY,EAAG5Q,EAAGU,KAAMV,EAAGU,KAAMV,EAAGW,cAAe2iB,GAEpEC,EAAWzuB,MAAQA,EACnByuB,EAAWxuB,OAASA,EAEhBiqB,GAEAhf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYoO,GAItC,OAAOuE,GAeXK,mBAAoB,SAAUC,EAAUL,EAAU1nB,QAE7B7J,IAAbuxB,IAA0BA,GAAW,QAC3BvxB,IAAV6J,IAAuBA,GAAQ,GAEnC,IAAIkE,EAAKjN,KAAKiN,GACV0J,EAAY1J,EAAGie,QACfC,EAAYle,EAAGie,QAEfnpB,EAAQ+uB,EAASC,WACjB/uB,EAAS8uB,EAASE,YAElBJ,EAAW3jB,EAAGoe,cAEdC,EAAMxL,EAAiB/d,EAAOC,GAalC,OAXKyuB,GAAYnF,IAEbsF,EAAW3jB,EAAGse,QAGdvrB,KAAKuB,OAAOG,YAEZiV,EAAY,EAAQ3W,KAAK6gB,aAAe5T,EAAGwe,OAC3CN,EAAYle,EAAGwe,QAGZzrB,KAAK0rB,gBAAgB,EAAG/U,EAAWwU,EAAWyF,EAAUA,EAAU3jB,EAAGU,KAAMmjB,EAAU/uB,EAAOC,GAAQ,GAAM,EAAM+G,IAe3HkoB,mBAAoB,SAAUH,EAAUN,EAAYznB,QAElC7J,IAAV6J,IAAuBA,GAAQ,GAEnC,IAAIkE,EAAKjN,KAAKiN,GAEVlL,EAAQ+uB,EAASC,WACjB/uB,EAAS8uB,EAASE,YAEtB,GAAIjvB,EAAQ,GAAKC,EAAS,EAC1B,CACIiL,EAAG0Q,cAAc1Q,EAAG2Q,UACpB,IAAIqO,EAAiBhf,EAAGkN,aAAalN,EAAGif,oBACxCjf,EAAGyQ,YAAYzQ,EAAG4Q,WAAY2S,GAE9BvjB,EAAGuf,YAAYvf,EAAGyf,oBAAqB3jB,GAEvCkE,EAAGwa,WAAWxa,EAAG4Q,WAAY,EAAG5Q,EAAGU,KAAMV,EAAGU,KAAMV,EAAGW,cAAekjB,GAEpEN,EAAWzuB,MAAQA,EACnByuB,EAAWxuB,OAASA,EAEhBiqB,GAEAhf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYoO,GAItC,OAAOuE,GAcXU,iBAAkB,SAAUrU,EAASsU,GAEjC,IAAIlkB,EAAKjN,KAAKiN,GACVmkB,EAAW,CAAEnkB,EAAGwe,OAAQxe,EAAGie,SAAUiG,GAEzClkB,EAAG0Q,cAAc1Q,EAAG2Q,UAEpB,IAAIqO,EAAiBhf,EAAGkN,aAAalN,EAAGif,oBAYxC,OAVAjf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYhB,GAE9B5P,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGmf,mBAAoBgF,GACvDnkB,EAAGkf,cAAclf,EAAG4Q,WAAY5Q,EAAGof,mBAAoB+E,GAEnDnF,GAEAhf,EAAGyQ,YAAYzQ,EAAG4Q,WAAYoO,GAG3BjsB,MAaXqxB,kBAAmB,WAEf,OAAOrxB,KAAKuB,OAAOof,gBASvBtW,QAAS,WAELrK,KAAKkC,OAAOovB,oBAAoB,mBAAoBtxB,KAAK6hB,oBAAoB,GAC7E7hB,KAAKkC,OAAOovB,oBAAoB,uBAAwBtxB,KAAK8hB,wBAAwB,GAMrF,IAJA,IAAI7U,EAAKjN,KAAKiN,GAEVod,EAAOrqB,KAAKmhB,aAEP/a,EAAI,EAAGA,EAAIikB,EAAKllB,OAAQiB,IAE7B6G,EAAGoa,cAAcgD,EAAKjkB,IAG1BpG,KAAKwP,UAAUnF,UAEfrK,KAAKsK,qBAELtK,KAAKuhB,SAAW,GAChBvhB,KAAK0iB,UAAY,GACjB1iB,KAAKkiB,WAAa,GAClBliB,KAAKkhB,eAAiB,GAEtBlhB,KAAKiN,GAAK,KACVjN,KAAKoB,KAAO,KACZpB,KAAKkC,OAAS,KACdlC,KAAK+gB,aAAc,EACnB/gB,KAAK2iB,YAAc,KACnB3iB,KAAK4iB,kBAAoB,QAKjC7jB,EAAOC,QAAUihB,G,gBCx6FjB,IAAIxf,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvB+kB,EAAc,EAAQ,OA2BtBpc,EAAc,IAAI1U,EAAM,CAExBU,WAEA,SAAsBiP,EAAUO,EAAMmd,EAAcC,EAAgB/U,GAWhEhZ,KAAKoQ,SAAWA,EAShBpQ,KAAK2Q,KAAOA,EASZ3Q,KAAK6O,SAAWuB,EAASvB,SASzB7O,KAAKiN,GAAKjN,KAAK6O,SAAS5B,GASxBjN,KAAKuS,QAAUvS,KAAK6O,SAASgf,cAAcC,EAAcC,GASzD/tB,KAAKgZ,WASLhZ,KAAK2b,qBAAuB,EAwB5B3b,KAAK8W,WAAa,EAalB9W,KAAKwxB,SAAW,GAEhBxxB,KAAKyxB,iBAAiBzY,GACtBhZ,KAAK0xB,kBAkBTD,iBAAkB,SAAUzY,GAExB,IAAI2Y,EAAQ,EACRC,EAAS,EACTC,EAAS,GAEb7xB,KAAK2b,qBAAuB,EAE5B,IAAK,IAAIvV,EAAI,EAAGA,EAAI4S,EAAW7T,OAAQiB,IACvC,CACI,IAAI0rB,EAAU9Y,EAAW5S,GAErBuK,EAAOmhB,EAAQnhB,KACfohB,EAAOvlB,EAAaslB,EAAS,OAAQ,GACrCE,EAASxlB,EAAaslB,EAAS,OAAQP,EAAY3M,OACnDhjB,EAAOowB,EAAOC,KACdC,EAAWF,EAAOD,KAElBI,IAAcL,EAAkB,WAEpCD,EAAOrb,KAAK,CACR7F,KAAMA,EACNohB,KAAMA,EACNnwB,KAAMA,EACNuwB,WAAYA,EACZP,OAAQA,EACRQ,SAAS,EACTC,UAAW,IAGE,IAAbH,EAEAP,GAASI,EAITJ,IAGJC,GAAUG,EAAOG,EAGrBlyB,KAAK8W,WAAa8a,EAClB5xB,KAAK2b,qBAAuBgW,EAC5B3xB,KAAKgZ,WAAa6Y,GAgBtBhgB,KAAM,SAAUmG,EAAe/G,GAiB3B,YAfsB/R,IAAlB8Y,IAA+BA,GAAgB,QACrC9Y,IAAV+R,IAAuBA,GAAQ,GAE/BA,GAEAjR,KAAKoQ,SAASa,QAGlBjR,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE1ByF,GAEAhY,KAAKsyB,oBAGFtyB,MAaXiU,OAAQ,WAMJ,OAJAjU,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE9BvS,KAAKsyB,mBAAkB,GAEhBtyB,MAiBXsyB,kBAAmB,SAAUjD,QAEXnwB,IAAVmwB,IAAuBA,GAAQ,GAOnC,IALA,IAAIpiB,EAAKjN,KAAKiN,GACV6J,EAAa9W,KAAK8W,WAClBkC,EAAahZ,KAAKgZ,WAClBzG,EAAUvS,KAAKuS,QAEVnM,EAAI,EAAGA,EAAI4S,EAAW7T,OAAQiB,IACvC,CACI,IAAI0rB,EAAU9Y,EAAW5S,GAErB2rB,EAAOD,EAAQC,KACfnwB,EAAOkwB,EAAQlwB,KACfgwB,EAASE,EAAQF,OACjBQ,EAAUN,EAAQM,QAClBC,EAAWP,EAAQO,SACnBF,IAAcL,EAAkB,WAEpC,GAAIzC,EACJ,CACI,IAAIkD,EAAiBtlB,EAAGulB,kBAAkBjgB,EAASuf,EAAQnhB,MAEvD4hB,GAAkB,GAElBtlB,EAAGwlB,wBAAwBF,GAE3BtlB,EAAGylB,oBAAoBH,EAAgBR,EAAMnwB,EAAMuwB,EAAYrb,EAAY8a,GAE3EE,EAAQM,SAAU,EAClBN,EAAQO,SAAWE,IAEM,IAApBA,GAELtlB,EAAG0lB,yBAAyBJ,QAG3BH,EAELnlB,EAAGylB,oBAAoBL,EAAUN,EAAMnwB,EAAMuwB,EAAYrb,EAAY8a,IAE/DQ,GAAWC,GAAY,IAE7BplB,EAAG0lB,yBAAyBN,GAE5BP,EAAQO,UAAY,GAI5B,OAAOryB,MAmBX0xB,eAAgB,WAEZ,IAIItrB,EACAuK,EACA0hB,EANAplB,EAAKjN,KAAKiN,GACVsF,EAAUvS,KAAKuS,QACfif,EAAWxxB,KAAKwxB,SAQhBoB,EAAgB3lB,EAAG2hB,oBAAoBrc,EAAStF,EAAG4lB,iBAEvD,IAAKzsB,EAAI,EAAGA,EAAIwsB,EAAexsB,IAC/B,CACI,IAAI0sB,EAAO7lB,EAAG8lB,iBAAiBxgB,EAASnM,GAExC,GAAI0sB,EACJ,CACIniB,EAAOmiB,EAAKniB,KAIK,QAFjB0hB,EAAWplB,EAAG+lB,mBAAmBzgB,EAAS5B,MAItC6gB,EAAS7gB,GACT,CACIA,KAAMA,EACN0hB,SAAUA,EACVY,OAAQ,KACRC,OAAQ,KACRC,OAAQ,KACRC,OAAQ,OAQhB,IAAIC,EAAS1iB,EAAKgW,QAAQ,KAEtB0M,EAAS,IAET1iB,EAAOA,EAAK2iB,OAAO,EAAGD,GAEjB7B,EAAS+B,eAAe5iB,IAIR,QAFjB0hB,EAAWplB,EAAG+lB,mBAAmBzgB,EAAS5B,MAItC6gB,EAAS7gB,GACT,CACIA,KAAMA,EACN0hB,SAAUA,EACVY,OAAQ,KACRC,OAAQ,KACRC,OAAQ,KACRC,OAAQ,SAQhC,OAAOpzB,MAaXuZ,WAAY,SAAU5I,GAElB,OAAO3Q,KAAKwxB,SAAS+B,eAAe5iB,IAaxC6I,aAAc,SAAU7I,GAEpB,IAAIqN,EAAUhe,KAAKwxB,SAAS7gB,GAU5B,OARIqN,IAEAA,EAAQiV,OAAS,KACjBjV,EAAQkV,OAAS,KACjBlV,EAAQmV,OAAS,KACjBnV,EAAQoV,OAAS,MAGdpzB,MAwBXwzB,YAAa,SAAUC,EAAQ9iB,EAAMsiB,EAAQS,GAEzC,IAAI1V,EAAUhe,KAAKwxB,SAAS7gB,GAE5B,OAAKqN,IAKD0V,GAAa1V,EAAQiV,SAAWA,KAEhCjV,EAAQiV,OAASA,EAEjBjzB,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE9BkhB,EAAOpyB,KAAKrB,KAAKiN,GAAI+Q,EAAQqU,SAAUY,GAEvCjzB,KAAKoQ,SAASsB,cAAgB1R,MAG3BA,MAdIA,MAuCf2zB,YAAa,SAAUF,EAAQ9iB,EAAMsiB,EAAQC,EAAQQ,GAEjD,IAAI1V,EAAUhe,KAAKwxB,SAAS7gB,GAE5B,OAAKqN,IAKD0V,GAAa1V,EAAQiV,SAAWA,GAAUjV,EAAQkV,SAAWA,KAE7DlV,EAAQiV,OAASA,EACjBjV,EAAQkV,OAASA,EAEjBlzB,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE9BkhB,EAAOpyB,KAAKrB,KAAKiN,GAAI+Q,EAAQqU,SAAUY,EAAQC,GAE/ClzB,KAAKoQ,SAASsB,cAAgB1R,MAG3BA,MAfIA,MAyCf4zB,YAAa,SAAUH,EAAQ9iB,EAAMsiB,EAAQC,EAAQC,EAAQO,GAEzD,IAAI1V,EAAUhe,KAAKwxB,SAAS7gB,GAE5B,OAAKqN,IAKD0V,GAAa1V,EAAQiV,SAAWA,GAAUjV,EAAQkV,SAAWA,GAAUlV,EAAQmV,SAAWA,KAE1FnV,EAAQiV,OAASA,EACjBjV,EAAQkV,OAASA,EACjBlV,EAAQmV,OAASA,EAEjBnzB,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE9BkhB,EAAOpyB,KAAKrB,KAAKiN,GAAI+Q,EAAQqU,SAAUY,EAAQC,EAAQC,GAEvDnzB,KAAKoQ,SAASsB,cAAgB1R,MAG3BA,MAhBIA,MA2Cf6zB,YAAa,SAAUJ,EAAQ9iB,EAAMsiB,EAAQC,EAAQC,EAAQC,EAAQM,GAEjE,IAAI1V,EAAUhe,KAAKwxB,SAAS7gB,GAE5B,OAAKqN,IAKD0V,GAAa1V,EAAQiV,SAAWA,GAAUjV,EAAQkV,SAAWA,GAAUlV,EAAQmV,SAAWA,GAAUnV,EAAQoV,SAAWA,KAEvHpV,EAAQiV,OAASA,EACjBjV,EAAQkV,OAASA,EACjBlV,EAAQmV,OAASA,EACjBnV,EAAQoV,OAASA,EAEjBpzB,KAAK6O,SAASic,WAAW9qB,KAAKuS,SAE9BkhB,EAAOpyB,KAAKrB,KAAKiN,GAAI+Q,EAAQqU,SAAUY,EAAQC,EAAQC,EAAQC,GAE/DpzB,KAAKoQ,SAASsB,cAAgB1R,MAG3BA,MAjBIA,MAqCfie,MAAO,SAAUtN,EAAMhO,GAEnB,OAAO3C,KAAKwzB,YAAYxzB,KAAKiN,GAAGkY,UAAWxU,EAAMhO,IAqBrDyb,MAAO,SAAUzN,EAAMhO,EAAGC,GAEtB,OAAO5C,KAAK2zB,YAAY3zB,KAAKiN,GAAGsY,UAAW5U,EAAMhO,EAAGC,IAsBxDyb,MAAO,SAAU1N,EAAMhO,EAAGC,EAAG0b,GAEzB,OAAOte,KAAK4zB,YAAY5zB,KAAKiN,GAAG0Y,UAAWhV,EAAMhO,EAAGC,EAAG0b,IAuB3DC,MAAO,SAAU5N,EAAMhO,EAAGC,EAAG0b,EAAGE,GAE5B,OAAOxe,KAAK6zB,YAAY7zB,KAAKiN,GAAG8Y,UAAWpV,EAAMhO,EAAGC,EAAG0b,EAAGE,IAoB9DC,OAAQ,SAAU9N,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAGmY,WAAYzU,EAAM+N,GAAK,IAoB3DC,OAAQ,SAAUhO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAGuY,WAAY7U,EAAM+N,GAAK,IAoB3DE,OAAQ,SAAUjO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAG2Y,WAAYjV,EAAM+N,GAAK,IAoB3DG,OAAQ,SAAUlO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAG+Y,WAAYrV,EAAM+N,GAAK,IAoB3DI,OAAQ,SAAUnO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAGqY,WAAY3U,EAAM+N,GAAK,IAoB3DK,OAAQ,SAAUpO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAGyY,WAAY/U,EAAM+N,GAAK,IAoB3DM,OAAQ,SAAUrO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAG6Y,WAAYnV,EAAM+N,GAAK,IAoB3DO,OAAQ,SAAUtO,EAAM+N,GAEpB,OAAO1e,KAAKwzB,YAAYxzB,KAAKiN,GAAGiZ,WAAYvV,EAAM+N,GAAK,IAoB3DQ,MAAO,SAAUvO,EAAMhO,GAEnB,OAAO3C,KAAKwzB,YAAYxzB,KAAKiN,GAAGoY,UAAW1U,EAAMhO,IAqBrDwc,MAAO,SAAUxO,EAAMhO,EAAGC,GAEtB,OAAO5C,KAAK2zB,YAAY3zB,KAAKiN,GAAGwY,UAAW9U,EAAMhO,EAAGC,IAsBxDwc,MAAO,SAAUzO,EAAMhO,EAAGC,EAAG0b,GAEzB,OAAOte,KAAK4zB,YAAY5zB,KAAKiN,GAAG4Y,UAAWlV,EAAMhO,EAAGC,EAAG0b,IAuB3De,MAAO,SAAU1O,EAAMhO,EAAGC,EAAG0b,EAAGE,GAE5B,OAAOxe,KAAK6zB,YAAY7zB,KAAKiN,GAAGgZ,UAAWtV,EAAMhO,EAAGC,EAAG0b,EAAGE,IAqB9Dc,aAAc,SAAU3O,EAAM4O,EAAWrZ,GAErC,OAAOlG,KAAK2zB,YAAY3zB,KAAKiN,GAAG6X,iBAAkBnU,EAAM4O,EAAWrZ,GAAQ,IAqB/EsZ,aAAc,SAAU7O,EAAM4O,EAAWrZ,GAErC,OAAOlG,KAAK2zB,YAAY3zB,KAAKiN,GAAG+X,iBAAkBrU,EAAM4O,EAAWrZ,GAAQ,IAqB/EuT,aAAc,SAAU9I,EAAM4O,EAAWrZ,GAErC,OAAOlG,KAAK2zB,YAAY3zB,KAAKiN,GAAGiY,iBAAkBvU,EAAM4O,EAAWrZ,GAAQ,IAW/EmE,QAAS,WAELrK,KAAKiN,GAAGsiB,cAAcvvB,KAAKuS,SAE3BvS,KAAKoQ,SAAW,KAChBpQ,KAAK6O,SAAW,KAChB7O,KAAKiN,GAAK,KACVjN,KAAKuS,QAAU,KACfvS,KAAKgZ,WAAa,KAClBhZ,KAAKwxB,SAAW,QAKxBzyB,EAAOC,QAAUmW,G,UCjgCjBpW,EAAOC,QAnEW,CASdylB,KAAM,CAAEwN,KAAM,KAAQF,KAAM,GAS5BnkB,cAAe,CAAEqkB,KAAM,KAAQF,KAAM,GASrCrN,MAAO,CAAEuN,KAAM,KAAQF,KAAM,GAS7BpN,eAAgB,CAAEsN,KAAM,KAAQF,KAAM,GAStC+B,IAAK,CAAE7B,KAAM,KAAQF,KAAM,GAS3BgC,aAAc,CAAE9B,KAAM,KAAQF,KAAM,GASpCnN,MAAO,CAAEqN,KAAM,KAAQF,KAAM,K,gBC9DjC,IAAItxB,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvBwnB,EAAiB,EAAQ,OACzBC,EAAiB,EAAQ,OACzB1C,EAAc,EAAQ,OACtBnc,EAAgB,EAAQ,OA8BxBhH,EAAqB,IAAI3N,EAAM,CAE/BS,QAASkU,EAETjU,WAEA,SAA6BI,GAEzBA,EAAOwX,WAAavM,EAAajL,EAAQ,aAAcyyB,GACvDzyB,EAAOuX,WAAatM,EAAajL,EAAQ,aAAc0yB,GACvD1yB,EAAOwV,UAAYvK,EAAajL,EAAQ,YAAa,GACrDA,EAAO2yB,SAAW1nB,EAAajL,EAAQ,WAAY,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IACvEA,EAAOyX,WAAaxM,EAAajL,EAAQ,aAAc,CACnD,CACIoP,KAAM,aACNohB,KAAM,EACNnwB,KAAM2vB,EAAY3M,SAI1BxP,EAAc/T,KAAKrB,KAAMuB,IAG7BiC,KAAM,WAEF4R,EAAc+e,UAAU3wB,KAAKnC,KAAKrB,MAElCA,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKkf,MAAM,eAAgB,IAG/Bpb,OAAQ,SAAU/B,EAAOC,GAErBoT,EAAc+e,UAAUrwB,OAAOzC,KAAKrB,KAAM+B,EAAOC,GAEjDhC,KAAKoe,MAAM,cAAerc,EAAOC,IAcrCoyB,UAAW,SAAUtuB,EAAMuuB,EAAcpvB,GAErC,IAAIgI,EAAKjN,KAAKiN,GAGd,GAAInH,EAAKwuB,YAAcrnB,EACvB,CACI,IAAI4B,EAAW7O,KAAK6O,SAEpBA,EAASoC,QAETpC,EAAS0b,gBAAgBzkB,EAAKyuB,iBAE9BtnB,EAAGiH,QAAQjH,EAAGsH,cACdtH,EAAGqW,WAAW,EAAG,EAAG,EAAG,GACvBrW,EAAG2F,MAAM3F,EAAGkjB,kBAERthB,EAAS+T,kBAAkB9c,OAASA,IAEpC+I,EAAS8T,YAAY7c,KAAOA,EAC5B+I,EAAS8T,YAAY1d,OAASA,KAgB1CuvB,QAAS,SAAU1uB,EAAMb,GAErB,IAAIgI,EAAKjN,KAAKiN,GACV4B,EAAW7O,KAAK6O,SAGhBylB,EAAaxuB,EAAKwuB,WAEtB,GAAIA,GAAcrnB,EAClB,CAEI4B,EAASoC,QAGTpC,EAAS0b,gBAAgBzkB,EAAK2uB,iBAG9BxnB,EAAGqW,WAAW,EAAG,EAAG,EAAG,GACvBrW,EAAG2F,MAAM3F,EAAGkjB,kBAEZthB,EAAS1K,aAAa,GAAG,GAEzBmwB,EAAWlE,YAAYvhB,EAAUylB,EAAYrvB,GAE7C4J,EAASoC,QAGTpC,EAASgc,iBACThc,EAASgc,iBAGT,IAAI+E,EAAO/gB,EAAS8gB,wBAEhBC,GAEA3iB,EAAG4Z,OAAO5Z,EAAGsH,cAEbqb,EAAK9pB,KAAK4uB,aAAa7lB,EAAU+gB,EAAK3qB,QAAQ,IAI9C4J,EAAS8T,YAAY7c,KAAO,KAIhC+I,EAASW,UAAUiB,IAAIzQ,MAEvBiN,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAY/X,EAAK6uB,aAEnC1nB,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAY/X,EAAK8uB,aAEnC50B,KAAKkf,MAAM,mBAAoBpZ,EAAK+uB,aAGpC5nB,EAAG+N,WAAWhb,KAAK0V,SAAU,EAAG,GAEhC7G,EAASgG,oBAMrB9V,EAAOC,QAAUoP,G,gBCxLjB,IAAI3N,EAAQ,EAAQ,OAChBq0B,EAAS,EAAQ,OACjBtoB,EAAe,EAAQ,OACvBwnB,EAAiB,EAAQ,OACzBC,EAAiB,EAAQ,OACzBjzB,EAAkB,EAAQ,MAC1BuwB,EAAc,EAAQ,OACtBnc,EAAgB,EAAQ,OA8BxB/G,EAAmB,IAAI5N,EAAM,CAE7BS,QAASkU,EAETjU,WAEA,SAA2BI,GAEvBA,EAAOwX,WAAavM,EAAajL,EAAQ,aAAcyyB,GACvDzyB,EAAOuX,WAAatM,EAAajL,EAAQ,aAAc0yB,GACvD1yB,EAAOyX,WAAaxM,EAAajL,EAAQ,aAAc,CACnD,CACIoP,KAAM,aACNohB,KAAM,GAEV,CACIphB,KAAM,UACNohB,KAAM,EACNnwB,KAAM2vB,EAAY3jB,cAClBukB,YAAY,KAIpB/c,EAAc/T,KAAKrB,KAAMuB,GAUzBvB,KAAK+0B,WAAa,IAAI/zB,EAUtBhB,KAAKg1B,aAAe,CAChB,CAAEryB,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,IAWzB/B,KAAKi1B,WAAa,CAAEC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU7Cr1B,KAAKs1B,SAAW,CAAEJ,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU3Cr1B,KAAKu1B,aAAe,CAAElZ,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU/Cxc,KAAKw1B,UAAY,CAAE,EAAG,EAAG,EAAG,EAAG,GAU/Bx1B,KAAKy1B,SAAW,CAAE,EAAG,EAAG,EAAG,EAAG,GAU9Bz1B,KAAK01B,aAAe,IAkBxBC,cAAe,SAAUhzB,EAAGC,EAAGb,EAAOC,EAAQ4zB,EAAeC,GAEzD71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAIxX,EAAK5a,EAAIZ,EACTyb,EAAK5a,EAAIZ,EAET6Z,EAAKkZ,EAAWe,KAAKnzB,EAAGC,GACxBkZ,EAAKiZ,EAAWgB,KAAKpzB,EAAGC,GAExBmZ,EAAKgZ,EAAWe,KAAKnzB,EAAG6a,GACxBxB,EAAK+Y,EAAWgB,KAAKpzB,EAAG6a,GAExBvB,EAAK8Y,EAAWe,KAAKvY,EAAIC,GACzBtB,EAAK6Y,EAAWgB,KAAKxY,EAAIC,GAEzBrB,EAAK4Y,EAAWe,KAAKvY,EAAI3a,GACzBwZ,EAAK2Y,EAAWgB,KAAKxY,EAAI3a,GAEzB6Y,EAAOzb,KAAKs1B,SAEhBt1B,KAAK4b,UAAUC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIX,EAAKyZ,GAAIzZ,EAAK0Z,GAAI1Z,EAAK2Z,GAAI3Z,EAAK4Z,KAoBnFW,kBAAmB,SAAUna,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI0Z,EAAeC,GAEhE71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAIkB,EAAMlB,EAAWe,KAAKja,EAAIC,GAC1Boa,EAAMnB,EAAWgB,KAAKla,EAAIC,GAE1Bqa,EAAMpB,EAAWe,KAAK/Z,EAAIC,GAC1Boa,EAAMrB,EAAWgB,KAAKha,EAAIC,GAE1Bqa,EAAMtB,EAAWe,KAAK7Z,EAAIC,GAC1Boa,EAAMvB,EAAWgB,KAAK9Z,EAAIC,GAE1BT,EAAOzb,KAAKs1B,SAEhBt1B,KAAKgd,SAASiZ,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAK7a,EAAKyZ,GAAIzZ,EAAK0Z,GAAI1Z,EAAK2Z,KAuBvEmB,oBAAqB,SAAU1a,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIsa,EAAWZ,EAAeC,GAE7E,IAAIb,EAAeh1B,KAAKg1B,aAExBA,EAAa,GAAGryB,EAAIkZ,EACpBmZ,EAAa,GAAGpyB,EAAIkZ,EACpBkZ,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIoZ,EACpBiZ,EAAa,GAAGpyB,EAAIoZ,EACpBgZ,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIsZ,EACpB+Y,EAAa,GAAGpyB,EAAIsZ,EACpB8Y,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIkZ,EACpBmZ,EAAa,GAAGpyB,EAAIkZ,EACpBkZ,EAAa,GAAGjzB,MAAQy0B,EAExBx2B,KAAKy2B,gBAAgBzB,EAAcwB,GAAW,EAAOZ,EAAeC,IAkBxEa,cAAe,SAAUC,EAAMf,EAAeC,GAE1C71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAYzC,IATA,IAEI6B,EACAC,EAHA1xB,EAASwxB,EAAKxxB,OACduwB,EAAe11B,KAAK01B,aAIpBjZ,EAASzc,KAAKs1B,SAASJ,GACvBxY,EAAS1c,KAAKs1B,SAASH,GACvBxY,EAAS3c,KAAKs1B,SAASF,GAElB0B,EAAY,EAAGA,EAAY3xB,IAAU2xB,EAE1CD,EAAQF,EAAKG,GACbpB,EAAalf,KAAKqgB,EAAMl0B,EAAGk0B,EAAMj0B,GAIrCuC,GADAyxB,EAAoB9B,EAAOY,IACAvwB,OAE3B,IAAK,IAAImiB,EAAQ,EAAGA,EAAQniB,EAAQmiB,GAAS,EAC7C,CACI,IAAIyP,EAAoC,EAA/BH,EAAkBtP,EAAQ,GAC/B0P,EAAoC,EAA/BJ,EAAkBtP,EAAQ,GAC/B2P,EAAoC,EAA/BL,EAAkBtP,EAAQ,GAE/BzL,EAAK6Z,EAAaqB,EAAK,GACvBjb,EAAK4Z,EAAaqB,EAAK,GACvBhb,EAAK2Z,EAAasB,EAAK,GACvBhb,EAAK0Z,EAAasB,EAAK,GACvB/a,EAAKyZ,EAAauB,EAAK,GACvB/a,EAAKwZ,EAAauB,EAAK,GAEvBhB,EAAMlB,EAAWe,KAAKja,EAAIC,GAC1Boa,EAAMnB,EAAWgB,KAAKla,EAAIC,GAE1Bqa,EAAMpB,EAAWe,KAAK/Z,EAAIC,GAC1Boa,EAAMrB,EAAWgB,KAAKha,EAAIC,GAE1Bqa,EAAMtB,EAAWe,KAAK7Z,EAAIC,GAC1Boa,EAAMvB,EAAWgB,KAAK9Z,EAAIC,GAE9Blc,KAAKgd,SAASiZ,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAK7Z,EAAQC,EAAQC,GAGhE+Y,EAAavwB,OAAS,GAoB1BsxB,gBAAiB,SAAUE,EAAMH,EAAWU,EAAUtB,EAAeC,GAEjE71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAG5BA,KAAKy1B,SAAS,GAAK,EACnBz1B,KAAKw1B,UAAU,GAAK,EAIpB,IAFA,IAAI2B,EAAaR,EAAKxxB,OAAS,EAEtB2xB,EAAY,EAAGA,EAAYK,EAAYL,IAChD,CACI,IAAIM,EAAST,EAAKG,GACdO,EAASV,EAAKG,EAAY,GAE9B92B,KAAKs3B,UACDF,EAAOz0B,EACPy0B,EAAOx0B,EACPy0B,EAAO10B,EACP00B,EAAOz0B,EACPw0B,EAAOr1B,MAAQ,EACfs1B,EAAOt1B,MAAQ,EACfy0B,EACAM,GACCI,GAAaJ,IAAcK,EAAa,EACzCvB,EACAC,KAsBZyB,UAAW,SAAUC,EAAIC,EAAIC,EAAIC,EAAIC,EAAYC,EAAYpB,EAAWlP,EAAOuQ,EAAWjC,EAAeC,GAErG71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAI+C,EAAKL,EAAKF,EACVQ,EAAKL,EAAKF,EAEV7e,EAAMvR,KAAK4wB,KAAKF,EAAKA,EAAKC,EAAKA,GAC/BE,EAAMN,GAAcD,EAAKF,GAAM7e,EAC/Buf,EAAMP,GAAcJ,EAAKE,GAAM9e,EAC/Bwf,EAAMP,GAAcF,EAAKF,GAAM7e,EAC/Byf,EAAMR,GAAcL,EAAKE,GAAM9e,EAE/B0f,EAAMZ,EAAKU,EACXG,EAAMZ,EAAKU,EACXG,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMpB,EAAKU,EACXW,EAAMpB,EAAKU,EAGXW,EAAM9D,EAAWe,KAAKuC,EAAKC,GAC3BQ,EAAM/D,EAAWgB,KAAKsC,EAAKC,GAG3BS,EAAMhE,EAAWe,KAAKyC,EAAKC,GAC3BQ,EAAMjE,EAAWgB,KAAKwC,EAAKC,GAG3BS,EAAMlE,EAAWe,KAAK2C,EAAKC,GAC3BQ,EAAMnE,EAAWgB,KAAK0C,EAAKC,GAG3BS,EAAMpE,EAAWe,KAAK6C,EAAKC,GAC3BQ,EAAMrE,EAAWgB,KAAK4C,EAAKC,GAE3Bnd,EAAOzb,KAAKi1B,WAEZxY,EAAShB,EAAKyZ,GACdxY,EAASjB,EAAK0Z,GACdxY,EAASlB,EAAK2Z,GACdxY,EAASnB,EAAK4Z,GAKlB,GAFAr1B,KAAK4b,UAAUud,EAAKC,EAAKL,EAAKC,EAAKH,EAAKC,EAAKG,EAAKC,EAAKzc,EAAQC,EAAQC,EAAQC,KAE3E4Z,GAAa,GAAjB,CAMA,IAAI5G,EAAO5vB,KAAKy1B,SACZ4D,EAAQr5B,KAAKw1B,UAEblO,EAAQ,GAAKsI,EAAK,GAElB5vB,KAAK4b,UAAUud,EAAKC,EAAKL,EAAKC,EAAKpJ,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAInT,EAAQC,EAAQC,EAAQC,IAI/Fyc,EAAM,GAAKF,EACXE,EAAM,GAAKD,EACXC,EAAM,GAAKN,EACXM,EAAM,GAAKL,EACXK,EAAM,GAAK,GAGXxB,GAAawB,EAAM,GAGnBr5B,KAAK4b,UAAUid,EAAKC,EAAKG,EAAKC,EAAKG,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAI5c,EAAQC,EAAQC,EAAQC,IAMnGgT,EAAK,GAAKiJ,EACVjJ,EAAK,GAAKkJ,EACVlJ,EAAK,GAAKqJ,EACVrJ,EAAK,GAAKsJ,EACVtJ,EAAK,GAAK,KAoBlBxU,UAAW,SAAUzY,EAAGC,EAAG6Y,GAEvB,IAAI5F,EAAgB7V,KAAK6V,cACrBC,EAAgB9V,KAAK8V,cAErB4F,EAAgB1b,KAAKsV,YAActV,KAAK0R,cAAciK,qBAAwB,EAElF9F,IAAgB6F,GAAgB/Y,EAChCkT,IAAgB6F,GAAgB9Y,EAChCkT,IAAgB4F,GAAgBD,EAEhCzb,KAAKsV,eAuCTsG,UAAW,SAAUC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIK,EAAQC,EAAQC,EAAQC,GAEzE,IAAIE,GAAa,EAgBjB,OAdI9c,KAAKmZ,YAAY,KAEjBnZ,KAAKiR,QAEL6L,GAAa,GAGjB9c,KAAKob,UAAUS,EAAIC,EAAIW,GACvBzc,KAAKob,UAAUW,EAAIC,EAAIW,GACvB3c,KAAKob,UAAUa,EAAIC,EAAIU,GACvB5c,KAAKob,UAAUS,EAAIC,EAAIW,GACvBzc,KAAKob,UAAUa,EAAIC,EAAIU,GACvB5c,KAAKob,UAAUe,EAAIC,EAAIM,GAEhBI,GAkCXE,SAAU,SAAUnB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIO,EAAQC,EAAQC,GAExD,IAAIG,GAAa,EAajB,OAXI9c,KAAKmZ,YAAY,KAEjBnZ,KAAKiR,QAEL6L,GAAa,GAGjB9c,KAAKob,UAAUS,EAAIC,EAAIW,GACvBzc,KAAKob,UAAUW,EAAIC,EAAIU,GACvB1c,KAAKob,UAAUa,EAAIC,EAAIS,GAEhBG,GAWXzS,QAAS,WAML,OAJA+K,EAAc+e,UAAU9pB,QAAQhJ,KAAKrB,MAErCA,KAAK01B,aAAe,KAEb11B,QAKfjB,EAAOC,QAAUqP,G,gBC7pBjB,IAAI5N,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvB8sB,EAAsB,EAAQ,OAC9B/qB,EAAgB,EAAQ,OACxBgrB,EAAO,EAAQ,OACfnkB,EAAgB,EAAQ,OAExBokB,EAAc,GACdC,EAAW,IAAIF,EA8CfjrB,EAAgB,IAAI7N,EAAM,CAE1BS,QAASqN,EAETpN,WAEA,SAAwBI,GAEpBi4B,EAAcj4B,EAAOH,KAAKyN,SAAStN,OAAOqf,UAM1C,IAJA,IAAI7H,EAAavM,EAAajL,EAAQ,aAAc+3B,GAEhDpjB,EAAU,GAEL9P,EAAI,EAAGA,GAAKozB,EAAapzB,IAE9B8P,EAAQM,KAAK,CACT7F,KAAM,SAAWvK,EACjB2S,WAAYA,EAAW2gB,QAAQ,gBAAiBtzB,EAAEuzB,cAI1Dp4B,EAAO2U,QAAUA,EAEjB3H,EAAclN,KAAKrB,KAAMuB,GAUzBvB,KAAK45B,sBAAwB,IAAI3iB,aAAa,CAC1C,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,IAWVjX,KAAK65B,iBAWL75B,KAAK85B,cAAe,GAYxBt2B,KAAM,WAEF4R,EAAc+e,UAAU3wB,KAAKnC,KAAKrB,MAElC,IAAIiN,EAAKjN,KAAKiN,GAEVsa,EAActa,EAAGua,gBAErBva,EAAG0Q,cAAc1Q,EAAG2Q,UAEpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAY0J,GAE9Bta,EAAGwa,WAAWxa,EAAG4Q,WAAY,EAAG5Q,EAAGU,KAAM,EAAG,EAAG,EAAGV,EAAGU,KAAMV,EAAGW,cAAe,IAAIJ,WAAW,CAAE,IAAK,IAAK,IAAK,OAE7GxN,KAAK65B,iBAAmB,CAAExc,UAAWkK,GAGrC,IAAK,IAAInhB,EAAI,EAAGA,EAAIpG,KAAKkW,QAAQ/Q,OAAQiB,IAErCpG,KAAK,eAAiBoG,EAAI,IAAMpG,KAAKkW,QAAQ9P,IAcrDsR,SAAU,SAAU3S,EAAOE,GAEvB,IAAI80B,EAAeh1B,EAAMU,IAAIu0B,OAI7B,GAFAh6B,KAAK85B,cAAe,EAEfC,GAAiBA,EAAa5nB,OAAnC,CAKA,IAAI6nB,EAASD,EAAaE,UAAUh1B,GAChCi1B,EAAcF,EAAO70B,OAEzB,GAAoB,IAAhB+0B,EAAJ,CAWA,IAAI9zB,EAJJpG,KAAK85B,cAAe,EAEpB95B,KAAK8X,UAAU9X,KAAK,cAAgBk6B,IAAc,GAGlD,IACIl4B,EADWhC,KAAK6O,SACE7M,OAClBm4B,EAAel1B,EAAOiB,OAQ1B,IANAlG,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKoe,MAAM,cAAepe,KAAK+B,MAAQ,EAAG/B,KAAKgC,OAAS,GACxDhC,KAAKue,MAAM,UAAWtZ,EAAOtC,EAAGsC,EAAOrC,EAAGqC,EAAOoE,SAAUpE,EAAOm1B,MAClEp6B,KAAKqe,MAAM,qBAAsB0b,EAAaM,aAAaC,EAAGP,EAAaM,aAAaE,EAAGR,EAAaM,aAAaG,GAEhHp0B,EAAI,EAAGA,EAAI8zB,EAAa9zB,IAC7B,CACI,IAAIq0B,EAAQT,EAAO5zB,GAAGq0B,MAClBvd,EAAQud,EAAMvd,MAEdwd,EAAY,WAAat0B,EAAI,KAEjC+zB,EAAaQ,eAAeF,EAAM93B,EAAG83B,EAAM73B,EAAG62B,GAE9Cz5B,KAAKoe,MAAMsc,EAAY,WAAYjB,EAAS92B,EAAKsC,EAAOyE,QAAU+wB,EAAM9wB,cAAgB1E,EAAOm1B,KAAOp4B,GAAUy3B,EAAS72B,EAAKqC,EAAO2E,QAAU6wB,EAAM5wB,cAAiB5E,EAAOm1B,OAC7Kp6B,KAAKqe,MAAMqc,EAAY,QAASxd,EAAMod,EAAGpd,EAAMqd,EAAGrd,EAAMsd,GACxDx6B,KAAKie,MAAMyc,EAAY,YAAaD,EAAMG,WAC1C56B,KAAKie,MAAMyc,EAAY,SAAUD,EAAMI,QAG3C76B,KAAK86B,yBAA2B,QAYpCC,qBAAsB,SAAU1xB,GAE5B,GAAIA,IAAarJ,KAAK86B,0BAAiD,IAArB96B,KAAKsV,YACvD,CACQtV,KAAKsV,YAAc,GAEnBtV,KAAKiR,QAGT,IAAI2oB,EAAwB55B,KAAK45B,sBAEjC,GAAIvwB,EACJ,CACI,IAAI2xB,GAAO3xB,EACP4xB,EAAI7zB,KAAK8zB,IAAIF,GACbG,EAAI/zB,KAAKg0B,IAAIJ,GAEjBpB,EAAsB,GAAKuB,EAC3BvB,EAAsB,IAAMuB,EAC5BvB,EAAsB,GAAKA,EAAsB,GAAKqB,OAItDrB,EAAsB,GAAKA,EAAsB,GAAK,EACtDA,EAAsB,GAAKA,EAAsB,GAAK,EAG1D55B,KAAKwf,aAAa,0BAA0B,EAAOoa,GAEnD55B,KAAK86B,yBAA2BzxB,IAcxC0T,aAAc,SAAUF,EAASzL,GAE7B,IAAIvC,EAAW7O,KAAK6O,cAEJ3P,IAAZ2d,IAAyBA,EAAUhO,EAASsS,aAAa,IAE7D,IAAIE,EAAgBrhB,KAAKq7B,aAAajqB,GAElCvC,EAASkb,eAAelN,EAASwE,KAEjCrhB,KAAKiR,QAELpC,EAAS+a,eAAe/M,GACxBhO,EAASqb,aAAa7I,IAG1B,IAAIhY,EAAW,EAAe+H,EAAW/H,SAAW,EAMpD,OAJArJ,KAAK+6B,qBAAqB1xB,GAE1BrJ,KAAK+V,YAAc,EAEZ,GAgBXkD,cAAe,SAAU7H,EAAY3J,QAEnBvI,IAAVuI,IAAuBA,EAAQ2J,EAAW3J,OAE9C,IAAIoH,EAAW7O,KAAK6O,SAChBgO,EAAUpV,EAAM4V,UAChBgE,EAAgBrhB,KAAKq7B,aAAajqB,GActC,OAZIvC,EAASkb,mBAET/pB,KAAKiR,QAELpC,EAAS+a,eAAe/M,GACxBhO,EAASqb,aAAa7I,IAG1BrhB,KAAK+6B,qBAAqB3pB,EAAW/H,UAErCrJ,KAAK+V,YAAc,EAEZ,GAcXslB,aAAc,SAAUjqB,GAEpB,IAAIiQ,EA+BJ,OA7BKjQ,EAIIA,EAAWkqB,eAEhBja,EAAgBjQ,EAAWkqB,eAAeC,WAAWnqB,EAAWoqB,aAAavtB,aAExEmD,EAAWyL,QAEhBwE,EAAgBjQ,EAAWyL,QAAQ0e,WAAWnqB,EAAW3J,MAAMwG,aAE1DmD,EAAWqqB,UAIZpa,EAFA5K,MAAMC,QAAQtF,EAAWqqB,SAETrqB,EAAWqqB,QAAQ,GAAGrxB,MAAMmxB,WAAW,GAIvCnqB,EAAWqqB,QAAQrxB,MAAMmxB,WAAW,IAlBxDla,EAAgBrhB,KAAK65B,iBAsBpBxY,IAEDA,EAAgBrhB,KAAK65B,kBAGlBxY,EAAchE,WAazB9V,YAAa,SAAU6J,EAAYnM,EAAQyC,GAEnC1H,KAAK85B,cAELvrB,EAAc4lB,UAAU5sB,YAAYlG,KAAKrB,KAAMoR,EAAYnM,EAAQyC,IA2C3Eg0B,aAAc,SACVtqB,EACAyL,EACA8e,EAAcC,EACdC,EAAMC,EACNC,EAAUC,EACV1yB,EAAQC,EACRF,EACAP,EAAOC,EACPY,EAAeE,EACfpB,EAAgBC,EAChBX,EAAQC,EAAQC,EAAYE,EAC5BsU,EAAQC,EAAQC,EAAQC,EAAQpB,EAChCygB,EAASC,EACTj3B,EACAyC,EACAy0B,EACAC,GAEIp8B,KAAK85B,cAELvrB,EAAc4lB,UAAUuH,aAAar6B,KACjCrB,KACAoR,EACAyL,EACA8e,EAAcC,EACdC,EAAMC,EACNC,EAAUC,EACV1yB,EAAQC,EACRF,EACAP,EAAOC,EACPY,EAAeE,EACfpB,EAAgBC,EAChBX,EAAQC,EAAQC,EAAYE,EAC5BsU,EAAQC,EAAQC,EAAQC,EAAQpB,EAChCygB,EAASC,EACTj3B,EACAyC,EACAy0B,EACAC,IAmBZC,kBAAmB,SACf50B,EACA9E,EAAGC,EACH6Y,EAAMrZ,EACNk6B,EACA50B,GAGI1H,KAAK85B,cAELvrB,EAAc4lB,UAAUkI,kBAAkBh7B,KACtCrB,KACAyH,EACA9E,EAAGC,EACH6Y,EAAMrZ,EACNk6B,EACA50B,MAOhB4G,EAAckrB,YAAcA,EAE5Bz6B,EAAOC,QAAUsP,G,gBChgBjB,IAAI7N,EAAQ,EAAQ,OAChBq0B,EAAS,EAAQ,OACjBtoB,EAAe,EAAQ,OACvBwnB,EAAiB,EAAQ,OACzBC,EAAiB,EAAQ,OACzBjzB,EAAkB,EAAQ,MAC1BkU,EAAQ,EAAQ,OAChBqc,EAAc,EAAQ,OACtBnc,EAAgB,EAAQ,OAmDxB7G,EAAgB,IAAI9N,EAAM,CAE1BS,QAASkU,EAETjU,WAEA,SAAwBI,GAEpB,IAAIsN,EAAWtN,EAAOH,KAAKyN,SAEvB0tB,EAAuB/vB,EAAajL,EAAQ,aAAcyyB,GAE9DzyB,EAAOwX,WAAa7D,EAAMqD,+BAA+BgkB,EAAsB1tB,EAAS2J,aACxFjX,EAAOuX,WAAatM,EAAajL,EAAQ,aAAc0yB,GACvD1yB,EAAOyX,WAAaxM,EAAajL,EAAQ,aAAc,CACnD,CACIoP,KAAM,aACNohB,KAAM,GAEV,CACIphB,KAAM,aACNohB,KAAM,GAEV,CACIphB,KAAM,WAEV,CACIA,KAAM,gBAEV,CACIA,KAAM,SACNohB,KAAM,EACNnwB,KAAM2vB,EAAY3jB,cAClBukB,YAAY,KAIpB/c,EAAc/T,KAAKrB,KAAMuB,GAUzBvB,KAAKgD,aAAe,IAAIhC,EAUxBhB,KAAKiD,aAAe,IAAIjC,EAUxBhB,KAAKkD,aAAe,IAAIlC,EAUxBhB,KAAK+0B,WAAa,IAAI/zB,EAUtBhB,KAAKg1B,aAAe,CAChB,CAAEryB,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,GACrB,CAAEY,EAAG,EAAGC,EAAG,EAAGb,MAAO,IAWzB/B,KAAKi1B,WAAa,CAAEC,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU7Cr1B,KAAKs1B,SAAW,CAAEJ,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU3Cr1B,KAAKu1B,aAAe,CAAElZ,GAAI,EAAGC,GAAI,EAAGC,GAAI,EAAGC,GAAI,GAU/Cxc,KAAKw1B,UAAY,CAAE,EAAG,EAAG,EAAG,EAAG,GAU/Bx1B,KAAKy1B,SAAW,CAAE,EAAG,EAAG,EAAG,EAAG,GAU9Bz1B,KAAK01B,aAAe,IAaxBlyB,KAAM,WAEF4R,EAAc+e,UAAU3wB,KAAKnC,KAAKrB,MAElCA,KAAK0R,cAAcoN,OAAO,eAAgB9e,KAAK6O,SAASqS,iBAa5D3Z,YAAa,SAAU6J,EAAYnM,EAAQyC,GAEvC1H,KAAK8Q,QAAQL,IAAIzQ,KAAMoR,GAEvB,IAAIzJ,EAAY3H,KAAKgD,aACjB4E,EAAe5H,KAAKiD,aACpB8xB,EAAa/0B,KAAKkD,aAElBuE,EAAQ2J,EAAW3J,MACnBoV,EAAUpV,EAAM4V,UAEhBhB,EAAK5U,EAAM4U,GACXC,EAAK7U,EAAM6U,GACXC,EAAK9U,EAAM8U,GACXC,EAAK/U,EAAM+U,GACXzU,EAASN,EAAM9E,EACfqF,EAASP,EAAM7E,EACfqF,EAAaR,EAAMS,SACnBC,EAAcV,EAAMW,UACpBC,EAAcZ,EAAMY,YAEpBI,EAAiB2I,EAAW3I,eAC5BC,EAAiB0I,EAAW1I,eAE5B/F,GAAK8F,EAAiBV,EACtBnF,GAAK8F,EAAiBV,EAE1B,GAAIoJ,EAAWzI,UACf,CACI,IAAIC,EAAOwI,EAAWvI,MAElBD,EAAKE,QAAUsI,EAAWtI,OAASF,EAAKG,QAAUqI,EAAWrI,OAE7DtB,EAAMuB,cAAcJ,EAAMwI,EAAWtI,MAAOsI,EAAWrI,OAG3DsT,EAAKzT,EAAKyT,GACVC,EAAK1T,EAAK0T,GACVC,EAAK3T,EAAK2T,GACVC,EAAK5T,EAAK4T,GAEVvU,EAAaW,EAAK7G,MAClBoG,EAAcS,EAAK5G,OAKnBW,GAAK8F,GAHLV,EAASa,EAAKjG,GAIdC,GAAK8F,GAHLV,EAASY,EAAKhG,GAMlB,IAAIkG,EAAQ,EACRC,EAAQ,EAERqI,EAAWtI,QAENT,IAED1F,IAAO8E,EAAMyB,UAA8B,EAAjBT,GAG9BK,GAAS,IAKTsI,EAAWrI,OAAUtB,EAAMc,OAAOi0B,cAAgB3f,EAAQ9T,SAErDV,IAEDzF,IAAO6E,EAAM0B,WAA+B,EAAjBT,GAG/BK,GAAS,GAGbnB,EAAawB,UAAUgI,EAAWzO,EAAGyO,EAAWxO,EAAGwO,EAAW/H,SAAU+H,EAAW9H,OAASR,EAAOsI,EAAW7H,OAASR,GAEvHpB,EAAU6B,SAASvE,EAAOiB,QAEtBwB,GAGAC,EAAU8B,mBAAmB/B,GAAwBzC,EAAOyE,QAAU0H,EAAWzH,eAAgB1E,EAAO2E,QAAUwH,EAAWvH,eAG7HjC,EAAakC,EAAIsH,EAAWzO,EAC5BiF,EAAamC,EAAIqH,EAAWxO,IAI5BgF,EAAakC,GAAK7E,EAAOyE,QAAU0H,EAAWzH,cAC9C/B,EAAamC,GAAK9E,EAAO2E,QAAUwH,EAAWvH,eAIlDlC,EAAUqC,SAASpC,EAAcmtB,GAEjC,IAAIxX,EAAK5a,EAAIsF,EACTuV,EAAK5a,EAAIuF,EAETxG,EAAcsD,EAAOtD,YAErBs0B,EAAMlB,EAAW0H,UAAU95B,EAAGC,EAAGjB,GACjCu0B,EAAMnB,EAAW2H,UAAU/5B,EAAGC,EAAGjB,GAEjCw0B,EAAMpB,EAAW0H,UAAU95B,EAAG6a,EAAI7b,GAClCy0B,EAAMrB,EAAW2H,UAAU/5B,EAAG6a,EAAI7b,GAElC00B,EAAMtB,EAAW0H,UAAUlf,EAAIC,EAAI7b,GACnC20B,EAAMvB,EAAW2H,UAAUnf,EAAIC,EAAI7b,GAEnCg7B,EAAM5H,EAAW0H,UAAUlf,EAAI3a,EAAGjB,GAClCi7B,EAAM7H,EAAW2H,UAAUnf,EAAI3a,EAAGjB,GAElCk7B,EAAU3nB,EAAM4nB,wBAChBC,EAAc93B,EAAO7C,MAErBqa,EAASogB,EAAQzrB,EAAW4rB,YAAaD,EAAc3rB,EAAW6rB,UAClEvgB,EAASmgB,EAAQzrB,EAAW8rB,aAAcH,EAAc3rB,EAAW+rB,UACnExgB,EAASkgB,EAAQzrB,EAAWgsB,eAAgBL,EAAc3rB,EAAWisB,UACrEzgB,EAASigB,EAAQzrB,EAAWksB,gBAAiBP,EAAc3rB,EAAWmsB,UAEtEv9B,KAAKmZ,YAAY,IAEjBnZ,KAAKiR,QAGT,IAAIsK,EAAOvb,KAAKiZ,cAAc7H,EAAY3J,GAE1CzH,KAAK8Q,QAAQkB,SAASZ,GAEtBpR,KAAK4b,UAAUxK,EAAY6kB,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKqG,EAAKC,EAAKvgB,EAAIC,EAAIC,EAAIC,EAAIC,EAAQC,EAAQC,EAAQC,EAAQxL,EAAWosB,SAAU3gB,EAAStB,GAEjJvb,KAAK8Q,QAAQsB,UAAUhB,IA0C3BsqB,aAAc,SACVtqB,EACAyL,EACA8e,EAAcC,EACdC,EAAMC,EACNC,EAAUC,EACV1yB,EAAQC,EACRF,EACAP,EAAOC,EACPY,EAAeE,EACfpB,EAAgBC,EAChBX,EAAQC,EAAQC,EAAYE,EAC5BsU,EAAQC,EAAQC,EAAQC,EAAQpB,EAChCygB,EAASC,EACTj3B,EACAyC,EACAy0B,EACAC,GAEAp8B,KAAK8Q,QAAQL,IAAIzQ,KAAMoR,GAEvB,IAAIzJ,EAAY3H,KAAKgD,aACjB4E,EAAe5H,KAAKiD,aACpB8xB,EAAa/0B,KAAKkD,aAElBmZ,EAAMtU,EAAS4zB,EAAgBM,EAC/B3f,EAAMtU,EAAS4zB,EAAiBM,EAChC3f,GAAMxU,EAASE,GAAc0zB,EAAeM,EAC5Czf,GAAMxU,EAASG,GAAeyzB,EAAgBM,EAE9Cn6B,EAAQg6B,EACR/5B,EAASg6B,EAETr5B,GAAK8F,EACL7F,GAAK8F,EAET,GAAI0I,EAAWzI,UACf,CACI,IAAIC,EAAOwI,EAAWvI,MAElB40B,EAAY70B,EAAK7G,MACjB27B,EAAa90B,EAAK5G,OAEtBD,EAAQ07B,EACRz7B,EAAS07B,EAET3B,EAAW0B,EACXzB,EAAY0B,EAKZ,IAAIC,EAHJ51B,EAASa,EAAKjG,EAIVi7B,EAHJ51B,EAASY,EAAKhG,EAKVkG,IAEA60B,EAAM11B,EAAaW,EAAKjG,EAAI86B,GAG5B10B,IAEA60B,EAAMz1B,EAAcS,EAAKhG,EAAI86B,GAGjCrhB,EAAMshB,EAAKhC,EAAgBM,EAC3B3f,EAAMshB,EAAKhC,EAAiBM,EAC5B3f,GAAMohB,EAAKF,GAAa9B,EAAeM,EACvCzf,GAAMohB,EAAKF,GAAc9B,EAAgBM,EAEzCv5B,GAAK8F,EAAiBV,EACtBnF,GAAK8F,EAAiBV,EAMtBc,IAEA/G,IAAU,EACVY,GAAKo5B,IALThzB,IAAkBozB,GAAYtf,EAAQgQ,gBAAkB,EAAI,KAUxD7qB,IAAW,EACXY,GAAKo5B,GAGT,IAAIze,EAAK5a,EAAIZ,EACTyb,EAAK5a,EAAIZ,EAEb4F,EAAawB,UAAUyyB,EAAMC,EAAMzyB,EAAUC,EAAQC,GAErD5B,EAAU6B,SAASvE,EAAOiB,QAEtBwB,GAGAC,EAAU8B,mBAAmB/B,GAAwBzC,EAAOyE,QAAUC,GAAgB1E,EAAO2E,QAAUC,GAGvGjC,EAAakC,EAAI+xB,EACjBj0B,EAAamC,EAAI+xB,IAIjBl0B,EAAakC,GAAK7E,EAAOyE,QAAUC,EACnC/B,EAAamC,GAAK9E,EAAO2E,QAAUC,GAIvClC,EAAUqC,SAASpC,EAAcmtB,GAEjC,IAAIpzB,EAAcsD,EAAOtD,YAErBs0B,EAAMlB,EAAW0H,UAAU95B,EAAGC,EAAGjB,GACjCu0B,EAAMnB,EAAW2H,UAAU/5B,EAAGC,EAAGjB,GAEjCw0B,EAAMpB,EAAW0H,UAAU95B,EAAG6a,EAAI7b,GAClCy0B,GAAMrB,EAAW2H,UAAU/5B,EAAG6a,EAAI7b,GAElC00B,GAAMtB,EAAW0H,UAAUlf,EAAIC,EAAI7b,GACnC20B,GAAMvB,EAAW2H,UAAUnf,EAAIC,EAAI7b,GAEnCg7B,GAAM5H,EAAW0H,UAAUlf,EAAI3a,EAAGjB,GAClCi7B,GAAM7H,EAAW2H,UAAUnf,EAAI3a,EAAGjB,QAElBzC,IAAhBk9B,IAEAA,EAAcp8B,KAAK6O,SAASkO,aAAaF,IAGzCzL,GAEApR,KAAK8Q,QAAQkB,SAASZ,GAG1BpR,KAAK4b,UAAUxK,EAAY6kB,EAAKC,EAAKC,EAAKC,GAAKC,GAAKC,GAAKqG,GAAKC,GAAKvgB,EAAIC,EAAIC,EAAIC,EAAIC,EAAQC,EAAQC,EAAQC,EAAQpB,EAAYqB,EAASuf,GAEpIhrB,GAEApR,KAAK8Q,QAAQsB,UAAUhB,IAkB/BirB,kBAAmB,SACf50B,EACA9E,EAAGC,EACH6Y,EAAMrZ,EACNk6B,EACA50B,GAGA1H,KAAK8Q,QAAQL,IAAIzQ,MAEjB,IAAI4H,EAAe5H,KAAKgD,aAAawG,SAAS8yB,GAC1CvH,EAAa/0B,KAAKiD,aAElBsa,EAAK5a,EAAI8E,EAAM1F,MACfyb,EAAK5a,EAAI6E,EAAMzF,OAEf0F,EAEAE,EAAaoC,SAAStC,EAAuBqtB,GAI7CA,EAAantB,EAGjB,IAAIquB,EAAMlB,EAAWe,KAAKnzB,EAAGC,GACzBszB,EAAMnB,EAAWgB,KAAKpzB,EAAGC,GAEzBuzB,EAAMpB,EAAWe,KAAKnzB,EAAG6a,GACzB4Y,EAAMrB,EAAWgB,KAAKpzB,EAAG6a,GAEzB6Y,EAAMtB,EAAWe,KAAKvY,EAAIC,GAC1B8Y,EAAMvB,EAAWgB,KAAKxY,EAAIC,GAE1Bmf,EAAM5H,EAAWe,KAAKvY,EAAI3a,GAC1Bg6B,EAAM7H,EAAWgB,KAAKxY,EAAI3a,GAE1B2Y,EAAOvb,KAAK6O,SAASqK,iBAAiBzR,EAAMc,QAEhDkT,EAAOvG,EAAM4nB,wBAAwBrhB,EAAMrZ,GAE3CpC,KAAK4b,UAAU,KAAMqa,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKqG,EAAKC,EAAKn1B,EAAM4U,GAAI5U,EAAM6U,GAAI7U,EAAM8U,GAAI9U,EAAM+U,GAAIf,EAAMA,EAAMA,EAAMA,EAAM,EAAGhU,EAAM4V,UAAW9B,IAkBrJoa,cAAe,SAAUhzB,EAAGC,EAAGb,EAAOC,EAAQ4zB,EAAeC,GAEzD71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAIxX,EAAK5a,EAAIZ,EACTyb,EAAK5a,EAAIZ,EAET6Z,EAAKkZ,EAAWe,KAAKnzB,EAAGC,GACxBkZ,EAAKiZ,EAAWgB,KAAKpzB,EAAGC,GAExBmZ,EAAKgZ,EAAWe,KAAKnzB,EAAG6a,GACxBxB,EAAK+Y,EAAWgB,KAAKpzB,EAAG6a,GAExBvB,EAAK8Y,EAAWe,KAAKvY,EAAIC,GACzBtB,EAAK6Y,EAAWgB,KAAKxY,EAAIC,GAEzBrB,EAAK4Y,EAAWe,KAAKvY,EAAI3a,GACzBwZ,EAAK2Y,EAAWgB,KAAKxY,EAAI3a,GAEzB6Y,EAAOzb,KAAKs1B,SAEhBt1B,KAAK4b,UAAU,KAAMC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,EAAG,EAAG,EAAG,EAAGX,EAAKyZ,GAAIzZ,EAAK0Z,GAAI1Z,EAAK2Z,GAAI3Z,EAAK4Z,GAAI,IAoBzGW,kBAAmB,SAAUna,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI0Z,EAAeC,GAEhE71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAIkB,EAAMlB,EAAWe,KAAKja,EAAIC,GAC1Boa,EAAMnB,EAAWgB,KAAKla,EAAIC,GAE1Bqa,EAAMpB,EAAWe,KAAK/Z,EAAIC,GAC1Boa,EAAMrB,EAAWgB,KAAKha,EAAIC,GAE1Bqa,EAAMtB,EAAWe,KAAK7Z,EAAIC,GAC1Boa,EAAMvB,EAAWgB,KAAK9Z,EAAIC,GAE1BT,EAAOzb,KAAKs1B,SAEhBt1B,KAAKgd,SAAS,KAAMiZ,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAK,EAAG,EAAG,EAAG,EAAG7a,EAAKyZ,GAAIzZ,EAAK0Z,GAAI1Z,EAAK2Z,GAAI,IAuB7FmB,oBAAqB,SAAU1a,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIsa,EAAWZ,EAAeC,GAE7E,IAAIb,EAAeh1B,KAAKg1B,aAExBA,EAAa,GAAGryB,EAAIkZ,EACpBmZ,EAAa,GAAGpyB,EAAIkZ,EACpBkZ,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIoZ,EACpBiZ,EAAa,GAAGpyB,EAAIoZ,EACpBgZ,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIsZ,EACpB+Y,EAAa,GAAGpyB,EAAIsZ,EACpB8Y,EAAa,GAAGjzB,MAAQy0B,EAExBxB,EAAa,GAAGryB,EAAIkZ,EACpBmZ,EAAa,GAAGpyB,EAAIkZ,EACpBkZ,EAAa,GAAGjzB,MAAQy0B,EAExBx2B,KAAKy2B,gBAAgBzB,EAAcwB,GAAW,EAAOZ,EAAeC,IAkBxEa,cAAe,SAAUC,EAAMf,EAAeC,GAE1C71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAYzC,IATA,IAEI6B,EACAC,EAHA1xB,EAASwxB,EAAKxxB,OACduwB,EAAe11B,KAAK01B,aAIpBjZ,EAASzc,KAAKs1B,SAASJ,GACvBxY,EAAS1c,KAAKs1B,SAASH,GACvBxY,EAAS3c,KAAKs1B,SAASF,GAElB0B,EAAY,EAAGA,EAAY3xB,IAAU2xB,EAE1CD,EAAQF,EAAKG,GACbpB,EAAalf,KAAKqgB,EAAMl0B,EAAGk0B,EAAMj0B,GAIrCuC,GADAyxB,EAAoB9B,EAAOY,IACAvwB,OAE3B,IAAK,IAAImiB,EAAQ,EAAGA,EAAQniB,EAAQmiB,GAAS,EAC7C,CACI,IAAIyP,EAAoC,EAA/BH,EAAkBtP,EAAQ,GAC/B0P,EAAoC,EAA/BJ,EAAkBtP,EAAQ,GAC/B2P,EAAoC,EAA/BL,EAAkBtP,EAAQ,GAE/BzL,EAAK6Z,EAAaqB,EAAK,GACvBjb,EAAK4Z,EAAaqB,EAAK,GACvBhb,EAAK2Z,EAAasB,EAAK,GACvBhb,EAAK0Z,EAAasB,EAAK,GACvB/a,EAAKyZ,EAAauB,EAAK,GACvB/a,EAAKwZ,EAAauB,EAAK,GAEvBhB,EAAMlB,EAAWe,KAAKja,EAAIC,GAC1Boa,EAAMnB,EAAWgB,KAAKla,EAAIC,GAE1Bqa,EAAMpB,EAAWe,KAAK/Z,EAAIC,GAC1Boa,EAAMrB,EAAWgB,KAAKha,EAAIC,GAE1Bqa,EAAMtB,EAAWe,KAAK7Z,EAAIC,GAC1Boa,EAAMvB,EAAWgB,KAAK9Z,EAAIC,GAE9Blc,KAAKgd,SAAS,KAAMiZ,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAK,EAAG,EAAG,EAAG,EAAG7Z,EAAQC,EAAQC,EAAQ,GAG1F+Y,EAAavwB,OAAS,GAoB1BsxB,gBAAiB,SAAUE,EAAMH,EAAWU,EAAUtB,EAAeC,GAEjE71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAG5BA,KAAKy1B,SAAS,GAAK,EACnBz1B,KAAKw1B,UAAU,GAAK,EAIpB,IAFA,IAAI2B,EAAaR,EAAKxxB,OAAS,EAEtB2xB,EAAY,EAAGA,EAAYK,EAAYL,IAChD,CACI,IAAIM,EAAST,EAAKG,GACdO,EAASV,EAAKG,EAAY,GAE9B92B,KAAKs3B,UACDF,EAAOz0B,EACPy0B,EAAOx0B,EACPy0B,EAAO10B,EACP00B,EAAOz0B,EACPw0B,EAAOr1B,MAAQ,EACfs1B,EAAOt1B,MAAQ,EACfy0B,EACAM,GACCI,GAAaJ,IAAcK,EAAa,EACzCvB,EACAC,KAsBZyB,UAAW,SAAUC,EAAIC,EAAIC,EAAIC,EAAIC,EAAYC,EAAYpB,EAAWlP,EAAOuQ,EAAWjC,EAAeC,GAErG71B,KAAK6O,SAASW,UAAUiB,IAAIzQ,MAE5B,IAAI+0B,EAAa/0B,KAAK+0B,WAGlBc,GAEAA,EAAa7rB,SAAS4rB,EAAeb,GAGzC,IAAI+C,EAAKL,EAAKF,EACVQ,EAAKL,EAAKF,EAEV7e,EAAMvR,KAAK4wB,KAAKF,EAAKA,EAAKC,EAAKA,GAC/BE,EAAMN,GAAcD,EAAKF,GAAM7e,EAC/Buf,EAAMP,GAAcJ,EAAKE,GAAM9e,EAC/Bwf,EAAMP,GAAcF,EAAKF,GAAM7e,EAC/Byf,EAAMR,GAAcL,EAAKE,GAAM9e,EAE/B0f,EAAMZ,EAAKU,EACXG,EAAMZ,EAAKU,EACXG,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMhB,EAAKU,EACXO,EAAMpB,EAAKU,EACXW,EAAMpB,EAAKU,EAGXW,EAAM9D,EAAWe,KAAKuC,EAAKC,GAC3BQ,EAAM/D,EAAWgB,KAAKsC,EAAKC,GAG3BS,EAAMhE,EAAWe,KAAKyC,EAAKC,GAC3BQ,EAAMjE,EAAWgB,KAAKwC,EAAKC,GAG3BS,EAAMlE,EAAWe,KAAK2C,EAAKC,GAC3BQ,EAAMnE,EAAWgB,KAAK0C,EAAKC,GAG3BS,EAAMpE,EAAWe,KAAK6C,EAAKC,GAC3BQ,EAAMrE,EAAWgB,KAAK4C,EAAKC,GAE3Bnd,EAAOzb,KAAKi1B,WAEZxY,EAAShB,EAAKyZ,GACdxY,EAASjB,EAAK0Z,GACdxY,EAASlB,EAAK2Z,GACdxY,EAASnB,EAAK4Z,GAKlB,GAFAr1B,KAAK4b,UAAU,KAAMud,EAAKC,EAAKL,EAAKC,EAAKH,EAAKC,EAAKG,EAAKC,EAAK,EAAG,EAAG,EAAG,EAAGzc,EAAQC,EAAQC,EAAQC,EAAQ,KAErG4Z,GAAa,GAAjB,CAMA,IAAI5G,EAAO5vB,KAAKy1B,SACZ4D,EAAQr5B,KAAKw1B,UAEblO,EAAQ,GAAKsI,EAAK,GAElB5vB,KAAK4b,UAAU,KAAMud,EAAKC,EAAKL,EAAKC,EAAKpJ,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI,EAAG,EAAG,EAAG,EAAGnT,EAAQC,EAAQC,EAAQC,EAAQ,IAIzHyc,EAAM,GAAKF,EACXE,EAAM,GAAKD,EACXC,EAAM,GAAKN,EACXM,EAAM,GAAKL,EACXK,EAAM,GAAK,GAGXxB,GAAawB,EAAM,GAGnBr5B,KAAK4b,UAAU,KAAMid,EAAKC,EAAKG,EAAKC,EAAKG,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAI,EAAG,EAAG,EAAG,EAAG5c,EAAQC,EAAQC,EAAQC,EAAQ,IAM7HgT,EAAK,GAAKiJ,EACVjJ,EAAK,GAAKkJ,EACVlJ,EAAK,GAAKqJ,EACVrJ,EAAK,GAAKsJ,EACVtJ,EAAK,GAAK,OAMtB7wB,EAAOC,QAAUuP,G,gBC99BjB,IAAI9N,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvBqxB,EAA2B,EAAQ,OACnCC,EAA2B,EAAQ,OACnC1oB,EAAgB,EAAQ,OA+BxB5G,EAAqB,IAAI/N,EAAM,CAE/BS,QAASkU,EAETjU,WAEA,SAA6BI,GAEzBA,EAAOuX,WAAatM,EAAajL,EAAQ,aAAcu8B,GACvDv8B,EAAOwX,WAAavM,EAAajL,EAAQ,aAAcs8B,GACvDt8B,EAAOyX,WAAaxM,EAAajL,EAAQ,aAAc,CACnD,CACIoP,KAAM,aACNohB,KAAM,GAEV,CACIphB,KAAM,kBACNohB,KAAM,GAEV,CACIphB,KAAM,iBAEV,CACIA,KAAM,sBAEV,CACIA,KAAM,eACNohB,KAAM,KAId3c,EAAc/T,KAAKrB,KAAMuB,IAG7BmW,SAAU,SAAU3S,EAAOE,GAEvBjF,KAAKoe,MAAM,cAAepe,KAAK+B,MAAO/B,KAAKgC,QAC3ChC,KAAKie,MAAM,cAAehZ,EAAOm1B,OAsBrC2D,gBAAiB,SAAUtD,EAAOx1B,EAAQ4W,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI4hB,EAAQC,GAE9E,IAAI/gB,EAAQud,EAAMvd,MACd0d,EAAYH,EAAMG,UAClBC,EAASJ,EAAMI,OACfqD,EAAczD,EAAMyD,YAEpB5D,EAAIpd,EAAMod,EAAIM,EACdL,EAAIrd,EAAMqd,EAAIK,EACdJ,EAAItd,EAAMsd,EAAII,EACduD,EAAIl5B,EAAO7C,MAAQq4B,EAAMr4B,MAEzBpC,KAAKmZ,YAAY,IAEjBnZ,KAAKiR,QAGTjR,KAAKo+B,eAAeviB,EAAIC,EAAIkiB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAC1En+B,KAAKo+B,eAAeriB,EAAIC,EAAIgiB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAC1En+B,KAAKo+B,eAAeniB,EAAIC,EAAI8hB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAC1En+B,KAAKo+B,eAAeviB,EAAIC,EAAIkiB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAC1En+B,KAAKo+B,eAAeniB,EAAIC,EAAI8hB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAC1En+B,KAAKo+B,eAAejiB,EAAIC,EAAI4hB,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,IAuB9EC,eAAgB,SAAUz7B,EAAGC,EAAGo7B,EAAQC,EAAQpD,EAAQqD,EAAa5D,EAAGC,EAAGC,EAAG2D,GAE1E,IAAItoB,EAAgB7V,KAAK6V,cAErB6F,EAAgB1b,KAAKsV,YAActV,KAAK0R,cAAciK,qBAAwB,EAElF9F,IAAgB6F,GAAgB/Y,EAChCkT,IAAgB6F,GAAgB9Y,EAChCiT,IAAgB6F,GAAgBsiB,EAChCnoB,IAAgB6F,GAAgBuiB,EAChCpoB,IAAgB6F,GAAgBmf,EAChChlB,IAAgB6F,GAAgBwiB,EAChCroB,IAAgB6F,GAAgB4e,EAChCzkB,IAAgB6F,GAAgB6e,EAChC1kB,IAAgB6F,GAAgB8e,EAChC3kB,IAAgB6F,GAAgByiB,EAEhCn+B,KAAKsV,iBAKbvW,EAAOC,QAAUwP,G,gBCjKjB,IAAI/N,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvB+B,EAAgB,EAAQ,OAoCxBE,EAAe,IAAIhO,EAAM,CAEzBS,QAASqN,EAETpN,WAEA,SAAuBI,GAGnBA,EAAOmU,SAAW,EAClBnU,EAAOwV,UAAYvK,EAAajL,EAAQ,YAAa,KAErDgN,EAAclN,KAAKrB,KAAMuB,MAIjCxC,EAAOC,QAAUyP,G,gBCtDjB,IAAIhO,EAAQ,EAAQ,OAChB+L,EAAe,EAAQ,OACvB+B,EAAgB,EAAQ,OACxBylB,EAAiB,EAAQ,OACzBC,EAAiB,EAAQ,OACzB7e,EAAgB,EAAQ,OAmCxB1G,EAAiB,IAAIjO,EAAM,CAE3BS,QAASqN,EAETpN,WAEA,SAAyBI,GAErBA,EAAOwX,WAAavM,EAAajL,EAAQ,aAAcyyB,GACvDzyB,EAAOuX,WAAatM,EAAajL,EAAQ,aAAc0yB,GACvD1yB,EAAOwS,WAAY,EAEnBxF,EAAclN,KAAKrB,KAAMuB,IAG7BiC,KAAM,WAEF4R,EAAc+e,UAAU3wB,KAAKnC,KAAKrB,MAElCA,KAAKkf,MAAM,eAAgB,MAKnCngB,EAAOC,QAAU0P,G,gBChEjB,IAAI2vB,EAAa,EAAQ,MACrB1W,EAAa,EAAQ,OACrBlnB,EAAQ,EAAQ,OAChB69B,EAAc,EAAQ,OACtBC,EAAgB,EAAQ,OACxBC,EAAS,EAAQ,KACjBhyB,EAAe,EAAQ,OACvBiyB,EAAgB,EAAQ,MACxBC,EAAS,EAAQ,OACjBtpB,EAAgB,EAAQ,OAoCxBzG,EAAkB,IAAIlO,EAAM,CAE5BS,QAASkU,EAETjU,WAEA,SAA0BI,GAEtBA,EAAO8hB,aAAe7W,EAAajL,EAAQ,eAAgB,CACvD,CACImC,MAAO,GAEX,CACIA,MAAO,GAEX,CACIA,MAAO,IAEX,CACIA,MAAO,MAIfnC,EAAOuX,WAAatM,EAAajL,EAAQ,aAAcm9B,GAEvDn9B,EAAO2U,QAAU1J,EAAajL,EAAQ,UAAW,CAC7C,CACIoP,KAAM,OACNoI,WAAYylB,GAEhB,CACI7tB,KAAM,WACNoI,WAAYslB,GAEhB,CACI1tB,KAAM,cACNoI,WAAY0lB,GAEhB,CACI9tB,KAAM,cACNoI,WAAYwlB,KAIpBh9B,EAAOyX,WAAaxM,EAAajL,EAAQ,aAAc,CACnD,CACIoP,KAAM,aACNohB,KAAM,GAEV,CACIphB,KAAM,aACNohB,KAAM,KAIdxwB,EAAO2yB,SAAW,EACb,GAAI,EAAG,EAAG,GACV,EAAG,EAAG,EAAG,EACV,EAAG,EAAG,EAAG,GACR,GAAI,EAAG,EAAG,EACX,EAAG,EAAG,EAAG,EACT,GAAI,EAAG,EAAG,GAGd3yB,EAAOwV,UAAY,EAEnB3B,EAAc/T,KAAKrB,KAAMuB,GAUzBvB,KAAKkT,YAAc,IAAIorB,EAYvBt+B,KAAK+S,WAWL/S,KAAK0T,UAWL1T,KAAKwT,aAWLxT,KAAKmT,kBAgBLnT,KAAK2P,WAgBL3P,KAAK4P,WAgBL5P,KAAK6P,WAgBL7P,KAAK8P,YAGTtM,KAAM,WAEF4R,EAAc+e,UAAU3wB,KAAKnC,KAAKrB,MAElC,IAAIkW,EAAUlW,KAAKkW,QACfK,EAAUvW,KAAKgW,cAEnBhW,KAAK+S,WAAamD,EAAQ,GAC1BlW,KAAK0T,UAAYwC,EAAQ,GACzBlW,KAAKwT,aAAe0C,EAAQ,GAC5BlW,KAAKmT,kBAAoB+C,EAAQ,GAEjClW,KAAK2P,WAAa4G,EAAQ,GAC1BvW,KAAK4P,WAAa2G,EAAQ,GAC1BvW,KAAK6P,WAAa0G,EAAQ,GAC1BvW,KAAK8P,WAAayG,EAAQ,IAqB9B9D,UAAW,SAAUlK,EAAQmK,EAAQC,EAAYC,EAAOC,QAEjC3T,IAAfyT,IAA4BA,EAAa,QAC/BzT,IAAV0T,IAAuBA,GAAQ,QAChB1T,IAAf2T,IAA4BA,GAAa,GAE7C,IAAI5F,EAAKjN,KAAKiN,GAEdjN,KAAK8X,UAAU9X,KAAK+S,YAEpB/S,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKie,MAAM,cAAetL,GAE1B1F,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYtV,EAAOsU,SAEjCnK,GAEAzF,EAAGwH,SAAS,EAAG,EAAG/B,EAAO3Q,MAAO2Q,EAAO1Q,QACvCiL,EAAG6a,gBAAgB7a,EAAG8a,YAAarV,EAAO8X,aAC1Cvd,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAYnL,EAAOmK,QAAS,IAI7F5P,EAAGwH,SAAS,EAAG,EAAGlM,EAAOxG,MAAOwG,EAAOvG,QAGvC4Q,IAEIC,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,mBAGhBljB,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGoK,aACnDpK,EAAG+N,WAAW/N,EAAG0I,UAAW,EAAG,GAE/B1I,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MACnC9a,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,OAsBlCjK,UAAW,SAAUrL,EAAQmK,EAAQC,EAAYC,EAAOC,EAAYgB,QAE7C3U,IAAfyT,IAA4BA,EAAa,QAC/BzT,IAAV0T,IAAuBA,GAAQ,QAChB1T,IAAf2T,IAA4BA,GAAa,QAC3B3T,IAAd2U,IAA2BA,GAAY,GAE3C,IAAI5G,EAAKjN,KAAKiN,GAUd,GARAjN,KAAK8X,UAAU9X,KAAK+S,YAEpB/S,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKie,MAAM,cAAetL,GAE1B1F,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYtV,EAAOsU,SAEjCtU,EAAOvG,OAAS0Q,EAAO1Q,OAEvBiL,EAAGwH,SAAS,EAAG,EAAGlM,EAAOxG,MAAOwG,EAAOvG,QAEvChC,KAAK2+B,aAAap2B,EAAQmK,OAG9B,CACI,IAAIksB,EAAOlsB,EAAO1Q,OAASuG,EAAOvG,OAElCiL,EAAGwH,SAAS,EAAGmqB,EAAMr2B,EAAOxG,MAAOwG,EAAOvG,QAoB9C,GAjBAiL,EAAG6a,gBAAgB7a,EAAG8a,YAAarV,EAAO8X,aAC1Cvd,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAYnL,EAAOmK,QAAS,GAEzFjK,IAEIC,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,mBAGZtc,EACJ,CACI,IAAIzP,EAAYpE,KAAK6O,SAAS2S,iBAE9BxhB,KAAK6O,SAAS1K,aAAawjB,EAAW/b,OAG1CqB,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGoK,aACnDpK,EAAG+N,WAAW/N,EAAG0I,UAAW,EAAG,GAE3B9B,GAEA7T,KAAK6O,SAAS1K,aAAaC,GAG/B6I,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MACnC9a,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,MAE9B7d,KAAK6+B,YAwBT/qB,cAAe,SAAUvL,EAAQmK,EAAQ/P,EAAGC,EAAGb,EAAOC,EAAQ4Q,EAAOC,QAEnD3T,IAAV0T,IAAuBA,GAAQ,QAChB1T,IAAf2T,IAA4BA,GAAa,GAE7C,IAAI5F,EAAKjN,KAAKiN,GAEdA,EAAG6a,gBAAgB7a,EAAG8a,YAAaxf,EAAOiiB,aAC1Cvd,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAYtV,EAAOsU,QAAS,GAEzFjK,IAEIC,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,mBAGhBljB,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYnL,EAAOmK,SAErC5P,EAAG6xB,kBAAkB7xB,EAAG4Q,WAAY,EAAG,EAAG,EAAGlb,EAAGC,EAAGb,EAAOC,GAE1DiL,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MACnC9a,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,OAkBlC7K,WAAY,SAAUzK,GAElB,IAAI0E,EAAKjN,KAAKiN,GAEdjN,KAAK8X,UAAU9X,KAAK+S,YAEpB/S,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKie,MAAM,cAAe,GAE1Bje,KAAK6O,SAASgc,iBAEd5d,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYtV,EAAOsU,SAErC5P,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGoK,aACnDpK,EAAG+N,WAAW/N,EAAG0I,UAAW,EAAG,GAE/B3V,KAAK6O,SAASgG,iBAoBlB5B,UAAW,SAAU1K,EAAQmK,EAAQG,EAAYK,QAE1BhU,IAAf2T,IAA4BA,GAAa,QACzB3T,IAAhBgU,IAA6BA,EAAclT,KAAKkT,aAEpD,IAAIjG,EAAKjN,KAAKiN,GAEdjN,KAAK8X,UAAU9X,KAAKmT,mBAEpBnT,KAAKkf,MAAM,eAAgB,GAC3Blf,KAAKye,OAAO,eAAgBvL,EAAY6rB,WACxC/+B,KAAKie,MAAM,SAAU/K,EAAY9Q,OAEjC6K,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYtV,EAAOsU,SAEjCnK,GAEAzF,EAAGwH,SAAS,EAAG,EAAG/B,EAAO3Q,MAAO2Q,EAAO1Q,QACvCiL,EAAG6a,gBAAgB7a,EAAG8a,YAAarV,EAAO8X,aAC1Cvd,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAYnL,EAAOmK,QAAS,IAI7F5P,EAAGwH,SAAS,EAAG,EAAGlM,EAAOxG,MAAOwG,EAAOvG,QAGvC6Q,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,kBAEZljB,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGoK,aACnDpK,EAAG+N,WAAW/N,EAAG0I,UAAW,EAAG,GAE/B1I,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MACnC9a,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,OAiBlCzK,YAAa,SAAUC,EAASC,EAASZ,EAAQa,EAAUV,EAAYmsB,QAElD9/B,IAAbqU,IAA0BA,EAAW,QACtBrU,IAAf2T,IAA4BA,GAAa,QACzB3T,IAAhB8/B,IAA6BA,EAAch/B,KAAKwT,cAEpD,IAAIvG,EAAKjN,KAAKiN,GAEdjN,KAAK8X,UAAUknB,GAEfh/B,KAAKkf,MAAM,gBAAiB,GAC5Blf,KAAKkf,MAAM,gBAAiB,GAC5Blf,KAAKie,MAAM,YAAa1K,GAExBtG,EAAG0Q,cAAc1Q,EAAG2Q,UACpB3Q,EAAGyQ,YAAYzQ,EAAG4Q,WAAYxK,EAAQwJ,SAEtC5P,EAAG0Q,cAAc1Q,EAAGya,UACpBza,EAAGyQ,YAAYzQ,EAAG4Q,WAAYvK,EAAQuJ,SAElCnK,GAEAzF,EAAG6a,gBAAgB7a,EAAG8a,YAAarV,EAAO8X,aAC1Cvd,EAAGwgB,qBAAqBxgB,EAAG8a,YAAa9a,EAAGygB,kBAAmBzgB,EAAG4Q,WAAYnL,EAAOmK,QAAS,GAC7F5P,EAAGwH,SAAS,EAAG,EAAG/B,EAAO3Q,MAAO2Q,EAAO1Q,SAIvCiL,EAAGwH,SAAS,EAAG,EAAGpB,EAAQtR,MAAOsR,EAAQrR,QAGzC6Q,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,kBAEZljB,EAAG4N,WAAW5N,EAAGqN,aAActa,KAAKwV,WAAYvI,EAAGoK,aACnDpK,EAAG+N,WAAW/N,EAAG0I,UAAW,EAAG,GAE/B1I,EAAG6a,gBAAgB7a,EAAG8a,YAAa,MACnC9a,EAAGyQ,YAAYzQ,EAAG4Q,WAAY,OAgBlCpK,oBAAqB,SAAUJ,EAASC,EAASZ,EAAQa,EAAUV,GAE/D7S,KAAKoT,YAAYC,EAASC,EAASZ,EAAQa,EAAUV,EAAY7S,KAAK0T,YAY1EC,WAAY,SAAUjB,EAAQG,QAEP3T,IAAf2T,IAA4BA,GAAa,GAE7C,IAAI5F,EAAKjN,KAAKiN,GAEdA,EAAGwH,SAAS,EAAG,EAAG/B,EAAO3Q,MAAO2Q,EAAO1Q,QAEvCiL,EAAG6a,gBAAgB7a,EAAG8a,YAAarV,EAAO8X,aAEtC3X,EAEA5F,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAIvBrW,EAAGqW,WAAW,EAAG,EAAG,EAAG,GAG3BrW,EAAG2F,MAAM3F,EAAGkjB,kBAEZ,IAAI8O,EAAMj/B,KAAK6O,SAASyS,mBAExBrU,EAAG6a,gBAAgB7a,EAAG8a,YAAakX,IAqBvCC,OAAQ,SAAUC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAE1C,IAAI7pB,EAAgB7V,KAAK6V,cAEzBA,EAAc,GAAKspB,EACnBtpB,EAAc,GAAKupB,EACnBvpB,EAAc,GAAKwpB,EACnBxpB,EAAc,GAAKypB,EACnBzpB,EAAc,IAAM0pB,EACpB1pB,EAAc,IAAM2pB,EACpB3pB,EAAc,IAAMspB,EACpBtpB,EAAc,IAAMupB,EACpBvpB,EAAc,IAAM0pB,EACpB1pB,EAAc,IAAM2pB,EACpB3pB,EAAc,IAAM4pB,EACpB5pB,EAAc,IAAM6pB,GAexBf,aAAc,SAAUp2B,EAAQmK,GAE5B,IAAIksB,EAAQlsB,EAAO1Q,OAASuG,EAAOvG,OAI/B48B,EAFAA,EAAO,GAEA,IAAOA,EAAO,IAIP,GAAMA,EAAb,GAGX5+B,KAAKk/B,OAAO,EAAGN,EAAM,EAAG,EAAIA,EAAM,EAAG,EAAIA,EAAM,EAAGA,IAYtD91B,MAAO,WAEH9I,KAAKk/B,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAYrCn2B,MAAO,WAEH/I,KAAKk/B,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAWrCL,SAAU,WAEN7+B,KAAKk/B,OAAO,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,MAKzCngC,EAAOC,QAAU2P,G,UC7qBjB5P,EAAOC,QA7Fc,CAUjBiQ,oBAAqB,qBAUrBG,eAAgB,UAUhBC,oBAAqB,qBAUrBH,gBAAiB,iBAUjBF,eAAgB,gBAUhBG,cAAe,eAUfG,kBAAmB,mBAUnBqwB,gBAAiB,iBAUjB5wB,iBAAkB,oB,UC9EtBhQ,EAAOC,QAAU,sB,UCAjBD,EAAOC,QAAU,uB,UCDjBD,EAAOC,QAAU,gB,UCDjBD,EAAOC,QAAU,gB,UCAjBD,EAAOC,QAAU,mB,UCCjBD,EAAOC,QAAU,kB,UCEjBD,EAAOC,QAAU,kB,gBCTjBD,EAAOC,QAAU,CAEbic,YAAa,EAAQ,OACrBN,aAAc,EAAQ,OACtBb,KAAM,EAAQ,OACdlC,KAAM,EAAQ,OACd6H,QAAS,EAAQ,OACjBzF,OAAQ,EAAQ,OAChBpW,OAAQ,EAAQ,S,SClBpB7E,EAAOC,QAAU,CACb,0CACA,GACA,2BACA,GACA,mCACA,mCACA,2BACA,GACA,4BACA,GACA,eACA,IACA,2DACA,2DACA,GACA,kDACA,IACA,IACF4gC,KAAK,O,UCnBP7gC,EAAOC,QAAU,CACb,4CACA,GACA,2BACA,GACA,4BACA,kCACA,kCACA,iCACA,GACA,eACA,IACA,+CACA,oDACA,oDACA,iCACA,GACA,6BACA,QACA,kCACA,QACA,WACA,QACA,wCACA,QACA,GACA,yDACA,IACA,IACF4gC,KAAK,O,UC7BP7gC,EAAOC,QAAU,CACb,4CACA,GACA,2BACA,GACA,6BACA,GACA,eACA,IACA,gDACA,IACA,IACF4gC,KAAK,O,UCZP7gC,EAAOC,QAAU,CACb,4CACA,GACA,2BACA,GACA,kCACA,kCACA,wBACA,GACA,4BACA,GACA,eACA,IACA,qDACA,GACA,yBACA,QACA,4BACA,GACA,kBACA,QACA,GACA,qBACA,QACA,wBACA,QACA,GACA,mBACA,GACA,0IACA,0IACA,+IACA,+IACA,GACA,iDACA,GACA,uBACA,GACA,0CACA,IACA,IACF4gC,KAAK,O,QCzCP7gC,EAAOC,QAAU,CACb,qCACA,GACA,2BACA,GACA,kCACA,6BACA,GACA,4BACA,GACA,eACA,IACA,yEACA,IACA,IACF4gC,KAAK,O,UCfP7gC,EAAOC,QAAU,CACb,yCACA,GACA,2BACA,GACA,yBACA,GACA,eACA,IACA,kEACA,IACA,IACF4gC,KAAK,O,UCZP7gC,EAAOC,QAAU,CACb,yCACA,GACA,2BACA,GACA,kCACA,GACA,6BACA,0BACA,GACA,yBACA,GACA,eACA,IACA,oEACA,GACA,0BACA,IACA,IACF4gC,KAAK,O,UCnBP7gC,EAAOC,QAAU,CACb,sCACA,GACA,2BACA,GACA,eACA,IACA,qBACA,kBACA,uBACA,oBACA,KACA,GACA,wCACA,GACA,mDACA,4BACA,kCACA,kCACA,mCACA,qCACA,uCACA,GACA,4BACA,wBACA,GACA,cACA,IACA,6CACA,oGACA,iEACA,qFACA,sEACA,GACA,uDACA,QACA,wCACA,0FACA,kDACA,2DACA,oEACA,yEACA,kGACA,sDACA,mEACA,QACA,GACA,qEACA,GACA,mFACA,IACA,IACF4gC,KAAK,O,SCpDP7gC,EAAOC,QAAU,CACb,6CACA,GACA,2BACA,GACA,mCACA,mCACA,2BACA,GACA,4BACA,GACA,eACA,IACA,2DACA,2DACA,GACA,2DACA,IACA,IACF4gC,KAAK,O,UCnBP7gC,EAAOC,QAAU,CACb,sCACA,GACA,2BACA,GACA,2CACA,GACA,4BACA,0BACA,+BACA,wBACA,GACA,eACA,IACA,oBACA,GACA,gBACA,GACA,6DACA,GACA,gCACA,oCACA,GACA,gCACA,QACA,0CACA,4EACA,QACA,qCACA,QACA,sCACA,yBACA,QACA,GACA,4BACA,IACA,IACF4gC,KAAK,O,UCrCP7gC,EAAOC,QAAU,CACb,sCACA,GACA,2BACA,GACA,kCACA,GACA,6BACA,6BACA,2BACA,gCACA,yBACA,GACA,4BACA,0BACA,+BACA,wBACA,GACA,eACA,IACA,oEACA,GACA,gCACA,0BACA,wBACA,oCACA,IACA,IACF4gC,KAAK,O,UC5BP7gC,EAAOC,QAAU,CACb,2CACA,GACA,2BACA,GACA,4BACA,6BACA,GACA,8BACA,2BACA,6BACA,kCACA,GACA,eACA,IACA,uEACA,GACA,2DACA,GACA,qEACA,GACA,yEACA,GACA,4EACA,GACA,8DACA,IACA,IACF4gC,KAAK,O,UC5BP7gC,EAAOC,QAAU,CACb,2CACA,GACA,2BACA,GACA,kCACA,GACA,6BACA,kCACA,+BACA,iCACA,sCACA,GACA,8BACA,2BACA,6BACA,kCACA,GACA,eACA,IACA,iCACA,mCACA,6CACA,2EACA,GACA,oEACA,IACA,IACF4gC,KAAK,O,UC5BP7gC,EAAOC,QAAU,CACb,qCACA,GACA,2BACA,GACA,6BACA,6BACA,GACA,6BACA,4BACA,GACA,eACA,IACA,gDACA,gCACA,GACA,4CACA,IACA,IACF4gC,KAAK,O,UCnBP7gC,EAAOC,QAAU,CACb,uCACA,GACA,2BACA,GACA,kCACA,GACA,4BACA,+BACA,wBACA,GACA,eACA,IACA,2DACA,6DACA,GACA,gCACA,oCACA,GACA,gCACA,QACA,0CACA,4EACA,QACA,qCACA,QACA,sCACA,yBACA,QACA,GACA,4BACA,IACA,IACF4gC,KAAK,O,UCjCP7gC,EAAOC,QAAU,CACb,uCACA,GACA,2BACA,GACA,kCACA,GACA,6BACA,6BACA,2BACA,gCACA,yBACA,GACA,4BACA,+BACA,wBACA,GACA,eACA,IACA,oEACA,GACA,gCACA,wBACA,oCACA,IACA,IACF4gC,KAAK,O,UCdP7gC,EAAOC,QAAU,mB,UCAjBD,EAAOC,QAAU,oB,UCAjBD,EAAOC,QAAU,yB,UCCjBD,EAAOC,QAAU,mB,UCGjBD,EAAOC,QAAU,qB,UCOjBD,EAAOC,QAAU,U,gBCbjBD,EAAOC,QAAU,CAEb6gC,iBAAkB,EAAQ,OAC1BC,kBAAmB,EAAQ,OAC3BC,uBAAwB,EAAQ,OAChCC,iBAAkB,EAAQ,OAC1BC,mBAAoB,EAAQ,OAC5Br8B,OAAQ,EAAQ,S,UCEpB7E,EAAOC,QAAU,c,UCAjBD,EAAOC,QAAU,W,UCGjBD,EAAOC,QAAU,U,UCNjBD,EAAOC,QAAU,S,UCKjBD,EAAOC,QAAU,iB,gBCXjBD,EAAOC,QAAU,CAEb4L,IAAK,EAAQ,OACbs1B,MAAO,EAAQ,OACfC,KAAM,EAAQ,OACd58B,MAAO,EAAQ,OACf68B,OAAQ,EAAQ,S,UCApB,IAAItrB,EAAW,SAAUurB,GAErB,IAAIC,EACAC,EACA5rB,EAEJ,GAAwB,iBAAb0rB,GAAsC,OAAbA,EAGhC,OAAOA,EAMX,IAAK1rB,KAFL2rB,EAAY7pB,MAAMC,QAAQ2pB,GAAY,GAAK,GAE/BA,EAERE,EAAQF,EAAS1rB,GAGjB2rB,EAAU3rB,GAAOG,EAASyrB,GAG9B,OAAOD,GAGXvhC,EAAOC,QAAU8V,M","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/device/CanvasFeatures.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/canvas/CanvasRenderer.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/canvas/utils/GetBlendModes.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/POST_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/PRE_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/RESIZE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/snapshot/CanvasSnapshot.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/snapshot/WebGLSnapshot.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/PipelineManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/WebGLPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/WebGLRenderer.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/WebGLShader.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/BitmapMaskPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/GraphicsPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/LightPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/MultiPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/PointLightPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/RopePipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/SinglePipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/UtilityPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/AFTER_FLUSH_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/BEFORE_FLUSH_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/BIND_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/BOOT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/DESTROY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/REBIND_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/RESIZE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/AddBlend-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/BitmapMask-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/ColorMatrix-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Copy-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Graphics-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Graphics-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Light-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/LinearBlend-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Multi-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Multi-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/PointLight-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/PointLight-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Quad-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Single-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/Single-vert.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/ENTER_FULLSCREEN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/FULLSCREEN_FAILED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/FULLSCREEN_UNSUPPORTED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/LEAVE_FULLSCREEN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/ORIENTATION_CHANGE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/RESIZE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/ERROR_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/LOAD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/READY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/REMOVE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/textures/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/DeepCopy.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../display/canvas/CanvasPool');\r\n\r\n/**\r\n * Determines the canvas features of the browser running this Phaser Game instance.\r\n * These values are read-only and populated during the boot sequence of the game.\r\n * They are then referenced by internal game systems and are available for you to access\r\n * via `this.sys.game.device.canvasFeatures` from within any Scene.\r\n *\r\n * @typedef {object} Phaser.Device.CanvasFeatures\r\n * @since 3.0.0\r\n *\r\n * @property {boolean} supportInverseAlpha - Set to true if the browser supports inversed alpha.\r\n * @property {boolean} supportNewBlendModes - Set to true if the browser supports new canvas blend modes.\r\n */\r\nvar CanvasFeatures = {\r\n\r\n    supportInverseAlpha: false,\r\n    supportNewBlendModes: false\r\n\r\n};\r\n\r\nfunction checkBlendMode ()\r\n{\r\n    var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/';\r\n    var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==';\r\n\r\n    var magenta = new Image();\r\n\r\n    magenta.onload = function ()\r\n    {\r\n        var yellow = new Image();\r\n\r\n        yellow.onload = function ()\r\n        {\r\n            var canvas = CanvasPool.create(yellow, 6, 1);\r\n            var context = canvas.getContext('2d');\r\n\r\n            context.globalCompositeOperation = 'multiply';\r\n\r\n            context.drawImage(magenta, 0, 0);\r\n            context.drawImage(yellow, 2, 0);\r\n\r\n            if (!context.getImageData(2, 0, 1, 1))\r\n            {\r\n                return false;\r\n            }\r\n\r\n            var data = context.getImageData(2, 0, 1, 1).data;\r\n\r\n            CanvasPool.remove(yellow);\r\n\r\n            CanvasFeatures.supportNewBlendModes = (data[0] === 255 && data[1] === 0 && data[2] === 0);\r\n        };\r\n\r\n        yellow.src = pngHead + '/wCKxvRF' + pngEnd;\r\n    };\r\n\r\n    magenta.src = pngHead + 'AP804Oa6' + pngEnd;\r\n\r\n    return false;\r\n}\r\n\r\nfunction checkInverseAlpha ()\r\n{\r\n    var canvas = CanvasPool.create(this, 2, 1);\r\n    var context = canvas.getContext('2d');\r\n\r\n    context.fillStyle = 'rgba(10, 20, 30, 0.5)';\r\n\r\n    //  Draw a single pixel\r\n    context.fillRect(0, 0, 1, 1);\r\n\r\n    //  Get the color values\r\n    var s1 = context.getImageData(0, 0, 1, 1);\r\n\r\n    if (s1 === null)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    //  Plot them to x2\r\n    context.putImageData(s1, 1, 0);\r\n\r\n    //  Get those values\r\n    var s2 = context.getImageData(1, 0, 1, 1);\r\n\r\n    //  Compare and return\r\n    return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]);\r\n}\r\n\r\nfunction init ()\r\n{\r\n    if (typeof importScripts !== 'function' && document !== undefined)\r\n    {\r\n        CanvasFeatures.supportNewBlendModes = checkBlendMode();\r\n        CanvasFeatures.supportInverseAlpha = checkInverseAlpha();\r\n    }\r\n\r\n    return CanvasFeatures;\r\n}\r\n\r\nmodule.exports = init();\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar CanvasSnapshot = require('../snapshot/CanvasSnapshot');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('../events');\r\nvar GetBlendModes = require('./utils/GetBlendModes');\r\nvar ScaleEvents = require('../../scale/events');\r\nvar TextureEvents = require('../../textures/events');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * The Canvas Renderer is responsible for managing 2D canvas rendering contexts,\r\n * including the one used by the Games canvas. It tracks the internal state of a\r\n * given context and can renderer textured Game Objects to it, taking into\r\n * account alpha, blending, and scaling.\r\n *\r\n * @class CanvasRenderer\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */\r\nvar CanvasRenderer = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function CanvasRenderer (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var gameConfig = game.config;\r\n\r\n        /**\r\n         * The local configuration settings of the CanvasRenderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: gameConfig.clearBeforeRender,\r\n            backgroundColor: gameConfig.backgroundColor,\r\n            antialias: gameConfig.antialias,\r\n            roundPixels: gameConfig.roundPixels\r\n        };\r\n\r\n        /**\r\n         * The Phaser Game instance that owns this renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a Canvas Renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.CANVAS;\r\n\r\n        /**\r\n         * The total number of Game Objects which were rendered in a frame.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.drawCount = 0;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The canvas element which the Game uses.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameCanvas = game.canvas;\r\n\r\n        var contextOptions = {\r\n            alpha: game.config.transparent,\r\n            desynchronized: game.config.desynchronized\r\n        };\r\n\r\n        /**\r\n         * The canvas context used to render all Cameras in all Scenes during the game loop.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameContext = (gameConfig.context) ? gameConfig.context : this.gameCanvas.getContext('2d', contextOptions);\r\n\r\n        /**\r\n         * The canvas context currently used by the CanvasRenderer for all rendering operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentContext = this.gameContext;\r\n\r\n        /**\r\n         * Should the Canvas use Image Smoothing or not when drawing Sprites?\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#antialias\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.antialias = game.config.antialias;\r\n\r\n        /**\r\n         * The blend modes supported by the Canvas Renderer.\r\n         *\r\n         * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = GetBlendModes();\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         *\r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.16.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92\r\n        };\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * Has this renderer fully booted yet?\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#isBooted\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        this.init();\r\n    },\r\n\r\n    /**\r\n     * Prepares the game canvas for rendering.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n     * @since 3.0.0\r\n     */\r\n    init: function ()\r\n    {\r\n        this.game.textures.once(TextureEvents.READY, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#boot\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.game;\r\n\r\n        var baseSize = game.scale.baseSize;\r\n\r\n        this.width = baseSize.width;\r\n        this.height = baseSize.height;\r\n\r\n        this.isBooted = true;\r\n\r\n        game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\r\n\r\n        this.resize(baseSize.width, baseSize.height);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n     */\r\n    onResize: function (gameSize, baseSize)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resize the main game canvas.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n     * @fires Phaser.Renderer.Events#RESIZE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.emit(Events.RESIZE, width, height);\r\n    },\r\n\r\n    /**\r\n     * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n     * @since 3.0.0\r\n     */\r\n    resetTransform: function ()\r\n    {\r\n        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode (compositing operation) of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} blendMode - The new blend mode which should be used.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setBlendMode: function (blendMode)\r\n    {\r\n        this.currentContext.globalCompositeOperation = blendMode;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the Canvas Rendering Context that all draw operations are performed against.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.\r\n     *\r\n     * @return {this} The Canvas Renderer instance.\r\n     */\r\n    setContext: function (ctx)\r\n    {\r\n        this.currentContext = (ctx) ? ctx : this.gameContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the global alpha of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setAlpha: function (alpha)\r\n    {\r\n        this.currentContext.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called at the start of the render loop.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n     * @fires Phaser.Renderer.Events#PRE_RENDER\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n        var config = this.config;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        ctx.globalAlpha = 1;\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n        if (config.clearBeforeRender)\r\n        {\r\n            ctx.clearRect(0, 0, width, height);\r\n\r\n            if (!config.transparent)\r\n            {\r\n                ctx.fillStyle = config.backgroundColor.rgba;\r\n                ctx.fillRect(0, 0, width, height);\r\n            }\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        this.drawCount = 0;\r\n\r\n        this.emit(Events.PRE_RENDER);\r\n    },\r\n\r\n    /**\r\n     * The core render step for a Scene Camera.\r\n     *\r\n     * Iterates through the given array of Game Objects and renders them with the given Camera.\r\n     *\r\n     * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n     * by the Scene Systems.render method.\r\n     *\r\n     * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n     * @fires Phaser.Renderer.Events#RENDER\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.GameObject[]} children - An array of filtered Game Objects that can be rendered by the given Camera.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, camera)\r\n    {\r\n        var childCount = children.length;\r\n\r\n        this.emit(Events.RENDER, scene, camera);\r\n\r\n        var cx = camera.x;\r\n        var cy = camera.y;\r\n        var cw = camera.width;\r\n        var ch = camera.height;\r\n\r\n        var ctx = (camera.renderToTexture) ? camera.context : scene.sys.context;\r\n\r\n        //  Save context pre-clip\r\n        ctx.save();\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            ctx.beginPath();\r\n            ctx.rect(cx, cy, cw, ch);\r\n            ctx.clip();\r\n        }\r\n\r\n        this.currentContext = ctx;\r\n\r\n        var mask = camera.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderCanvas(this, null, camera._maskCamera);\r\n        }\r\n\r\n        if (!camera.transparent)\r\n        {\r\n            ctx.fillStyle = camera.backgroundColor.rgba;\r\n            ctx.fillRect(cx, cy, cw, ch);\r\n        }\r\n\r\n        ctx.globalAlpha = camera.alpha;\r\n\r\n        ctx.globalCompositeOperation = 'source-over';\r\n\r\n        this.drawCount += childCount;\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.PRE_RENDER, camera);\r\n        }\r\n\r\n        camera.matrix.copyToContext(ctx);\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            var child = children[i];\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.preRenderCanvas(this, child, camera);\r\n            }\r\n\r\n            child.renderCanvas(this, child, camera);\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.postRenderCanvas(this, child, camera);\r\n            }\r\n        }\r\n\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.globalAlpha = 1;\r\n\r\n        camera.flashEffect.postRenderCanvas(ctx);\r\n        camera.fadeEffect.postRenderCanvas(ctx);\r\n\r\n        camera.dirty = false;\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderCanvas(this);\r\n        }\r\n\r\n        //  Restore pre-clip context\r\n        ctx.restore();\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.POST_RENDER, camera);\r\n\r\n            if (camera.renderToGame)\r\n            {\r\n                scene.sys.context.drawImage(camera.canvas, cx, cy);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Restores the game context's global settings and takes a snapshot if one is scheduled.\r\n     *\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n     * @fires Phaser.Renderer.Events#POST_RENDER\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n\r\n        ctx.restore();\r\n\r\n        this.emit(Events.POST_RENDER);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            CanvasSnapshot(this.gameCanvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of the given canvas.\r\n     *\r\n     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n     *\r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotCanvas\r\n     * @since 3.19.0\r\n     *\r\n     * @param {HTMLCanvasElement} canvas - The canvas to grab from.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n     * @param {number} [x=0] - The x coordinate to grab from.\r\n     * @param {number} [y=0] - The y coordinate to grab from.\r\n     * @param {number} [width=canvas.width] - The width of the area to grab.\r\n     * @param {number} [height=canvas.height] - The height of the area to grab.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Canvas Renderer.\r\n     */\r\n    snapshotCanvas: function (canvas, callback, getPixel, x, y, width, height, type, encoderOptions)\r\n    {\r\n        if (getPixel === undefined) { getPixel = false; }\r\n\r\n        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        state.getPixel = getPixel;\r\n\r\n        CanvasSnapshot(this.canvas, state);\r\n\r\n        state.callback = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate to grab from.\r\n     * @param {number} y - The y coordinate to grab from.\r\n     * @param {number} width - The width of the area to grab.\r\n     * @param {number} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gameCanvas.width);\r\n        state.height = Math.min(height, this.gameCanvas.height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get.\r\n     * @param {number} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.\r\n     * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n     */\r\n    batchSprite: function (sprite, frame, camera, parentTransformMatrix)\r\n    {\r\n        var alpha = camera.alpha * sprite.alpha;\r\n\r\n        if (alpha === 0)\r\n        {\r\n            //  Nothing to see, so abort early\r\n            return;\r\n        }\r\n\r\n        var ctx = this.currentContext;\r\n\r\n        var camMatrix = this._tempMatrix1;\r\n        var spriteMatrix = this._tempMatrix2;\r\n\r\n        var cd = frame.canvasData;\r\n\r\n        var frameX = cd.x;\r\n        var frameY = cd.y;\r\n        var frameWidth = frame.cutWidth;\r\n        var frameHeight = frame.cutHeight;\r\n        var customPivot = frame.customPivot;\r\n\r\n        var res = frame.source.resolution;\r\n\r\n        var displayOriginX = sprite.displayOriginX;\r\n        var displayOriginY = sprite.displayOriginY;\r\n\r\n        var x = -displayOriginX + frame.x;\r\n        var y = -displayOriginY + frame.y;\r\n\r\n        if (sprite.isCropped)\r\n        {\r\n            var crop = sprite._crop;\r\n\r\n            if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY)\r\n            {\r\n                frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\r\n            }\r\n\r\n            frameWidth = crop.cw;\r\n            frameHeight = crop.ch;\r\n\r\n            frameX = crop.cx;\r\n            frameY = crop.cy;\r\n\r\n            x = -displayOriginX + crop.x;\r\n            y = -displayOriginY + crop.y;\r\n\r\n            if (sprite.flipX)\r\n            {\r\n                if (x >= 0)\r\n                {\r\n                    x = -(x + frameWidth);\r\n                }\r\n                else if (x < 0)\r\n                {\r\n                    x = (Math.abs(x) - frameWidth);\r\n                }\r\n            }\r\n\r\n            if (sprite.flipY)\r\n            {\r\n                if (y >= 0)\r\n                {\r\n                    y = -(y + frameHeight);\r\n                }\r\n                else if (y < 0)\r\n                {\r\n                    y = (Math.abs(y) - frameHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        var flipX = 1;\r\n        var flipY = 1;\r\n\r\n        if (sprite.flipX)\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                x += (-frame.realWidth + (displayOriginX * 2));\r\n            }\r\n\r\n            flipX = -1;\r\n        }\r\n\r\n        //  Auto-invert the flipY if this is coming from a GLTexture\r\n        if (sprite.flipY)\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                y += (-frame.realHeight + (displayOriginY * 2));\r\n            }\r\n\r\n            flipY = -1;\r\n        }\r\n\r\n        spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX * flipX, sprite.scaleY * flipY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            spriteMatrix.e = sprite.x;\r\n            spriteMatrix.f = sprite.y;\r\n        }\r\n        else\r\n        {\r\n            spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\r\n            spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;\r\n        }\r\n\r\n        //  Multiply by the Sprite matrix\r\n        camMatrix.multiply(spriteMatrix);\r\n\r\n        ctx.save();\r\n\r\n        camMatrix.setToContext(ctx);\r\n\r\n        ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];\r\n\r\n        ctx.globalAlpha = alpha;\r\n\r\n        ctx.imageSmoothingEnabled = !(!this.antialias || frame.source.scaleMode);\r\n\r\n        if (sprite.mask)\r\n        {\r\n            sprite.mask.preRenderCanvas(this, sprite, camera);\r\n        }\r\n\r\n        ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);\r\n\r\n        if (sprite.mask)\r\n        {\r\n            sprite.mask.postRenderCanvas(this, sprite, camera);\r\n        }\r\n\r\n        ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Destroys all object references in the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.game = null;\r\n        this.gameCanvas = null;\r\n        this.gameContext = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar modes = require('../../BlendModes');\r\nvar CanvasFeatures = require('../../../device/CanvasFeatures');\r\n\r\n/**\r\n * Returns an array which maps the default blend modes to supported Canvas blend modes.\r\n *\r\n * If the browser doesn't support a blend mode, it will default to the normal `source-over` blend mode.\r\n *\r\n * @function Phaser.Renderer.Canvas.GetBlendModes\r\n * @since 3.0.0\r\n *\r\n * @return {array} Which Canvas blend mode corresponds to which default Phaser blend mode.\r\n */\r\nvar GetBlendModes = function ()\r\n{\r\n    var output = [];\r\n    var useNew = CanvasFeatures.supportNewBlendModes;\r\n    var so = 'source-over';\r\n\r\n    output[modes.NORMAL] = so;\r\n    output[modes.ADD] = 'lighter';\r\n    output[modes.MULTIPLY] = (useNew) ? 'multiply' : so;\r\n    output[modes.SCREEN] = (useNew) ? 'screen' : so;\r\n    output[modes.OVERLAY] = (useNew) ? 'overlay' : so;\r\n    output[modes.DARKEN] = (useNew) ? 'darken' : so;\r\n    output[modes.LIGHTEN] = (useNew) ? 'lighten' : so;\r\n    output[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : so;\r\n    output[modes.COLOR_BURN] = (useNew) ? 'color-burn' : so;\r\n    output[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : so;\r\n    output[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : so;\r\n    output[modes.DIFFERENCE] = (useNew) ? 'difference' : so;\r\n    output[modes.EXCLUSION] = (useNew) ? 'exclusion' : so;\r\n    output[modes.HUE] = (useNew) ? 'hue' : so;\r\n    output[modes.SATURATION] = (useNew) ? 'saturation' : so;\r\n    output[modes.COLOR] = (useNew) ? 'color' : so;\r\n    output[modes.LUMINOSITY] = (useNew) ? 'luminosity' : so;\r\n    output[modes.ERASE] = 'destination-out';\r\n    output[modes.SOURCE_IN] = 'source-in';\r\n    output[modes.SOURCE_OUT] = 'source-out';\r\n    output[modes.SOURCE_ATOP] = 'source-atop';\r\n    output[modes.DESTINATION_OVER] = 'destination-over';\r\n    output[modes.DESTINATION_IN] = 'destination-in';\r\n    output[modes.DESTINATION_OUT] = 'destination-out';\r\n    output[modes.DESTINATION_ATOP] = 'destination-atop';\r\n    output[modes.LIGHTER] = 'lighter';\r\n    output[modes.COPY] = 'copy';\r\n    output[modes.XOR] = 'xor';\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = GetBlendModes;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Post-Render Event.\r\n *\r\n * This event is dispatched by the Renderer when all rendering, for all cameras in all Scenes,\r\n * has completed, but before any pending snap shots have been taken.\r\n *\r\n * @event Phaser.Renderer.Events#POST_RENDER\r\n * @since 3.50.0\r\n */\r\nmodule.exports = 'postrender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Pre-Render Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer. This happens right at the start of the render\r\n * process, after the context has been cleared, the scissors enabled (WebGL only) and everything has been\r\n * reset ready for the render.\r\n *\r\n * @event Phaser.Renderer.Events#PRE_RENDER\r\n * @since 3.50.0\r\n */\r\nmodule.exports = 'prerender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Render Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer for every camera in every Scene.\r\n *\r\n * It is dispatched before any of the children in the Scene have been rendered.\r\n *\r\n * @event Phaser.Renderer.Events#RENDER\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene being rendered.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered.\r\n */\r\nmodule.exports = 'render';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Renderer Resize Event.\r\n *\r\n * This event is dispatched by the Phaser Renderer when it is resized, usually as a result\r\n * of the Scale Manager resizing.\r\n *\r\n * @event Phaser.Renderer.Events#RESIZE\r\n * @since 3.50.0\r\n *\r\n * @param {number} width - The new width of the renderer.\r\n * @param {number} height - The new height of the renderer.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    POST_RENDER: require('./POST_RENDER_EVENT'),\r\n    PRE_RENDER: require('./PRE_RENDER_EVENT'),\r\n    RENDER: require('./RENDER_EVENT'),\r\n    RESIZE: require('./RESIZE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Color = require('../../display/color/Color');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Takes a snapshot of an area from the current frame displayed by a canvas.\r\n * \r\n * This is then copied to an Image object. When this loads, the results are sent\r\n * to the callback provided in the Snapshot Configuration object.\r\n *\r\n * @function Phaser.Renderer.Snapshot.Canvas\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} sourceCanvas - The canvas to take a snapshot of.\r\n * @param {Phaser.Types.Renderer.Snapshot.SnapshotState} config - The snapshot configuration object.\r\n */\r\nvar CanvasSnapshot = function (canvas, config)\r\n{\r\n    var callback = GetFastValue(config, 'callback');\r\n    var type = GetFastValue(config, 'type', 'image/png');\r\n    var encoderOptions = GetFastValue(config, 'encoder', 0.92);\r\n    var x = Math.abs(Math.round(GetFastValue(config, 'x', 0)));\r\n    var y = Math.abs(Math.round(GetFastValue(config, 'y', 0)));\r\n    var width = GetFastValue(config, 'width', canvas.width);\r\n    var height = GetFastValue(config, 'height', canvas.height);\r\n    var getPixel = GetFastValue(config, 'getPixel', false);\r\n\r\n    if (getPixel)\r\n    {\r\n        var context = canvas.getContext('2d');\r\n        var imageData = context.getImageData(x, y, 1, 1);\r\n        var data = imageData.data;\r\n\r\n        callback.call(null, new Color(data[0], data[1], data[2], data[3] / 255));\r\n    }\r\n    else if (x !== 0 || y !== 0 || width !== canvas.width || height !== canvas.height)\r\n    {\r\n        //  Area Grab\r\n        var copyCanvas = CanvasPool.createWebGL(this, width, height);\r\n        var ctx = copyCanvas.getContext('2d');\r\n\r\n        ctx.drawImage(canvas, x, y, width, height, 0, 0, width, height);\r\n\r\n        var image1 = new Image();\r\n    \r\n        image1.onerror = function ()\r\n        {\r\n            callback.call(null);\r\n\r\n            CanvasPool.remove(copyCanvas);\r\n        };\r\n\r\n        image1.onload = function ()\r\n        {\r\n            callback.call(null, image1);\r\n\r\n            CanvasPool.remove(copyCanvas);\r\n        };\r\n\r\n        image1.src = copyCanvas.toDataURL(type, encoderOptions);\r\n    }\r\n    else\r\n    {\r\n        //  Full Grab\r\n        var image2 = new Image();\r\n    \r\n        image2.onerror = function ()\r\n        {\r\n            callback.call(null);\r\n        };\r\n\r\n        image2.onload = function ()\r\n        {\r\n            callback.call(null, image2);\r\n        };\r\n\r\n        image2.src = canvas.toDataURL(type, encoderOptions);\r\n    }\r\n};\r\n\r\nmodule.exports = CanvasSnapshot;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Color = require('../../display/color/Color');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Takes a snapshot of an area from the current frame displayed by a WebGL canvas.\r\n *\r\n * This is then copied to an Image object. When this loads, the results are sent\r\n * to the callback provided in the Snapshot Configuration object.\r\n *\r\n * @function Phaser.Renderer.Snapshot.WebGL\r\n * @since 3.0.0\r\n *\r\n * @param {HTMLCanvasElement} sourceCanvas - The canvas to take a snapshot of.\r\n * @param {Phaser.Types.Renderer.Snapshot.SnapshotState} config - The snapshot configuration object.\r\n */\r\nvar WebGLSnapshot = function (sourceCanvas, config)\r\n{\r\n    var gl = sourceCanvas.getContext('experimental-webgl');\r\n\r\n    var callback = GetFastValue(config, 'callback');\r\n    var type = GetFastValue(config, 'type', 'image/png');\r\n    var encoderOptions = GetFastValue(config, 'encoder', 0.92);\r\n    var x = GetFastValue(config, 'x', 0);\r\n    var y = GetFastValue(config, 'y', 0);\r\n\r\n    var getPixel = GetFastValue(config, 'getPixel', false);\r\n\r\n    var isFramebuffer = GetFastValue(config, 'isFramebuffer', false);\r\n\r\n    var bufferWidth = (isFramebuffer) ? GetFastValue(config, 'bufferWidth', 1) : gl.drawingBufferWidth;\r\n    var bufferHeight = (isFramebuffer) ? GetFastValue(config, 'bufferHeight', 1) : gl.drawingBufferHeight;\r\n\r\n    if (getPixel)\r\n    {\r\n        var pixel = new Uint8Array(4);\r\n\r\n        var destY = (isFramebuffer) ? y : bufferHeight - y;\r\n\r\n        gl.readPixels(x, destY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\r\n\r\n        callback.call(null, new Color(pixel[0], pixel[1], pixel[2], pixel[3] / 255));\r\n    }\r\n    else\r\n    {\r\n        var width = GetFastValue(config, 'width', bufferWidth);\r\n        var height = GetFastValue(config, 'height', bufferHeight);\r\n\r\n        var total = width * height * 4;\r\n\r\n        var pixels = new Uint8Array(total);\r\n\r\n        gl.readPixels(x, bufferHeight - y - height, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\r\n\r\n        var canvas = CanvasPool.createWebGL(this, width, height);\r\n        var ctx = canvas.getContext('2d');\r\n\r\n        var imageData = ctx.getImageData(0, 0, width, height);\r\n\r\n        var data = imageData.data;\r\n\r\n        // var destIndex = (isFramebuffer) ? total - ((py * width + (width - px)) * 4) : (py * width + px) * 4;\r\n\r\n        for (var py = 0; py < height; py++)\r\n        {\r\n            for (var px = 0; px < width; px++)\r\n            {\r\n                var sourceIndex = ((height - py - 1) * width + px) * 4;\r\n                var destIndex = (py * width + px) * 4;\r\n\r\n                data[destIndex + 0] = pixels[sourceIndex + 0];\r\n                data[destIndex + 1] = pixels[sourceIndex + 1];\r\n                data[destIndex + 2] = pixels[sourceIndex + 2];\r\n                data[destIndex + 3] = pixels[sourceIndex + 3];\r\n            }\r\n        }\r\n\r\n        ctx.putImageData(imageData, 0, 0);\r\n\r\n        var image = new Image();\r\n\r\n        image.onerror = function ()\r\n        {\r\n            callback.call(null);\r\n\r\n            CanvasPool.remove(canvas);\r\n        };\r\n\r\n        image.onload = function ()\r\n        {\r\n            callback.call(null, image);\r\n\r\n            CanvasPool.remove(canvas);\r\n        };\r\n\r\n        image.src = canvas.toDataURL(type, encoderOptions);\r\n    }\r\n};\r\n\r\nmodule.exports = WebGLSnapshot;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./pipelines/const');\r\nvar CustomMap = require('../../structs/Map');\r\n\r\n//  Default Phaser 3 Pipelines\r\nvar BitmapMaskPipeline = require('./pipelines/BitmapMaskPipeline');\r\nvar GraphicsPipeline = require('./pipelines/GraphicsPipeline');\r\nvar LightPipeline = require('./pipelines/LightPipeline');\r\nvar MultiPipeline = require('./pipelines/MultiPipeline');\r\nvar PointLightPipeline = require('./pipelines/PointLightPipeline');\r\nvar RopePipeline = require('./pipelines/RopePipeline');\r\nvar SinglePipeline = require('./pipelines/SinglePipeline');\r\nvar UtilityPipeline = require('./pipelines/UtilityPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Pipeline Manager is responsible for the creation, activation, running and destruction\r\n * of WebGL Pipelines and Post FX Pipelines in Phaser 3.\r\n *\r\n * The `WebGLRenderer` owns a single instance of the Pipeline Manager, which you can access\r\n * via the `WebGLRenderer.pipelines` property.\r\n *\r\n * By default, there are 8 pipelines installed into the Pipeline Manager when Phaser boots:\r\n *\r\n * 1. The Multi Pipeline. Responsible for all multi-texture rendering, i.e. Sprites and Tilemaps.\r\n * 2. The Graphics Pipeline. Responsible for rendering Graphics and Shape objects.\r\n * 3. The Rope Pipeline. Responsible for rendering the Rope Game Object.\r\n * 4. The Light Pipeline. Responsible for rendering the Light Game Object.\r\n * 5. The Point Light Pipeline. Responsible for rendering the Point Light Game Object.\r\n * 6. The Single Pipeline. Responsible for rendering Game Objects that explicitly require one bound texture.\r\n * 7. The Bitmap Mask Pipeline. Responsible for Bitmap Mask rendering.\r\n * 8. The Utility Pipeline. Responsible for providing lots of handy texture manipulation functions.\r\n *\r\n * You can add your own custom pipeline via the `PipelineManager.add` method. Pipelines are\r\n * identified by unique string-based keys.\r\n *\r\n * @class PipelineManager\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the WebGL Renderer that owns this Pipeline Manager.\r\n */\r\nvar PipelineManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function PipelineManager (renderer)\r\n    {\r\n        /**\r\n         * A reference to the Game instance.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.50.0\r\n         */\r\n        this.game = renderer.game;\r\n\r\n        /**\r\n         * A reference to the WebGL Renderer instance.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#renderer\r\n         * @type {Phaser.Renderer.WebGL.WebGLRenderer}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * This map stores all pipeline classes available in this manager.\r\n         *\r\n         * The Utility Class must always come first.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#classes\r\n         * @type {Phaser.Structs.Map.<string, Class>}\r\n         * @since 3.50.0\r\n         */\r\n        this.classes = new CustomMap([\r\n            [ CONST.UTILITY_PIPELINE, UtilityPipeline ],\r\n            [ CONST.MULTI_PIPELINE, MultiPipeline ],\r\n            [ CONST.BITMAPMASK_PIPELINE, BitmapMaskPipeline ],\r\n            [ CONST.SINGLE_PIPELINE, SinglePipeline ],\r\n            [ CONST.ROPE_PIPELINE, RopePipeline ],\r\n            [ CONST.LIGHT_PIPELINE, LightPipeline ],\r\n            [ CONST.POINTLIGHT_PIPELINE, PointLightPipeline ],\r\n            [ CONST.GRAPHICS_PIPELINE, GraphicsPipeline ]\r\n        ]);\r\n\r\n        /**\r\n         * This map stores all Post FX Pipeline classes available in this manager.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#postPipelineClasses\r\n         * @type {Phaser.Structs.Map.<string, Class>}\r\n         * @since 3.50.0\r\n         */\r\n        this.postPipelineClasses = new CustomMap();\r\n\r\n        /**\r\n         * This map stores all pipeline instances in this manager.\r\n         *\r\n         * This is populated with the default pipelines in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#pipelines\r\n         * @type {Phaser.Structs.Map.<string, Phaser.Renderer.WebGL.WebGLPipeline>}\r\n         * @since 3.50.0\r\n         */\r\n        this.pipelines = new CustomMap();\r\n\r\n        /**\r\n         * Current pipeline in use by the WebGLRenderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#current\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.current = null;\r\n\r\n        /**\r\n         * The previous WebGLPipeline that was in use.\r\n         *\r\n         * This is set when `clearPipeline` is called and restored in `rebindPipeline` if none is given.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#previous\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.previous = null;\r\n\r\n        /**\r\n         * A constant-style reference to the Multi Pipeline Instance.\r\n         *\r\n         * This is the default Phaser 3 pipeline and is used by the WebGL Renderer to manage\r\n         * camera effects and more. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#MULTI_PIPELINE\r\n         * @type {Phaser.Renderer.WebGL.Pipelines.MultiPipeline}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.MULTI_PIPELINE = null;\r\n\r\n        /**\r\n         * A constant-style reference to the Bitmap Mask Pipeline Instance.\r\n         *\r\n         * This is the default Phaser 3 mask pipeline and is used Game Objects using\r\n         * a Bitmap Mask. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#BITMAPMASK_PIPELINE\r\n         * @type {Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.BITMAPMASK_PIPELINE = null;\r\n\r\n        /**\r\n         * A constant-style reference to the Utility Pipeline Instance.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#UTILITY_PIPELINE\r\n         * @type {Phaser.Renderer.WebGL.Pipelines.UtilityPipeline}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.UTILITY_PIPELINE = null;\r\n\r\n        /**\r\n         * A reference to the Full Frame 1 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#fullFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame1;\r\n\r\n        /**\r\n         * A reference to the Full Frame 2 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#fullFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame2;\r\n\r\n        /**\r\n         * A reference to the Half Frame 1 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#halfFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame1;\r\n\r\n        /**\r\n         * A reference to the Half Frame 2 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.PipelineManager#halfFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame2;\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler, called by the WebGLRenderer durings its boot process.\r\n     *\r\n     * Adds all of the default pipelines, based on the game config, and then calls\r\n     * the `boot` method on each one of them.\r\n     *\r\n     * Finally, the default pipeline is set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#boot\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Core.PipelineConfig} [pipelineConfig] - The pipeline configuration object as set in the Game Config.\r\n     */\r\n    boot: function (pipelineConfig)\r\n    {\r\n        //  Install each of the default pipelines\r\n\r\n        var instance;\r\n        var pipelineName;\r\n\r\n        var _this = this;\r\n        var game = this.game;\r\n\r\n        this.classes.each(function (pipelineName, pipeline)\r\n        {\r\n            instance = _this.add(pipelineName, new pipeline({ game: game }));\r\n\r\n            if (pipelineName === CONST.UTILITY_PIPELINE)\r\n            {\r\n                _this.UTILITY_PIPELINE = instance;\r\n\r\n                //  FBO references\r\n                _this.fullFrame1 = instance.fullFrame1;\r\n                _this.fullFrame2 = instance.fullFrame2;\r\n                _this.halfFrame1 = instance.halfFrame1;\r\n                _this.halfFrame2 = instance.halfFrame2;\r\n            }\r\n        });\r\n\r\n        //  Our const-like references\r\n        this.MULTI_PIPELINE = this.get(CONST.MULTI_PIPELINE);\r\n        this.BITMAPMASK_PIPELINE = this.get(CONST.BITMAPMASK_PIPELINE);\r\n\r\n        //  And now the ones in the config, if any\r\n\r\n        if (pipelineConfig)\r\n        {\r\n            for (pipelineName in pipelineConfig)\r\n            {\r\n                var pipelineClass = pipelineConfig[pipelineName];\r\n\r\n                instance = new pipelineClass(game);\r\n\r\n                if (instance.isPostFX)\r\n                {\r\n                    this.postPipelineClasses.set(pipelineName, pipelineClass);\r\n                }\r\n                else if (!this.has(pipelineName))\r\n                {\r\n                    this.classes.set(pipelineName, pipelineClass);\r\n\r\n                    this.add(pipelineName, instance);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a pipeline instance to this Pipeline Manager.\r\n     *\r\n     * The name of the instance must be unique within this manager.\r\n     *\r\n     * Make sure to pass an instance to this method, not a base class.\r\n     *\r\n     * For example, you should pass it like this:\r\n     *\r\n     * ```javascript\r\n     * this.add('yourName', new CustomPipeline());`\r\n     * ```\r\n     *\r\n     * and **not** like this:\r\n     *\r\n     * ```javascript\r\n     * this.add('yourName', CustomPipeline);`\r\n     * ```\r\n     *\r\n     * To add a **Post Pipeline**, see `addPostPipeline` instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#add\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - A unique string-based key for the pipeline within the manager.\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - A pipeline _instance_ which must extend `WebGLPipeline`.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.\r\n     */\r\n    add: function (name, pipeline)\r\n    {\r\n        if (pipeline.isPostFX)\r\n        {\r\n            console.warn(name + ' is a Post Pipeline. Use `addPostPipeline` instead');\r\n\r\n            return;\r\n        }\r\n\r\n        var pipelines = this.pipelines;\r\n        var renderer = this.renderer;\r\n\r\n        if (!pipelines.has(name))\r\n        {\r\n            pipeline.name = name;\r\n            pipeline.manager = this;\r\n\r\n            pipelines.set(name, pipeline);\r\n        }\r\n        else\r\n        {\r\n            console.warn('Pipeline exists: ' + name);\r\n        }\r\n\r\n        if (!pipeline.hasBooted)\r\n        {\r\n            pipeline.boot();\r\n        }\r\n\r\n        if (renderer.width !== 0 && renderer.height !== 0)\r\n        {\r\n            pipeline.resize(renderer.width, renderer.height);\r\n        }\r\n\r\n        return pipeline;\r\n    },\r\n\r\n    /**\r\n     * Adds a Post Pipeline to this Pipeline Manager.\r\n     *\r\n     * Make sure to pass a base class to this method, not an instance.\r\n     *\r\n     * For example, you should pass it like this:\r\n     *\r\n     * ```javascript\r\n     * this.addPostPipeline('yourName', CustomPipeline);`\r\n     * ```\r\n     *\r\n     * and **not** like this:\r\n     *\r\n     * ```javascript\r\n     * this.addPostPipeline('yourName', new CustomPipeline());`\r\n     * ```\r\n     *\r\n     * To add a regular pipeline, see the `add` method instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#addPostPipeline\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - A unique string-based key for the pipeline within the manager.\r\n     * @param {function} pipeline - A pipeline class which must extend `PostFXPipeline`.\r\n     *\r\n     * @return {this} This Pipeline Manager.\r\n     */\r\n    addPostPipeline: function (name, pipeline)\r\n    {\r\n        if (!this.postPipelineClasses.has(name))\r\n        {\r\n            this.postPipelineClasses.set(name, pipeline);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline, if one is bound.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#flush\r\n     * @since 3.50.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        if (this.current)\r\n        {\r\n            this.current.flush();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if a pipeline is present in this Pipeline Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#has\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} pipeline - Either the string-based name of the pipeline to get, or a pipeline instance to look-up.\r\n     *\r\n     * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.\r\n     */\r\n    has: function (pipeline)\r\n    {\r\n        var pipelines = this.pipelines;\r\n\r\n        if (typeof pipeline === 'string')\r\n        {\r\n            return pipelines.has(pipeline);\r\n        }\r\n        else if (pipelines.contains(pipeline))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Returns the pipeline instance based on the given name, or instance.\r\n     *\r\n     * If no instance, or matching name, exists in this manager, it returns `undefined`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#get\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|Phaser.Renderer.WebGL.WebGLPipeline)} pipeline - Either the string-based name of the pipeline to get, or a pipeline instance to look-up.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `undefined` if not found.\r\n     */\r\n    get: function (pipeline)\r\n    {\r\n        var pipelines = this.pipelines;\r\n\r\n        if (typeof pipeline === 'string')\r\n        {\r\n            return pipelines.get(pipeline);\r\n        }\r\n        else if (pipelines.contains(pipeline))\r\n        {\r\n            return pipeline;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a _new instance_ of the post pipeline based on the given name, or class.\r\n     *\r\n     * If no instance, or matching name, exists in this manager, it returns `undefined`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#getPostPipeline\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|function|Phaser.Renderer.WebGL.Pipelines.PostFXPipeline)} pipeline - Either the string-based name of the pipeline to get, or a pipeline instance, or class to look-up.\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - If this post pipeline is being installed into a Game Object or Camera, this is a reference to it.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.Pipelines.PostFXPipeline} The pipeline instance, or `undefined` if not found.\r\n     */\r\n    getPostPipeline: function (pipeline, gameObject)\r\n    {\r\n        var pipelineClasses = this.postPipelineClasses;\r\n\r\n        var instance;\r\n\r\n        if (typeof pipeline === 'string')\r\n        {\r\n            instance = pipelineClasses.get(pipeline);\r\n        }\r\n        else if (typeof pipeline === 'function')\r\n        {\r\n            //  A class\r\n            if (pipelineClasses.contains(pipeline))\r\n            {\r\n                instance = pipeline;\r\n            }\r\n        }\r\n        else if (typeof pipeline === 'object')\r\n        {\r\n            //  Instance\r\n            instance = pipelineClasses.get(pipeline.name);\r\n        }\r\n\r\n        if (instance)\r\n        {\r\n            var newPipeline = new instance(this.game);\r\n\r\n            if (gameObject)\r\n            {\r\n                newPipeline.gameObject = gameObject;\r\n            }\r\n\r\n            return newPipeline;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes a pipeline instance based on the given name.\r\n     *\r\n     * If no pipeline matches the name, this method does nothing.\r\n     *\r\n     * Note that the pipeline will not be flushed or destroyed, it's simply removed from\r\n     * this manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#remove\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the pipeline to be removed.\r\n     * @param {boolean} [removeClass=true] - Remove the pipeline class as well as the instance?\r\n     * @param {boolean} [removePostPipelineClass=true] - Remove the post pipeline class as well as the instance?\r\n     */\r\n    remove: function (name, removeClass, removePostPipelineClass)\r\n    {\r\n        if (removeClass === undefined) { removeClass = true; }\r\n        if (removePostPipelineClass === undefined) { removePostPipelineClass = true; }\r\n\r\n        this.pipelines.delete(name);\r\n\r\n        if (removeClass)\r\n        {\r\n            this.classes.delete(name);\r\n        }\r\n\r\n        if (removePostPipelineClass)\r\n        {\r\n            this.postPipelineClasses.delete(name);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current pipeline to be used by the `WebGLRenderer`.\r\n     *\r\n     * This method accepts a pipeline instance as its parameter, not the name.\r\n     *\r\n     * If the pipeline isn't already the current one it will call `WebGLPipeline.bind` and then `onBind`.\r\n     *\r\n     * You cannot set Post FX Pipelines using this method. To use a Post FX Pipeline, you should\r\n     * apply it to either a Camera, Container or other supporting Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#set\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline instance to be set as current.\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to set as being current.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was set, or undefined if it couldn't be set.\r\n     */\r\n    set: function (pipeline, gameObject, currentShader)\r\n    {\r\n        if (pipeline.isPostFX)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!this.isCurrent(pipeline, currentShader))\r\n        {\r\n            this.flush();\r\n\r\n            if (this.current)\r\n            {\r\n                this.current.unbind();\r\n            }\r\n\r\n            this.current = pipeline;\r\n\r\n            pipeline.bind(currentShader);\r\n        }\r\n\r\n        pipeline.updateProjectionMatrix();\r\n\r\n        pipeline.onBind(gameObject);\r\n\r\n        return pipeline;\r\n    },\r\n\r\n    /**\r\n     * This method is called by the `WebGLPipeline.batchQuad` method, right before a quad\r\n     * belonging to a Game Object is about to be added to the batch. It causes a batch\r\n     * flush, then calls the `preBatch` method on the post-fx pipelines belonging to the\r\n     * Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#preBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object about to be batched.\r\n     */\r\n    preBatch: function (gameObject)\r\n    {\r\n        if (gameObject.hasPostPipeline)\r\n        {\r\n            this.flush();\r\n\r\n            var pipelines = gameObject.postPipelines;\r\n\r\n            //  Iterate in reverse because we need them stacked in the order they're in the array\r\n            for (var i = pipelines.length - 1; i >= 0; i--)\r\n            {\r\n                var pipeline = pipelines[i];\r\n\r\n                if (pipeline.active)\r\n                {\r\n                    pipeline.preBatch(gameObject);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This method is called by the `WebGLPipeline.batchQuad` method, right after a quad\r\n     * belonging to a Game Object has been added to the batch. It causes a batch\r\n     * flush, then calls the `postBatch` method on the post-fx pipelines belonging to the\r\n     * Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#postBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to the batch.\r\n     */\r\n    postBatch: function (gameObject)\r\n    {\r\n        if (gameObject.hasPostPipeline)\r\n        {\r\n            this.flush();\r\n\r\n            var pipelines = gameObject.postPipelines;\r\n\r\n            for (var i = 0; i < pipelines.length; i++)\r\n            {\r\n                var pipeline = pipelines[i];\r\n\r\n                if (pipeline.active)\r\n                {\r\n                    pipeline.postBatch(gameObject);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called at the start of the `WebGLRenderer.preRenderCamera` method.\r\n     *\r\n     * If the Camera has post pipelines set, it will flush the batch and then call the\r\n     * `preBatch` method on the post-fx pipelines belonging to the Camera.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#preBatchCamera\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera about to be rendered.\r\n     */\r\n    preBatchCamera: function (camera)\r\n    {\r\n        if (camera.hasPostPipeline)\r\n        {\r\n            this.flush();\r\n\r\n            var pipelines = camera.postPipelines;\r\n\r\n            //  Iterate in reverse because we need them stacked in the order they're in the array\r\n            for (var i = pipelines.length - 1; i >= 0; i--)\r\n            {\r\n                var pipeline = pipelines[i];\r\n\r\n                if (pipeline.active)\r\n                {\r\n                    pipeline.preBatch(camera);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called at the end of the `WebGLRenderer.postRenderCamera` method.\r\n     *\r\n     * If the Camera has post pipelines set, it will flush the batch and then call the\r\n     * `postBatch` method on the post-fx pipelines belonging to the Camera.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#postBatchCamera\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that was just rendered.\r\n     */\r\n    postBatchCamera: function (camera)\r\n    {\r\n        if (camera.hasPostPipeline)\r\n        {\r\n            this.flush();\r\n\r\n            var pipelines = camera.postPipelines;\r\n\r\n            for (var i = 0; i < pipelines.length; i++)\r\n            {\r\n                var pipeline = pipelines[i];\r\n\r\n                if (pipeline.active)\r\n                {\r\n                    pipeline.postBatch(camera);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given pipeline is already the active pipeline, both within this\r\n     * Pipeline Manager and also has the same shader set in the Renderer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#isCurrent\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline instance to be checked.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to set as being current.\r\n     *\r\n     * @return {boolean} `true` if the given pipeline is already the current pipeline, otherwise `false`.\r\n     */\r\n    isCurrent: function (pipeline, currentShader)\r\n    {\r\n        var renderer = this.renderer;\r\n        var current = this.current;\r\n\r\n        if (current && !currentShader)\r\n        {\r\n            currentShader = current.currentShader;\r\n        }\r\n\r\n        return !(current !== pipeline || currentShader.program !== renderer.currentProgram);\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * The difference between this method and `drawFrame` is that this method\r\n     * uses a faster copy shader, where only the brightness can be modified.\r\n     * If you need color level manipulation, see `drawFrame` instead.\r\n     *\r\n     * The copy itself is handled by the Utility Pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#copyFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    copyFrame: function (source, target, brightness, clear, clearAlpha)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(source, target, brightness, clear, clearAlpha);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pops the framebuffer from the renderers FBO stack and sets that as the active target,\r\n     * then draws the `source` Render Target to it. It then resets the renderer textures.\r\n     *\r\n     * This should be done when you need to draw the _final_ results of a pipeline to the game\r\n     * canvas, or the next framebuffer in line on the FBO stack. You should only call this once\r\n     * in the `onDraw` handler and it should be the final thing called. Be careful not to call\r\n     * this if you need to actually use the pipeline shader, instead of the copy shader. In\r\n     * those cases, use the `bindAndDraw` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#copyToGame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The Render Target to draw from.\r\n     */\r\n    copyToGame: function (source)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(source);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target, using the\r\n     * given Color Matrix.\r\n     *\r\n     * The difference between this method and `copyFrame` is that this method\r\n     * uses a color matrix shader, where you have full control over the luminance\r\n     * values used during the copy. If you don't need this, you can use the faster\r\n     * `copyFrame` method instead.\r\n     *\r\n     * The copy itself is handled by the Utility Pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#drawFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {Phaser.Display.ColorMatrix} [colorMatrix] - The Color Matrix to use when performing the draw.\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    drawFrame: function (source, target, clearAlpha, colorMatrix)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(source, target, clearAlpha, colorMatrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using a linear blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * The draw itself is handled by the Utility Pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#blendFrames\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    blendFrames: function (source1, source2, target, strength, clearAlpha)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(source1, source2, target, strength, clearAlpha);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using an additive blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * The draw itself is handled by the Utility Pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#blendFramesAdditive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(source1, source2, target, strength, clearAlpha);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the given Render Target.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#clearFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The Render Target to clear.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    clearFrame: function (target, clearAlpha)\r\n    {\r\n        this.UTILITY_PIPELINE.clearFrame(target, clearAlpha);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * The difference with this copy is that no resizing takes place. If the `source`\r\n     * Render Target is larger than the `target` then only a portion the same size as\r\n     * the `target` dimensions is copied across.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#blitFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {boolean} [eraseMode=false] - Erase source from target using ERASE Blend Mode?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode)\r\n    {\r\n        this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds the `source` Render Target and then copies a section of it to the `target` Render Target.\r\n     *\r\n     * This method is extremely fast because it uses `gl.copyTexSubImage2D` and doesn't\r\n     * require the use of any shaders. Remember the coordinates are given in standard WebGL format,\r\n     * where x and y specify the lower-left corner of the section, not the top-left. Also, the\r\n     * copy entirely replaces the contents of the target texture, no 'merging' or 'blending' takes\r\n     * place.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#copyFrameRect\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} x - The x coordinate of the lower left corner where to start copying.\r\n     * @param {number} y - The y coordinate of the lower left corner where to start copying.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     *\r\n     * @return {this} This Pipeline Manager instance.\r\n     */\r\n    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)\r\n    {\r\n        this.UTILITY_PIPELINE.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the current pipeline is forced to use texture unit zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#forceZero\r\n     * @since 3.50.0\r\n     *\r\n     * @return {boolean} `true` if the current pipeline is forced to use texture unit zero.\r\n     */\r\n    forceZero: function ()\r\n    {\r\n        return (this.current && this.current.forceZero);\r\n    },\r\n\r\n    /**\r\n     * Sets the Multi Pipeline to be the currently bound pipeline.\r\n     *\r\n     * This is the default Phaser 3 rendering pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#setMulti\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.Pipelines.MultiPipeline} The Multi Pipeline instance.\r\n     */\r\n    setMulti: function ()\r\n    {\r\n        return this.set(this.MULTI_PIPELINE);\r\n    },\r\n\r\n    /**\r\n     * Sets the Utility Pipeline to be the currently bound pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#setUtility\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to set as being current.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.Pipelines.UtilityPipeline} The Utility Pipeline instance.\r\n     */\r\n    setUtility: function (currentShader)\r\n    {\r\n        return this.UTILITY_PIPELINE.bind(currentShader);\r\n    },\r\n\r\n    /**\r\n     * Use this to reset the gl context to the state that Phaser requires to continue rendering.\r\n     *\r\n     * Calling this will:\r\n     *\r\n     * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.\r\n     * * Clear the depth buffer and stencil buffers.\r\n     * * Reset the viewport size.\r\n     * * Reset the blend mode.\r\n     * * Bind a blank texture as the active texture on texture unit zero.\r\n     * * Rebinds the given pipeline instance.\r\n     *\r\n     * You should call this if you have previously called `clear`, and then wish to return\r\n     * rendering control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#rebind\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} [pipeline] - The pipeline instance to be rebound. If not given, the previous pipeline will be bound.\r\n     */\r\n    rebind: function (pipeline)\r\n    {\r\n        if (pipeline === undefined && this.previous)\r\n        {\r\n            pipeline = this.previous;\r\n        }\r\n\r\n        var renderer = this.renderer;\r\n        var gl = renderer.gl;\r\n\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        if (renderer.hasActiveStencilMask())\r\n        {\r\n            gl.clear(gl.DEPTH_BUFFER_BIT);\r\n        }\r\n        else\r\n        {\r\n            //  If there wasn't a stencil mask set before this call, we can disable it safely\r\n            gl.disable(gl.STENCIL_TEST);\r\n            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.viewport(0, 0, renderer.width, renderer.height);\r\n\r\n        renderer.currentProgram = null;\r\n\r\n        renderer.setBlendMode(0, true);\r\n\r\n        var entries = this.pipelines.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            entries[key].glReset = true;\r\n        }\r\n\r\n        if (pipeline)\r\n        {\r\n            this.current = pipeline;\r\n\r\n            pipeline.rebind();\r\n        }\r\n\r\n        renderer.resetTextures();\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline being used and then clears it, along with the\r\n     * the current shader program and vertex buffer from the `WebGLRenderer`.\r\n     *\r\n     * Then resets the blend mode to NORMAL.\r\n     *\r\n     * Call this before jumping to your own gl context handler, and then call `rebind` when\r\n     * you wish to return control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#clear\r\n     * @since 3.50.0\r\n     */\r\n    clear: function ()\r\n    {\r\n        var renderer = this.renderer;\r\n\r\n        this.flush();\r\n\r\n        if (this.current)\r\n        {\r\n            this.current.unbind();\r\n            this.previous = this.current;\r\n            this.current = null;\r\n        }\r\n        else\r\n        {\r\n            this.previous = null;\r\n        }\r\n\r\n        renderer.currentProgram = null;\r\n\r\n        renderer.setBlendMode(0, true);\r\n    },\r\n\r\n    /**\r\n     * Destroy the Pipeline Manager, cleaning up all related resources and references.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.PipelineManager#destroy\r\n     * @since 3.50.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.flush();\r\n\r\n        this.classes.clear();\r\n        this.postPipelineClasses.clear();\r\n        this.pipelines.clear();\r\n\r\n        this.renderer = null;\r\n        this.game = null;\r\n        this.classes = null;\r\n        this.postPipelineClasses = null;\r\n        this.pipelines = null;\r\n        this.current = null;\r\n        this.previous = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PipelineManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DeepCopy = require('../../utils/object/DeepCopy');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./pipelines/events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar RendererEvents = require('../events');\r\nvar RenderTarget = require('./RenderTarget');\r\nvar Utils = require('./Utils');\r\nvar WebGLShader = require('./WebGLShader');\r\n\r\n/**\r\n * @classdesc\r\n * The `WebGLPipeline` is a base class used by all of the core Phaser pipelines.\r\n *\r\n * It describes the way elements will be rendered in WebGL. Internally, it handles\r\n * compiling the shaders, creating vertex buffers, assigning primitive topology and\r\n * binding vertex attributes, all based on the given configuration data.\r\n *\r\n * The pipeline is configured by passing in a `WebGLPipelineConfig` object. Please\r\n * see the documentation for this type to fully understand the configuration options\r\n * available to you.\r\n *\r\n * Usually, you would not extend from this class directly, but would instead extend\r\n * from one of the core pipelines, such as the Multi Pipeline.\r\n *\r\n * The pipeline flow per render-step is as follows:\r\n *\r\n * 1) onPreRender - called once at the start of the render step\r\n * 2) onRender - call for each Scene Camera that needs to render (so can be multiple times per render step)\r\n * 3) Internal flow:\r\n * 3a)   bind (only called if a Game Object is using this pipeline and it's not currently active)\r\n * 3b)   onBind (called for every Game Object that uses this pipeline)\r\n * 3c)   flush (can be called by a Game Object, internal method or from outside by changing pipeline)\r\n * 4) onPostRender - called once at the end of the render step\r\n *\r\n * @class WebGLPipeline\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration object for this WebGL Pipeline.\r\n */\r\nvar WebGLPipeline = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function WebGLPipeline (config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var game = config.game;\r\n        var renderer = game.renderer;\r\n        var gl = renderer.gl;\r\n\r\n        /**\r\n         * Name of the pipeline. Used for identification and setting from Game Objects.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'WebGLPipeline');\r\n\r\n        /**\r\n         * The Phaser Game instance to which this pipeline is bound.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * The WebGL Renderer instance to which this pipeline is bound.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#renderer\r\n         * @type {Phaser.Renderer.WebGL.WebGLRenderer}\r\n         * @since 3.0.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * A reference to the WebGL Pipeline Manager.\r\n         *\r\n         * This is initially undefined and only set when this pipeline is added\r\n         * to the manager.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#manager\r\n         * @type {?Phaser.Renderer.WebGL.PipelineManager}\r\n         * @since 3.50.0\r\n         */\r\n        this.manager;\r\n\r\n        /**\r\n         * The WebGL context this WebGL Pipeline uses.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = gl;\r\n\r\n        /**\r\n         * The canvas which this WebGL Pipeline renders to.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#view\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.view = game.canvas;\r\n\r\n        /**\r\n         * Width of the current viewport.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * Height of the current viewport.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The current number of vertices that have been added to the pipeline batch.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexCount = 0;\r\n\r\n        /**\r\n         * The total number of vertices that this pipeline batch can hold before it will flush.\r\n         *\r\n         * This defaults to `renderer batchSize * 6`, where `batchSize` is defined in the Renderer Game Config.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexCapacity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexCapacity = 0;\r\n\r\n        /**\r\n         * Raw byte buffer of vertices.\r\n         *\r\n         * Either set via the config object `vertices` property, or generates a new Array Buffer of\r\n         * size `vertexCapacity * vertexSize`.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexData;\r\n\r\n        /**\r\n         * The WebGLBuffer that holds the vertex data.\r\n         *\r\n         * Created from the `vertexData` ArrayBuffer. If `vertices` are set in the config, a `STATIC_DRAW` buffer\r\n         * is created. If not, a `DYNAMIC_DRAW` buffer is created.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexBuffer;\r\n\r\n        /**\r\n         * The primitive topology which the pipeline will use to submit draw calls.\r\n         *\r\n         * Defaults to GL_TRIANGLES if not otherwise set in the config.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#topology\r\n         * @type {GLenum}\r\n         * @since 3.0.0\r\n         */\r\n        this.topology = GetFastValue(config, 'topology', gl.TRIANGLES);\r\n\r\n        /**\r\n         * Uint8 view to the `vertexData` ArrayBuffer. Used for uploading vertex buffer resources to the GPU.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.bytes;\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the pipeline's vertices.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexViewF32;\r\n\r\n        /**\r\n         * Uint32 view of the array buffer containing the pipeline's vertices.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#vertexViewU32\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.vertexViewU32;\r\n\r\n        /**\r\n         * Indicates if the current pipeline is active, or not.\r\n         *\r\n         * Toggle this property to enable or disable a pipeline from rendering anything.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#active\r\n         * @type {boolean}\r\n         * @since 3.10.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Holds the most recently assigned texture unit.\r\n         *\r\n         * Treat this value as read-only.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#currentUnit\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.currentUnit = 0;\r\n\r\n        /**\r\n         * Some pipelines require the forced use of texture zero (like the light pipeline).\r\n         *\r\n         * This property should be set when that is the case.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#forceZero\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.forceZero = GetFastValue(config, 'forceZero', false);\r\n\r\n        /**\r\n         * Indicates if this pipeline has booted or not.\r\n         *\r\n         * A pipeline boots only when the Game instance itself, and all associated systems, is\r\n         * fully ready.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#hasBooted\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.hasBooted = false;\r\n\r\n        /**\r\n         * Indicates if this is a Post FX Pipeline, or not.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#isPostFX\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.isPostFX = false;\r\n\r\n        /**\r\n         * An array of RenderTarget instances that belong to this pipeline.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#renderTargets\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderTargets = [];\r\n\r\n        /**\r\n         * A reference to the currently bound Render Target instance from the `WebGLPipeline.renderTargets` array.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#currentRenderTarget\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.currentRenderTarget;\r\n\r\n        /**\r\n         * An array of all the WebGLShader instances that belong to this pipeline.\r\n         *\r\n         * Shaders manage their own attributes and uniforms, but share the same vertex data buffer,\r\n         * which belongs to this pipeline.\r\n         *\r\n         * Shaders are set in a call to the `setShadersFromConfig` method, which happens automatically,\r\n         * but can also be called at any point in your game. See the method documentation for details.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#shaders\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.shaders = [];\r\n\r\n        /**\r\n         * A reference to the currently bound WebGLShader instance from the `WebGLPipeline.shaders` array.\r\n         *\r\n         * For lots of pipelines, this is the only shader, so it is a quick way to reference it without\r\n         * an array look-up.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#currentShader\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader}\r\n         * @since 3.50.0\r\n         */\r\n        this.currentShader;\r\n\r\n        /**\r\n         * The Projection matrix, used by shaders as 'uProjectionMatrix' uniform.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#projectionMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionMatrix;\r\n\r\n        /**\r\n         * The cached width of the Projection matrix.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#projectionWidth\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionWidth = 0;\r\n\r\n        /**\r\n         * The cached height of the Projection matrix.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#projectionHeight\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionHeight = 0;\r\n\r\n        /**\r\n         * The configuration object that was used to create this pipeline.\r\n         *\r\n         * Treat this object as 'read only', because changing it post-creation will not\r\n         * impact this pipeline in any way. However, it is used internally for cloning\r\n         * and post-boot set-up.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#config\r\n         * @type {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig}\r\n         * @since 3.50.0\r\n         */\r\n        this.config = config;\r\n\r\n        /**\r\n         * Has the GL Context been reset to the Phaser defaults since the last time\r\n         * this pipeline was bound? This is set automatically when the Pipeline Manager\r\n         * resets itself, usually after handing off to a 3rd party renderer like Spine.\r\n         *\r\n         * You should treat this property as read-only.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLPipeline#glReset\r\n         * @type {boolean}\r\n         * @since 3.53.0\r\n         */\r\n        this.glReset = false;\r\n    },\r\n\r\n    /**\r\n     * Called when the Game has fully booted and the Renderer has finished setting up.\r\n     *\r\n     * By this stage all Game level systems are now in place. You can perform any final tasks that the\r\n     * pipeline may need, that relies on game systems such as the Texture Manager being ready.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#boot\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#BOOT\r\n     * @since 3.11.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var i;\r\n        var gl = this.gl;\r\n        var config = this.config;\r\n        var renderer = this.renderer;\r\n\r\n        if (!this.isPostFX)\r\n        {\r\n            this.projectionMatrix = new Matrix4().identity();\r\n        }\r\n\r\n        //  Create the Render Targets\r\n\r\n        var renderTargets = this.renderTargets;\r\n\r\n        var targets = GetFastValue(config, 'renderTarget', false);\r\n\r\n        //  If boolean, set to number = 1\r\n        if (typeof(targets) === 'boolean' && targets)\r\n        {\r\n            targets = 1;\r\n        }\r\n\r\n        var width = renderer.width;\r\n        var height = renderer.height;\r\n\r\n        if (typeof(targets) === 'number')\r\n        {\r\n            //  Create this many default RTs\r\n            for (i = 0; i < targets; i++)\r\n            {\r\n                renderTargets.push(new RenderTarget(renderer, width, height, 1, 0, true));\r\n            }\r\n        }\r\n        else if (Array.isArray(targets))\r\n        {\r\n            for (i = 0; i < targets.length; i++)\r\n            {\r\n                var scale = GetFastValue(targets[i], 'scale', 1);\r\n                var minFilter = GetFastValue(targets[i], 'minFilter', 0);\r\n                var autoClear = GetFastValue(targets[i], 'autoClear', 1);\r\n\r\n                renderTargets.push(new RenderTarget(renderer, width, height, scale, minFilter, autoClear));\r\n            }\r\n        }\r\n\r\n        if (renderTargets.length)\r\n        {\r\n            //  Default to the first one in the array\r\n            this.currentRenderTarget = renderTargets[0];\r\n        }\r\n\r\n        //  Create the Shaders\r\n\r\n        this.setShadersFromConfig(config);\r\n\r\n        //  Which shader has the largest vertex size?\r\n        var shaders = this.shaders;\r\n        var vertexSize = 0;\r\n\r\n        for (i = 0; i < shaders.length; i++)\r\n        {\r\n            if (shaders[i].vertexSize > vertexSize)\r\n            {\r\n                vertexSize = shaders[i].vertexSize;\r\n            }\r\n        }\r\n\r\n        var batchSize = GetFastValue(config, 'batchSize', renderer.config.batchSize);\r\n\r\n        //  * 6 because there are 6 vertices in a quad and 'batchSize' represents the quantity of quads in the batch\r\n\r\n        this.vertexCapacity = batchSize * 6;\r\n\r\n        var data = new ArrayBuffer(this.vertexCapacity * vertexSize);\r\n\r\n        this.vertexData = data;\r\n        this.bytes = new Uint8Array(data);\r\n        this.vertexViewF32 = new Float32Array(data);\r\n        this.vertexViewU32 = new Uint32Array(data);\r\n\r\n        var configVerts = GetFastValue(config, 'vertices', null);\r\n\r\n        if (configVerts)\r\n        {\r\n            this.vertexViewF32.set(configVerts);\r\n\r\n            this.vertexBuffer = renderer.createVertexBuffer(data, gl.STATIC_DRAW);\r\n        }\r\n        else\r\n        {\r\n            this.vertexBuffer = renderer.createVertexBuffer(data.byteLength, gl.DYNAMIC_DRAW);\r\n        }\r\n\r\n        //  Set-up shaders\r\n\r\n        this.setVertexBuffer();\r\n\r\n        for (i = shaders.length - 1; i >= 0; i--)\r\n        {\r\n            shaders[i].rebind();\r\n        }\r\n\r\n        this.hasBooted = true;\r\n\r\n        renderer.on(RendererEvents.RESIZE, this.resize, this);\r\n        renderer.on(RendererEvents.PRE_RENDER, this.onPreRender, this);\r\n        renderer.on(RendererEvents.RENDER, this.onRender, this);\r\n        renderer.on(RendererEvents.POST_RENDER, this.onPostRender, this);\r\n\r\n        this.emit(Events.BOOT, this);\r\n\r\n        this.onBoot();\r\n    },\r\n\r\n    /**\r\n     * This method is called once when this pipeline has finished being set-up\r\n     * at the end of the boot process. By the time this method is called, all\r\n     * of the shaders are ready and configured.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBoot\r\n     * @since 3.50.0\r\n     */\r\n    onBoot: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * This method is called once when this pipeline has finished being set-up\r\n     * at the end of the boot process. By the time this method is called, all\r\n     * of the shaders are ready and configured. It's also called if the renderer\r\n     * changes size.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onResize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} width - The new width of this WebGL Pipeline.\r\n     * @param {number} height - The new height of this WebGL Pipeline.\r\n     */\r\n    onResize: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Sets the currently active shader within this pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setShader\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} shader - The shader to set as being current.\r\n     * @param {boolean} [setAttributes=false] - Should the vertex attribute pointers be set?\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setShader: function (shader, setAttributes)\r\n    {\r\n        var renderer = this.renderer;\r\n\r\n        if (shader !== this.currentShader || renderer.currentProgram !== this.currentShader.program)\r\n        {\r\n            this.flush();\r\n\r\n            renderer.resetTextures();\r\n\r\n            var wasBound = this.setVertexBuffer();\r\n\r\n            if (wasBound && !setAttributes)\r\n            {\r\n                setAttributes = true;\r\n            }\r\n\r\n            shader.bind(setAttributes, false);\r\n\r\n            this.currentShader = shader;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Searches all shaders in this pipeline for one matching the given name, then returns it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#getShaderByName\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The index of the shader to set.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLShader} The WebGLShader instance, if found.\r\n     */\r\n    getShaderByName: function (name)\r\n    {\r\n        var shaders = this.shaders;\r\n\r\n        for (var i = 0; i < shaders.length; i++)\r\n        {\r\n            if (shaders[i].name === name)\r\n            {\r\n                return shaders[i];\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys all shaders currently set in the `WebGLPipeline.shaders` array and then parses the given\r\n     * `config` object, extracting the shaders from it, creating `WebGLShader` instances and finally\r\n     * setting them into the `shaders` array of this pipeline.\r\n     *\r\n     * This is a destructive process. Be very careful when you call it, should you need to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setShadersFromConfig\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration object for this WebGL Pipeline.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setShadersFromConfig: function (config)\r\n    {\r\n        var i;\r\n        var shaders = this.shaders;\r\n        var renderer = this.renderer;\r\n\r\n        for (i = 0; i < shaders.length; i++)\r\n        {\r\n            shaders[i].destroy();\r\n        }\r\n\r\n        var vName = 'vertShader';\r\n        var fName = 'fragShader';\r\n        var aName = 'attributes';\r\n\r\n        var defaultVertShader = GetFastValue(config, vName, null);\r\n        var defaultFragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(config, fName, null), renderer.maxTextures);\r\n        var defaultAttribs = GetFastValue(config, aName, null);\r\n\r\n        var configShaders = GetFastValue(config, 'shaders', []);\r\n\r\n        var len = configShaders.length;\r\n\r\n        if (len === 0)\r\n        {\r\n            if (defaultVertShader && defaultFragShader)\r\n            {\r\n                this.shaders = [ new WebGLShader(this, 'default', defaultVertShader, defaultFragShader, DeepCopy(defaultAttribs)) ];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var newShaders = [];\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                var shaderEntry = configShaders[i];\r\n\r\n                var name = GetFastValue(shaderEntry, 'name', 'default');\r\n\r\n                var vertShader = GetFastValue(shaderEntry, vName, defaultVertShader);\r\n                var fragShader = Utils.parseFragmentShaderMaxTextures(GetFastValue(shaderEntry, fName, defaultFragShader), renderer.maxTextures);\r\n                var attributes = GetFastValue(shaderEntry, aName, defaultAttribs);\r\n\r\n                if (vertShader && fragShader)\r\n                {\r\n                    newShaders.push(new WebGLShader(this, name, vertShader, fragShader, DeepCopy(attributes)));\r\n                }\r\n            }\r\n\r\n            this.shaders = newShaders;\r\n        }\r\n\r\n        if (this.shaders.length === 0)\r\n        {\r\n            console.warn('Pipeline: ' + this.name + ' - Invalid shader config');\r\n        }\r\n        else\r\n        {\r\n            this.currentShader = this.shaders[0];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Custom pipelines can use this method in order to perform any required pre-batch tasks\r\n     * for the given Game Object. It must return the texture unit the Game Object was assigned.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setGameObject\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object being rendered or added to the batch.\r\n     * @param {Phaser.Textures.Frame} [frame] - Optional frame to use. Can override that of the Game Object.\r\n     *\r\n     * @return {number} The texture unit the Game Object has been assigned.\r\n     */\r\n    setGameObject: function (gameObject, frame)\r\n    {\r\n        if (frame === undefined) { frame = gameObject.frame; }\r\n\r\n        this.currentUnit = this.renderer.setTextureSource(frame.source);\r\n\r\n        return this.currentUnit;\r\n    },\r\n\r\n    /**\r\n     * Check if the current batch of vertices is full.\r\n     *\r\n     * You can optionally provide an `amount` parameter. If given, it will check if the batch\r\n     * needs to flush _if_ the `amount` is added to it. This allows you to test if you should\r\n     * flush before populating the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#shouldFlush\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [amount=0] - Will the batch need to flush if this many vertices are added to it?\r\n     *\r\n     * @return {boolean} `true` if the current batch should be flushed, otherwise `false`.\r\n     */\r\n    shouldFlush: function (amount)\r\n    {\r\n        if (amount === undefined) { amount = 0; }\r\n\r\n        return (this.vertexCount + amount > this.vertexCapacity);\r\n    },\r\n\r\n    /**\r\n     * Resizes the properties used to describe the viewport.\r\n     *\r\n     * This method is called automatically by the renderer during its resize handler.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#resize\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#RESIZE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The new width of this WebGL Pipeline.\r\n     * @param {number} height - The new height of this WebGL Pipeline.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            this.flush();\r\n        }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        var targets = this.renderTargets;\r\n\r\n        for (var i = 0; i < targets.length; i++)\r\n        {\r\n            targets[i].resize(width, height);\r\n        }\r\n\r\n        this.setProjectionMatrix(width, height);\r\n\r\n        this.emit(Events.RESIZE, width, height, this);\r\n\r\n        this.onResize(width, height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adjusts this pipelines ortho Projection Matrix to use the given dimensions\r\n     * and resets the `uProjectionMatrix` uniform on all bound shaders.\r\n     *\r\n     * This method is called automatically by the renderer during its resize handler.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setProjectionMatrix\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} width - The new width of this WebGL Pipeline.\r\n     * @param {number} height - The new height of this WebGL Pipeline.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setProjectionMatrix: function (width, height)\r\n    {\r\n        var projectionMatrix = this.projectionMatrix;\r\n\r\n        //  Because not all pipelines have them\r\n        if (!projectionMatrix)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.projectionWidth = width;\r\n        this.projectionHeight = height;\r\n\r\n        projectionMatrix.ortho(0, width, height, 0, -1000, 1000);\r\n\r\n        var shaders = this.shaders;\r\n\r\n        var name = 'uProjectionMatrix';\r\n\r\n        for (var i = 0; i < shaders.length; i++)\r\n        {\r\n            var shader = shaders[i];\r\n\r\n            if (shader.hasUniform(name))\r\n            {\r\n                shader.resetUniform(name);\r\n\r\n                shader.setMatrix4fv(name, false, projectionMatrix.val, shader);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adjusts this pipelines ortho Projection Matrix to match that of the global\r\n     * WebGL Renderer Projection Matrix.\r\n     *\r\n     * This method is called automatically by the Pipeline Manager when this\r\n     * pipeline is set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#updateProjectionMatrix\r\n     * @since 3.50.0\r\n     */\r\n    updateProjectionMatrix: function ()\r\n    {\r\n        if (this.projectionMatrix)\r\n        {\r\n            var globalWidth = this.renderer.projectionWidth;\r\n            var globalHeight = this.renderer.projectionHeight;\r\n\r\n            if (this.projectionWidth !== globalWidth || this.projectionHeight !== globalHeight)\r\n            {\r\n                this.setProjectionMatrix(globalWidth, globalHeight);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This method is called every time the Pipeline Manager makes this pipeline the currently active one.\r\n     *\r\n     * It binds the resources and shader needed for this pipeline, including setting the vertex buffer\r\n     * and attribute pointers.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#bind\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#BIND\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to set as being current.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    bind: function (currentShader)\r\n    {\r\n        if (currentShader === undefined) { currentShader = this.currentShader; }\r\n\r\n        if (this.glReset)\r\n        {\r\n            return this.rebind(currentShader);\r\n        }\r\n\r\n        var wasBound = this.setVertexBuffer();\r\n\r\n        currentShader.bind(wasBound);\r\n\r\n        this.currentShader = currentShader;\r\n\r\n        this.emit(Events.BIND, this, currentShader);\r\n\r\n        this.onActive(currentShader);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is called every time the Pipeline Manager rebinds this pipeline.\r\n     *\r\n     * It resets all shaders this pipeline uses, setting their attributes again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#rebind\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#REBIND\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to set as being current.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    rebind: function (currentShader)\r\n    {\r\n        this.setVertexBuffer();\r\n\r\n        var shaders = this.shaders;\r\n\r\n        //  Loop in reverse, so the first shader in the array is left as being bound\r\n        for (var i = shaders.length - 1; i >= 0; i--)\r\n        {\r\n            var shader = shaders[i].rebind();\r\n\r\n            if (!currentShader || shader === currentShader)\r\n            {\r\n                this.currentShader = shader;\r\n            }\r\n        }\r\n\r\n        this.emit(Events.REBIND, this.currentShader);\r\n\r\n        this.onActive(this.currentShader);\r\n\r\n        this.onRebind();\r\n\r\n        this.glReset = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds the vertex buffer to be the active ARRAY_BUFFER on the WebGL context.\r\n     *\r\n     * It first checks to see if it's already set as the active buffer and only\r\n     * binds itself if not.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setVertexBuffer\r\n     * @since 3.50.0\r\n     *\r\n     * @return {boolean} `true` if the vertex buffer was bound, or `false` if it was already bound.\r\n     */\r\n    setVertexBuffer: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var buffer = this.vertexBuffer;\r\n\r\n        if (gl.getParameter(gl.ARRAY_BUFFER_BINDING) !== buffer)\r\n        {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * This method is called as a result of the `WebGLPipeline.batchQuad` method, right before a quad\r\n     * belonging to a Game Object is about to be added to the batch. When this is called, the\r\n     * renderer has just performed a flush. It will bind the current render target, if any are set\r\n     * and finally call the `onPreBatch` hook.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#preBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.Cameras.Scene2D.Camera)} [gameObject] - The Game Object or Camera that invoked this pipeline, if any.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    preBatch: function (gameObject)\r\n    {\r\n        if (this.currentRenderTarget)\r\n        {\r\n            this.currentRenderTarget.bind();\r\n        }\r\n\r\n        this.onPreBatch(gameObject);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is called as a result of the `WebGLPipeline.batchQuad` method, right after a quad\r\n     * belonging to a Game Object has been added to the batch. When this is called, the\r\n     * renderer has just performed a flush.\r\n     *\r\n     * It calls the `onDraw` hook followed by the `onPostBatch` hook, which can be used to perform\r\n     * additional Post FX Pipeline processing.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#postBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.Cameras.Scene2D.Camera)} [gameObject] - The Game Object or Camera that invoked this pipeline, if any.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    postBatch: function (gameObject)\r\n    {\r\n        this.onDraw(this.currentRenderTarget);\r\n\r\n        this.onPostBatch(gameObject);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method is only used by Post FX Pipelines and those that extend from them.\r\n     *\r\n     * This method is called every time the `postBatch` method is called and is passed a\r\n     * reference to the current render target.\r\n     *\r\n     * At the very least a Post FX Pipeline should call `this.bindAndDraw(renderTarget)`,\r\n     * however, you can do as much additional processing as you like in this method if\r\n     * you override it from within your own pipelines.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} renderTarget - The Render Target.\r\n     */\r\n    onDraw: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * This method is called every time the Pipeline Manager deactivates this pipeline, swapping from\r\n     * it to another one. This happens after a call to `flush` and before the new pipeline is bound.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#unbind\r\n     * @since 3.50.0\r\n     */\r\n    unbind: function ()\r\n    {\r\n        if (this.currentRenderTarget)\r\n        {\r\n            this.currentRenderTarget.unbind();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Uploads the vertex data and emits a draw call for the current batch of vertices.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#flush\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#BEFORE_FLUSH\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#AFTER_FLUSH\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [isPostFlush=false] - Was this flush invoked as part of a post-process, or not?\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    flush: function (isPostFlush)\r\n    {\r\n        if (isPostFlush === undefined) { isPostFlush = false; }\r\n\r\n        if (this.vertexCount > 0)\r\n        {\r\n            this.emit(Events.BEFORE_FLUSH, this, isPostFlush);\r\n\r\n            this.onBeforeFlush(isPostFlush);\r\n\r\n            var gl = this.gl;\r\n            var vertexCount = this.vertexCount;\r\n            var vertexSize = this.currentShader.vertexSize;\r\n\r\n            if (this.active)\r\n            {\r\n                this.setVertexBuffer();\r\n\r\n                if (vertexCount === this.vertexCapacity)\r\n                {\r\n                    gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.DYNAMIC_DRAW);\r\n                }\r\n                else\r\n                {\r\n                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\r\n                }\r\n\r\n                gl.drawArrays(this.topology, 0, vertexCount);\r\n            }\r\n\r\n            this.vertexCount = 0;\r\n\r\n            this.emit(Events.AFTER_FLUSH, this, isPostFlush);\r\n\r\n            this.onAfterFlush(isPostFlush);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called every time the Pipeline Manager makes this the active pipeline. It is called\r\n     * at the end of the `WebGLPipeline.bind` method, after the current shader has been set. The current\r\n     * shader is passed to this hook.\r\n     *\r\n     * For example, if a display list has 3 Sprites in it that all use the same pipeline, this hook will\r\n     * only be called for the first one, as the 2nd and 3rd Sprites do not cause the pipeline to be changed.\r\n     *\r\n     * If you need to listen for that event instead, use the `onBind` hook.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onActive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} currentShader - The shader that was set as current.\r\n     */\r\n    onActive: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called every time a **Game Object** asks the Pipeline Manager to use this pipeline,\r\n     * even if the pipeline is already active.\r\n     *\r\n     * Unlike the `onActive` method, which is only called when the Pipeline Manager makes this pipeline\r\n     * active, this hook is called for every Game Object that requests use of this pipeline, allowing you to\r\n     * perform per-object set-up, such as loading shader uniform data.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBind\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     */\r\n    onBind: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called when the Pipeline Manager needs to rebind this pipeline. This happens after a\r\n     * pipeline has been cleared, usually when passing control over to a 3rd party WebGL library, like Spine,\r\n     * and then returing to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onRebind\r\n     * @since 3.50.0\r\n     */\r\n    onRebind: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called every time the `batchQuad` or `batchTri` methods are called. If this was\r\n     * as a result of a Game Object, then the Game Object reference is passed to this hook too.\r\n     *\r\n     * This hook is called _after_ the quad (or tri) has been added to the batch, so you can safely\r\n     * call 'flush' from within this.\r\n     *\r\n     * Note that Game Objects may call `batchQuad` or `batchTri` multiple times for a single draw,\r\n     * for example the Graphics Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     */\r\n    onBatch: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called immediately before a **Game Object** is about to add itself to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPreBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     */\r\n    onPreBatch: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called immediately after a **Game Object** has been added to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPostBatch\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     */\r\n    onPostBatch: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called once per frame, right before anything has been rendered, but after the canvas\r\n     * has been cleared. If this pipeline has a render target, it will also have been cleared by this point.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPreRender\r\n     * @since 3.50.0\r\n     */\r\n    onPreRender: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called _once per frame_, by every Camera in a Scene that wants to render.\r\n     *\r\n     * It is called at the start of the rendering process, before anything has been drawn to the Camera.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onRender\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered with.\r\n     */\r\n    onRender: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called _once per frame_, after all rendering has happened and snapshots have been taken.\r\n     *\r\n     * It is called at the very end of the rendering process, once all Cameras, for all Scenes, have\r\n     * been rendered.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onPostRender\r\n     * @since 3.50.0\r\n     */\r\n    onPostRender: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called every time this pipeline is asked to flush its batch.\r\n     *\r\n     * It is called immediately before the `gl.bufferData` and `gl.drawArrays` calls are made, so you can\r\n     * perform any final pre-render modifications. To apply changes post-render, see `onAfterFlush`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onBeforeFlush\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [isPostFlush=false] - Was this flush invoked as part of a post-process, or not?\r\n     */\r\n    onBeforeFlush: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * By default this is an empty method hook that you can override and use in your own custom pipelines.\r\n     *\r\n     * This method is called immediately after this pipeline has finished flushing its batch.\r\n     *\r\n     * It is called after the `gl.drawArrays` call.\r\n     *\r\n     * You can perform additional post-render effects, but be careful not to call `flush`\r\n     * on this pipeline from within this method, or you'll cause an infinite loop.\r\n     *\r\n     * To apply changes pre-render, see `onBeforeFlush`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#onAfterFlush\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [isPostFlush=false] - Was this flush invoked as part of a post-process, or not?\r\n     */\r\n    onAfterFlush: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Adds a single vertex to the current vertex buffer and increments the\r\n     * `vertexCount` property by 1.\r\n     *\r\n     * This method is called directly by `batchTri` and `batchQuad`.\r\n     *\r\n     * It does not perform any batch limit checking itself, so if you need to call\r\n     * this method directly, do so in the same way that `batchQuad` does, for example.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#batchVert\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The vertex x position.\r\n     * @param {number} y - The vertex y position.\r\n     * @param {number} u - UV u value.\r\n     * @param {number} v - UV v value.\r\n     * @param {number} unit - Texture unit to which the texture needs to be bound.\r\n     * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.\r\n     * @param {number} tint - The tint color value.\r\n     */\r\n    batchVert: function (x, y, u, v, unit, tintEffect, tint)\r\n    {\r\n        var vertexViewF32 = this.vertexViewF32;\r\n        var vertexViewU32 = this.vertexViewU32;\r\n\r\n        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;\r\n\r\n        vertexViewF32[++vertexOffset] = x;\r\n        vertexViewF32[++vertexOffset] = y;\r\n        vertexViewF32[++vertexOffset] = u;\r\n        vertexViewF32[++vertexOffset] = v;\r\n        vertexViewF32[++vertexOffset] = unit;\r\n        vertexViewF32[++vertexOffset] = tintEffect;\r\n        vertexViewU32[++vertexOffset] = tint;\r\n\r\n        this.vertexCount++;\r\n    },\r\n\r\n    /**\r\n     * Adds the vertices data into the batch and flushes if full.\r\n     *\r\n     * Assumes 6 vertices in the following arrangement:\r\n     *\r\n     * ```\r\n     * 0----3\r\n     * |\\  B|\r\n     * | \\  |\r\n     * |  \\ |\r\n     * | A \\|\r\n     * |    \\\r\n     * 1----2\r\n     * ```\r\n     *\r\n     * Where tx0/ty0 = 0, tx1/ty1 = 1, tx2/ty2 = 2 and tx3/ty3 = 3\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#batchQuad\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|null)} gameObject - The Game Object, if any, drawing this quad.\r\n     * @param {number} x0 - The top-left x position.\r\n     * @param {number} y0 - The top-left y position.\r\n     * @param {number} x1 - The bottom-left x position.\r\n     * @param {number} y1 - The bottom-left y position.\r\n     * @param {number} x2 - The bottom-right x position.\r\n     * @param {number} y2 - The bottom-right y position.\r\n     * @param {number} x3 - The top-right x position.\r\n     * @param {number} y3 - The top-right y position.\r\n     * @param {number} u0 - UV u0 value.\r\n     * @param {number} v0 - UV v0 value.\r\n     * @param {number} u1 - UV u1 value.\r\n     * @param {number} v1 - UV v1 value.\r\n     * @param {number} tintTL - The top-left tint color value.\r\n     * @param {number} tintTR - The top-right tint color value.\r\n     * @param {number} tintBL - The bottom-left tint color value.\r\n     * @param {number} tintBR - The bottom-right tint color value.\r\n     * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.\r\n     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.\r\n     * @param {number} [unit=0] - Texture unit to which the texture needs to be bound.\r\n     *\r\n     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n     */\r\n    batchQuad: function (gameObject, x0, y0, x1, y1, x2, y2, x3, y3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, unit)\r\n    {\r\n        if (unit === undefined) { unit = this.currentUnit; }\r\n\r\n        var hasFlushed = false;\r\n\r\n        if (this.shouldFlush(6))\r\n        {\r\n            this.flush();\r\n\r\n            hasFlushed = true;\r\n\r\n            unit = this.setTexture2D(texture);\r\n        }\r\n\r\n        this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);\r\n        this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintBL);\r\n        this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);\r\n        this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);\r\n        this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBR);\r\n        this.batchVert(x3, y3, u1, v0, unit, tintEffect, tintTR);\r\n\r\n        this.onBatch(gameObject);\r\n\r\n        return hasFlushed;\r\n    },\r\n\r\n    /**\r\n     * Adds the vertices data into the batch and flushes if full.\r\n     *\r\n     * Assumes 3 vertices in the following arrangement:\r\n     *\r\n     * ```\r\n     * 0\r\n     * |\\\r\n     * | \\\r\n     * |  \\\r\n     * |   \\\r\n     * |    \\\r\n     * 1-----2\r\n     * ```\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#batchTri\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|null)} gameObject - The Game Object, if any, drawing this quad.\r\n     * @param {number} x1 - The bottom-left x position.\r\n     * @param {number} y1 - The bottom-left y position.\r\n     * @param {number} x2 - The bottom-right x position.\r\n     * @param {number} y2 - The bottom-right y position.\r\n     * @param {number} x3 - The top-right x position.\r\n     * @param {number} y3 - The top-right y position.\r\n     * @param {number} u0 - UV u0 value.\r\n     * @param {number} v0 - UV v0 value.\r\n     * @param {number} u1 - UV u1 value.\r\n     * @param {number} v1 - UV v1 value.\r\n     * @param {number} tintTL - The top-left tint color value.\r\n     * @param {number} tintTR - The top-right tint color value.\r\n     * @param {number} tintBL - The bottom-left tint color value.\r\n     * @param {(number|boolean)} tintEffect - The tint effect for the shader to use.\r\n     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.\r\n     * @param {number} [unit=0] - Texture unit to which the texture needs to be bound.\r\n     *\r\n     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n     */\r\n    batchTri: function (gameObject, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintEffect, texture, unit)\r\n    {\r\n        if (unit === undefined) { unit = this.currentUnit; }\r\n\r\n        var hasFlushed = false;\r\n\r\n        if (this.shouldFlush(3))\r\n        {\r\n            this.flush();\r\n\r\n            hasFlushed = true;\r\n\r\n            unit = this.setTexture2D(texture);\r\n        }\r\n\r\n        this.batchVert(x0, y0, u0, v0, unit, tintEffect, tintTL);\r\n        this.batchVert(x1, y1, u0, v1, unit, tintEffect, tintTR);\r\n        this.batchVert(x2, y2, u1, v1, unit, tintEffect, tintBL);\r\n\r\n        this.onBatch(gameObject);\r\n\r\n        return hasFlushed;\r\n    },\r\n\r\n    /**\r\n     * Pushes a filled rectangle into the vertex batch.\r\n     *\r\n     * The dimensions are run through `Math.floor` before the quad is generated.\r\n     *\r\n     * Rectangle has no transform values and isn't transformed into the local space.\r\n     *\r\n     * Used for directly batching untransformed rectangles, such as Camera background colors.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#drawFillRect\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - Horizontal top left coordinate of the rectangle.\r\n     * @param {number} y - Vertical top left coordinate of the rectangle.\r\n     * @param {number} width - Width of the rectangle.\r\n     * @param {number} height - Height of the rectangle.\r\n     * @param {number} color - Color of the rectangle to draw.\r\n     * @param {number} alpha - Alpha value of the rectangle to draw.\r\n     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch if a flush occurs.\r\n     * @param {boolean} [flipUV=true] - Flip the vertical UV coordinates of the texture before rendering?\r\n     */\r\n    drawFillRect: function (x, y, width, height, color, alpha, texture, flipUV)\r\n    {\r\n        if (texture === undefined) { texture = this.renderer.whiteTexture.glTexture; }\r\n        if (flipUV === undefined) { flipUV = true; }\r\n\r\n        x = Math.floor(x);\r\n        y = Math.floor(y);\r\n\r\n        var xw = Math.floor(x + width);\r\n        var yh = Math.floor(y + height);\r\n\r\n        var unit = this.setTexture2D(texture);\r\n\r\n        var tint = Utils.getTintAppendFloatAlphaAndSwap(color, alpha);\r\n\r\n        var u0 = 0;\r\n        var v0 = 0;\r\n        var u1 = 1;\r\n        var v1 = 1;\r\n\r\n        if (flipUV)\r\n        {\r\n            v0 = 1;\r\n            v1 = 0;\r\n        }\r\n\r\n        this.batchQuad(null, x, y, x, yh, xw, yh, xw, y, u0, v0, u1, v1, tint, tint, tint, tint, 0, texture, unit);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture to be bound to the next available texture unit and returns\r\n     * the unit id.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setTexture2D\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch. If not given uses `whiteTexture`.\r\n     *\r\n     * @return {number} The assigned texture unit.\r\n     */\r\n    setTexture2D: function (texture)\r\n    {\r\n        if (texture === undefined) { texture = this.renderer.whiteTexture.glTexture; }\r\n\r\n        this.currentUnit = this.renderer.setTexture2D(texture);\r\n\r\n        return this.currentUnit;\r\n    },\r\n\r\n    /**\r\n     * Activates the given WebGL Texture and binds it to the requested texture slot.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#bindTexture\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} [target] - The WebGLTexture to activate and bind.\r\n     * @param {number} [unit=0] - The WebGL texture ID to activate. Defaults to `gl.TEXTURE0`.\r\n     *\r\n     * @return {this} This WebGL Pipeline instance.\r\n     */\r\n    bindTexture: function (texture, unit)\r\n    {\r\n        if (unit === undefined) { unit = 0; }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.activeTexture(gl.TEXTURE0 + unit);\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Activates the given Render Target texture and binds it to the\r\n     * requested WebGL texture slot.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#bindRenderTarget\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The Render Target to activate and bind.\r\n     * @param {number} [unit=0] - The WebGL texture ID to activate. Defaults to `gl.TEXTURE0`.\r\n     *\r\n     * @return {this} This WebGL Pipeline instance.\r\n     */\r\n    bindRenderTarget: function (target, unit)\r\n    {\r\n        return this.bindTexture(target.texture, unit);\r\n    },\r\n\r\n    /**\r\n     * Sets the current duration into a 1f uniform value based on the given name.\r\n     *\r\n     * This can be used for mapping time uniform values, such as `iTime`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setTime\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setTime: function (uniform)\r\n    {\r\n        this.set1f(uniform, this.game.loop.getDuration());\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 1f uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set1f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new value of the `float` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set1f: function (name, x, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set1f(name, x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 2f uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set2f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `vec2` uniform.\r\n     * @param {number} y - The new Y component of the `vec2` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set2f: function (name, x, y, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set2f(name, x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 3f uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set3f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `vec3` uniform.\r\n     * @param {number} y - The new Y component of the `vec3` uniform.\r\n     * @param {number} z - The new Z component of the `vec3` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set3f: function (name, x, y, z, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set3f(name, x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 4f uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set4f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - X component of the uniform\r\n     * @param {number} y - Y component of the uniform\r\n     * @param {number} z - Z component of the uniform\r\n     * @param {number} w - W component of the uniform\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set4f: function (name, x, y, z, w, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set4f(name, x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 1fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set1fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set1fv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set1fv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 2fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set2fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set2fv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set2fv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 3fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set3fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set3fv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set3fv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 4fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set4fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set4fv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set4fv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 1iv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set1iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set1iv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set1iv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 2iv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set2iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set2iv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set2iv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 3iv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set3iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set3iv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set3iv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 4iv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set4iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set4iv: function (name, arr, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set4iv(name, arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 1i uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set1i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new value of the `int` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set1i: function (name, x, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set1i(name, x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 2i uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set2i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `ivec2` uniform.\r\n     * @param {number} y - The new Y component of the `ivec2` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set2i: function (name, x, y, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set2i(name, x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 3i uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set3i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `ivec3` uniform.\r\n     * @param {number} y - The new Y component of the `ivec3` uniform.\r\n     * @param {number} z - The new Z component of the `ivec3` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set3i: function (name, x, y, z, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set3i(name, x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 4i uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#set4i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - X component of the uniform.\r\n     * @param {number} y - Y component of the uniform.\r\n     * @param {number} z - Z component of the uniform.\r\n     * @param {number} w - W component of the uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    set4i: function (name, x, y, z, w, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.set4i(name, x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 2fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix2fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.\r\n     * @param {number[]|Float32Array} matrix - The new values for the `mat2` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setMatrix2fv: function (name, transpose, matrix, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.setMatrix2fv(name, transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 3fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix3fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.\r\n     * @param {Float32Array} matrix - The new values for the `mat3` uniform.\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setMatrix3fv: function (name, transpose, matrix, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.setMatrix3fv(name, transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 4fv uniform value based on the given name on the currently set shader.\r\n     *\r\n     * The current shader is bound, before the uniform is set, making it active within the\r\n     * WebGLRenderer. This means you can safely call this method from a location such as\r\n     * a Scene `create` or `update` method. However, when working within a Shader file\r\n     * directly, use the `WebGLShader` method equivalent instead, to avoid the program\r\n     * being set.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#setMatrix4fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Should the matrix be transpose\r\n     * @param {Float32Array} matrix - Matrix data\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [shader] - The shader to set the value on. If not given, the `currentShader` is used.\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    setMatrix4fv: function (name, transpose, matrix, shader)\r\n    {\r\n        if (shader === undefined) { shader = this.currentShader; }\r\n\r\n        shader.setMatrix4fv(name, transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys all shader instances, removes all object references and nulls all external references.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLPipeline#destroy\r\n     * @fires Phaser.Renderer.WebGL.Pipelines.Events#DESTROY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        var i;\r\n\r\n        var shaders = this.shaders;\r\n\r\n        for (i = 0; i < shaders.length; i++)\r\n        {\r\n            shaders[i].destroy();\r\n        }\r\n\r\n        var targets = this.renderTargets;\r\n\r\n        for (i = 0; i < targets.length; i++)\r\n        {\r\n            targets[i].destroy();\r\n        }\r\n\r\n        this.gl.deleteBuffer(this.vertexBuffer);\r\n\r\n        var renderer = this.renderer;\r\n\r\n        renderer.off(RendererEvents.RESIZE, this.resize, this);\r\n        renderer.off(RendererEvents.PRE_RENDER, this.onPreRender, this);\r\n        renderer.off(RendererEvents.RENDER, this.onRender, this);\r\n        renderer.off(RendererEvents.POST_RENDER, this.onPostRender, this);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.game = null;\r\n        this.renderer = null;\r\n        this.manager = null;\r\n        this.gl = null;\r\n        this.view = null;\r\n        this.shaders = null;\r\n        this.renderTargets = null;\r\n        this.bytes = null;\r\n        this.vertexViewF32 = null;\r\n        this.vertexViewU32 = null;\r\n        this.vertexData = null;\r\n        this.vertexBuffer = null;\r\n        this.currentShader = null;\r\n        this.currentRenderTarget = null;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = WebGLPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArrayRemove = require('../../utils/array/Remove');\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('../events');\r\nvar GameEvents = require('../../core/events');\r\nvar IsSizePowerOfTwo = require('../../math/pow2/IsSizePowerOfTwo');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar PipelineManager = require('./PipelineManager');\r\nvar RenderTarget = require('./RenderTarget');\r\nvar ScaleEvents = require('../../scale/events');\r\nvar TextureEvents = require('../../textures/events');\r\nvar Utils = require('./Utils');\r\nvar WebGLSnapshot = require('../snapshot/WebGLSnapshot');\r\n\r\n/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer which owns the context.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * WebGLRenderer is a class that contains the needed functionality to keep the\r\n * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of\r\n * any context change that happens for WebGL rendering inside of Phaser. This means\r\n * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL\r\n * rendering ecosystem they might pollute the current WebGLRenderingContext state producing\r\n * unexpected behavior. It's recommended that WebGL interaction is done through\r\n * WebGLRenderer and/or WebGLPipeline.\r\n *\r\n * @class WebGLRenderer\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance which owns this WebGL Renderer.\r\n */\r\nvar WebGLRenderer = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function WebGLRenderer (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var gameConfig = game.config;\r\n\r\n        var contextCreationConfig = {\r\n            alpha: gameConfig.transparent,\r\n            desynchronized: gameConfig.desynchronized,\r\n            depth: false,\r\n            antialias: gameConfig.antialiasGL,\r\n            premultipliedAlpha: gameConfig.premultipliedAlpha,\r\n            stencil: true,\r\n            failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,\r\n            powerPreference: gameConfig.powerPreference,\r\n            preserveDrawingBuffer: gameConfig.preserveDrawingBuffer\r\n        };\r\n\r\n        /**\r\n         * The local configuration settings of this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: gameConfig.clearBeforeRender,\r\n            antialias: gameConfig.antialias,\r\n            backgroundColor: gameConfig.backgroundColor,\r\n            contextCreation: contextCreationConfig,\r\n            roundPixels: gameConfig.roundPixels,\r\n            maxTextures: gameConfig.maxTextures,\r\n            maxTextureSize: gameConfig.maxTextureSize,\r\n            batchSize: gameConfig.batchSize,\r\n            maxLights: gameConfig.maxLights,\r\n            mipmapFilter: gameConfig.mipmapFilter\r\n        };\r\n\r\n        /**\r\n         * The Game instance which owns this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.WEBGL;\r\n\r\n        /**\r\n         * An instance of the Pipeline Manager class, that handles all WebGL Pipelines.\r\n         *\r\n         * Use this to manage all of your interactions with pipelines, such as adding, getting,\r\n         * setting and rendering them.\r\n         *\r\n         * The Pipeline Manager class is created in the `init` method and then populated\r\n         * with pipelines during the `boot` method.\r\n         *\r\n         * Prior to Phaser v3.50.0 this was just a plain JavaScript object, not a class.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n         * @type {Phaser.Renderer.WebGL.PipelineManager}\r\n         * @since 3.50.0\r\n         */\r\n        this.pipelines = null;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The canvas which this WebGL Renderer draws to.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = game.canvas;\r\n\r\n        /**\r\n         * An array of blend modes supported by the WebGL Renderer.\r\n         *\r\n         * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = [];\r\n\r\n        /**\r\n         * This property is set to `true` if the WebGL context of the renderer is lost.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.contextLost = false;\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         *\r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.0.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92,\r\n            isFramebuffer: false,\r\n            bufferWidth: 0,\r\n            bufferHeight: 0\r\n        };\r\n\r\n        /**\r\n         * Cached value for the last texture unit that was used.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTexture\r\n         * @type {number}\r\n         * @since 3.1.0\r\n         */\r\n        this.currentActiveTexture = 0;\r\n\r\n        /**\r\n         * Contains the current starting active texture unit.\r\n         * This value is constantly updated and should be treated as read-only by your code.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#startActiveTexture\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.startActiveTexture = 0;\r\n\r\n        /**\r\n         * The maximum number of textures the GPU can handle. The minimum under the WebGL1 spec is 8.\r\n         * This is set via the Game Config `maxTextures` property and should never be changed after boot.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maxTextures\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.maxTextures = 0;\r\n\r\n        /**\r\n         * An array of the available WebGL texture units, used to populate the uSampler uniforms.\r\n         *\r\n         * This array is populated during the init phase and should never be changed after boot.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#textureIndexes\r\n         * @type {array}\r\n         * @since 3.50.0\r\n         */\r\n        this.textureIndexes;\r\n\r\n        /**\r\n         * An array of default temporary WebGL Textures.\r\n         *\r\n         * This array is populated during the init phase and should never be changed after boot.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#tempTextures\r\n         * @type {array}\r\n         * @since 3.50.0\r\n         */\r\n        this.tempTextures;\r\n\r\n        /**\r\n         * The currently bound texture at texture unit zero, if any.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#textureZero\r\n         * @type {?WebGLTexture}\r\n         * @since 3.50.0\r\n         */\r\n        this.textureZero;\r\n\r\n        /**\r\n         * The currently bound normal map texture at texture unit one, if any.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#normalTexture\r\n         * @type {?WebGLTexture}\r\n         * @since 3.50.0\r\n         */\r\n        this.normalTexture;\r\n\r\n        /**\r\n         * The currently bound framebuffer in use.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentFramebuffer = null;\r\n\r\n        /**\r\n         * A stack into which the frame buffer objects are pushed and popped.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#fboStack\r\n         * @type {WebGLFramebuffer[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.fboStack = [];\r\n\r\n        /**\r\n         * Current WebGLProgram in use.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n         * @type {WebGLProgram}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentProgram = null;\r\n\r\n        /**\r\n         * Current blend mode in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentBlendMode = Infinity;\r\n\r\n        /**\r\n         * Indicates if the the scissor state is enabled in WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScissorEnabled = false;\r\n\r\n        /**\r\n         * Stores the current scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScissor = null;\r\n\r\n        /**\r\n         * Stack of scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scissorStack = [];\r\n\r\n        /**\r\n         * The handler to invoke when the context is lost.\r\n         * This should not be changed and is set in the boot method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLostHandler\r\n         * @type {function}\r\n         * @since 3.19.0\r\n         */\r\n        this.contextLostHandler = NOOP;\r\n\r\n        /**\r\n         * The handler to invoke when the context is restored.\r\n         * This should not be changed and is set in the boot method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextRestoredHandler\r\n         * @type {function}\r\n         * @since 3.19.0\r\n         */\r\n        this.contextRestoredHandler = NOOP;\r\n\r\n        /**\r\n         * The underlying WebGL context of the renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = null;\r\n\r\n        /**\r\n         * Array of strings that indicate which WebGL extensions are supported by the browser.\r\n         * This is populated in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n         * @type {string[]}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.supportedExtensions = null;\r\n\r\n        /**\r\n         * If the browser supports the `ANGLE_instanced_arrays` extension, this property will hold\r\n         * a reference to the glExtension for it.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#instancedArraysExtension\r\n         * @type {ANGLE_instanced_arrays}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.instancedArraysExtension = null;\r\n\r\n        /**\r\n         * If the browser supports the `OES_vertex_array_object` extension, this property will hold\r\n         * a reference to the glExtension for it.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#vaoExtension\r\n         * @type {OES_vertex_array_object}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.vaoExtension = null;\r\n\r\n        /**\r\n         * The WebGL Extensions loaded into the current context.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.extensions = {};\r\n\r\n        /**\r\n         * Stores the current WebGL component formats for further use.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.2.0\r\n         */\r\n        this.glFormats = [];\r\n\r\n        /**\r\n         * Stores the supported WebGL texture compression formats.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#compression\r\n         * @type {Phaser.Types.Renderer.WebGL.WebGLTextureCompression}\r\n         * @since 3.8.0\r\n         */\r\n        this.compression = {\r\n            ETC1: false,\r\n            PVRTC: false,\r\n            S3TC: false\r\n        };\r\n\r\n        /**\r\n         * Cached drawing buffer height to reduce gl calls.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.drawingBufferHeight = 0;\r\n\r\n        /**\r\n         * A blank 32x32 transparent texture, as used by the Graphics system where needed.\r\n         * This is set in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture\r\n         * @type {WebGLTexture}\r\n         * @readonly\r\n         * @since 3.12.0\r\n         */\r\n        this.blankTexture = null;\r\n\r\n        /**\r\n         * A pure white 4x4 texture, as used by the Graphics system where needed.\r\n         * This is set in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#whiteTexture\r\n         * @type {WebGLTexture}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.whiteTexture = null;\r\n\r\n        /**\r\n         * The total number of masks currently stacked.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskCount\r\n         * @type {number}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskCount = 0;\r\n\r\n        /**\r\n         * The mask stack.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskStack\r\n         * @type {Phaser.Display.Masks.GeometryMask[]}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskStack = [];\r\n\r\n        /**\r\n         * Internal property that tracks the currently set mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal property that tracks the currently set camera mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentCameraMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentCameraMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal gl function mapping for uniform look-up.\r\n         * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFuncMap\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.glFuncMap = null;\r\n\r\n        /**\r\n         * The `type` of the Game Object being currently rendered.\r\n         * This can be used by advanced render functions for batching look-ahead.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentType\r\n         * @type {string}\r\n         * @since 3.19.0\r\n         */\r\n        this.currentType = '';\r\n\r\n        /**\r\n         * Is the `type` of the Game Object being currently rendered different than the\r\n         * type of the object before it in the display list? I.e. it's a 'new' type.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#newType\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.newType = false;\r\n\r\n        /**\r\n         * Does the `type` of the next Game Object in the display list match that\r\n         * of the object being currently rendered?\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#nextTypeMatch\r\n         * @type {boolean}\r\n         * @since 3.19.0\r\n         */\r\n        this.nextTypeMatch = false;\r\n\r\n        /**\r\n         * Is the Game Object being currently rendered the final one in the list?\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#finalType\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.finalType = false;\r\n\r\n        /**\r\n         * The mipmap magFilter to be used when creating textures.\r\n         *\r\n         * You can specify this as a string in the game config, i.e.:\r\n         *\r\n         * `renderer: { mipmapFilter: 'NEAREST_MIPMAP_LINEAR' }`\r\n         *\r\n         * The 6 options for WebGL1 are, in order from least to most computationally expensive:\r\n         *\r\n         * NEAREST (for pixel art)\r\n         * LINEAR (the default)\r\n         * NEAREST_MIPMAP_NEAREST\r\n         * LINEAR_MIPMAP_NEAREST\r\n         * NEAREST_MIPMAP_LINEAR\r\n         * LINEAR_MIPMAP_LINEAR\r\n         *\r\n         * Mipmaps only work with textures that are fully power-of-two in size.\r\n         *\r\n         * For more details see https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#mipmapFilter\r\n         * @type {GLenum}\r\n         * @since 3.21.0\r\n         */\r\n        this.mipmapFilter = null;\r\n\r\n        /**\r\n         * The number of times the renderer had to flush this frame, due to running out of texture units.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#textureFlush\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.textureFlush = 0;\r\n\r\n        /**\r\n         * Are the WebGL Textures in their default state?\r\n         *\r\n         * Used to avoid constant gl binds.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#isTextureClean\r\n         * @type {boolean}\r\n         * @since 3.51.0\r\n         */\r\n        this.isTextureClean = false;\r\n\r\n        /**\r\n         * The default scissor, set during `preRender` and modified during `resize`.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultScissor\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.defaultScissor = [ 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * Has this renderer fully booted yet?\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#isBooted\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        /**\r\n         * A Render Target you can use to capture the current state of the Renderer.\r\n         *\r\n         * A Render Target encapsulates a framebuffer and texture for the WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#renderTarget\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderTarget = null;\r\n\r\n        /**\r\n         * The global game Projection matrix, used by shaders as 'uProjectionMatrix' uniform.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#projectionMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionMatrix;\r\n\r\n        /**\r\n         * The cached width of the Projection matrix.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#projectionWidth\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionWidth = 0;\r\n\r\n        /**\r\n         * The cached height of the Projection matrix.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#projectionHeight\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionHeight = 0;\r\n\r\n        this.init(this.config);\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGLRenderingContext and initializes all internal state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - The configuration object for the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    init: function (config)\r\n    {\r\n        var gl;\r\n        var game = this.game;\r\n        var canvas = this.canvas;\r\n        var clearColor = config.backgroundColor;\r\n\r\n        //  Did they provide their own context?\r\n        if (game.config.context)\r\n        {\r\n            gl = game.config.context;\r\n        }\r\n        else\r\n        {\r\n            gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);\r\n        }\r\n\r\n        if (!gl || gl.isContextLost())\r\n        {\r\n            this.contextLost = true;\r\n\r\n            throw new Error('WebGL unsupported');\r\n        }\r\n\r\n        this.gl = gl;\r\n\r\n        var _this = this;\r\n\r\n        this.contextLostHandler = function (event)\r\n        {\r\n            _this.contextLost = true;\r\n\r\n            _this.game.events.emit(GameEvents.CONTEXT_LOST, _this);\r\n\r\n            event.preventDefault();\r\n        };\r\n\r\n        this.contextRestoredHandler = function ()\r\n        {\r\n            _this.contextLost = false;\r\n\r\n            _this.init(_this.config);\r\n\r\n            _this.game.events.emit(GameEvents.CONTEXT_RESTORED, _this);\r\n        };\r\n\r\n        canvas.addEventListener('webglcontextlost', this.contextLostHandler, false);\r\n        canvas.addEventListener('webglcontextrestored', this.contextRestoredHandler, false);\r\n\r\n        //  Set it back into the Game, so developers can access it from there too\r\n        game.context = gl;\r\n\r\n        for (var i = 0; i <= 27; i++)\r\n        {\r\n            this.blendModes.push({ func: [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_ADD });\r\n        }\r\n\r\n        //  ADD\r\n        this.blendModes[1].func = [ gl.ONE, gl.DST_ALPHA ];\r\n\r\n        //  MULTIPLY\r\n        this.blendModes[2].func = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];\r\n\r\n        //  SCREEN\r\n        this.blendModes[3].func = [ gl.ONE, gl.ONE_MINUS_SRC_COLOR ];\r\n\r\n        //  ERASE\r\n        this.blendModes[17] = { func: [ gl.ZERO, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_REVERSE_SUBTRACT };\r\n\r\n        this.glFormats[0] = gl.BYTE;\r\n        this.glFormats[1] = gl.SHORT;\r\n        this.glFormats[2] = gl.UNSIGNED_BYTE;\r\n        this.glFormats[3] = gl.UNSIGNED_SHORT;\r\n        this.glFormats[4] = gl.FLOAT;\r\n\r\n        //  Set the gl function map\r\n        this.glFuncMap = {\r\n\r\n            mat2: { func: gl.uniformMatrix2fv, length: 1, matrix: true },\r\n            mat3: { func: gl.uniformMatrix3fv, length: 1, matrix: true },\r\n            mat4: { func: gl.uniformMatrix4fv, length: 1, matrix: true },\r\n\r\n            '1f': { func: gl.uniform1f, length: 1 },\r\n            '1fv': { func: gl.uniform1fv, length: 1 },\r\n            '1i': { func: gl.uniform1i, length: 1 },\r\n            '1iv': { func: gl.uniform1iv, length: 1 },\r\n\r\n            '2f': { func: gl.uniform2f, length: 2 },\r\n            '2fv': { func: gl.uniform2fv, length: 1 },\r\n            '2i': { func: gl.uniform2i, length: 2 },\r\n            '2iv': { func: gl.uniform2iv, length: 1 },\r\n\r\n            '3f': { func: gl.uniform3f, length: 3 },\r\n            '3fv': { func: gl.uniform3fv, length: 1 },\r\n            '3i': { func: gl.uniform3i, length: 3 },\r\n            '3iv': { func: gl.uniform3iv, length: 1 },\r\n\r\n            '4f': { func: gl.uniform4f, length: 4 },\r\n            '4fv': { func: gl.uniform4fv, length: 1 },\r\n            '4i': { func: gl.uniform4i, length: 4 },\r\n            '4iv': { func: gl.uniform4iv, length: 1 }\r\n\r\n        };\r\n\r\n        //  Load supported extensions\r\n        var exts = gl.getSupportedExtensions();\r\n\r\n        if (!config.maxTextures || config.maxTextures === -1)\r\n        {\r\n            config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n        }\r\n\r\n        if (!config.maxTextureSize)\r\n        {\r\n            config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n        }\r\n\r\n        var extString = 'WEBGL_compressed_texture_';\r\n        var wkExtString = 'WEBKIT_' + extString;\r\n\r\n        this.compression.ETC1 = gl.getExtension(extString + 'etc1') || gl.getExtension(wkExtString + 'etc1');\r\n        this.compression.PVRTC = gl.getExtension(extString + 'pvrtc') || gl.getExtension(wkExtString + 'pvrtc');\r\n        this.compression.S3TC = gl.getExtension(extString + 's3tc') || gl.getExtension(wkExtString + 's3tc');\r\n\r\n        this.supportedExtensions = exts;\r\n\r\n        var angleString = 'ANGLE_instanced_arrays';\r\n\r\n        this.instancedArraysExtension = (exts.indexOf(angleString) > -1) ? gl.getExtension(angleString) : null;\r\n\r\n        var vaoString = 'OES_vertex_array_object';\r\n\r\n        this.vaoExtension = (exts.indexOf(vaoString) > -1) ? gl.getExtension(vaoString) : null;\r\n\r\n        //  Setup initial WebGL state\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        gl.enable(gl.BLEND);\r\n\r\n        gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n        //  Mipmaps\r\n        this.mipmapFilter = gl[config.mipmapFilter];\r\n\r\n        //  Check maximum supported textures\r\n        this.maxTextures = Utils.checkShaderMax(gl, config.maxTextures);\r\n\r\n        this.textureIndexes = [];\r\n\r\n        //  Create temporary WebGL textures\r\n        var tempTextures = this.tempTextures;\r\n\r\n        if (Array.isArray(tempTextures))\r\n        {\r\n            for (var t = 0; i < this.maxTextures; t++)\r\n            {\r\n                gl.deleteTexture(tempTextures[t]);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            tempTextures = new Array(this.maxTextures);\r\n        }\r\n\r\n        //  Create temp textures to stop WebGL errors on mac os\r\n        for (var index = 0; index < this.maxTextures; index++)\r\n        {\r\n            var tempTexture = gl.createTexture();\r\n\r\n            gl.activeTexture(gl.TEXTURE0 + index);\r\n\r\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([ 0, 0, 255, 255 ]));\r\n\r\n            tempTextures[index] = tempTexture;\r\n\r\n            this.textureIndexes.push(index);\r\n        }\r\n\r\n        this.tempTextures = tempTextures;\r\n\r\n        //  Reset to texture 1 (texture zero is reserved for framebuffers)\r\n        this.currentActiveTexture = 1;\r\n        this.startActiveTexture++;\r\n        gl.activeTexture(gl.TEXTURE1);\r\n\r\n        this.pipelines = new PipelineManager(this);\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        this.projectionMatrix = new Matrix4().identity();\r\n\r\n        game.textures.once(TextureEvents.READY, this.boot, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler. Calls 'boot' on each pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#boot\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.game;\r\n        var pipelineManager = this.pipelines;\r\n\r\n        var baseSize = game.scale.baseSize;\r\n\r\n        this.width = baseSize.width;\r\n        this.height = baseSize.height;\r\n\r\n        this.isBooted = true;\r\n\r\n        this.renderTarget = new RenderTarget(this, this.width, this.height, 1, 0, true, true);\r\n\r\n        //  Set-up pipelines\r\n\r\n        pipelineManager.boot(game.config.pipeline);\r\n\r\n        //  Set-up default textures, fbo and scissor\r\n\r\n        this.blankTexture = game.textures.getFrame('__DEFAULT');\r\n        this.whiteTexture = game.textures.getFrame('__WHITE');\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        game.scale.on(ScaleEvents.RESIZE, this.onResize, this);\r\n\r\n        this.resize(baseSize.width, baseSize.height);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions. The canvas width / height values match this.\r\n     */\r\n    onResize: function (gameSize, baseSize)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Binds the WebGL Renderers Render Target, so all drawn content is now redirected to it.\r\n     *\r\n     * Make sure to call `endCapture` when you are finished.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#beginCapture\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [width] - Optional new width of the Render Target.\r\n     * @param {number} [height] - Optional new height of the Render Target.\r\n     */\r\n    beginCapture: function (width, height)\r\n    {\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        this.renderTarget.bind(true, width, height);\r\n\r\n        this.setProjectionMatrix(width, height);\r\n\r\n        this.resetTextures();\r\n    },\r\n\r\n    /**\r\n     * Unbinds the WebGL Renderers Render Target and returns it, stopping any further content being drawn to it.\r\n     *\r\n     * If the viewport or scissors were modified during the capture, you should reset them by calling\r\n     * `resetViewport` and `resetScissor` accordingly.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#endCapture\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.RenderTarget} A reference to the WebGL Renderer Render Target.\r\n     */\r\n    endCapture: function ()\r\n    {\r\n        this.renderTarget.unbind(true);\r\n\r\n        this.resetProjectionMatrix();\r\n\r\n        return this.renderTarget;\r\n    },\r\n\r\n    /**\r\n     * Resizes the drawing buffer to match that required by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n     * @fires Phaser.Renderer.Events#RESIZE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.setProjectionMatrix(width, height);\r\n\r\n        gl.viewport(0, 0, width, height);\r\n\r\n        this.drawingBufferHeight = gl.drawingBufferHeight;\r\n\r\n        gl.scissor(0, (gl.drawingBufferHeight - height), width, height);\r\n\r\n        this.defaultScissor[2] = width;\r\n        this.defaultScissor[3] = height;\r\n\r\n        this.emit(Events.RESIZE, width, height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the aspect ratio of the WebGLRenderer dimensions.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getAspectRatio\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The aspect ratio of the WebGLRenderer dimensions.\r\n     */\r\n    getAspectRatio: function ()\r\n    {\r\n        return this.width / this.height;\r\n    },\r\n\r\n    /**\r\n     * Sets the Projection Matrix of this renderer to the given dimensions.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProjectionMatrix\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} width - The new width of the Projection Matrix.\r\n     * @param {number} height - The new height of the Projection Matrix.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setProjectionMatrix: function (width, height)\r\n    {\r\n        if (width !== this.projectionWidth || height !== this.projectionHeight)\r\n        {\r\n            this.projectionWidth = width;\r\n            this.projectionHeight = height;\r\n\r\n            this.projectionMatrix.ortho(0, width, height, 0, -1000, 1000);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the Projection Matrix back to this renderers width and height.\r\n     *\r\n     * This is called during `endCapture`, should the matrix have been changed\r\n     * as a result of the capture process.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resetProjectionMatrix\r\n     * @since 3.50.0\r\n     */\r\n    resetProjectionMatrix: function ()\r\n    {\r\n        this.projectionWidth = this.width;\r\n        this.projectionHeight = this.height;\r\n\r\n        this.projectionMatrix.ortho(0, this.width, this.height, 0, -1000, 1000);\r\n    },\r\n\r\n    /**\r\n     * Checks if a WebGL extension is supported\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - Name of the WebGL extension\r\n     *\r\n     * @return {boolean} `true` if the extension is supported, otherwise `false`.\r\n     */\r\n    hasExtension: function (extensionName)\r\n    {\r\n        return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;\r\n    },\r\n\r\n    /**\r\n     * Loads a WebGL extension\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - The name of the extension to load.\r\n     *\r\n     * @return {object} WebGL extension if the extension is supported\r\n     */\r\n    getExtension: function (extensionName)\r\n    {\r\n        if (!this.hasExtension(extensionName)) { return null; }\r\n\r\n        if (!(extensionName in this.extensions))\r\n        {\r\n            this.extensions[extensionName] = this.gl.getExtension(extensionName);\r\n        }\r\n\r\n        return this.extensions[extensionName];\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline if the pipeline is bound\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n     * @since 3.0.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        this.pipelines.flush();\r\n    },\r\n\r\n    /**\r\n     * Pushes a new scissor state. This is used to set nested scissor states.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the scissor.\r\n     * @param {number} y - The y position of the scissor.\r\n     * @param {number} width - The width of the scissor.\r\n     * @param {number} height - The height of the scissor.\r\n     * @param {number} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     *\r\n     * @return {number[]} An array containing the scissor values.\r\n     */\r\n    pushScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }\r\n\r\n        var scissorStack = this.scissorStack;\r\n\r\n        var scissor = [ x, y, width, height ];\r\n\r\n        scissorStack.push(scissor);\r\n\r\n        this.setScissor(x, y, width, height, drawingBufferHeight);\r\n\r\n        this.currentScissor = scissor;\r\n\r\n        return scissor;\r\n    },\r\n\r\n    /**\r\n     * Sets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the scissor.\r\n     * @param {number} y - The y position of the scissor.\r\n     * @param {number} width - The width of the scissor.\r\n     * @param {number} height - The height of the scissor.\r\n     * @param {number} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     */\r\n    setScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var current = this.currentScissor;\r\n\r\n        var setScissor = (width > 0 && height > 0);\r\n\r\n        if (current && setScissor)\r\n        {\r\n            var cx = current[0];\r\n            var cy = current[1];\r\n            var cw = current[2];\r\n            var ch = current[3];\r\n\r\n            setScissor = (cx !== x || cy !== y || cw !== width || ch !== height);\r\n        }\r\n\r\n        if (setScissor)\r\n        {\r\n            this.flush();\r\n\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\r\n            gl.scissor(x, (drawingBufferHeight - y - height), width, height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets the gl scissor state to be whatever the current scissor is, if there is one, without\r\n     * modifying the scissor stack.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resetScissor\r\n     * @since 3.50.0\r\n     */\r\n    resetScissor: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        var current = this.currentScissor;\r\n\r\n        if (current)\r\n        {\r\n            var x = current[0];\r\n            var y = current[1];\r\n            var width = current[2];\r\n            var height = current[3];\r\n\r\n            if (width > 0 && height > 0)\r\n            {\r\n                gl.scissor(x, (this.drawingBufferHeight - y - height), width, height);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Pops the last scissor state and sets it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n     * @since 3.0.0\r\n     */\r\n    popScissor: function ()\r\n    {\r\n        var scissorStack = this.scissorStack;\r\n\r\n        //  Remove the current scissor\r\n        scissorStack.pop();\r\n\r\n        //  Reset the previous scissor\r\n        var scissor = scissorStack[scissorStack.length - 1];\r\n\r\n        if (scissor)\r\n        {\r\n            this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);\r\n        }\r\n\r\n        this.currentScissor = scissor;\r\n    },\r\n\r\n    /**\r\n     * Is there an active stencil mask?\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasActiveStencilMask\r\n     * @since 3.17.0\r\n     *\r\n     * @return {boolean} `true` if there is an active stencil mask, otherwise `false`.\r\n     */\r\n    hasActiveStencilMask: function ()\r\n    {\r\n        var mask = this.currentMask.mask;\r\n        var camMask = this.currentCameraMask.mask;\r\n\r\n        return ((mask && mask.isStencil) || (camMask && camMask.isStencil));\r\n    },\r\n\r\n    /**\r\n     * Resets the gl viewport to the current renderer dimensions.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resetViewport\r\n     * @since 3.50.0\r\n     */\r\n    resetViewport: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.viewport(0, 0, this.width, this.height);\r\n\r\n        this.drawingBufferHeight = gl.drawingBufferHeight;\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode to the value given.\r\n     *\r\n     * If the current blend mode is different from the one given, the pipeline is flushed and the new\r\n     * blend mode is enabled.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.\r\n     * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.\r\n     *\r\n     * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.\r\n     */\r\n    setBlendMode: function (blendModeId, force)\r\n    {\r\n        if (force === undefined) { force = false; }\r\n\r\n        var gl = this.gl;\r\n        var blendMode = this.blendModes[blendModeId];\r\n\r\n        if (force || (blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId))\r\n        {\r\n            this.flush();\r\n\r\n            gl.enable(gl.BLEND);\r\n            gl.blendEquation(blendMode.equation);\r\n\r\n            if (blendMode.func.length > 2)\r\n            {\r\n                gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);\r\n            }\r\n            else\r\n            {\r\n                gl.blendFunc(blendMode.func[0], blendMode.func[1]);\r\n            }\r\n\r\n            this.currentBlendMode = blendModeId;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new custom blend mode for the renderer.\r\n     *\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants#Blending_modes\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {GLenum[]} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.\r\n     * @param {GLenum} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.\r\n     *\r\n     * @return {number} The index of the new blend mode, used for referencing it in the future.\r\n     */\r\n    addBlendMode: function (func, equation)\r\n    {\r\n        var index = this.blendModes.push({ func: func, equation: equation });\r\n\r\n        return index - 1;\r\n    },\r\n\r\n    /**\r\n     * Updates the function bound to a given custom blend mode.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The index of the custom blend mode.\r\n     * @param {function} func - The function to use for the blend mode.\r\n     * @param {function} equation - The equation to use for the blend mode.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    updateBlendMode: function (index, func, equation)\r\n    {\r\n        if (this.blendModes[index])\r\n        {\r\n            this.blendModes[index].func = func;\r\n\r\n            if (equation)\r\n            {\r\n                this.blendModes[index].equation = equation;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a custom blend mode from the renderer.\r\n     * Any Game Objects still using this blend mode will error, so be sure to clear them first.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The index of the custom blend mode to be removed.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    removeBlendMode: function (index)\r\n    {\r\n        if (index > 17 && this.blendModes[index])\r\n        {\r\n            this.blendModes.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current active texture for texture unit zero to be a blank texture.\r\n     * This only happens if there isn't a texture already in use by texture unit zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture\r\n     * @private\r\n     * @since 3.12.0\r\n     */\r\n    setBlankTexture: function ()\r\n    {\r\n        this.setTexture2D(this.blankTexture.glTexture);\r\n    },\r\n\r\n    /**\r\n     * Activates the Texture Source and assigns it the next available texture unit.\r\n     * If none are available, it will flush the current pipeline first.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureSource\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Textures.TextureSource} textureSource - The Texture Source to be assigned the texture unit.\r\n     *\r\n     * @return {number} The texture unit that was assigned to the Texture Source.\r\n     */\r\n    setTextureSource: function (textureSource)\r\n    {\r\n        if (this.pipelines.forceZero())\r\n        {\r\n            this.setTextureZero(textureSource.glTexture, true);\r\n\r\n            return 0;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var currentActiveTexture = this.currentActiveTexture;\r\n\r\n        if (textureSource.glIndexCounter < this.startActiveTexture)\r\n        {\r\n            textureSource.glIndexCounter = this.startActiveTexture;\r\n\r\n            if (currentActiveTexture < this.maxTextures)\r\n            {\r\n                textureSource.glIndex = currentActiveTexture;\r\n\r\n                gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);\r\n                gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);\r\n\r\n                this.currentActiveTexture++;\r\n            }\r\n            else\r\n            {\r\n                //  We're out of textures, so flush the batch and reset back to 0\r\n                this.flush();\r\n\r\n                this.startActiveTexture++;\r\n\r\n                this.textureFlush++;\r\n\r\n                textureSource.glIndexCounter = this.startActiveTexture;\r\n\r\n                textureSource.glIndex = 1;\r\n\r\n                gl.activeTexture(gl.TEXTURE1);\r\n                gl.bindTexture(gl.TEXTURE_2D, textureSource.glTexture);\r\n\r\n                this.currentActiveTexture = 2;\r\n            }\r\n        }\r\n\r\n        this.isTextureClean = false;\r\n\r\n        return textureSource.glIndex;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given diffuse and normal map textures are already bound, or not.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#isNewNormalMap\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL diffuse texture.\r\n     * @param {WebGLTexture} normalMap - The WebGL normal map texture.\r\n     *\r\n     * @return {boolean} Returns `false` if this combination is already set, or `true` if it's a new combination.\r\n     */\r\n    isNewNormalMap: function (texture, normalMap)\r\n    {\r\n        return (this.textureZero !== texture || this.normalTexture !== normalMap);\r\n    },\r\n\r\n    /**\r\n     * Binds a texture directly to texture unit zero then activates it.\r\n     * If the texture is already at unit zero, it skips the bind.\r\n     * Make sure to call `clearTextureZero` after using this method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureZero\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n     * @param {boolean} [flush=false] - Flush the pipeline if the texture is different?\r\n     */\r\n    setTextureZero: function (texture, flush)\r\n    {\r\n        if (this.textureZero !== texture)\r\n        {\r\n            if (flush)\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            var gl = this.gl;\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n            this.textureZero = texture;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears the texture that was directly bound to texture unit zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#clearTextureZero\r\n     * @since 3.50.0\r\n     */\r\n    clearTextureZero: function ()\r\n    {\r\n        this.textureZero = null;\r\n    },\r\n\r\n    /**\r\n     * Binds a texture directly to texture unit one then activates it.\r\n     * If the texture is already at unit one, it skips the bind.\r\n     * Make sure to call `clearNormalMap` after using this method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setNormalMap\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n     */\r\n    setNormalMap: function (texture)\r\n    {\r\n        if (this.normalTexture !== texture)\r\n        {\r\n            var gl = this.gl;\r\n\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n            this.normalTexture = texture;\r\n\r\n            if (this.currentActiveTexture === 1)\r\n            {\r\n                this.currentActiveTexture = 2;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears the texture that was directly bound to texture unit one and\r\n     * increases the start active texture counter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#clearNormalMap\r\n     * @since 3.50.0\r\n     */\r\n    clearNormalMap: function ()\r\n    {\r\n        this.normalTexture = null;\r\n        this.startActiveTexture++;\r\n        this.currentActiveTexture = 1;\r\n\r\n        this.textureFlush++;\r\n    },\r\n\r\n    /**\r\n     * Activates each texture, in turn, then binds them all to `null`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#unbindTextures\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [all=false] - Reset all textures, or just the first two?\r\n     */\r\n    unbindTextures: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var temp = this.tempTextures;\r\n\r\n        for (var i = 0; i < temp.length; i++)\r\n        {\r\n            gl.activeTexture(gl.TEXTURE0 + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, null);\r\n        }\r\n\r\n        this.normalTexture = null;\r\n        this.textureZero = null;\r\n\r\n        this.currentActiveTexture = 1;\r\n        this.startActiveTexture++;\r\n\r\n        this.textureFlush++;\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline, then resets the first two textures\r\n     * back to the default temporary textures, resets the start active\r\n     * counter and sets texture unit 1 as being active.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resetTextures\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [all=false] - Reset all textures, or just the first two?\r\n     */\r\n    resetTextures: function (all)\r\n    {\r\n        if (all === undefined) { all = false; }\r\n\r\n        if (this.isTextureClean)\r\n        {\r\n            //  No need to do this if the textures are already clean\r\n            return;\r\n        }\r\n\r\n        this.flush();\r\n\r\n        var gl = this.gl;\r\n        var temp = this.tempTextures;\r\n\r\n        if (all)\r\n        {\r\n            for (var i = 0; i < temp.length; i++)\r\n            {\r\n                gl.activeTexture(gl.TEXTURE0 + i);\r\n                gl.bindTexture(gl.TEXTURE_2D, temp[i]);\r\n            }\r\n\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, temp[1]);\r\n\r\n            this.isTextureClean = true;\r\n        }\r\n        else\r\n        {\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, temp[0]);\r\n\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, temp[1]);\r\n        }\r\n\r\n        this.normalTexture = null;\r\n        this.textureZero = null;\r\n\r\n        this.currentActiveTexture = 1;\r\n        this.startActiveTexture++;\r\n\r\n        this.textureFlush++;\r\n    },\r\n\r\n    /**\r\n     * Binds a texture at a texture unit. If a texture is already\r\n     * bound to that unit it will force a flush on the current pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n     * @since 3.0.0\r\n     * @version 2.0 - Updated in 3.50.0 to remove the `textureUnit` and `flush` parameters.\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n     *\r\n     * @return {number} The texture unit that was assigned to the Texture Source.\r\n     */\r\n    setTexture2D: function (texture)\r\n    {\r\n        if (this.pipelines.forceZero())\r\n        {\r\n            this.setTextureZero(texture, true);\r\n\r\n            return 0;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var currentActiveTexture = this.currentActiveTexture;\r\n\r\n        if (texture.glIndexCounter < this.startActiveTexture)\r\n        {\r\n            texture.glIndexCounter = this.startActiveTexture;\r\n\r\n            if (currentActiveTexture < this.maxTextures)\r\n            {\r\n                texture.glIndex = currentActiveTexture;\r\n\r\n                gl.activeTexture(gl.TEXTURE0 + currentActiveTexture);\r\n                gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n                this.currentActiveTexture++;\r\n            }\r\n            else\r\n            {\r\n                //  We're out of textures, so flush the batch and reset back to 1 (0 is reserved for fbos)\r\n                this.flush();\r\n\r\n                this.startActiveTexture++;\r\n\r\n                this.textureFlush++;\r\n\r\n                texture.glIndexCounter = this.startActiveTexture;\r\n\r\n                texture.glIndex = 1;\r\n\r\n                gl.activeTexture(gl.TEXTURE1);\r\n                gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n                this.currentActiveTexture = 2;\r\n            }\r\n        }\r\n\r\n        this.isTextureClean = false;\r\n\r\n        return texture.glIndex;\r\n    },\r\n\r\n    /**\r\n     * Pushes a new framebuffer onto the FBO stack and makes it the currently bound framebuffer.\r\n     *\r\n     * If there was another framebuffer already bound it will force a pipeline flush.\r\n     *\r\n     * Call `popFramebuffer` to remove it again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushFramebuffer\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n     * @param {boolean} [updateScissor=false] - Set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n     * @param {boolean} [resetTextures=false] - Should the WebGL Textures be reset after the new framebuffer is bound?\r\n     * @param {boolean} [setViewport=true] - Should the WebGL viewport be set?\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    pushFramebuffer: function (framebuffer, updateScissor, resetTextures, setViewport)\r\n    {\r\n        if (framebuffer === this.currentFramebuffer)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.fboStack.push(framebuffer);\r\n\r\n        return this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);\r\n    },\r\n\r\n    /**\r\n     * Sets the given framebuffer as the active and currently bound framebuffer.\r\n     *\r\n     * If there was another framebuffer already bound it will force a pipeline flush.\r\n     *\r\n     * Typically, you should call `pushFramebuffer` instead of this method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n     * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n     * @param {boolean} [resetTextures=false] - Should the WebGL Textures be reset after the new framebuffer is bound?\r\n     * @param {boolean} [setViewport=true] - Should the WebGL viewport be set?\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setFramebuffer: function (framebuffer, updateScissor, resetTextures, setViewport)\r\n    {\r\n        if (updateScissor === undefined) { updateScissor = false; }\r\n        if (resetTextures === undefined) { resetTextures = false; }\r\n        if (setViewport === undefined) { setViewport = true; }\r\n\r\n        if (framebuffer === this.currentFramebuffer)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        if (framebuffer && framebuffer.renderTexture && setViewport)\r\n        {\r\n            width = framebuffer.renderTexture.width;\r\n            height = framebuffer.renderTexture.height;\r\n        }\r\n        else\r\n        {\r\n            this.flush();\r\n        }\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n\r\n        if (setViewport)\r\n        {\r\n            gl.viewport(0, 0, width, height);\r\n        }\r\n\r\n        if (updateScissor)\r\n        {\r\n            if (framebuffer)\r\n            {\r\n                this.drawingBufferHeight = height;\r\n\r\n                this.pushScissor(0, 0, width, height);\r\n            }\r\n            else\r\n            {\r\n                this.drawingBufferHeight = this.height;\r\n\r\n                this.popScissor();\r\n            }\r\n        }\r\n\r\n        this.currentFramebuffer = framebuffer;\r\n\r\n        if (resetTextures)\r\n        {\r\n            this.resetTextures();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pops the previous framebuffer from the fbo stack and sets it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#popFramebuffer\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n     * @param {boolean} [resetTextures=false] - Should the WebGL Textures be reset after the new framebuffer is bound?\r\n     * @param {boolean} [setViewport=true] - Should the WebGL viewport be set?\r\n     *\r\n     * @return {WebGLFramebuffer} The Framebuffer that was set, or `null` if there aren't any more in the stack.\r\n     */\r\n    popFramebuffer: function (updateScissor, resetTextures, setViewport)\r\n    {\r\n        if (updateScissor === undefined) { updateScissor = false; }\r\n        if (resetTextures === undefined) { resetTextures = false; }\r\n        if (setViewport === undefined) { setViewport = true; }\r\n\r\n        var fboStack = this.fboStack;\r\n\r\n        //  Remove the current fbo\r\n        fboStack.pop();\r\n\r\n        //  Reset the previous framebuffer\r\n        var framebuffer = fboStack[fboStack.length - 1];\r\n\r\n        if (!framebuffer)\r\n        {\r\n            framebuffer = null;\r\n        }\r\n\r\n        this.setFramebuffer(framebuffer, updateScissor, resetTextures, setViewport);\r\n\r\n        return framebuffer;\r\n    },\r\n\r\n    /**\r\n     * Binds a shader program.\r\n     *\r\n     * If there was a different program already bound it will force a pipeline flush first.\r\n     *\r\n     * If the same program given to this method is already set as the current program, no change\r\n     * will take place and this method will return `false`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The program that needs to be bound.\r\n     *\r\n     * @return {boolean} `true` if the given program was bound, otherwise `false`.\r\n     */\r\n    setProgram: function (program)\r\n    {\r\n        if (program !== this.currentProgram)\r\n        {\r\n            this.flush();\r\n\r\n            this.gl.useProgram(program);\r\n\r\n            this.currentProgram = program;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Rebinds whatever program `WebGLRenderer.currentProgram` is set as, without\r\n     * changing anything, or flushing.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resetProgram\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    resetProgram: function ()\r\n    {\r\n        this.gl.useProgram(this.currentProgram);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a texture from an image source. If the source is not valid it creates an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - The source of the texture.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {number} scaleMode - The scale mode to be used by the texture.\r\n     *\r\n     * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.\r\n     */\r\n    createTextureFromSource: function (source, width, height, scaleMode)\r\n    {\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n        var wrap = gl.CLAMP_TO_EDGE;\r\n        var texture = null;\r\n\r\n        width = source ? source.width : width;\r\n        height = source ? source.height : height;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (pow)\r\n        {\r\n            wrap = gl.REPEAT;\r\n        }\r\n\r\n        if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        if (!source && typeof width === 'number' && typeof height === 'number')\r\n        {\r\n            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, null, width, height);\r\n        }\r\n        else\r\n        {\r\n            texture = this.createTexture2D(0, minFilter, magFilter, wrap, wrap, gl.RGBA, source);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} mipLevel - Mip level of the texture.\r\n     * @param {number} minFilter - Filtering of the texture.\r\n     * @param {number} magFilter - Filtering of the texture.\r\n     * @param {number} wrapT - Wrapping mode of the texture.\r\n     * @param {number} wrapS - Wrapping mode of the texture.\r\n     * @param {number} format - Which format does the texture use.\r\n     * @param {?object} pixels - pixel data.\r\n     * @param {number} width - Width of the texture in pixels.\r\n     * @param {number} height - Height of the texture in pixels.\r\n     * @param {boolean} [pma=true] - Does the texture have premultiplied alpha?\r\n     * @param {boolean} [forceSize=false] - If `true` it will use the width and height passed to this method, regardless of the pixels dimension.\r\n     * @param {boolean} [flipY=false] - Sets the `UNPACK_FLIP_Y_WEBGL` flag the WebGL Texture uses during upload.\r\n     *\r\n     * @return {WebGLTexture} The WebGLTexture that was created.\r\n     */\r\n    createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma, forceSize, flipY)\r\n    {\r\n        pma = (pma === undefined || pma === null) ? true : pma;\r\n        if (forceSize === undefined) { forceSize = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var texture = gl.createTexture();\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n\r\n        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n\r\n        if (pixels === null || pixels === undefined)\r\n        {\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);\r\n        }\r\n        else\r\n        {\r\n            if (!forceSize)\r\n            {\r\n                width = pixels.width;\r\n                height = pixels.height;\r\n            }\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);\r\n        }\r\n\r\n        if (IsSizePowerOfTwo(width, height))\r\n        {\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n\r\n        if (currentTexture)\r\n        {\r\n            gl.bindTexture(gl.TEXTURE_2D, currentTexture);\r\n        }\r\n\r\n        texture.isAlphaPremultiplied = pma;\r\n        texture.isRenderTexture = false;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.glIndex = 0;\r\n        texture.glIndexCounter = -1;\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Creates a WebGL Framebuffer object and optionally binds a depth stencil render buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - If `addDepthStencilBuffer` is true, this controls the width of the depth stencil.\r\n     * @param {number} height - If `addDepthStencilBuffer` is true, this controls the height of the depth stencil.\r\n     * @param {WebGLTexture} renderTexture - The color texture where the color pixels are written.\r\n     * @param {boolean} [addDepthStencilBuffer=false] - Create a Renderbuffer for the depth stencil?\r\n     *\r\n     * @return {WebGLFramebuffer} Raw WebGLFramebuffer\r\n     */\r\n    createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer)\r\n    {\r\n        var gl = this.gl;\r\n        var framebuffer = gl.createFramebuffer();\r\n        var complete = 0;\r\n\r\n        this.setFramebuffer(framebuffer);\r\n\r\n        if (addDepthStencilBuffer)\r\n        {\r\n            var depthStencilBuffer = gl.createRenderbuffer();\r\n\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\r\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\r\n        }\r\n\r\n        renderTexture.isRenderTexture = true;\r\n        renderTexture.isAlphaPremultiplied = false;\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\r\n\r\n        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n\r\n        if (complete !== gl.FRAMEBUFFER_COMPLETE)\r\n        {\r\n            var errors = {\r\n                36054: 'Incomplete Attachment',\r\n                36055: 'Missing Attachment',\r\n                36057: 'Incomplete Dimensions',\r\n                36061: 'Framebuffer Unsupported'\r\n            };\r\n\r\n            throw new Error('Framebuffer status: ' + errors[complete]);\r\n        }\r\n\r\n        framebuffer.renderTexture = renderTexture;\r\n\r\n        this.setFramebuffer(null);\r\n\r\n        this.resetTextures();\r\n\r\n        return framebuffer;\r\n    },\r\n\r\n    /**\r\n     * Creates a WebGLProgram instance based on the given vertex and fragment shader source.\r\n     *\r\n     * Then compiles, attaches and links the program before returning it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} vertexShader - The vertex shader source code as a single string.\r\n     * @param {string} fragmentShader - The fragment shader source code as a single string.\r\n     *\r\n     * @return {WebGLProgram} The linked WebGLProgram created from the given shader source.\r\n     */\r\n    createProgram: function (vertexShader, fragmentShader)\r\n    {\r\n        var gl = this.gl;\r\n        var program = gl.createProgram();\r\n        var vs = gl.createShader(gl.VERTEX_SHADER);\r\n        var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n\r\n        gl.shaderSource(vs, vertexShader);\r\n        gl.shaderSource(fs, fragmentShader);\r\n        gl.compileShader(vs);\r\n        gl.compileShader(fs);\r\n\r\n        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Vertex Shader failed:\\n' + gl.getShaderInfoLog(vs));\r\n        }\r\n\r\n        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Fragment Shader failed:\\n' + gl.getShaderInfoLog(fs));\r\n        }\r\n\r\n        gl.attachShader(program, vs);\r\n        gl.attachShader(program, fs);\r\n        gl.linkProgram(program);\r\n\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\r\n        {\r\n            throw new Error('Link Program failed:\\n' + gl.getProgramInfoLog(program));\r\n        }\r\n\r\n        gl.useProgram(program);\r\n\r\n        return program;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo\r\n     * @param {number} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\r\n     *\r\n     * @return {WebGLBuffer} Raw vertex buffer\r\n     */\r\n    createVertexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var vertexBuffer = gl.createBuffer();\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        return vertexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.\r\n     * @param {number} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.\r\n     *\r\n     * @return {WebGLBuffer} Raw index buffer\r\n     */\r\n    createIndexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var indexBuffer = gl.createBuffer();\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\r\n        return indexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Calls `GL.deleteTexture` on the given WebGLTexture and also optionally\r\n     * resets the currently defined textures.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL Texture to be deleted.\r\n     * @param {boolean} [reset=false] - Call the `resetTextures` method after deleting this texture?\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteTexture: function (texture, reset)\r\n    {\r\n        if (reset)\r\n        {\r\n            this.resetTextures(true);\r\n        }\r\n\r\n        if (texture)\r\n        {\r\n            this.gl.deleteTexture(texture);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLFramebuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteFramebuffer: function (framebuffer)\r\n    {\r\n        if (framebuffer)\r\n        {\r\n            this.gl.deleteFramebuffer(framebuffer);\r\n\r\n            ArrayRemove(this.fboStack, framebuffer);\r\n\r\n            if (this.currentFramebuffer === framebuffer)\r\n            {\r\n                this.currentFramebuffer = null;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLProgram from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The shader program to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteProgram: function (program)\r\n    {\r\n        if (program)\r\n        {\r\n            this.gl.deleteProgram(program);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLBuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteBuffer: function (buffer)\r\n    {\r\n        this.gl.deleteBuffer(buffer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the pre-render operations for the given camera.\r\n     * Handles any clipping needed by the camera and renders the background color if a color is visible.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.\r\n     */\r\n    preRenderCamera: function (camera)\r\n    {\r\n        var cx = camera.x;\r\n        var cy = camera.y;\r\n        var cw = camera.width;\r\n        var ch = camera.height;\r\n\r\n        var color = camera.backgroundColor;\r\n\r\n        camera.emit(CameraEvents.PRE_RENDER, camera);\r\n\r\n        this.pipelines.preBatchCamera(camera);\r\n\r\n        this.pushScissor(cx, cy, cw, ch);\r\n\r\n        if (camera.mask)\r\n        {\r\n            this.currentCameraMask.mask = camera.mask;\r\n            this.currentCameraMask.camera = camera._maskCamera;\r\n\r\n            camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\r\n        }\r\n\r\n        if (color.alphaGL > 0)\r\n        {\r\n            var pipeline = this.pipelines.setMulti();\r\n\r\n            pipeline.drawFillRect(\r\n                cx, cy, cw, ch,\r\n                Utils.getTintFromFloats(color.blueGL, color.greenGL, color.redGL, 1),\r\n                color.alphaGL\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Return the current stencil mask.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getCurrentStencilMask\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    getCurrentStencilMask: function ()\r\n    {\r\n        var prev = null;\r\n        var stack = this.maskStack;\r\n        var cameraMask = this.currentCameraMask;\r\n\r\n        if (stack.length > 0)\r\n        {\r\n            prev = stack[stack.length - 1];\r\n        }\r\n        else if (cameraMask.mask && cameraMask.mask.isStencil)\r\n        {\r\n            prev = cameraMask;\r\n        }\r\n\r\n        return prev;\r\n    },\r\n\r\n    /**\r\n     * Controls the post-render operations for the given camera.\r\n     *\r\n     * Renders the foreground camera effects like flash and fading, then resets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.\r\n     */\r\n    postRenderCamera: function (camera)\r\n    {\r\n        var flashEffect = camera.flashEffect;\r\n        var fadeEffect = camera.fadeEffect;\r\n\r\n        if (flashEffect.isRunning || (fadeEffect.isRunning || fadeEffect.isComplete))\r\n        {\r\n            var pipeline = this.pipelines.setMulti();\r\n\r\n            flashEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);\r\n            fadeEffect.postRenderWebGL(pipeline, Utils.getTintFromFloats);\r\n        }\r\n\r\n        camera.dirty = false;\r\n\r\n        this.popScissor();\r\n\r\n        if (camera.mask)\r\n        {\r\n            this.currentCameraMask.mask = null;\r\n\r\n            camera.mask.postRenderWebGL(this, camera._maskCamera);\r\n        }\r\n\r\n        this.pipelines.postBatchCamera(camera);\r\n\r\n        camera.emit(CameraEvents.POST_RENDER, camera);\r\n    },\r\n\r\n    /**\r\n     * Clears the current vertex buffer and updates pipelines.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n     * @fires Phaser.Renderer.Events#PRE_RENDER\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var gl = this.gl;\r\n\r\n        //  Make sure we are bound to the main frame buffer\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        if (this.config.clearBeforeRender)\r\n        {\r\n            var clearColor = this.config.backgroundColor;\r\n\r\n            gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        this.currentScissor = this.defaultScissor;\r\n\r\n        this.scissorStack.length = 0;\r\n        this.scissorStack.push(this.currentScissor);\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            gl.scissor(0, (this.drawingBufferHeight - this.height), this.width, this.height);\r\n        }\r\n\r\n        this.currentMask.mask = null;\r\n        this.currentCameraMask.mask = null;\r\n        this.maskStack.length = 0;\r\n\r\n        this.textureFlush = 0;\r\n\r\n        this.emit(Events.PRE_RENDER);\r\n    },\r\n\r\n    /**\r\n     * The core render step for a Scene Camera.\r\n     *\r\n     * Iterates through the given array of Game Objects and renders them with the given Camera.\r\n     *\r\n     * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n     * by the Scene Systems.render method.\r\n     *\r\n     * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n     * @fires Phaser.Renderer.Events#RENDER\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.GameObject[]} children - An array of filtered Game Objects that can be rendered by the given Camera.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, camera)\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var childCount = children.length;\r\n\r\n        this.emit(Events.RENDER, scene, camera);\r\n\r\n        //   Apply scissor for cam region + render background color, if not transparent\r\n        this.preRenderCamera(camera);\r\n\r\n        //  Nothing to render, so bail out\r\n        if (childCount === 0)\r\n        {\r\n            this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n            //  Applies camera effects and pops the scissor, if set\r\n            this.postRenderCamera(camera);\r\n\r\n            return;\r\n        }\r\n\r\n        //  Reset the current type\r\n        this.currentType = '';\r\n\r\n        var current = this.currentMask;\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            this.finalType = (i === childCount - 1);\r\n\r\n            var child = children[i];\r\n\r\n            var mask = child.mask;\r\n\r\n            current = this.currentMask;\r\n\r\n            if (current.mask && current.mask !== mask)\r\n            {\r\n                //  Render out the previously set mask\r\n                current.mask.postRenderWebGL(this, current.camera);\r\n            }\r\n\r\n            if (mask && current.mask !== mask)\r\n            {\r\n                mask.preRenderWebGL(this, child, camera);\r\n            }\r\n\r\n            if (child.blendMode !== this.currentBlendMode)\r\n            {\r\n                this.setBlendMode(child.blendMode);\r\n            }\r\n\r\n            var type = child.type;\r\n\r\n            if (type !== this.currentType)\r\n            {\r\n                this.newType = true;\r\n                this.currentType = type;\r\n            }\r\n\r\n            if (!this.finalType)\r\n            {\r\n                this.nextTypeMatch = (children[i + 1].type === this.currentType);\r\n            }\r\n            else\r\n            {\r\n                this.nextTypeMatch = false;\r\n            }\r\n\r\n            child.renderWebGL(this, child, camera);\r\n\r\n            this.newType = false;\r\n        }\r\n\r\n        current = this.currentMask;\r\n\r\n        if (current.mask)\r\n        {\r\n            //  Render out the previously set mask, if it was the last item in the display list\r\n            current.mask.postRenderWebGL(this, current.camera);\r\n        }\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        //  Applies camera effects and pops the scissor, if set\r\n        this.postRenderCamera(camera);\r\n    },\r\n\r\n    /**\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n     * @fires Phaser.Renderer.Events#POST_RENDER\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        this.flush();\r\n\r\n        this.emit(Events.POST_RENDER);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            WebGLSnapshot(this.canvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n\r\n        if (this.textureFlush > 0)\r\n        {\r\n            this.startActiveTexture++;\r\n            this.currentActiveTexture = 1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate to grab from.\r\n     * @param {number} y - The y coordinate to grab from.\r\n     * @param {number} width - The width of the area to grab.\r\n     * @param {number} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gl.drawingBufferWidth);\r\n        state.height = Math.min(height, this.gl.drawingBufferHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     *\r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     *\r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     *\r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get.\r\n     * @param {number} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of the given frame buffer.\r\n     *\r\n     * Unlike the other snapshot methods, this one is processed immediately and doesn't wait for the next render.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotFramebuffer\r\n     * @since 3.19.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer to grab from.\r\n     * @param {number} bufferWidth - The width of the framebuffer.\r\n     * @param {number} bufferHeight - The height of the framebuffer.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {boolean} [getPixel=false] - Grab a single pixel as a Color object, or an area as an Image object?\r\n     * @param {number} [x=0] - The x coordinate to grab from.\r\n     * @param {number} [y=0] - The y coordinate to grab from.\r\n     * @param {number} [width=bufferWidth] - The width of the area to grab.\r\n     * @param {number} [height=bufferHeight] - The height of the area to grab.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotFramebuffer: function (framebuffer, bufferWidth, bufferHeight, callback, getPixel, x, y, width, height, type, encoderOptions)\r\n    {\r\n        if (getPixel === undefined) { getPixel = false; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = bufferWidth; }\r\n        if (height === undefined) { height = bufferHeight; }\r\n\r\n        var currentFramebuffer = this.currentFramebuffer;\r\n\r\n        this.snapshotArea(x, y, width, height, callback, type, encoderOptions);\r\n\r\n        var state = this.snapshotState;\r\n\r\n        state.getPixel = getPixel;\r\n\r\n        state.isFramebuffer = true;\r\n        state.bufferWidth = bufferWidth;\r\n        state.bufferHeight = bufferHeight;\r\n\r\n        this.setFramebuffer(framebuffer);\r\n\r\n        WebGLSnapshot(this.canvas, state);\r\n\r\n        this.setFramebuffer(currentFramebuffer);\r\n\r\n        state.callback = null;\r\n        state.isFramebuffer = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given Canvas Element.\r\n     *\r\n     * If the `dstTexture` parameter is given, the WebGL Texture is updated, rather than created fresh.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n     * @param {WebGLTexture} [dstTexture] - The destination WebGL Texture to set.\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     *\r\n     * @return {WebGLTexture} The newly created, or updated, WebGL Texture.\r\n     */\r\n    canvasToTexture: function (srcCanvas, dstTexture, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (!dstTexture)\r\n        {\r\n            return this.createCanvasTexture(srcCanvas, noRepeat, flipY);\r\n        }\r\n        else\r\n        {\r\n            return this.updateCanvasTexture(srcCanvas, dstTexture, flipY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given Canvas Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createCanvasTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to create the WebGL Texture from\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT` (such as for Text objects?)\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     *\r\n     * @return {WebGLTexture} The newly created WebGL Texture.\r\n     */\r\n    createCanvasTexture: function (srcCanvas, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n\r\n        var width = srcCanvas.width;\r\n        var height = srcCanvas.height;\r\n\r\n        var wrapping = gl.CLAMP_TO_EDGE;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (!noRepeat && pow)\r\n        {\r\n            wrapping = gl.REPEAT;\r\n        }\r\n\r\n        if (this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcCanvas, width, height, true, false, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates a WebGL Texture based on the given Canvas Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateCanvasTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas to update the WebGL Texture from.\r\n     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     *\r\n     * @return {WebGLTexture} The updated WebGL Texture.\r\n     */\r\n    updateCanvasTexture: function (srcCanvas, dstTexture, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = srcCanvas.width;\r\n        var height = srcCanvas.height;\r\n\r\n        if (width > 0 && height > 0)\r\n        {\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n            gl.bindTexture(gl.TEXTURE_2D, dstTexture);\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\r\n\r\n            dstTexture.width = width;\r\n            dstTexture.height = height;\r\n\r\n            if (currentTexture)\r\n            {\r\n                gl.bindTexture(gl.TEXTURE_2D, currentTexture);\r\n            }\r\n        }\r\n\r\n        return dstTexture;\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGL Texture based on the given HTML Video Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVideoTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {HTMLVideoElement} srcVideo - The Video to create the WebGL Texture from\r\n     * @param {boolean} [noRepeat=false] - Should this canvas be allowed to set `REPEAT`?\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     *\r\n     * @return {WebGLTexture} The newly created WebGL Texture.\r\n     */\r\n    createVideoTexture: function (srcVideo, noRepeat, flipY)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n        var minFilter = gl.NEAREST;\r\n        var magFilter = gl.NEAREST;\r\n\r\n        var width = srcVideo.videoWidth;\r\n        var height = srcVideo.videoHeight;\r\n\r\n        var wrapping = gl.CLAMP_TO_EDGE;\r\n\r\n        var pow = IsSizePowerOfTwo(width, height);\r\n\r\n        if (!noRepeat && pow)\r\n        {\r\n            wrapping = gl.REPEAT;\r\n        }\r\n\r\n        if (this.config.antialias)\r\n        {\r\n            minFilter = (pow) ? this.mipmapFilter : gl.LINEAR;\r\n            magFilter = gl.LINEAR;\r\n        }\r\n\r\n        return this.createTexture2D(0, minFilter, magFilter, wrapping, wrapping, gl.RGBA, srcVideo, width, height, true, true, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates a WebGL Texture based on the given HTML Video Element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateVideoTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {HTMLVideoElement} srcVideo - The Video to update the WebGL Texture with.\r\n     * @param {WebGLTexture} dstTexture - The destination WebGL Texture to update.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y`?\r\n     *\r\n     * @return {WebGLTexture} The updated WebGL Texture.\r\n     */\r\n    updateVideoTexture: function (srcVideo, dstTexture, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = srcVideo.videoWidth;\r\n        var height = srcVideo.videoHeight;\r\n\r\n        if (width > 0 && height > 0)\r\n        {\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n            gl.bindTexture(gl.TEXTURE_2D, dstTexture);\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcVideo);\r\n\r\n            dstTexture.width = width;\r\n            dstTexture.height = height;\r\n\r\n            if (currentTexture)\r\n            {\r\n                gl.bindTexture(gl.TEXTURE_2D, currentTexture);\r\n            }\r\n        }\r\n\r\n        return dstTexture;\r\n    },\r\n\r\n    /**\r\n     * Sets the minification and magnification filter for a texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} texture - The texture to set the filter for.\r\n     * @param {number} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setTextureFilter: function (texture, filter)\r\n    {\r\n        var gl = this.gl;\r\n        var glFilter = [ gl.LINEAR, gl.NEAREST ][filter];\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n\r\n        var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\r\n\r\n        if (currentTexture)\r\n        {\r\n            gl.bindTexture(gl.TEXTURE_2D, currentTexture);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the largest texture size (either width or height) that can be created.\r\n     * Note that VRAM may not allow a texture of any given size, it just expresses\r\n     * hardware / driver support for a given size.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize\r\n     * @since 3.8.0\r\n     *\r\n     * @return {number} The maximum supported texture size.\r\n     */\r\n    getMaxTextureSize: function ()\r\n    {\r\n        return this.config.maxTextureSize;\r\n    },\r\n\r\n    /**\r\n     * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, false);\r\n        this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, false);\r\n\r\n        var gl = this.gl;\r\n\r\n        var temp = this.tempTextures;\r\n\r\n        for (var i = 0; i < temp.length; i++)\r\n        {\r\n            gl.deleteTexture(temp[i]);\r\n        }\r\n\r\n        this.pipelines.destroy();\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.fboStack = [];\r\n        this.maskStack = [];\r\n        this.extensions = {};\r\n        this.textureIndexes = [];\r\n\r\n        this.gl = null;\r\n        this.game = null;\r\n        this.canvas = null;\r\n        this.contextLost = true;\r\n        this.currentMask = null;\r\n        this.currentCameraMask = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = WebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar WEBGL_CONST = require('./const');\r\n\r\n/**\r\n * @classdesc\r\n * Instances of the WebGLShader class belong to the WebGL Pipeline classes. When the pipeline is\r\n * created it will create an instance of this class for each one of its shaders, as defined in\r\n * the pipeline configuration.\r\n *\r\n * This class encapsulates everything needed to manage a shader in a pipeline, including the\r\n * shader attributes and uniforms, as well as lots of handy methods such as `set2f`, for setting\r\n * uniform values on this shader.\r\n *\r\n * Typically, you do not create an instance of this class directly, as it works in unison with\r\n * the pipeline to which it belongs. You can gain access to this class via a pipeline's `shaders`\r\n * array, post-creation.\r\n *\r\n * @class WebGLShader\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGLPipeline to which this Shader belongs.\r\n * @param {string} name - The name of this Shader.\r\n * @param {string} vertexShader - The vertex shader source code as a single string.\r\n * @param {string} fragmentShader - The fragment shader source code as a single string.\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineAttributeConfig[]} attributes - An array of attributes.\r\n */\r\nvar WebGLShader = new Class({\r\n\r\n    initialize:\r\n\r\n    function WebGLShader (pipeline, name, vertexShader, fragmentShader, attributes)\r\n    {\r\n        /**\r\n         * A reference to the WebGLPipeline that owns this Shader.\r\n         *\r\n         * A Shader class can only belong to a single pipeline.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#pipeline\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @since 3.50.0\r\n         */\r\n        this.pipeline = pipeline;\r\n\r\n        /**\r\n         * The name of this shader.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#name\r\n         * @type {string}\r\n         * @since 3.50.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * A reference to the WebGLRenderer instance.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#renderer\r\n         * @type {Phaser.Renderer.WebGL.WebGLRenderer}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderer = pipeline.renderer;\r\n\r\n        /**\r\n         * A reference to the WebGL Rendering Context the WebGL Renderer is using.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.50.0\r\n         */\r\n        this.gl = this.renderer.gl;\r\n\r\n        /**\r\n         * The WebGLProgram created from the vertex and fragment shaders.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.50.0\r\n         */\r\n        this.program = this.renderer.createProgram(vertexShader, fragmentShader);\r\n\r\n        /**\r\n         * Array of objects that describe the vertex attributes.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#attributes\r\n         * @type {Phaser.Types.Renderer.WebGL.WebGLPipelineAttribute[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.attributes;\r\n\r\n        /**\r\n         * The amount of vertex attribute components of 32 bit length.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#vertexComponentCount\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.vertexComponentCount = 0;\r\n\r\n        /**\r\n         * The size, in bytes, of a single vertex.\r\n         *\r\n         * This is derived by adding together all of the vertex attributes.\r\n         *\r\n         * For example, the Multi Pipeline has the following attributes:\r\n         *\r\n         * inPosition - (size 2 x gl.FLOAT) = 8\r\n         * inTexCoord - (size 2 x gl.FLOAT) = 8\r\n         * inTexId - (size 1 x gl.FLOAT) = 4\r\n         * inTintEffect - (size 1 x gl.FLOAT) = 4\r\n         * inTint - (size 4 x gl.UNSIGNED_BYTE) = 4\r\n         *\r\n         * The total, in this case, is 8 + 8 + 4 + 4 + 4 = 28.\r\n         *\r\n         * This is calculated automatically during the `createAttributes` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#vertexSize\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.vertexSize = 0;\r\n\r\n        /**\r\n         * The active uniforms that this shader has.\r\n         *\r\n         * This is an object that maps the uniform names to their WebGL location and cached values.\r\n         *\r\n         * It is populated automatically via the `createUniforms` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLShader#uniforms\r\n         * @type {Phaser.Types.Renderer.WebGL.WebGLPipelineUniformsConfig}\r\n         * @since 3.50.0\r\n         */\r\n        this.uniforms = {};\r\n\r\n        this.createAttributes(attributes);\r\n        this.createUniforms();\r\n    },\r\n\r\n    /**\r\n     * Takes the vertex attributes config and parses it, creating the resulting array that is stored\r\n     * in this shaders `attributes` property, calculating the offset, normalization and location\r\n     * in the process.\r\n     *\r\n     * Calling this method resets `WebGLShader.attributes`, `WebGLShader.vertexSize` and\r\n     * `WebGLShader.vertexComponentCount`.\r\n     *\r\n     * It is called automatically when this class is created, but can be called manually if required.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#createAttributes\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineAttributeConfig[]} attributes - An array of attributes configs.\r\n     */\r\n    createAttributes: function (attributes)\r\n    {\r\n        var count = 0;\r\n        var offset = 0;\r\n        var result = [];\r\n\r\n        this.vertexComponentCount = 0;\r\n\r\n        for (var i = 0; i < attributes.length; i++)\r\n        {\r\n            var element = attributes[i];\r\n\r\n            var name = element.name;\r\n            var size = GetFastValue(element, 'size', 1); // i.e. 1 for a float, 2 for a vec2, 4 for a vec4, etc\r\n            var glType = GetFastValue(element, 'type', WEBGL_CONST.FLOAT);\r\n            var type = glType.enum; // The GLenum\r\n            var typeSize = glType.size; // The size in bytes of the type\r\n\r\n            var normalized = (element.normalized) ? true : false;\r\n\r\n            result.push({\r\n                name: name,\r\n                size: size,\r\n                type: type,\r\n                normalized: normalized,\r\n                offset: offset,\r\n                enabled: false,\r\n                location: -1\r\n            });\r\n\r\n            if (typeSize === 4)\r\n            {\r\n                count += size;\r\n            }\r\n            else\r\n            {\r\n                count++;\r\n            }\r\n\r\n            offset += size * typeSize;\r\n        }\r\n\r\n        this.vertexSize = offset;\r\n        this.vertexComponentCount = count;\r\n        this.attributes = result;\r\n    },\r\n\r\n    /**\r\n     * Sets the program this shader uses as being the active shader in the WebGL Renderer.\r\n     *\r\n     * This method is called every time the parent pipeline is made the current active pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#bind\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [setAttributes=false] - Should the vertex attribute pointers be set?\r\n     * @param {boolean} [flush=false] - Flush the pipeline before binding this shader?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    bind: function (setAttributes, flush)\r\n    {\r\n        if (setAttributes === undefined) { setAttributes = false; }\r\n        if (flush === undefined) { flush = false; }\r\n\r\n        if (flush)\r\n        {\r\n            this.pipeline.flush();\r\n        }\r\n\r\n        this.renderer.setProgram(this.program);\r\n\r\n        if (setAttributes)\r\n        {\r\n            this.setAttribPointers();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the program this shader uses as being the active shader in the WebGL Renderer.\r\n     *\r\n     * Then resets all of the attribute pointers.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#rebind\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    rebind: function ()\r\n    {\r\n        this.renderer.setProgram(this.program);\r\n\r\n        this.setAttribPointers(true);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertex attribute pointers.\r\n     *\r\n     * This should only be called after the vertex buffer has been bound.\r\n     *\r\n     * It is called automatically during the `bind` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setAttribPointers\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [reset=false] - Reset the vertex attribute locations?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setAttribPointers: function (reset)\r\n    {\r\n        if (reset === undefined) { reset = false; }\r\n\r\n        var gl = this.gl;\r\n        var vertexSize = this.vertexSize;\r\n        var attributes = this.attributes;\r\n        var program = this.program;\r\n\r\n        for (var i = 0; i < attributes.length; i++)\r\n        {\r\n            var element = attributes[i];\r\n\r\n            var size = element.size;\r\n            var type = element.type;\r\n            var offset = element.offset;\r\n            var enabled = element.enabled;\r\n            var location = element.location;\r\n            var normalized = (element.normalized) ? true : false;\r\n\r\n            if (reset)\r\n            {\r\n                var attribLocation = gl.getAttribLocation(program, element.name);\r\n\r\n                if (attribLocation >= 0)\r\n                {\r\n                    gl.enableVertexAttribArray(attribLocation);\r\n\r\n                    gl.vertexAttribPointer(attribLocation, size, type, normalized, vertexSize, offset);\r\n\r\n                    element.enabled = true;\r\n                    element.location = attribLocation;\r\n                }\r\n                else if (attribLocation !== -1)\r\n                {\r\n                    gl.disableVertexAttribArray(attribLocation);\r\n                }\r\n            }\r\n            else if (enabled)\r\n            {\r\n                gl.vertexAttribPointer(location, size, type, normalized, vertexSize, offset);\r\n            }\r\n            else if (!enabled && location > -1)\r\n            {\r\n                gl.disableVertexAttribArray(location);\r\n\r\n                element.location = -1;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets up the `WebGLShader.uniforms` object, populating it with the names\r\n     * and locations of the shader uniforms this shader requires.\r\n     *\r\n     * It works by first calling `gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS)` to\r\n     * find out how many active uniforms this shader has. It then iterates through them,\r\n     * calling `gl.getActiveUniform` to get the WebGL Active Info from each one. Finally,\r\n     * the name and location are stored in the local array.\r\n     *\r\n     * This method is called automatically when this class is created.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#createUniforms\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    createUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var program = this.program;\r\n        var uniforms = this.uniforms;\r\n\r\n        var i;\r\n        var name;\r\n        var location;\r\n\r\n        //  Look-up all active uniforms\r\n\r\n        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n\r\n        for (i = 0; i < totalUniforms; i++)\r\n        {\r\n            var info = gl.getActiveUniform(program, i);\r\n\r\n            if (info)\r\n            {\r\n                name = info.name;\r\n\r\n                location = gl.getUniformLocation(program, name);\r\n\r\n                if (location !== null)\r\n                {\r\n                    uniforms[name] =\r\n                    {\r\n                        name: name,\r\n                        location: location,\r\n                        value1: null,\r\n                        value2: null,\r\n                        value3: null,\r\n                        value4: null\r\n                    };\r\n                }\r\n\r\n                //  If the uniform name contains [] for an array struct,\r\n                //  we'll add an entry for the non-struct name as well.\r\n                //  Such as uMainSampler[12] = uMainSampler\r\n\r\n                var struct = name.indexOf('[');\r\n\r\n                if (struct > 0)\r\n                {\r\n                    name = name.substr(0, struct);\r\n\r\n                    if (!uniforms.hasOwnProperty(name))\r\n                    {\r\n                        location = gl.getUniformLocation(program, name);\r\n\r\n                        if (location !== null)\r\n                        {\r\n                            uniforms[name] =\r\n                            {\r\n                                name: name,\r\n                                location: location,\r\n                                value1: null,\r\n                                value2: null,\r\n                                value3: null,\r\n                                value4: null\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the given uniform name exists and is active in this shader.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#hasUniform\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to check for.\r\n     *\r\n     * @return {boolean} `true` if the uniform exists, otherwise `false`.\r\n     */\r\n    hasUniform: function (name)\r\n    {\r\n        return this.uniforms.hasOwnProperty(name);\r\n    },\r\n\r\n    /**\r\n     * Resets the cached values of the given uniform.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#resetUniform\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to reset.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    resetUniform: function (name)\r\n    {\r\n        var uniform = this.uniforms[name];\r\n\r\n        if (uniform)\r\n        {\r\n            uniform.value1 = null;\r\n            uniform.value2 = null;\r\n            uniform.value3 = null;\r\n            uniform.value4 = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given uniform value/s based on the name and GL function.\r\n     *\r\n     * This method is called internally by other methods such as `set1f` and `set3iv`.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setUniform1\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} setter - The GL function to call.\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {(boolean|number|number[]|Float32Array)} value1 - The new value of the uniform.\r\n     * @param {boolean} [skipCheck=false] - Skip the value comparison?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setUniform1: function (setter, name, value1, skipCheck)\r\n    {\r\n        var uniform = this.uniforms[name];\r\n\r\n        if (!uniform)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (skipCheck || uniform.value1 !== value1)\r\n        {\r\n            uniform.value1 = value1;\r\n\r\n            this.renderer.setProgram(this.program);\r\n\r\n            setter.call(this.gl, uniform.location, value1);\r\n\r\n            this.pipeline.currentShader = this;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given uniform value/s based on the name and GL function.\r\n     *\r\n     * This method is called internally by other methods such as `set1f` and `set3iv`.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setUniform2\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} setter - The GL function to call.\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {(boolean|number|number[]|Float32Array)} value1 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value2 - The new value of the uniform.\r\n     * @param {boolean} [skipCheck=false] - Skip the value comparison?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setUniform2: function (setter, name, value1, value2, skipCheck)\r\n    {\r\n        var uniform = this.uniforms[name];\r\n\r\n        if (!uniform)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2)\r\n        {\r\n            uniform.value1 = value1;\r\n            uniform.value2 = value2;\r\n\r\n            this.renderer.setProgram(this.program);\r\n\r\n            setter.call(this.gl, uniform.location, value1, value2);\r\n\r\n            this.pipeline.currentShader = this;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given uniform value/s based on the name and GL function.\r\n     *\r\n     * This method is called internally by other methods such as `set1f` and `set3iv`.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setUniform3\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} setter - The GL function to call.\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {(boolean|number|number[]|Float32Array)} value1 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value2 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value3 - The new value of the uniform.\r\n     * @param {boolean} [skipCheck=false] - Skip the value comparison?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setUniform3: function (setter, name, value1, value2, value3, skipCheck)\r\n    {\r\n        var uniform = this.uniforms[name];\r\n\r\n        if (!uniform)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3)\r\n        {\r\n            uniform.value1 = value1;\r\n            uniform.value2 = value2;\r\n            uniform.value3 = value3;\r\n\r\n            this.renderer.setProgram(this.program);\r\n\r\n            setter.call(this.gl, uniform.location, value1, value2, value3);\r\n\r\n            this.pipeline.currentShader = this;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the given uniform value/s based on the name and GL function.\r\n     *\r\n     * This method is called internally by other methods such as `set1f` and `set3iv`.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setUniform4\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} setter - The GL function to call.\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {(boolean|number|number[]|Float32Array)} value1 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value2 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value3 - The new value of the uniform.\r\n     * @param {(boolean|number|number[]|Float32Array)} value4 - The new value of the uniform.\r\n     * @param {boolean} [skipCheck=false] - Skip the value comparison?\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setUniform4: function (setter, name, value1, value2, value3, value4, skipCheck)\r\n    {\r\n        var uniform = this.uniforms[name];\r\n\r\n        if (!uniform)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (skipCheck || uniform.value1 !== value1 || uniform.value2 !== value2 || uniform.value3 !== value3 || uniform.value4 !== value4)\r\n        {\r\n            uniform.value1 = value1;\r\n            uniform.value2 = value2;\r\n            uniform.value3 = value3;\r\n            uniform.value4 = value4;\r\n\r\n            this.renderer.setProgram(this.program);\r\n\r\n            setter.call(this.gl, uniform.location, value1, value2, value3, value4);\r\n\r\n            this.pipeline.currentShader = this;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a 1f uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set1f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new value of the `float` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set1f: function (name, x)\r\n    {\r\n        return this.setUniform1(this.gl.uniform1f, name, x);\r\n    },\r\n\r\n    /**\r\n     * Sets a 2f uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set2f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `vec2` uniform.\r\n     * @param {number} y - The new Y component of the `vec2` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set2f: function (name, x, y)\r\n    {\r\n        return this.setUniform2(this.gl.uniform2f, name, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets a 3f uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set3f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `vec3` uniform.\r\n     * @param {number} y - The new Y component of the `vec3` uniform.\r\n     * @param {number} z - The new Z component of the `vec3` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set3f: function (name, x, y, z)\r\n    {\r\n        return this.setUniform3(this.gl.uniform3f, name, x, y, z);\r\n    },\r\n\r\n    /**\r\n     * Sets a 4f uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set4f\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - X component of the uniform\r\n     * @param {number} y - Y component of the uniform\r\n     * @param {number} z - Z component of the uniform\r\n     * @param {number} w - W component of the uniform\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set4f: function (name, x, y, z, w)\r\n    {\r\n        return this.setUniform4(this.gl.uniform4f, name, x, y, z, w);\r\n    },\r\n\r\n    /**\r\n     * Sets a 1fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set1fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set1fv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform1fv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 2fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set2fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set2fv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform2fv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 3fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set3fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set3fv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform3fv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 4fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set4fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set4fv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform4fv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 1iv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set1iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set1iv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform1iv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 2iv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set2iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set2iv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform2iv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 3iv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set3iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set3iv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform3iv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 4iv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set4iv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number[]|Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set4iv: function (name, arr)\r\n    {\r\n        return this.setUniform1(this.gl.uniform4iv, name, arr, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a 1i uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set1i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new value of the `int` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set1i: function (name, x)\r\n    {\r\n        return this.setUniform1(this.gl.uniform1i, name, x);\r\n    },\r\n\r\n    /**\r\n     * Sets a 2i uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set2i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `ivec2` uniform.\r\n     * @param {number} y - The new Y component of the `ivec2` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set2i: function (name, x, y)\r\n    {\r\n        return this.setUniform2(this.gl.uniform2i, name, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets a 3i uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set3i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - The new X component of the `ivec3` uniform.\r\n     * @param {number} y - The new Y component of the `ivec3` uniform.\r\n     * @param {number} z - The new Z component of the `ivec3` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set3i: function (name, x, y, z)\r\n    {\r\n        return this.setUniform3(this.gl.uniform3i, name, x, y, z);\r\n    },\r\n\r\n    /**\r\n     * Sets a 4i uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#set4i\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {number} x - X component of the uniform\r\n     * @param {number} y - Y component of the uniform\r\n     * @param {number} z - Z component of the uniform\r\n     * @param {number} w - W component of the uniform\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    set4i: function (name, x, y, z, w)\r\n    {\r\n        return this.setUniform4(this.gl.uniform4i, name, x, y, z, w);\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 2fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setMatrix2fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.\r\n     * @param {number[]|Float32Array} matrix - The new values for the `mat2` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setMatrix2fv: function (name, transpose, matrix)\r\n    {\r\n        return this.setUniform2(this.gl.uniformMatrix2fv, name, transpose, matrix, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 3fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setMatrix3fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Whether to transpose the matrix. Should be `false`.\r\n     * @param {Float32Array} matrix - The new values for the `mat3` uniform.\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setMatrix3fv: function (name, transpose, matrix)\r\n    {\r\n        return this.setUniform2(this.gl.uniformMatrix3fv, name, transpose, matrix, true);\r\n    },\r\n\r\n    /**\r\n     * Sets a matrix 4fv uniform value based on the given name on this shader.\r\n     *\r\n     * The uniform is only set if the value/s given are different to those previously set.\r\n     *\r\n     * This method works by first setting this shader as being the current shader within the\r\n     * WebGL Renderer, if it isn't already. It also sets this shader as being the current\r\n     * one within the pipeline it belongs to.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#setMatrix4fv\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} name - The name of the uniform to set.\r\n     * @param {boolean} transpose - Should the matrix be transpose\r\n     * @param {Float32Array} matrix - Matrix data\r\n     *\r\n     * @return {this} This WebGLShader instance.\r\n     */\r\n    setMatrix4fv: function (name, transpose, matrix)\r\n    {\r\n        return this.setUniform2(this.gl.uniformMatrix4fv, name, transpose, matrix, true);\r\n    },\r\n\r\n    /**\r\n     * Removes all external references from this class and deletes the WebGL program from the WebGL context.\r\n     *\r\n     * Does not remove this shader from the parent pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLShader#destroy\r\n     * @since 3.50.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.gl.deleteProgram(this.program);\r\n\r\n        this.pipeline = null;\r\n        this.renderer = null;\r\n        this.gl = null;\r\n        this.program = null;\r\n        this.attributes = null;\r\n        this.uniforms = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = WebGLShader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar WEBGL_CONST = {\r\n\r\n    /**\r\n     * \t8-bit twos complement signed integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.BYTE\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    BYTE: { enum: 0x1400, size: 1 },\r\n\r\n    /**\r\n     * 8-bit twos complement unsigned integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.UNSIGNED_BYTE\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    UNSIGNED_BYTE: { enum: 0x1401, size: 1 },\r\n\r\n    /**\r\n     * 16-bit twos complement signed integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.SHORT\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    SHORT: { enum: 0x1402, size: 2 },\r\n\r\n    /**\r\n     * 16-bit twos complement unsigned integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.UNSIGNED_SHORT\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    UNSIGNED_SHORT: { enum: 0x1403, size: 2 },\r\n\r\n    /**\r\n     * 32-bit twos complement signed integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.INT\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    INT: { enum: 0x1404, size: 4 },\r\n\r\n    /**\r\n     * 32-bit twos complement unsigned integer.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.UNSIGNED_INT\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    UNSIGNED_INT: { enum: 0x1405, size: 4 },\r\n\r\n    /**\r\n     * 32-bit IEEE floating point number.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.FLOAT\r\n     * @type {Phaser.Types.Renderer.WebGL.WebGLConst}\r\n     * @since 3.50.0\r\n     */\r\n    FLOAT: { enum: 0x1406, size: 4 }\r\n\r\n};\r\n\r\nmodule.exports = WEBGL_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ShaderSourceFS = require('../shaders/BitmapMask-frag.js');\r\nvar ShaderSourceVS = require('../shaders/BitmapMask-vert.js');\r\nvar WEBGL_CONST = require('../const');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Bitmap Mask Pipeline handles all of the bitmap mask rendering in WebGL for applying\r\n * alpha masks to Game Objects. It works by sampling two texture on the fragment shader and\r\n * using the fragments alpha to clip the region.\r\n *\r\n * The fragment shader it uses can be found in `shaders/src/BitmapMask.frag`.\r\n * The vertex shader it uses can be found in `shaders/src/BitmapMask.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2, offset 0)\r\n *\r\n * The default shader uniforms for this pipeline are:\r\n *\r\n * `uResolution` (vec2)\r\n * `uMainSampler` (sampler2D)\r\n * `uMaskSampler` (sampler2D)\r\n * `uInvertMaskAlpha` (bool)\r\n *\r\n * @class BitmapMaskPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar BitmapMaskPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function BitmapMaskPipeline (config)\r\n    {\r\n        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS),\r\n        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS),\r\n        config.batchSize = GetFastValue(config, 'batchSize', 1),\r\n        config.vertices = GetFastValue(config, 'vertices', [ -1, 1, -1, -7, 7, 1 ]),\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2,\r\n                type: WEBGL_CONST.FLOAT\r\n            }\r\n        ]);\r\n\r\n        WebGLPipeline.call(this, config);\r\n    },\r\n\r\n    boot: function ()\r\n    {\r\n        WebGLPipeline.prototype.boot.call(this);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1i('uMaskSampler', 1);\r\n    },\r\n\r\n    resize: function (width, height)\r\n    {\r\n        WebGLPipeline.prototype.resize.call(this, width, height);\r\n\r\n        this.set2f('uResolution', width, height);\r\n    },\r\n\r\n    /**\r\n     * Binds necessary resources and renders the mask to a separated framebuffer.\r\n     * The framebuffer for the masked object is also bound for further use.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#beginMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as mask.\r\n     * @param {Phaser.GameObjects.GameObject} maskedObject - GameObject masked by the mask GameObject.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera rendering the current mask.\r\n     */\r\n    beginMask: function (mask, maskedObject, camera)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        if (mask.bitmapMask && gl)\r\n        {\r\n            var renderer = this.renderer;\r\n\r\n            renderer.flush();\r\n\r\n            renderer.pushFramebuffer(mask.mainFramebuffer);\r\n\r\n            gl.disable(gl.STENCIL_TEST);\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            if (renderer.currentCameraMask.mask !== mask)\r\n            {\r\n                renderer.currentMask.mask = mask;\r\n                renderer.currentMask.camera = camera;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The masked game objects framebuffer is unbound and its texture\r\n     * is bound together with the mask texture and the mask shader and\r\n     * a draw call with a single quad is processed. Here is where the\r\n     * masking effect is applied.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline#endMask\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} mask - GameObject used as a mask.\r\n     */\r\n    endMask: function (mask, camera)\r\n    {\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        //  The renderable Game Object that is being used for the bitmap mask\r\n        var bitmapMask = mask.bitmapMask;\r\n\r\n        if (bitmapMask && gl)\r\n        {\r\n            //  mask.mainFramebuffer should now contain all the Game Objects we want masked\r\n            renderer.flush();\r\n\r\n            //  Swap to the mask framebuffer (push, in case the bitmapMask GO has a post-pipeline)\r\n            renderer.pushFramebuffer(mask.maskFramebuffer);\r\n\r\n            //  Clear it and draw the Game Object that is acting as a mask to it\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            renderer.setBlendMode(0, true);\r\n\r\n            bitmapMask.renderWebGL(renderer, bitmapMask, camera);\r\n\r\n            renderer.flush();\r\n\r\n            //  Clear the mask framebuffer + main framebuffer\r\n            renderer.popFramebuffer();\r\n            renderer.popFramebuffer();\r\n\r\n            //  Is there a stencil further up the stack?\r\n            var prev = renderer.getCurrentStencilMask();\r\n\r\n            if (prev)\r\n            {\r\n                gl.enable(gl.STENCIL_TEST);\r\n\r\n                prev.mask.applyStencil(renderer, prev.camera, true);\r\n            }\r\n            else\r\n            {\r\n                renderer.currentMask.mask = null;\r\n            }\r\n\r\n            //  Bind this pipeline and draw\r\n            renderer.pipelines.set(this);\r\n\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_2D, mask.maskTexture);\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, mask.mainTexture);\r\n\r\n            this.set1i('uInvertMaskAlpha', mask.invertAlpha);\r\n\r\n            //  Finally, draw a triangle filling the whole screen\r\n            gl.drawArrays(this.topology, 0, 3);\r\n\r\n            renderer.resetTextures();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BitmapMaskPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ShaderSourceFS = require('../shaders/Graphics-frag.js');\r\nvar ShaderSourceVS = require('../shaders/Graphics-vert.js');\r\nvar TransformMatrix = require('../../../gameobjects/components/TransformMatrix');\r\nvar WEBGL_CONST = require('../const');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Graphics Pipeline is the rendering pipeline used by Phaser in WebGL when drawing\r\n * primitive geometry objects, such as the Graphics Game Object, or the Shape Game Objects\r\n * such as Arc, Line, Rectangle and Star. It handles the preperation and batching of related vertices.\r\n *\r\n * Prior to Phaser v3.50 the functions of this pipeline were merged with the `TextureTintPipeline`.\r\n *\r\n * The fragment shader it uses can be found in `shaders/src/Graphics.frag`.\r\n * The vertex shader it uses can be found in `shaders/src/Graphics.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2)\r\n * `inColor` (vec4, normalized)\r\n *\r\n * The default shader uniforms for this pipeline are:\r\n *\r\n * `uProjectionMatrix` (mat4)\r\n *\r\n * @class GraphicsPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar GraphicsPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function GraphicsPipeline (config)\r\n    {\r\n        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS);\r\n        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inColor',\r\n                size: 4,\r\n                type: WEBGL_CONST.UNSIGNED_BYTE,\r\n                normalized: true\r\n            }\r\n        ]);\r\n\r\n        WebGLPipeline.call(this, config);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching by the\r\n         * Shape Game Objects.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#calcMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.50.0\r\n         */\r\n        this.calcMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * Used internally to draw stroked triangles.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#tempTriangle\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.tempTriangle = [\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 }\r\n        ];\r\n\r\n        /**\r\n         * Cached stroke tint.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#strokeTint\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };\r\n\r\n        /**\r\n         * Cached fill tint.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#fillTint\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };\r\n\r\n        /**\r\n         * Internal texture frame reference.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#currentFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };\r\n\r\n        /**\r\n         * Internal path quad cache.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#firstQuad\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.firstQuad = [ 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * Internal path quad cache.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#prevQuad\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevQuad = [ 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * Used internally for triangulating a polygon.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#polygonCache\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.polygonCache = [];\r\n    },\r\n\r\n    /**\r\n     * Pushes a filled rectangle into the vertex batch.\r\n     *\r\n     * Rectangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchFillRect\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - Horizontal top left coordinate of the rectangle.\r\n     * @param {number} y - Vertical top left coordinate of the rectangle.\r\n     * @param {number} width - Width of the rectangle.\r\n     * @param {number} height - Height of the rectangle.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillRect: function (x, y, width, height, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var xw = x + width;\r\n        var yh = y + height;\r\n\r\n        var x0 = calcMatrix.getX(x, y);\r\n        var y0 = calcMatrix.getY(x, y);\r\n\r\n        var x1 = calcMatrix.getX(x, yh);\r\n        var y1 = calcMatrix.getY(x, yh);\r\n\r\n        var x2 = calcMatrix.getX(xw, yh);\r\n        var y2 = calcMatrix.getY(xw, yh);\r\n\r\n        var x3 = calcMatrix.getX(xw, y);\r\n        var y3 = calcMatrix.getY(xw, y);\r\n\r\n        var tint = this.fillTint;\r\n\r\n        this.batchQuad(x0, y0, x1, y1, x2, y2, x3, y3, tint.TL, tint.TR, tint.BL, tint.BR);\r\n    },\r\n\r\n    /**\r\n     * Pushes a filled triangle into the vertex batch.\r\n     *\r\n     * Triangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchFillTriangle\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x0 - Point 0 x coordinate.\r\n     * @param {number} y0 - Point 0 y coordinate.\r\n     * @param {number} x1 - Point 1 x coordinate.\r\n     * @param {number} y1 - Point 1 y coordinate.\r\n     * @param {number} x2 - Point 2 x coordinate.\r\n     * @param {number} y2 - Point 2 y coordinate.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillTriangle: function (x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var tx0 = calcMatrix.getX(x0, y0);\r\n        var ty0 = calcMatrix.getY(x0, y0);\r\n\r\n        var tx1 = calcMatrix.getX(x1, y1);\r\n        var ty1 = calcMatrix.getY(x1, y1);\r\n\r\n        var tx2 = calcMatrix.getX(x2, y2);\r\n        var ty2 = calcMatrix.getY(x2, y2);\r\n\r\n        var tint = this.fillTint;\r\n\r\n        this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tint.TL, tint.TR, tint.BL);\r\n    },\r\n\r\n    /**\r\n     * Pushes a stroked triangle into the vertex batch.\r\n     *\r\n     * Triangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * The triangle is created from 3 lines and drawn using the `batchStrokePath` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchStrokeTriangle\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x0 - Point 0 x coordinate.\r\n     * @param {number} y0 - Point 0 y coordinate.\r\n     * @param {number} x1 - Point 1 x coordinate.\r\n     * @param {number} y1 - Point 1 y coordinate.\r\n     * @param {number} x2 - Point 2 x coordinate.\r\n     * @param {number} y2 - Point 2 y coordinate.\r\n     * @param {number} lineWidth - The width of the line in pixels.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchStrokeTriangle: function (x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix)\r\n    {\r\n        var tempTriangle = this.tempTriangle;\r\n\r\n        tempTriangle[0].x = x0;\r\n        tempTriangle[0].y = y0;\r\n        tempTriangle[0].width = lineWidth;\r\n\r\n        tempTriangle[1].x = x1;\r\n        tempTriangle[1].y = y1;\r\n        tempTriangle[1].width = lineWidth;\r\n\r\n        tempTriangle[2].x = x2;\r\n        tempTriangle[2].y = y2;\r\n        tempTriangle[2].width = lineWidth;\r\n\r\n        tempTriangle[3].x = x0;\r\n        tempTriangle[3].y = y0;\r\n        tempTriangle[3].width = lineWidth;\r\n\r\n        this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);\r\n    },\r\n\r\n    /**\r\n     * Adds the given path to the vertex batch for rendering.\r\n     *\r\n     * It works by taking the array of path data and then passing it through Earcut, which\r\n     * creates a list of polygons. Each polygon is then added to the batch.\r\n     *\r\n     * The path is always automatically closed because it's filled.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchFillPath\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like[]} path - Collection of points that represent the path.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillPath: function (path, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var length = path.length;\r\n        var polygonCache = this.polygonCache;\r\n        var polygonIndexArray;\r\n        var point;\r\n\r\n        var tintTL = this.fillTint.TL;\r\n        var tintTR = this.fillTint.TR;\r\n        var tintBL = this.fillTint.BL;\r\n\r\n        for (var pathIndex = 0; pathIndex < length; ++pathIndex)\r\n        {\r\n            point = path[pathIndex];\r\n            polygonCache.push(point.x, point.y);\r\n        }\r\n\r\n        polygonIndexArray = Earcut(polygonCache);\r\n        length = polygonIndexArray.length;\r\n\r\n        for (var index = 0; index < length; index += 3)\r\n        {\r\n            var p0 = polygonIndexArray[index + 0] * 2;\r\n            var p1 = polygonIndexArray[index + 1] * 2;\r\n            var p2 = polygonIndexArray[index + 2] * 2;\r\n\r\n            var x0 = polygonCache[p0 + 0];\r\n            var y0 = polygonCache[p0 + 1];\r\n            var x1 = polygonCache[p1 + 0];\r\n            var y1 = polygonCache[p1 + 1];\r\n            var x2 = polygonCache[p2 + 0];\r\n            var y2 = polygonCache[p2 + 1];\r\n\r\n            var tx0 = calcMatrix.getX(x0, y0);\r\n            var ty0 = calcMatrix.getY(x0, y0);\r\n\r\n            var tx1 = calcMatrix.getX(x1, y1);\r\n            var ty1 = calcMatrix.getY(x1, y1);\r\n\r\n            var tx2 = calcMatrix.getX(x2, y2);\r\n            var ty2 = calcMatrix.getY(x2, y2);\r\n\r\n            this.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, tintTL, tintTR, tintBL);\r\n        }\r\n\r\n        polygonCache.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds the given path to the vertex batch for rendering.\r\n     *\r\n     * It works by taking the array of path data and calling `batchLine` for each section\r\n     * of the path.\r\n     *\r\n     * The path is optionally closed at the end.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchStrokePath\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like[]} path - Collection of points that represent the path.\r\n     * @param {number} lineWidth - The width of the line segments in pixels.\r\n     * @param {boolean} pathOpen - Indicates if the path should be closed or left open.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchStrokePath: function (path, lineWidth, pathOpen, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        //  Reset the closePath booleans\r\n        this.prevQuad[4] = 0;\r\n        this.firstQuad[4] = 0;\r\n\r\n        var pathLength = path.length - 1;\r\n\r\n        for (var pathIndex = 0; pathIndex < pathLength; pathIndex++)\r\n        {\r\n            var point0 = path[pathIndex];\r\n            var point1 = path[pathIndex + 1];\r\n\r\n            this.batchLine(\r\n                point0.x,\r\n                point0.y,\r\n                point1.x,\r\n                point1.y,\r\n                point0.width / 2,\r\n                point1.width / 2,\r\n                lineWidth,\r\n                pathIndex,\r\n                !pathOpen && (pathIndex === pathLength - 1),\r\n                currentMatrix,\r\n                parentMatrix\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a line out of 4 quads and adds it to the vertex batch based on the given line values.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchLine\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} ax - x coordinate of the start of the line.\r\n     * @param {number} ay - y coordinate of the start of the line.\r\n     * @param {number} bx - x coordinate of the end of the line.\r\n     * @param {number} by - y coordinate of the end of the line.\r\n     * @param {number} aLineWidth - Width of the start of the line.\r\n     * @param {number} bLineWidth - Width of the end of the line.\r\n     * @param {number} index - If this line is part of a multi-line draw, the index of the line in the draw.\r\n     * @param {boolean} closePath - Does this line close a multi-line path?\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchLine: function (ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var dx = bx - ax;\r\n        var dy = by - ay;\r\n\r\n        var len = Math.sqrt(dx * dx + dy * dy);\r\n        var al0 = aLineWidth * (by - ay) / len;\r\n        var al1 = aLineWidth * (ax - bx) / len;\r\n        var bl0 = bLineWidth * (by - ay) / len;\r\n        var bl1 = bLineWidth * (ax - bx) / len;\r\n\r\n        var lx0 = bx - bl0;\r\n        var ly0 = by - bl1;\r\n        var lx1 = ax - al0;\r\n        var ly1 = ay - al1;\r\n        var lx2 = bx + bl0;\r\n        var ly2 = by + bl1;\r\n        var lx3 = ax + al0;\r\n        var ly3 = ay + al1;\r\n\r\n        //  tx0 = bottom right\r\n        var brX = calcMatrix.getX(lx0, ly0);\r\n        var brY = calcMatrix.getY(lx0, ly0);\r\n\r\n        //  tx1 = bottom left\r\n        var blX = calcMatrix.getX(lx1, ly1);\r\n        var blY = calcMatrix.getY(lx1, ly1);\r\n\r\n        //  tx2 = top right\r\n        var trX = calcMatrix.getX(lx2, ly2);\r\n        var trY = calcMatrix.getY(lx2, ly2);\r\n\r\n        //  tx3 = top left\r\n        var tlX = calcMatrix.getX(lx3, ly3);\r\n        var tlY = calcMatrix.getY(lx3, ly3);\r\n\r\n        var tint = this.strokeTint;\r\n\r\n        var tintTL = tint.TL;\r\n        var tintTR = tint.TR;\r\n        var tintBL = tint.BL;\r\n        var tintBR = tint.BR;\r\n\r\n        //  TL, BL, BR, TR\r\n        this.batchQuad(tlX, tlY, blX, blY, brX, brY, trX, trY, tintTL, tintTR, tintBL, tintBR);\r\n\r\n        if (lineWidth <= 2)\r\n        {\r\n            //  No point doing a linejoin if the line isn't thick enough\r\n            return;\r\n        }\r\n\r\n        var prev = this.prevQuad;\r\n        var first = this.firstQuad;\r\n\r\n        if (index > 0 && prev[4])\r\n        {\r\n            this.batchQuad(tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], tintTL, tintTR, tintBL, tintBR);\r\n        }\r\n        else\r\n        {\r\n            first[0] = tlX;\r\n            first[1] = tlY;\r\n            first[2] = blX;\r\n            first[3] = blY;\r\n            first[4] = 1;\r\n        }\r\n\r\n        if (closePath && first[4])\r\n        {\r\n            //  Add a join for the final path segment\r\n            this.batchQuad(brX, brY, trX, trY, first[0], first[1], first[2], first[3], tintTL, tintTR, tintBL, tintBR);\r\n        }\r\n        else\r\n        {\r\n            //  Store it\r\n\r\n            prev[0] = brX;\r\n            prev[1] = brY;\r\n            prev[2] = trX;\r\n            prev[3] = trY;\r\n            prev[4] = 1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a single vertex to the current vertex buffer and increments the\r\n     * `vertexCount` property by 1.\r\n     *\r\n     * This method is called directly by `batchTri` and `batchQuad`.\r\n     *\r\n     * It does not perform any batch limit checking itself, so if you need to call\r\n     * this method directly, do so in the same way that `batchQuad` does, for example.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchVert\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The vertex x position.\r\n     * @param {number} y - The vertex y position.\r\n     * @param {number} tint - The tint color value.\r\n     */\r\n    batchVert: function (x, y, tint)\r\n    {\r\n        var vertexViewF32 = this.vertexViewF32;\r\n        var vertexViewU32 = this.vertexViewU32;\r\n\r\n        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;\r\n\r\n        vertexViewF32[++vertexOffset] = x;\r\n        vertexViewF32[++vertexOffset] = y;\r\n        vertexViewU32[++vertexOffset] = tint;\r\n\r\n        this.vertexCount++;\r\n    },\r\n\r\n    /**\r\n     * Adds the vertices data into the batch and flushes if full.\r\n     *\r\n     * Assumes 6 vertices in the following arrangement:\r\n     *\r\n     * ```\r\n     * 0----3\r\n     * |\\  B|\r\n     * | \\  |\r\n     * |  \\ |\r\n     * | A \\|\r\n     * |    \\\r\n     * 1----2\r\n     * ```\r\n     *\r\n     * Where tx0/ty0 = 0, tx1/ty1 = 1, tx2/ty2 = 2 and tx3/ty3 = 3\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchQuad\r\n     * @override\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x0 - The top-left x position.\r\n     * @param {number} y0 - The top-left y position.\r\n     * @param {number} x1 - The bottom-left x position.\r\n     * @param {number} y1 - The bottom-left y position.\r\n     * @param {number} x2 - The bottom-right x position.\r\n     * @param {number} y2 - The bottom-right y position.\r\n     * @param {number} x3 - The top-right x position.\r\n     * @param {number} y3 - The top-right y position.\r\n     * @param {number} tintTL - The top-left tint color value.\r\n     * @param {number} tintTR - The top-right tint color value.\r\n     * @param {number} tintBL - The bottom-left tint color value.\r\n     * @param {number} tintBR - The bottom-right tint color value.\r\n     *\r\n     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n     */\r\n    batchQuad: function (x0, y0, x1, y1, x2, y2, x3, y3, tintTL, tintTR, tintBL, tintBR)\r\n    {\r\n        var hasFlushed = false;\r\n\r\n        if (this.shouldFlush(6))\r\n        {\r\n            this.flush();\r\n\r\n            hasFlushed = true;\r\n        }\r\n\r\n        this.batchVert(x0, y0, tintTL);\r\n        this.batchVert(x1, y1, tintBL);\r\n        this.batchVert(x2, y2, tintBR);\r\n        this.batchVert(x0, y0, tintTL);\r\n        this.batchVert(x2, y2, tintBR);\r\n        this.batchVert(x3, y3, tintTR);\r\n\r\n        return hasFlushed;\r\n    },\r\n\r\n    /**\r\n     * Adds the vertices data into the batch and flushes if full.\r\n     *\r\n     * Assumes 3 vertices in the following arrangement:\r\n     *\r\n     * ```\r\n     * 0\r\n     * |\\\r\n     * | \\\r\n     * |  \\\r\n     * |   \\\r\n     * |    \\\r\n     * 1-----2\r\n     * ```\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#batchTri\r\n     * @override\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x1 - The bottom-left x position.\r\n     * @param {number} y1 - The bottom-left y position.\r\n     * @param {number} x2 - The bottom-right x position.\r\n     * @param {number} y2 - The bottom-right y position.\r\n     * @param {number} x3 - The top-right x position.\r\n     * @param {number} y3 - The top-right y position.\r\n     * @param {number} tintTL - The top-left tint color value.\r\n     * @param {number} tintTR - The top-right tint color value.\r\n     * @param {number} tintBL - The bottom-left tint color value.\r\n     *\r\n     * @return {boolean} `true` if this method caused the batch to flush, otherwise `false`.\r\n     */\r\n    batchTri: function (x0, y0, x1, y1, x2, y2, tintTL, tintTR, tintBL)\r\n    {\r\n        var hasFlushed = false;\r\n\r\n        if (this.shouldFlush(3))\r\n        {\r\n            this.flush();\r\n\r\n            hasFlushed = true;\r\n        }\r\n\r\n        this.batchVert(x0, y0, tintTL);\r\n        this.batchVert(x1, y1, tintTR);\r\n        this.batchVert(x2, y2, tintBL);\r\n\r\n        return hasFlushed;\r\n    },\r\n\r\n    /**\r\n     * Destroys all shader instances, removes all object references and nulls all external references.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.GraphicsPipeline#destroy\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        WebGLPipeline.prototype.destroy.call(this);\r\n\r\n        this.polygonCache = null;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = GraphicsPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LightShaderSourceFS = require('../shaders/Light-frag.js');\r\nvar MultiPipeline = require('./MultiPipeline');\r\nvar Vec2 = require('../../../math/Vector2');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\nvar LIGHT_COUNT = 10;\r\nvar tempVec2 = new Vec2();\r\n\r\n/**\r\n * @classdesc\r\n * The Light Pipeline is an extension of the Multi Pipeline and uses a custom shader\r\n * designed to handle forward diffused rendering of 2D lights in a Scene.\r\n *\r\n * The shader works in tandem with Light Game Objects, and optionally texture normal maps,\r\n * to provide an ambient illumination effect.\r\n *\r\n * If you wish to provide your own shader, you can use the `%LIGHT_COUNT%` declaration in the source,\r\n * and it will be automatically replaced at run-time with the total number of configured lights.\r\n *\r\n * The maximum number of lights can be set in the Render Config `maxLights` property and defaults to 10.\r\n *\r\n * Prior to Phaser v3.50 this pipeline was called the `ForwardDiffuseLightPipeline`.\r\n *\r\n * The fragment shader it uses can be found in `shaders/src/Light.frag`.\r\n * The vertex shader it uses can be found in `shaders/src/Multi.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2, offset 0)\r\n * `inTexCoord` (vec2, offset 8)\r\n * `inTexId` (float, offset 16)\r\n * `inTintEffect` (float, offset 20)\r\n * `inTint` (vec4, offset 24, normalized)\r\n *\r\n * The default shader uniforms for this pipeline are those from the Multi Pipeline, plus:\r\n *\r\n * `uMainSampler` (sampler2D)\r\n * `uNormSampler` (sampler2D)\r\n * `uCamera` (vec4)\r\n * `uResolution` (vec2)\r\n * `uAmbientLightColor` (vec3)\r\n * `uInverseRotationMatrix` (mat3)\r\n * `uLights` (Light struct)\r\n *\r\n * @class LightPipeline\r\n * @extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar LightPipeline = new Class({\r\n\r\n    Extends: MultiPipeline,\r\n\r\n    initialize:\r\n\r\n    function LightPipeline (config)\r\n    {\r\n        LIGHT_COUNT = config.game.renderer.config.maxLights;\r\n\r\n        var fragShader = GetFastValue(config, 'fragShader', LightShaderSourceFS);\r\n\r\n        var shaders = [];\r\n\r\n        for (var i = 1; i <= LIGHT_COUNT; i++)\r\n        {\r\n            shaders.push({\r\n                name: 'lights' + i,\r\n                fragShader: fragShader.replace('%LIGHT_COUNT%', i.toString())\r\n            });\r\n        }\r\n\r\n        config.shaders = shaders;\r\n\r\n        MultiPipeline.call(this, config);\r\n\r\n        /**\r\n         * Inverse rotation matrix for normal map rotations.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.LightPipeline#inverseRotationMatrix\r\n         * @type {Float32Array}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this.inverseRotationMatrix = new Float32Array([\r\n            1, 0, 0,\r\n            0, 1, 0,\r\n            0, 0, 1\r\n        ]);\r\n\r\n        /**\r\n         * Stores a default normal map, which is an object with a `glTexture` property that\r\n         * maps to a 1x1 texture of the color #7f7fff created in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.LightPipeline#defaultNormalMap\r\n         * @type {object}\r\n         * @since 3.50.0\r\n         */\r\n        this.defaultNormalMap;\r\n\r\n        /**\r\n         * A boolean that is set automatically during `onRender` that determines\r\n         * if the Scene LightManager is active, or not.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.LightPipeline#lightsActive\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.53.0\r\n         */\r\n        this.lightsActive = true;\r\n    },\r\n\r\n    /**\r\n     * Called when the Game has fully booted and the Renderer has finished setting up.\r\n     *\r\n     * By this stage all Game level systems are now in place and you can perform any final\r\n     * tasks that the pipeline may need that relied on game systems such as the Texture Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#boot\r\n     * @since 3.11.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        WebGLPipeline.prototype.boot.call(this);\r\n\r\n        var gl = this.gl;\r\n\r\n        var tempTexture = gl.createTexture();\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, tempTexture);\r\n\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([ 127, 127, 255, 255 ]));\r\n\r\n        this.defaultNormalMap = { glTexture: tempTexture };\r\n\r\n        //  Set the lights shaders\r\n        for (var i = 0; i < this.shaders.length; i++)\r\n        {\r\n            this['lightShader' + (i + 1)] = this.shaders[i];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This function sets all the needed resources for each camera pass.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#onRender\r\n     * @ignore\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene being rendered.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera being rendered with.\r\n     */\r\n    onRender: function (scene, camera)\r\n    {\r\n        var lightManager = scene.sys.lights;\r\n\r\n        this.lightsActive = false;\r\n\r\n        if (!lightManager || !lightManager.active)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var lights = lightManager.getLights(camera);\r\n        var lightsCount = lights.length;\r\n\r\n        if (lightsCount === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Ok, we're good to go ...\r\n\r\n        this.lightsActive = true;\r\n\r\n        this.setShader(this['lightShader' + lightsCount], true);\r\n\r\n        var i;\r\n        var renderer = this.renderer;\r\n        var height = renderer.height;\r\n        var cameraMatrix = camera.matrix;\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1i('uNormSampler', 1);\r\n        this.set2f('uResolution', this.width / 2, this.height / 2);\r\n        this.set4f('uCamera', camera.x, camera.y, camera.rotation, camera.zoom);\r\n        this.set3f('uAmbientLightColor', lightManager.ambientColor.r, lightManager.ambientColor.g, lightManager.ambientColor.b);\r\n\r\n        for (i = 0; i < lightsCount; i++)\r\n        {\r\n            var light = lights[i].light;\r\n            var color = light.color;\r\n\r\n            var lightName = 'uLights[' + i + '].';\r\n\r\n            cameraMatrix.transformPoint(light.x, light.y, tempVec2);\r\n\r\n            this.set2f(lightName + 'position', tempVec2.x - (camera.scrollX * light.scrollFactorX * camera.zoom), height - (tempVec2.y - (camera.scrollY * light.scrollFactorY) * camera.zoom));\r\n            this.set3f(lightName + 'color', color.r, color.g, color.b);\r\n            this.set1f(lightName + 'intensity', light.intensity);\r\n            this.set1f(lightName + 'radius', light.radius);\r\n        }\r\n\r\n        this.currentNormalMapRotation = null;\r\n    },\r\n\r\n    /**\r\n     * Rotates the normal map vectors inversely by the given angle.\r\n     * Only works in 2D space.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#setNormalMapRotation\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} rotation - The angle of rotation in radians.\r\n     */\r\n    setNormalMapRotation: function (rotation)\r\n    {\r\n        if (rotation !== this.currentNormalMapRotation || this.vertexCount === 0)\r\n        {\r\n            if (this.vertexCount > 0)\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            var inverseRotationMatrix = this.inverseRotationMatrix;\r\n\r\n            if (rotation)\r\n            {\r\n                var rot = -rotation;\r\n                var c = Math.cos(rot);\r\n                var s = Math.sin(rot);\r\n\r\n                inverseRotationMatrix[1] = s;\r\n                inverseRotationMatrix[3] = -s;\r\n                inverseRotationMatrix[0] = inverseRotationMatrix[4] = c;\r\n            }\r\n            else\r\n            {\r\n                inverseRotationMatrix[0] = inverseRotationMatrix[4] = 1;\r\n                inverseRotationMatrix[1] = inverseRotationMatrix[3] = 0;\r\n            }\r\n\r\n            this.setMatrix3fv('uInverseRotationMatrix', false, inverseRotationMatrix);\r\n\r\n            this.currentNormalMapRotation = rotation;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Assigns a texture to the current batch. If a different texture is already set it creates a new batch object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#setTexture2D\r\n     * @ignore\r\n     * @since 3.50.0\r\n     *\r\n     * @param {WebGLTexture} [texture] - WebGLTexture that will be assigned to the current batch. If not given uses blankTexture.\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object being rendered or added to the batch.\r\n     */\r\n    setTexture2D: function (texture, gameObject)\r\n    {\r\n        var renderer = this.renderer;\r\n\r\n        if (texture === undefined) { texture = renderer.tempTextures[0]; }\r\n\r\n        var normalTexture = this.getNormalMap(gameObject);\r\n\r\n        if (renderer.isNewNormalMap(texture, normalTexture))\r\n        {\r\n            this.flush();\r\n\r\n            renderer.setTextureZero(texture);\r\n            renderer.setNormalMap(normalTexture);\r\n        }\r\n\r\n        var rotation = (gameObject) ? gameObject.rotation : 0;\r\n\r\n        this.setNormalMapRotation(rotation);\r\n\r\n        this.currentUnit = 0;\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Custom pipelines can use this method in order to perform any required pre-batch tasks\r\n     * for the given Game Object. It must return the texture unit the Game Object was assigned.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#setGameObject\r\n     * @ignore\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object being rendered or added to the batch.\r\n     * @param {Phaser.Textures.Frame} [frame] - Optional frame to use. Can override that of the Game Object.\r\n     *\r\n     * @return {number} The texture unit the Game Object has been assigned.\r\n     */\r\n    setGameObject: function (gameObject, frame)\r\n    {\r\n        if (frame === undefined) { frame = gameObject.frame; }\r\n\r\n        var renderer = this.renderer;\r\n        var texture = frame.glTexture;\r\n        var normalTexture = this.getNormalMap(gameObject);\r\n\r\n        if (renderer.isNewNormalMap())\r\n        {\r\n            this.flush();\r\n\r\n            renderer.setTextureZero(texture);\r\n            renderer.setNormalMap(normalTexture);\r\n        }\r\n\r\n        this.setNormalMapRotation(gameObject.rotation);\r\n\r\n        this.currentUnit = 0;\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns the normal map WebGLTexture from the given Game Object.\r\n     * If the Game Object doesn't have one, it returns the default normal map from this pipeline instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#getNormalMap\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object to get the normal map from.\r\n     *\r\n     * @return {WebGLTexture} The normal map texture.\r\n     */\r\n    getNormalMap: function (gameObject)\r\n    {\r\n        var normalTexture;\r\n\r\n        if (!gameObject)\r\n        {\r\n            normalTexture = this.defaultNormalMap;\r\n        }\r\n        else if (gameObject.displayTexture)\r\n        {\r\n            normalTexture = gameObject.displayTexture.dataSource[gameObject.displayFrame.sourceIndex];\r\n        }\r\n        else if (gameObject.texture)\r\n        {\r\n            normalTexture = gameObject.texture.dataSource[gameObject.frame.sourceIndex];\r\n        }\r\n        else if (gameObject.tileset)\r\n        {\r\n            if (Array.isArray(gameObject.tileset))\r\n            {\r\n                normalTexture = gameObject.tileset[0].image.dataSource[0];\r\n            }\r\n            else\r\n            {\r\n                normalTexture = gameObject.tileset.image.dataSource[0];\r\n            }\r\n        }\r\n\r\n        if (!normalTexture)\r\n        {\r\n            normalTexture = this.defaultNormalMap;\r\n        }\r\n\r\n        return normalTexture.glTexture;\r\n    },\r\n\r\n    /**\r\n     * Takes a Sprite Game Object, or any object that extends it, and adds it to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#batchSprite\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.GameObjects.Image|Phaser.GameObjects.Sprite)} gameObject - The texture based Game Object to add to the batch.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n     */\r\n    batchSprite: function (gameObject, camera, parentTransformMatrix)\r\n    {\r\n        if (this.lightsActive)\r\n        {\r\n            MultiPipeline.prototype.batchSprite.call(this, gameObject, camera, parentTransformMatrix);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Generic function for batching a textured quad using argument values instead of a Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#batchTexture\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject.\r\n     * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad.\r\n     * @param {number} textureWidth - Real texture width.\r\n     * @param {number} textureHeight - Real texture height.\r\n     * @param {number} srcX - X coordinate of the quad.\r\n     * @param {number} srcY - Y coordinate of the quad.\r\n     * @param {number} srcWidth - Width of the quad.\r\n     * @param {number} srcHeight - Height of the quad.\r\n     * @param {number} scaleX - X component of scale.\r\n     * @param {number} scaleY - Y component of scale.\r\n     * @param {number} rotation - Rotation of the quad.\r\n     * @param {boolean} flipX - Indicates if the quad is horizontally flipped.\r\n     * @param {boolean} flipY - Indicates if the quad is vertically flipped.\r\n     * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll.\r\n     * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll.\r\n     * @param {number} displayOriginX - Horizontal origin in pixels.\r\n     * @param {number} displayOriginY - Vertical origin in pixels.\r\n     * @param {number} frameX - X coordinate of the texture frame.\r\n     * @param {number} frameY - Y coordinate of the texture frame.\r\n     * @param {number} frameWidth - Width of the texture frame.\r\n     * @param {number} frameHeight - Height of the texture frame.\r\n     * @param {number} tintTL - Tint for top left.\r\n     * @param {number} tintTR - Tint for top right.\r\n     * @param {number} tintBL - Tint for bottom left.\r\n     * @param {number} tintBR - Tint for bottom right.\r\n     * @param {number} tintEffect - The tint effect.\r\n     * @param {number} uOffset - Horizontal offset on texture coordinate.\r\n     * @param {number} vOffset - Vertical offset on texture coordinate.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container.\r\n     * @param {boolean} [skipFlip=false] - Skip the renderTexture check.\r\n     * @param {number} [textureUnit] - Use the currently bound texture unit?\r\n     */\r\n    batchTexture: function (\r\n        gameObject,\r\n        texture,\r\n        textureWidth, textureHeight,\r\n        srcX, srcY,\r\n        srcWidth, srcHeight,\r\n        scaleX, scaleY,\r\n        rotation,\r\n        flipX, flipY,\r\n        scrollFactorX, scrollFactorY,\r\n        displayOriginX, displayOriginY,\r\n        frameX, frameY, frameWidth, frameHeight,\r\n        tintTL, tintTR, tintBL, tintBR, tintEffect,\r\n        uOffset, vOffset,\r\n        camera,\r\n        parentTransformMatrix,\r\n        skipFlip,\r\n        textureUnit)\r\n    {\r\n        if (this.lightsActive)\r\n        {\r\n            MultiPipeline.prototype.batchTexture.call(\r\n                this,\r\n                gameObject,\r\n                texture,\r\n                textureWidth, textureHeight,\r\n                srcX, srcY,\r\n                srcWidth, srcHeight,\r\n                scaleX, scaleY,\r\n                rotation,\r\n                flipX, flipY,\r\n                scrollFactorX, scrollFactorY,\r\n                displayOriginX, displayOriginY,\r\n                frameX, frameY, frameWidth, frameHeight,\r\n                tintTL, tintTR, tintBL, tintBR, tintEffect,\r\n                uOffset, vOffset,\r\n                camera,\r\n                parentTransformMatrix,\r\n                skipFlip,\r\n                textureUnit\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Frame into the batch for rendering.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.LightPipeline#batchTextureFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} frame - The Texture Frame to be rendered.\r\n     * @param {number} x - The horizontal position to render the texture at.\r\n     * @param {number} y - The vertical position to render the texture at.\r\n     * @param {number} tint - The tint color.\r\n     * @param {number} alpha - The alpha value.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} transformMatrix - The Transform Matrix to use for the texture.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - A parent Transform Matrix.\r\n     */\r\n    batchTextureFrame: function (\r\n        frame,\r\n        x, y,\r\n        tint, alpha,\r\n        transformMatrix,\r\n        parentTransformMatrix\r\n    )\r\n    {\r\n        if (this.lightsActive)\r\n        {\r\n            MultiPipeline.prototype.batchTextureFrame.call(\r\n                this,\r\n                frame,\r\n                x, y,\r\n                tint, alpha,\r\n                transformMatrix,\r\n                parentTransformMatrix\r\n            );\r\n        }\r\n    }\r\n\r\n});\r\n\r\nLightPipeline.LIGHT_COUNT = LIGHT_COUNT;\r\n\r\nmodule.exports = LightPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ShaderSourceFS = require('../shaders/Multi-frag.js');\r\nvar ShaderSourceVS = require('../shaders/Multi-vert.js');\r\nvar TransformMatrix = require('../../../gameobjects/components/TransformMatrix');\r\nvar Utils = require('../Utils');\r\nvar WEBGL_CONST = require('../const');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Multi Pipeline is the core 2D texture rendering pipeline used by Phaser in WebGL.\r\n * Virtually all Game Objects use this pipeline by default, including Sprites, Graphics\r\n * and Tilemaps. It handles the batching of quads and tris, as well as methods for\r\n * drawing and batching geometry data.\r\n *\r\n * Prior to Phaser v3.50 this pipeline was called the `TextureTintPipeline`.\r\n *\r\n * In previous versions of Phaser only one single texture unit was supported at any one time.\r\n * The Multi Pipeline is an evolution of the old Texture Tint Pipeline, updated to support\r\n * multi-textures for increased performance.\r\n *\r\n * The fragment shader it uses can be found in `shaders/src/Multi.frag`.\r\n * The vertex shader it uses can be found in `shaders/src/Multi.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2, offset 0)\r\n * `inTexCoord` (vec2, offset 8)\r\n * `inTexId` (float, offset 16)\r\n * `inTintEffect` (float, offset 20)\r\n * `inTint` (vec4, offset 24, normalized)\r\n *\r\n * The default shader uniforms for this pipeline are:\r\n *\r\n * `uProjectionMatrix` (mat4)\r\n * `uMainSampler` (sampler2D array)\r\n *\r\n * If you wish to create a custom pipeline extending from this one, you can use two string\r\n * declarations in your fragment shader source: `%count%` and `%forloop%`, where `count` is\r\n * used to set the number of `sampler2Ds` available, and `forloop` is a block of GLSL code\r\n * that will get the currently bound texture unit.\r\n *\r\n * This pipeline will automatically inject that code for you, should those values exist\r\n * in your shader source. If you wish to handle this yourself, you can also use the\r\n * function `Utils.parseFragmentShaderMaxTextures`.\r\n *\r\n * If you wish to create a pipeline that works from a single texture, or that doesn't have\r\n * internal texture iteration, please see the `SinglePipeline` instead.\r\n *\r\n * @class MultiPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar MultiPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function MultiPipeline (config)\r\n    {\r\n        var renderer = config.game.renderer;\r\n\r\n        var fragmentShaderSource = GetFastValue(config, 'fragShader', ShaderSourceFS);\r\n\r\n        config.fragShader = Utils.parseFragmentShaderMaxTextures(fragmentShaderSource, renderer.maxTextures);\r\n        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inTexCoord',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inTexId'\r\n            },\r\n            {\r\n                name: 'inTintEffect'\r\n            },\r\n            {\r\n                name: 'inTint',\r\n                size: 4,\r\n                type: WEBGL_CONST.UNSIGNED_BYTE,\r\n                normalized: true\r\n            }\r\n        ]);\r\n\r\n        WebGLPipeline.call(this, config);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.11.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching by the\r\n         * Shape Game Objects.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#calcMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.55.0\r\n         */\r\n        this.calcMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * Used internally to draw stroked triangles.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#tempTriangle\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.tempTriangle = [\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 },\r\n            { x: 0, y: 0, width: 0 }\r\n        ];\r\n\r\n        /**\r\n         * Cached stroke tint.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#strokeTint\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 };\r\n\r\n        /**\r\n         * Cached fill tint.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#fillTint\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 };\r\n\r\n        /**\r\n         * Internal texture frame reference.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#currentFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 };\r\n\r\n        /**\r\n         * Internal path quad cache.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#firstQuad\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.firstQuad = [ 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * Internal path quad cache.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#prevQuad\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.prevQuad = [ 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * Used internally for triangulating a polygon.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.MultiPipeline#polygonCache\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.55.0\r\n         */\r\n        this.polygonCache = [];\r\n    },\r\n\r\n    /**\r\n     * Called every time the pipeline is bound by the renderer.\r\n     * Sets the shader program, vertex buffer and other resources.\r\n     * Should only be called when changing pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#bind\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This WebGLPipeline instance.\r\n     */\r\n    boot: function ()\r\n    {\r\n        WebGLPipeline.prototype.boot.call(this);\r\n\r\n        this.currentShader.set1iv('uMainSampler', this.renderer.textureIndexes);\r\n    },\r\n\r\n    /**\r\n     * Takes a Sprite Game Object, or any object that extends it, and adds it to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.Image|Phaser.GameObjects.Sprite)} gameObject - The texture based Game Object to add to the batch.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n     */\r\n    batchSprite: function (gameObject, camera, parentTransformMatrix)\r\n    {\r\n        this.manager.set(this, gameObject);\r\n\r\n        var camMatrix = this._tempMatrix1;\r\n        var spriteMatrix = this._tempMatrix2;\r\n        var calcMatrix = this._tempMatrix3;\r\n\r\n        var frame = gameObject.frame;\r\n        var texture = frame.glTexture;\r\n\r\n        var u0 = frame.u0;\r\n        var v0 = frame.v0;\r\n        var u1 = frame.u1;\r\n        var v1 = frame.v1;\r\n        var frameX = frame.x;\r\n        var frameY = frame.y;\r\n        var frameWidth = frame.cutWidth;\r\n        var frameHeight = frame.cutHeight;\r\n        var customPivot = frame.customPivot;\r\n\r\n        var displayOriginX = gameObject.displayOriginX;\r\n        var displayOriginY = gameObject.displayOriginY;\r\n\r\n        var x = -displayOriginX + frameX;\r\n        var y = -displayOriginY + frameY;\r\n\r\n        if (gameObject.isCropped)\r\n        {\r\n            var crop = gameObject._crop;\r\n\r\n            if (crop.flipX !== gameObject.flipX || crop.flipY !== gameObject.flipY)\r\n            {\r\n                frame.updateCropUVs(crop, gameObject.flipX, gameObject.flipY);\r\n            }\r\n\r\n            u0 = crop.u0;\r\n            v0 = crop.v0;\r\n            u1 = crop.u1;\r\n            v1 = crop.v1;\r\n\r\n            frameWidth = crop.width;\r\n            frameHeight = crop.height;\r\n\r\n            frameX = crop.x;\r\n            frameY = crop.y;\r\n\r\n            x = -displayOriginX + frameX;\r\n            y = -displayOriginY + frameY;\r\n        }\r\n\r\n        var flipX = 1;\r\n        var flipY = 1;\r\n\r\n        if (gameObject.flipX)\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                x += (-frame.realWidth + (displayOriginX * 2));\r\n            }\r\n\r\n            flipX = -1;\r\n        }\r\n\r\n        //  Auto-invert the flipY if this is coming from a GLTexture\r\n\r\n        if (gameObject.flipY || (frame.source.isGLTexture && !texture.flipY))\r\n        {\r\n            if (!customPivot)\r\n            {\r\n                y += (-frame.realHeight + (displayOriginY * 2));\r\n            }\r\n\r\n            flipY = -1;\r\n        }\r\n\r\n        spriteMatrix.applyITRS(gameObject.x, gameObject.y, gameObject.rotation, gameObject.scaleX * flipX, gameObject.scaleY * flipY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * gameObject.scrollFactorX, -camera.scrollY * gameObject.scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            spriteMatrix.e = gameObject.x;\r\n            spriteMatrix.f = gameObject.y;\r\n        }\r\n        else\r\n        {\r\n            spriteMatrix.e -= camera.scrollX * gameObject.scrollFactorX;\r\n            spriteMatrix.f -= camera.scrollY * gameObject.scrollFactorY;\r\n        }\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n\r\n        var xw = x + frameWidth;\r\n        var yh = y + frameHeight;\r\n\r\n        var roundPixels = camera.roundPixels;\r\n\r\n        var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n        var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n        var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n        var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n        var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n        var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n        var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n        var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n        var getTint = Utils.getTintAppendFloatAlpha;\r\n        var cameraAlpha = camera.alpha;\r\n\r\n        var tintTL = getTint(gameObject.tintTopLeft, cameraAlpha * gameObject._alphaTL);\r\n        var tintTR = getTint(gameObject.tintTopRight, cameraAlpha * gameObject._alphaTR);\r\n        var tintBL = getTint(gameObject.tintBottomLeft, cameraAlpha * gameObject._alphaBL);\r\n        var tintBR = getTint(gameObject.tintBottomRight, cameraAlpha * gameObject._alphaBR);\r\n\r\n        if (this.shouldFlush(6))\r\n        {\r\n            this.flush();\r\n        }\r\n\r\n        var unit = this.setGameObject(gameObject, frame);\r\n\r\n        this.manager.preBatch(gameObject);\r\n\r\n        this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, gameObject.tintFill, texture, unit);\r\n\r\n        this.manager.postBatch(gameObject);\r\n    },\r\n\r\n    /**\r\n     * Generic function for batching a textured quad using argument values instead of a Game Object.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Source GameObject.\r\n     * @param {WebGLTexture} texture - Raw WebGLTexture associated with the quad.\r\n     * @param {number} textureWidth - Real texture width.\r\n     * @param {number} textureHeight - Real texture height.\r\n     * @param {number} srcX - X coordinate of the quad.\r\n     * @param {number} srcY - Y coordinate of the quad.\r\n     * @param {number} srcWidth - Width of the quad.\r\n     * @param {number} srcHeight - Height of the quad.\r\n     * @param {number} scaleX - X component of scale.\r\n     * @param {number} scaleY - Y component of scale.\r\n     * @param {number} rotation - Rotation of the quad.\r\n     * @param {boolean} flipX - Indicates if the quad is horizontally flipped.\r\n     * @param {boolean} flipY - Indicates if the quad is vertically flipped.\r\n     * @param {number} scrollFactorX - By which factor is the quad affected by the camera horizontal scroll.\r\n     * @param {number} scrollFactorY - By which factor is the quad effected by the camera vertical scroll.\r\n     * @param {number} displayOriginX - Horizontal origin in pixels.\r\n     * @param {number} displayOriginY - Vertical origin in pixels.\r\n     * @param {number} frameX - X coordinate of the texture frame.\r\n     * @param {number} frameY - Y coordinate of the texture frame.\r\n     * @param {number} frameWidth - Width of the texture frame.\r\n     * @param {number} frameHeight - Height of the texture frame.\r\n     * @param {number} tintTL - Tint for top left.\r\n     * @param {number} tintTR - Tint for top right.\r\n     * @param {number} tintBL - Tint for bottom left.\r\n     * @param {number} tintBR - Tint for bottom right.\r\n     * @param {number} tintEffect - The tint effect.\r\n     * @param {number} uOffset - Horizontal offset on texture coordinate.\r\n     * @param {number} vOffset - Vertical offset on texture coordinate.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - Current used camera.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentTransformMatrix - Parent container.\r\n     * @param {boolean} [skipFlip=false] - Skip the renderTexture check.\r\n     * @param {number} [textureUnit] - Use the currently bound texture unit?\r\n     */\r\n    batchTexture: function (\r\n        gameObject,\r\n        texture,\r\n        textureWidth, textureHeight,\r\n        srcX, srcY,\r\n        srcWidth, srcHeight,\r\n        scaleX, scaleY,\r\n        rotation,\r\n        flipX, flipY,\r\n        scrollFactorX, scrollFactorY,\r\n        displayOriginX, displayOriginY,\r\n        frameX, frameY, frameWidth, frameHeight,\r\n        tintTL, tintTR, tintBL, tintBR, tintEffect,\r\n        uOffset, vOffset,\r\n        camera,\r\n        parentTransformMatrix,\r\n        skipFlip,\r\n        textureUnit)\r\n    {\r\n        this.manager.set(this, gameObject);\r\n\r\n        var camMatrix = this._tempMatrix1;\r\n        var spriteMatrix = this._tempMatrix2;\r\n        var calcMatrix = this._tempMatrix3;\r\n\r\n        var u0 = (frameX / textureWidth) + uOffset;\r\n        var v0 = (frameY / textureHeight) + vOffset;\r\n        var u1 = (frameX + frameWidth) / textureWidth + uOffset;\r\n        var v1 = (frameY + frameHeight) / textureHeight + vOffset;\r\n\r\n        var width = srcWidth;\r\n        var height = srcHeight;\r\n\r\n        var x = -displayOriginX;\r\n        var y = -displayOriginY;\r\n\r\n        if (gameObject.isCropped)\r\n        {\r\n            var crop = gameObject._crop;\r\n\r\n            var cropWidth = crop.width;\r\n            var cropHeight = crop.height;\r\n\r\n            width = cropWidth;\r\n            height = cropHeight;\r\n\r\n            srcWidth = cropWidth;\r\n            srcHeight = cropHeight;\r\n\r\n            frameX = crop.x;\r\n            frameY = crop.y;\r\n\r\n            var ox = frameX;\r\n            var oy = frameY;\r\n\r\n            if (flipX)\r\n            {\r\n                ox = (frameWidth - crop.x - cropWidth);\r\n            }\r\n\r\n            if (flipY)\r\n            {\r\n                oy = (frameHeight - crop.y - cropHeight);\r\n            }\r\n\r\n            u0 = (ox / textureWidth) + uOffset;\r\n            v0 = (oy / textureHeight) + vOffset;\r\n            u1 = (ox + cropWidth) / textureWidth + uOffset;\r\n            v1 = (oy + cropHeight) / textureHeight + vOffset;\r\n\r\n            x = -displayOriginX + frameX;\r\n            y = -displayOriginY + frameY;\r\n        }\r\n\r\n        //  Invert the flipY if this is a RenderTexture\r\n        flipY = flipY ^ (!skipFlip && texture.isRenderTexture ? 1 : 0);\r\n\r\n        if (flipX)\r\n        {\r\n            width *= -1;\r\n            x += srcWidth;\r\n        }\r\n\r\n        if (flipY)\r\n        {\r\n            height *= -1;\r\n            y += srcHeight;\r\n        }\r\n\r\n        var xw = x + width;\r\n        var yh = y + height;\r\n\r\n        spriteMatrix.applyITRS(srcX, srcY, rotation, scaleX, scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            spriteMatrix.e = srcX;\r\n            spriteMatrix.f = srcY;\r\n        }\r\n        else\r\n        {\r\n            spriteMatrix.e -= camera.scrollX * scrollFactorX;\r\n            spriteMatrix.f -= camera.scrollY * scrollFactorY;\r\n        }\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(spriteMatrix, calcMatrix);\r\n\r\n        var roundPixels = camera.roundPixels;\r\n\r\n        var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n        var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n        var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n        var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n        var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n        var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n        var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n        var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n        if (textureUnit === undefined)\r\n        {\r\n            textureUnit = this.renderer.setTexture2D(texture);\r\n        }\r\n\r\n        if (gameObject)\r\n        {\r\n            this.manager.preBatch(gameObject);\r\n        }\r\n\r\n        this.batchQuad(gameObject, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n\r\n        if (gameObject)\r\n        {\r\n            this.manager.postBatch(gameObject);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Texture Frame into the batch for rendering.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchTextureFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} frame - The Texture Frame to be rendered.\r\n     * @param {number} x - The horizontal position to render the texture at.\r\n     * @param {number} y - The vertical position to render the texture at.\r\n     * @param {number} tint - The tint color.\r\n     * @param {number} alpha - The alpha value.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} transformMatrix - The Transform Matrix to use for the texture.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - A parent Transform Matrix.\r\n     */\r\n    batchTextureFrame: function (\r\n        frame,\r\n        x, y,\r\n        tint, alpha,\r\n        transformMatrix,\r\n        parentTransformMatrix\r\n    )\r\n    {\r\n        this.manager.set(this);\r\n\r\n        var spriteMatrix = this._tempMatrix1.copyFrom(transformMatrix);\r\n        var calcMatrix = this._tempMatrix2;\r\n\r\n        var xw = x + frame.width;\r\n        var yh = y + frame.height;\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            spriteMatrix.multiply(parentTransformMatrix, calcMatrix);\r\n        }\r\n        else\r\n        {\r\n            calcMatrix = spriteMatrix;\r\n        }\r\n\r\n        var tx0 = calcMatrix.getX(x, y);\r\n        var ty0 = calcMatrix.getY(x, y);\r\n\r\n        var tx1 = calcMatrix.getX(x, yh);\r\n        var ty1 = calcMatrix.getY(x, yh);\r\n\r\n        var tx2 = calcMatrix.getX(xw, yh);\r\n        var ty2 = calcMatrix.getY(xw, yh);\r\n\r\n        var tx3 = calcMatrix.getX(xw, y);\r\n        var ty3 = calcMatrix.getY(xw, y);\r\n\r\n        var unit = this.renderer.setTextureSource(frame.source);\r\n\r\n        tint = Utils.getTintAppendFloatAlpha(tint, alpha);\r\n\r\n        this.batchQuad(null, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, 0, frame.glTexture, unit);\r\n    },\r\n\r\n    /**\r\n     * Pushes a filled rectangle into the vertex batch.\r\n     *\r\n     * Rectangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchFillRect\r\n     * @since 3.55.0\r\n     *\r\n     * @param {number} x - Horizontal top left coordinate of the rectangle.\r\n     * @param {number} y - Vertical top left coordinate of the rectangle.\r\n     * @param {number} width - Width of the rectangle.\r\n     * @param {number} height - Height of the rectangle.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillRect: function (x, y, width, height, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var xw = x + width;\r\n        var yh = y + height;\r\n\r\n        var x0 = calcMatrix.getX(x, y);\r\n        var y0 = calcMatrix.getY(x, y);\r\n\r\n        var x1 = calcMatrix.getX(x, yh);\r\n        var y1 = calcMatrix.getY(x, yh);\r\n\r\n        var x2 = calcMatrix.getX(xw, yh);\r\n        var y2 = calcMatrix.getY(xw, yh);\r\n\r\n        var x3 = calcMatrix.getX(xw, y);\r\n        var y3 = calcMatrix.getY(xw, y);\r\n\r\n        var tint = this.fillTint;\r\n\r\n        this.batchQuad(null, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, tint.BR, 2);\r\n    },\r\n\r\n    /**\r\n     * Pushes a filled triangle into the vertex batch.\r\n     *\r\n     * Triangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchFillTriangle\r\n     * @since 3.55.0\r\n     *\r\n     * @param {number} x0 - Point 0 x coordinate.\r\n     * @param {number} y0 - Point 0 y coordinate.\r\n     * @param {number} x1 - Point 1 x coordinate.\r\n     * @param {number} y1 - Point 1 y coordinate.\r\n     * @param {number} x2 - Point 2 x coordinate.\r\n     * @param {number} y2 - Point 2 y coordinate.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillTriangle: function (x0, y0, x1, y1, x2, y2, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var tx0 = calcMatrix.getX(x0, y0);\r\n        var ty0 = calcMatrix.getY(x0, y0);\r\n\r\n        var tx1 = calcMatrix.getX(x1, y1);\r\n        var ty1 = calcMatrix.getY(x1, y1);\r\n\r\n        var tx2 = calcMatrix.getX(x2, y2);\r\n        var ty2 = calcMatrix.getY(x2, y2);\r\n\r\n        var tint = this.fillTint;\r\n\r\n        this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tint.TL, tint.TR, tint.BL, 2);\r\n    },\r\n\r\n    /**\r\n     * Pushes a stroked triangle into the vertex batch.\r\n     *\r\n     * Triangle factors in the given transform matrices before adding to the batch.\r\n     *\r\n     * The triangle is created from 3 lines and drawn using the `batchStrokePath` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchStrokeTriangle\r\n     * @since 3.55.0\r\n     *\r\n     * @param {number} x0 - Point 0 x coordinate.\r\n     * @param {number} y0 - Point 0 y coordinate.\r\n     * @param {number} x1 - Point 1 x coordinate.\r\n     * @param {number} y1 - Point 1 y coordinate.\r\n     * @param {number} x2 - Point 2 x coordinate.\r\n     * @param {number} y2 - Point 2 y coordinate.\r\n     * @param {number} lineWidth - The width of the line in pixels.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchStrokeTriangle: function (x0, y0, x1, y1, x2, y2, lineWidth, currentMatrix, parentMatrix)\r\n    {\r\n        var tempTriangle = this.tempTriangle;\r\n\r\n        tempTriangle[0].x = x0;\r\n        tempTriangle[0].y = y0;\r\n        tempTriangle[0].width = lineWidth;\r\n\r\n        tempTriangle[1].x = x1;\r\n        tempTriangle[1].y = y1;\r\n        tempTriangle[1].width = lineWidth;\r\n\r\n        tempTriangle[2].x = x2;\r\n        tempTriangle[2].y = y2;\r\n        tempTriangle[2].width = lineWidth;\r\n\r\n        tempTriangle[3].x = x0;\r\n        tempTriangle[3].y = y0;\r\n        tempTriangle[3].width = lineWidth;\r\n\r\n        this.batchStrokePath(tempTriangle, lineWidth, false, currentMatrix, parentMatrix);\r\n    },\r\n\r\n    /**\r\n     * Adds the given path to the vertex batch for rendering.\r\n     *\r\n     * It works by taking the array of path data and then passing it through Earcut, which\r\n     * creates a list of polygons. Each polygon is then added to the batch.\r\n     *\r\n     * The path is always automatically closed because it's filled.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchFillPath\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like[]} path - Collection of points that represent the path.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchFillPath: function (path, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var length = path.length;\r\n        var polygonCache = this.polygonCache;\r\n        var polygonIndexArray;\r\n        var point;\r\n\r\n        var tintTL = this.fillTint.TL;\r\n        var tintTR = this.fillTint.TR;\r\n        var tintBL = this.fillTint.BL;\r\n\r\n        for (var pathIndex = 0; pathIndex < length; ++pathIndex)\r\n        {\r\n            point = path[pathIndex];\r\n            polygonCache.push(point.x, point.y);\r\n        }\r\n\r\n        polygonIndexArray = Earcut(polygonCache);\r\n        length = polygonIndexArray.length;\r\n\r\n        for (var index = 0; index < length; index += 3)\r\n        {\r\n            var p0 = polygonIndexArray[index + 0] * 2;\r\n            var p1 = polygonIndexArray[index + 1] * 2;\r\n            var p2 = polygonIndexArray[index + 2] * 2;\r\n\r\n            var x0 = polygonCache[p0 + 0];\r\n            var y0 = polygonCache[p0 + 1];\r\n            var x1 = polygonCache[p1 + 0];\r\n            var y1 = polygonCache[p1 + 1];\r\n            var x2 = polygonCache[p2 + 0];\r\n            var y2 = polygonCache[p2 + 1];\r\n\r\n            var tx0 = calcMatrix.getX(x0, y0);\r\n            var ty0 = calcMatrix.getY(x0, y0);\r\n\r\n            var tx1 = calcMatrix.getX(x1, y1);\r\n            var ty1 = calcMatrix.getY(x1, y1);\r\n\r\n            var tx2 = calcMatrix.getX(x2, y2);\r\n            var ty2 = calcMatrix.getY(x2, y2);\r\n\r\n            this.batchTri(null, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, tintTL, tintTR, tintBL, 2);\r\n        }\r\n\r\n        polygonCache.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds the given path to the vertex batch for rendering.\r\n     *\r\n     * It works by taking the array of path data and calling `batchLine` for each section\r\n     * of the path.\r\n     *\r\n     * The path is optionally closed at the end.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchStrokePath\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like[]} path - Collection of points that represent the path.\r\n     * @param {number} lineWidth - The width of the line segments in pixels.\r\n     * @param {boolean} pathOpen - Indicates if the path should be closed or left open.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchStrokePath: function (path, lineWidth, pathOpen, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        //  Reset the closePath booleans\r\n        this.prevQuad[4] = 0;\r\n        this.firstQuad[4] = 0;\r\n\r\n        var pathLength = path.length - 1;\r\n\r\n        for (var pathIndex = 0; pathIndex < pathLength; pathIndex++)\r\n        {\r\n            var point0 = path[pathIndex];\r\n            var point1 = path[pathIndex + 1];\r\n\r\n            this.batchLine(\r\n                point0.x,\r\n                point0.y,\r\n                point1.x,\r\n                point1.y,\r\n                point0.width / 2,\r\n                point1.width / 2,\r\n                lineWidth,\r\n                pathIndex,\r\n                !pathOpen && (pathIndex === pathLength - 1),\r\n                currentMatrix,\r\n                parentMatrix\r\n            );\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a line out of 4 quads and adds it to the vertex batch based on the given line values.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.MultiPipeline#batchLine\r\n     * @since 3.55.0\r\n     *\r\n     * @param {number} ax - x coordinate of the start of the line.\r\n     * @param {number} ay - y coordinate of the start of the line.\r\n     * @param {number} bx - x coordinate of the end of the line.\r\n     * @param {number} by - y coordinate of the end of the line.\r\n     * @param {number} aLineWidth - Width of the start of the line.\r\n     * @param {number} bLineWidth - Width of the end of the line.\r\n     * @param {number} index - If this line is part of a multi-line draw, the index of the line in the draw.\r\n     * @param {boolean} closePath - Does this line close a multi-line path?\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} currentMatrix - The current transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - The parent transform.\r\n     */\r\n    batchLine: function (ax, ay, bx, by, aLineWidth, bLineWidth, lineWidth, index, closePath, currentMatrix, parentMatrix)\r\n    {\r\n        this.renderer.pipelines.set(this);\r\n\r\n        var calcMatrix = this.calcMatrix;\r\n\r\n        //  Multiply and store result in calcMatrix, only if the parentMatrix is set, otherwise we'll use whatever values are already in the calcMatrix\r\n        if (parentMatrix)\r\n        {\r\n            parentMatrix.multiply(currentMatrix, calcMatrix);\r\n        }\r\n\r\n        var dx = bx - ax;\r\n        var dy = by - ay;\r\n\r\n        var len = Math.sqrt(dx * dx + dy * dy);\r\n        var al0 = aLineWidth * (by - ay) / len;\r\n        var al1 = aLineWidth * (ax - bx) / len;\r\n        var bl0 = bLineWidth * (by - ay) / len;\r\n        var bl1 = bLineWidth * (ax - bx) / len;\r\n\r\n        var lx0 = bx - bl0;\r\n        var ly0 = by - bl1;\r\n        var lx1 = ax - al0;\r\n        var ly1 = ay - al1;\r\n        var lx2 = bx + bl0;\r\n        var ly2 = by + bl1;\r\n        var lx3 = ax + al0;\r\n        var ly3 = ay + al1;\r\n\r\n        //  tx0 = bottom right\r\n        var brX = calcMatrix.getX(lx0, ly0);\r\n        var brY = calcMatrix.getY(lx0, ly0);\r\n\r\n        //  tx1 = bottom left\r\n        var blX = calcMatrix.getX(lx1, ly1);\r\n        var blY = calcMatrix.getY(lx1, ly1);\r\n\r\n        //  tx2 = top right\r\n        var trX = calcMatrix.getX(lx2, ly2);\r\n        var trY = calcMatrix.getY(lx2, ly2);\r\n\r\n        //  tx3 = top left\r\n        var tlX = calcMatrix.getX(lx3, ly3);\r\n        var tlY = calcMatrix.getY(lx3, ly3);\r\n\r\n        var tint = this.strokeTint;\r\n\r\n        var tintTL = tint.TL;\r\n        var tintTR = tint.TR;\r\n        var tintBL = tint.BL;\r\n        var tintBR = tint.BR;\r\n\r\n        //  TL, BL, BR, TR\r\n        this.batchQuad(null, tlX, tlY, blX, blY, brX, brY, trX, trY, 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);\r\n\r\n        if (lineWidth <= 2)\r\n        {\r\n            //  No point doing a linejoin if the line isn't thick enough\r\n            return;\r\n        }\r\n\r\n        var prev = this.prevQuad;\r\n        var first = this.firstQuad;\r\n\r\n        if (index > 0 && prev[4])\r\n        {\r\n            this.batchQuad(null, tlX, tlY, blX, blY, prev[0], prev[1], prev[2], prev[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);\r\n        }\r\n        else\r\n        {\r\n            first[0] = tlX;\r\n            first[1] = tlY;\r\n            first[2] = blX;\r\n            first[3] = blY;\r\n            first[4] = 1;\r\n        }\r\n\r\n        if (closePath && first[4])\r\n        {\r\n            //  Add a join for the final path segment\r\n            this.batchQuad(null, brX, brY, trX, trY, first[0], first[1], first[2], first[3], 0, 0, 1, 1, tintTL, tintTR, tintBL, tintBR, 2);\r\n        }\r\n        else\r\n        {\r\n            //  Store it\r\n\r\n            prev[0] = brX;\r\n            prev[1] = brY;\r\n            prev[2] = trX;\r\n            prev[3] = trY;\r\n            prev[4] = 1;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar PointLightShaderSourceFS = require('../shaders/PointLight-frag.js');\r\nvar PointLightShaderSourceVS = require('../shaders/PointLight-vert.js');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Point Light Pipeline handles rendering the Point Light Game Objects in WebGL.\r\n *\r\n * The fragment shader it uses can be found in `shaders/src/PointLight.frag`.\r\n * The vertex shader it uses can be found in `shaders/src/PointLight.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2)\r\n * `inLightPosition` (vec2)\r\n * `inLightRadius` (float)\r\n * `inLightAttenuation` (float)\r\n * `inLightColor` (vec4)\r\n *\r\n * The default shader uniforms for this pipeline are:\r\n *\r\n * `uProjectionMatrix` (mat4)\r\n * `uResolution` (vec2)\r\n * `uCameraZoom` (sampler2D)\r\n *\r\n * @class PointLightPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar PointLightPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function PointLightPipeline (config)\r\n    {\r\n        config.vertShader = GetFastValue(config, 'vertShader', PointLightShaderSourceVS);\r\n        config.fragShader = GetFastValue(config, 'fragShader', PointLightShaderSourceFS);\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inLightPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inLightRadius'\r\n            },\r\n            {\r\n                name: 'inLightAttenuation'\r\n            },\r\n            {\r\n                name: 'inLightColor',\r\n                size: 4\r\n            }\r\n        ]);\r\n\r\n        WebGLPipeline.call(this, config);\r\n    },\r\n\r\n    onRender: function (scene, camera)\r\n    {\r\n        this.set2f('uResolution', this.width, this.height);\r\n        this.set1f('uCameraZoom', camera.zoom);\r\n    },\r\n\r\n    /**\r\n     * Adds a Point Light Game Object to the batch, flushing if required.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PointLightPipeline#batchPointLight\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.PointLight} light - The Point Light Game Object.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera rendering the Point Light.\r\n     * @param {number} x0 - The top-left x position.\r\n     * @param {number} y0 - The top-left y position.\r\n     * @param {number} x1 - The bottom-left x position.\r\n     * @param {number} y1 - The bottom-left y position.\r\n     * @param {number} x2 - The bottom-right x position.\r\n     * @param {number} y2 - The bottom-right y position.\r\n     * @param {number} x3 - The top-right x position.\r\n     * @param {number} y3 - The top-right y position.\r\n     * @param {number} lightX - The horizontal center of the light.\r\n     * @param {number} lightY - The vertical center of the light.\r\n     */\r\n    batchPointLight: function (light, camera, x0, y0, x1, y1, x2, y2, x3, y3, lightX, lightY)\r\n    {\r\n        var color = light.color;\r\n        var intensity = light.intensity;\r\n        var radius = light.radius;\r\n        var attenuation = light.attenuation;\r\n\r\n        var r = color.r * intensity;\r\n        var g = color.g * intensity;\r\n        var b = color.b * intensity;\r\n        var a = camera.alpha * light.alpha;\r\n\r\n        if (this.shouldFlush(6))\r\n        {\r\n            this.flush();\r\n        }\r\n\r\n        this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);\r\n        this.batchLightVert(x1, y1, lightX, lightY, radius, attenuation, r, g, b, a);\r\n        this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);\r\n        this.batchLightVert(x0, y0, lightX, lightY, radius, attenuation, r, g, b, a);\r\n        this.batchLightVert(x2, y2, lightX, lightY, radius, attenuation, r, g, b, a);\r\n        this.batchLightVert(x3, y3, lightX, lightY, radius, attenuation, r, g, b, a);\r\n    },\r\n\r\n    /**\r\n     * Adds a single Point Light vertex to the current vertex buffer and increments the\r\n     * `vertexCount` property by 1.\r\n     *\r\n     * This method is called directly by `batchPointLight`.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PointLightPipeline#batchLightVert\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The vertex x position.\r\n     * @param {number} y - The vertex y position.\r\n     * @param {number} lightX - The horizontal center of the light.\r\n     * @param {number} lightY - The vertical center of the light.\r\n     * @param {number} radius - The radius of the light.\r\n     * @param {number} attenuation - The attenuation of the light.\r\n     * @param {number} r - The red color channel of the light.\r\n     * @param {number} g - The green color channel of the light.\r\n     * @param {number} b - The blue color channel of the light.\r\n     * @param {number} a - The alpha color channel of the light.\r\n     */\r\n    batchLightVert: function (x, y, lightX, lightY, radius, attenuation, r, g, b, a)\r\n    {\r\n        var vertexViewF32 = this.vertexViewF32;\r\n\r\n        var vertexOffset = (this.vertexCount * this.currentShader.vertexComponentCount) - 1;\r\n\r\n        vertexViewF32[++vertexOffset] = x;\r\n        vertexViewF32[++vertexOffset] = y;\r\n        vertexViewF32[++vertexOffset] = lightX;\r\n        vertexViewF32[++vertexOffset] = lightY;\r\n        vertexViewF32[++vertexOffset] = radius;\r\n        vertexViewF32[++vertexOffset] = attenuation;\r\n        vertexViewF32[++vertexOffset] = r;\r\n        vertexViewF32[++vertexOffset] = g;\r\n        vertexViewF32[++vertexOffset] = b;\r\n        vertexViewF32[++vertexOffset] = a;\r\n\r\n        this.vertexCount++;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointLightPipeline;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar GetFastValue = require('../../../utils/object/GetFastValue');\nvar MultiPipeline = require('./MultiPipeline');\n\n/**\n * @classdesc\n * The Rope Pipeline is a variation of the Multi Pipeline that uses a `TRIANGLE_STRIP` for\n * its topology, instead of TRIANGLES. This is primarily used by the Rope Game Object,\n * or anything that extends it.\n *\n * Prior to Phaser v3.50 this pipeline was called the `TextureTintStripPipeline`.\n *\n * The fragment shader it uses can be found in `shaders/src/Multi.frag`.\n * The vertex shader it uses can be found in `shaders/src/Multi.vert`.\n *\n * The default shader attributes for this pipeline are:\n *\n * `inPosition` (vec2, offset 0)\n * `inTexCoord` (vec2, offset 8)\n * `inTexId` (float, offset 16)\n * `inTintEffect` (float, offset 20)\n * `inTint` (vec4, offset 24, normalized)\n *\n * The default shader uniforms for this pipeline are:\n *\n * `uProjectionMatrix` (mat4)\n * `uMainSampler` (sampler2D array)\n *\n * The pipeline is structurally identical to the Multi Pipeline and should be treated as such.\n *\n * @class RopePipeline\n * @extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline\n * @memberof Phaser.Renderer.WebGL.Pipelines\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\n */\nvar RopePipeline = new Class({\n\n    Extends: MultiPipeline,\n\n    initialize:\n\n    function RopePipeline (config)\n    {\n        //  GLenum 5 = TRIANGLE_STRIP\n        config.topology = 5;\n        config.batchSize = GetFastValue(config, 'batchSize', 256);\n\n        MultiPipeline.call(this, config);\n    }\n});\n\nmodule.exports = RopePipeline;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar GetFastValue = require('../../../utils/object/GetFastValue');\nvar MultiPipeline = require('./MultiPipeline');\nvar ShaderSourceFS = require('../shaders/Single-frag.js');\nvar ShaderSourceVS = require('../shaders/Single-vert.js');\nvar WebGLPipeline = require('../WebGLPipeline');\n\n/**\n * @classdesc\n * The Single Pipeline is a special version of the Multi Pipeline that only ever\n * uses one texture, bound to texture unit zero. Although not as efficient as the\n * Multi Pipeline, it provides an easier way to create custom pipelines that only require\n * a single bound texture.\n *\n * Prior to Phaser v3.50 this pipeline didn't exist, but could be compared to the old `TextureTintPipeline`.\n *\n * The fragment shader it uses can be found in `shaders/src/Single.frag`.\n * The vertex shader it uses can be found in `shaders/src/Single.vert`.\n *\n * The default shader attributes for this pipeline are:\n *\n * `inPosition` (vec2, offset 0)\n * `inTexCoord` (vec2, offset 8)\n * `inTexId` (float, offset 16) - this value is always zero in the Single Pipeline\n * `inTintEffect` (float, offset 20)\n * `inTint` (vec4, offset 24, normalized)\n *\n * The default shader uniforms for this pipeline are:\n *\n * `uProjectionMatrix` (mat4)\n * `uMainSampler` (sampler2D)\n *\n * @class SinglePipeline\n * @extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline\n * @memberof Phaser.Renderer.WebGL.Pipelines\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\n */\nvar SinglePipeline = new Class({\n\n    Extends: MultiPipeline,\n\n    initialize:\n\n    function SinglePipeline (config)\n    {\n        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS),\n        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS),\n        config.forceZero = true;\n\n        MultiPipeline.call(this, config);\n    },\n\n    boot: function ()\n    {\n        WebGLPipeline.prototype.boot.call(this);\n\n        this.set1i('uMainSampler', 0);\n    }\n\n});\n\nmodule.exports = SinglePipeline;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AddBlendFS = require('../shaders/AddBlend-frag.js');\r\nvar BlendModes = require('../../BlendModes');\r\nvar Class = require('../../../utils/Class');\r\nvar ColorMatrix = require('../../../display/ColorMatrix');\r\nvar ColorMatrixFS = require('../shaders/ColorMatrix-frag.js');\r\nvar CopyFS = require('../shaders/Copy-frag.js');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LinearBlendFS = require('../shaders/LinearBlend-frag.js');\r\nvar QuadVS = require('../shaders/Quad-vert.js');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Utility Pipeline is a special-use pipeline that belongs to the Pipeline Manager.\r\n *\r\n * It provides 4 shaders and handy associated methods:\r\n *\r\n * 1) Copy Shader. A fast texture to texture copy shader with optional brightness setting.\r\n * 2) Additive Blend Mode Shader. Blends two textures using an additive blend mode.\r\n * 3) Linear Blend Mode Shader. Blends two textures using a linear blend mode.\r\n * 4) Color Matrix Copy Shader. Draws a texture to a target using a Color Matrix.\r\n *\r\n * You do not extend this pipeline, but instead get a reference to it from the Pipeline\r\n * Manager via the `setUtility` method. You can also access methods such as `copyFrame`\r\n * directly from the Pipeline Manager.\r\n *\r\n * This pipeline provides methods for manipulating framebuffer backed textures, such as\r\n * copying or blending one texture to another, copying a portion of a texture, additively\r\n * blending two textures, flipping textures and more.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2, offset 0)\r\n * `inTexCoord` (vec2, offset 8)\r\n *\r\n * This pipeline has a hard-coded batch size of 1 and a hard coded set of vertices.\r\n *\r\n * @class UtilityPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar UtilityPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function UtilityPipeline (config)\r\n    {\r\n        config.renderTarget = GetFastValue(config, 'renderTarget', [\r\n            {\r\n                scale: 1\r\n            },\r\n            {\r\n                scale: 1\r\n            },\r\n            {\r\n                scale: 0.5\r\n            },\r\n            {\r\n                scale: 0.5\r\n            }\r\n        ]);\r\n\r\n        config.vertShader = GetFastValue(config, 'vertShader', QuadVS);\r\n\r\n        config.shaders = GetFastValue(config, 'shaders', [\r\n            {\r\n                name: 'Copy',\r\n                fragShader: CopyFS\r\n            },\r\n            {\r\n                name: 'AddBlend',\r\n                fragShader: AddBlendFS\r\n            },\r\n            {\r\n                name: 'LinearBlend',\r\n                fragShader: LinearBlendFS\r\n            },\r\n            {\r\n                name: 'ColorMatrix',\r\n                fragShader: ColorMatrixFS\r\n            }\r\n        ]);\r\n\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inTexCoord',\r\n                size: 2\r\n            }\r\n        ]);\r\n\r\n        config.vertices = [\r\n            -1, -1, 0, 0,\r\n            -1, 1, 0, 1,\r\n            1, 1, 1, 1,\r\n            -1, -1, 0, 0,\r\n            1, 1, 1, 1,\r\n            1, -1, 1, 0\r\n        ];\r\n\r\n        config.batchSize = 1;\r\n\r\n        WebGLPipeline.call(this, config);\r\n\r\n        /**\r\n         * A default Color Matrix, used by the Color Matrix Shader when one\r\n         * isn't provided.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#colorMatrix\r\n         * @type {Phaser.Display.ColorMatrix}\r\n         * @since 3.50.0\r\n         */\r\n        this.colorMatrix = new ColorMatrix();\r\n\r\n        /**\r\n         * A reference to the Copy Shader belonging to this Utility Pipeline.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#copyShader\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.copyShader;\r\n\r\n        /**\r\n         * A reference to the Additive Blend Shader belonging to this Utility Pipeline.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#addShader\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader}\r\n         * @since 3.50.0\r\n         */\r\n        this.addShader;\r\n\r\n        /**\r\n         * A reference to the Linear Blend Shader belonging to this Utility Pipeline.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#linearShader\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader}\r\n         * @since 3.50.0\r\n         */\r\n        this.linearShader;\r\n\r\n        /**\r\n         * A reference to the Color Matrix Shader belonging to this Utility Pipeline.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#colorMatrixShader\r\n         * @type {Phaser.Renderer.WebGL.WebGLShader}\r\n         * @since 3.50.0\r\n         */\r\n        this.colorMatrixShader;\r\n\r\n        /**\r\n         * A reference to the Full Frame 1 Render Target.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#fullFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame1;\r\n\r\n        /**\r\n         * A reference to the Full Frame 2 Render Target.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#fullFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame2;\r\n\r\n        /**\r\n         * A reference to the Half Frame 1 Render Target.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#halfFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame1;\r\n\r\n        /**\r\n         * A reference to the Half Frame 2 Render Target.\r\n         *\r\n         * This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#halfFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame2;\r\n    },\r\n\r\n    boot: function ()\r\n    {\r\n        WebGLPipeline.prototype.boot.call(this);\r\n\r\n        var shaders = this.shaders;\r\n        var targets = this.renderTargets;\r\n\r\n        this.copyShader = shaders[0];\r\n        this.addShader = shaders[1];\r\n        this.linearShader = shaders[2];\r\n        this.colorMatrixShader = shaders[3];\r\n\r\n        this.fullFrame1 = targets[0];\r\n        this.fullFrame2 = targets[1];\r\n        this.halfFrame1 = targets[2];\r\n        this.halfFrame2 = targets[3];\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * The difference between this method and `drawFrame` is that this method\r\n     * uses a faster copy shader, where only the brightness can be modified.\r\n     * If you need color level manipulation, see `drawFrame` instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#copyFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    copyFrame: function (source, target, brightness, clear, clearAlpha)\r\n    {\r\n        if (brightness === undefined) { brightness = 1; }\r\n        if (clear === undefined) { clear = true; }\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.setShader(this.copyShader);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1f('uBrightness', brightness);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source.texture);\r\n\r\n        if (target)\r\n        {\r\n            gl.viewport(0, 0, target.width, target.height);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);\r\n        }\r\n        else\r\n        {\r\n            gl.viewport(0, 0, source.width, source.height);\r\n        }\r\n\r\n        if (clear)\r\n        {\r\n            if (clearAlpha)\r\n            {\r\n                gl.clearColor(0, 0, 0, 0);\r\n            }\r\n            else\r\n            {\r\n                gl.clearColor(0, 0, 0, 1);\r\n            }\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * The difference with this copy is that no resizing takes place. If the `source`\r\n     * Render Target is larger than the `target` then only a portion the same size as\r\n     * the `target` dimensions is copied across.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#blitFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {boolean} [eraseMode=false] - Erase source from target using ERASE Blend Mode?\r\n     */\r\n    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode)\r\n    {\r\n        if (brightness === undefined) { brightness = 1; }\r\n        if (clear === undefined) { clear = true; }\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n        if (eraseMode === undefined) { eraseMode = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.setShader(this.copyShader);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1f('uBrightness', brightness);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source.texture);\r\n\r\n        if (source.height > target.height)\r\n        {\r\n            gl.viewport(0, 0, source.width, source.height);\r\n\r\n            this.setTargetUVs(source, target);\r\n        }\r\n        else\r\n        {\r\n            var diff = target.height - source.height;\r\n\r\n            gl.viewport(0, diff, source.width, source.height);\r\n        }\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);\r\n\r\n        if (clear)\r\n        {\r\n            if (clearAlpha)\r\n            {\r\n                gl.clearColor(0, 0, 0, 0);\r\n            }\r\n            else\r\n            {\r\n                gl.clearColor(0, 0, 0, 1);\r\n            }\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        if (eraseMode)\r\n        {\r\n            var blendMode = this.renderer.currentBlendMode;\r\n\r\n            this.renderer.setBlendMode(BlendModes.ERASE);\r\n        }\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        if (eraseMode)\r\n        {\r\n            this.renderer.setBlendMode(blendMode);\r\n        }\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n        this.resetUVs();\r\n    },\r\n\r\n    /**\r\n     * Binds the `source` Render Target and then copies a section of it to the `target` Render Target.\r\n     *\r\n     * This method is extremely fast because it uses `gl.copyTexSubImage2D` and doesn't\r\n     * require the use of any shaders. Remember the coordinates are given in standard WebGL format,\r\n     * where x and y specify the lower-left corner of the section, not the top-left. Also, the\r\n     * copy entirely replaces the contents of the target texture, no 'merging' or 'blending' takes\r\n     * place.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#copyFrameRect\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} x - The x coordinate of the lower left corner where to start copying.\r\n     * @param {number} y - The y coordinate of the lower left corner where to start copying.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)\r\n    {\r\n        if (clear === undefined) { clear = true; }\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, source.framebuffer);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.texture, 0);\r\n\r\n        if (clear)\r\n        {\r\n            if (clearAlpha)\r\n            {\r\n                gl.clearColor(0, 0, 0, 0);\r\n            }\r\n            else\r\n            {\r\n                gl.clearColor(0, 0, 0, 1);\r\n            }\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, target.texture);\r\n\r\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, width, height);\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    /**\r\n     * Pops the framebuffer from the renderers FBO stack and sets that as the active target,\r\n     * then draws the `source` Render Target to it. It then resets the renderer textures.\r\n     *\r\n     * This should be done when you need to draw the _final_ results of a pipeline to the game\r\n     * canvas, or the next framebuffer in line on the FBO stack. You should only call this once\r\n     * in the `onDraw` handler and it should be the final thing called. Be careful not to call\r\n     * this if you need to actually use the pipeline shader, instead of the copy shader. In\r\n     * those cases, use the `bindAndDraw` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#copyToGame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The Render Target to draw from.\r\n     */\r\n    copyToGame: function (source)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        this.setShader(this.copyShader);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1f('uBrightness', 1);\r\n\r\n        this.renderer.popFramebuffer();\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source.texture);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        this.renderer.resetTextures();\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target, using the\r\n     * given Color Matrix.\r\n     *\r\n     * The difference between this method and `copyFrame` is that this method\r\n     * uses a color matrix shader, where you have full control over the luminance\r\n     * values used during the copy. If you don't need this, you can use the faster\r\n     * `copyFrame` method instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#drawFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {Phaser.Display.ColorMatrix} [colorMatrix] - The Color Matrix to use when performing the draw.\r\n     */\r\n    drawFrame: function (source, target, clearAlpha, colorMatrix)\r\n    {\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n        if (colorMatrix === undefined) { colorMatrix = this.colorMatrix; }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.setShader(this.colorMatrixShader);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n        this.set1fv('uColorMatrix', colorMatrix.getData());\r\n        this.set1f('uAlpha', colorMatrix.alpha);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source.texture);\r\n\r\n        if (target)\r\n        {\r\n            gl.viewport(0, 0, target.width, target.height);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);\r\n        }\r\n        else\r\n        {\r\n            gl.viewport(0, 0, source.width, source.height);\r\n        }\r\n\r\n        if (clearAlpha)\r\n        {\r\n            gl.clearColor(0, 0, 0, 0);\r\n        }\r\n        else\r\n        {\r\n            gl.clearColor(0, 0, 0, 1);\r\n        }\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using a linear blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#blendFrames\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [blendShader] - The shader to use during the blend copy.\r\n     */\r\n    blendFrames: function (source1, source2, target, strength, clearAlpha, blendShader)\r\n    {\r\n        if (strength === undefined) { strength = 1; }\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n        if (blendShader === undefined) { blendShader = this.linearShader; }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.setShader(blendShader);\r\n\r\n        this.set1i('uMainSampler1', 0);\r\n        this.set1i('uMainSampler2', 1);\r\n        this.set1f('uStrength', strength);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source1.texture);\r\n\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        gl.bindTexture(gl.TEXTURE_2D, source2.texture);\r\n\r\n        if (target)\r\n        {\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);\r\n            gl.viewport(0, 0, target.width, target.height);\r\n        }\r\n        else\r\n        {\r\n            gl.viewport(0, 0, source1.width, source1.height);\r\n        }\r\n\r\n        if (clearAlpha)\r\n        {\r\n            gl.clearColor(0, 0, 0, 0);\r\n        }\r\n        else\r\n        {\r\n            gl.clearColor(0, 0, 0, 1);\r\n        }\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        gl.bindTexture(gl.TEXTURE_2D, null);\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using an additive blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#blendFramesAdditive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)\r\n    {\r\n        this.blendFrames(source1, source2, target, strength, clearAlpha, this.addShader);\r\n    },\r\n\r\n    /**\r\n     * Clears the given Render Target.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#clearFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The Render Target to clear.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    clearFrame: function (target, clearAlpha)\r\n    {\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.viewport(0, 0, target.width, target.height);\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n\r\n        if (clearAlpha)\r\n        {\r\n            gl.clearColor(0, 0, 0, 0);\r\n        }\r\n        else\r\n        {\r\n            gl.clearColor(0, 0, 0, 1);\r\n        }\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        var fbo = this.renderer.currentFramebuffer;\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n    },\r\n\r\n    /**\r\n     * Set the UV values for the 6 vertices that make up the quad used by the shaders\r\n     * in the Utility Pipeline.\r\n     *\r\n     * Be sure to call `resetUVs` once you have finished manipulating the UV coordinates.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#setUVs\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} uA - The u value of vertex A.\r\n     * @param {number} vA - The v value of vertex A.\r\n     * @param {number} uB - The u value of vertex B.\r\n     * @param {number} vB - The v value of vertex B.\r\n     * @param {number} uC - The u value of vertex C.\r\n     * @param {number} vC - The v value of vertex C.\r\n     * @param {number} uD - The u value of vertex D.\r\n     * @param {number} vD - The v value of vertex D.\r\n     */\r\n    setUVs: function (uA, vA, uB, vB, uC, vC, uD, vD)\r\n    {\r\n        var vertexViewF32 = this.vertexViewF32;\r\n\r\n        vertexViewF32[2] = uA;\r\n        vertexViewF32[3] = vA;\r\n        vertexViewF32[6] = uB;\r\n        vertexViewF32[7] = vB;\r\n        vertexViewF32[10] = uC;\r\n        vertexViewF32[11] = vC;\r\n        vertexViewF32[14] = uA;\r\n        vertexViewF32[15] = vA;\r\n        vertexViewF32[18] = uC;\r\n        vertexViewF32[19] = vC;\r\n        vertexViewF32[22] = uD;\r\n        vertexViewF32[23] = vD;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertex UV coordinates of the quad used by the shaders in the Utility Pipeline\r\n     * so that they correctly adjust the texture coordinates for a blit frame effect.\r\n     *\r\n     * Be sure to call `resetUVs` once you have finished manipulating the UV coordinates.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#setTargetUVs\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     */\r\n    setTargetUVs: function (source, target)\r\n    {\r\n        var diff = (target.height / source.height);\r\n\r\n        if (diff > 0.5)\r\n        {\r\n            diff = 0.5 - (diff - 0.5);\r\n        }\r\n        else\r\n        {\r\n            diff = 0.5 + (0.5 - diff);\r\n        }\r\n\r\n        this.setUVs(0, diff, 0, 1 + diff, 1, 1 + diff, 1, diff);\r\n    },\r\n\r\n    /**\r\n     * Horizontally flips the UV coordinates of the quad used by the shaders in this\r\n     * Utility Pipeline.\r\n     *\r\n     * Be sure to call `resetUVs` once you have finished manipulating the UV coordinates.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#flipX\r\n     * @since 3.50.0\r\n     */\r\n    flipX: function ()\r\n    {\r\n        this.setUVs(1, 0, 1, 1, 0, 1, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Vertically flips the UV coordinates of the quad used by the shaders in this\r\n     * Utility Pipeline.\r\n     *\r\n     * Be sure to call `resetUVs` once you have finished manipulating the UV coordinates.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#flipY\r\n     * @since 3.50.0\r\n     */\r\n    flipY: function ()\r\n    {\r\n        this.setUVs(0, 1, 0, 0, 1, 0, 1, 1);\r\n    },\r\n\r\n    /**\r\n     * Resets the quad vertice UV values to their default settings.\r\n     *\r\n     * The quad is used by all shaders of the Utility Pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.UtilityPipeline#resetUVs\r\n     * @since 3.50.0\r\n     */\r\n    resetUVs: function ()\r\n    {\r\n        this.setUVs(0, 0, 0, 1, 1, 1, 1, 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = UtilityPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PIPELINE_CONST = {\r\n\r\n    /**\r\n     * The Bitmap Mask Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.BITMAPMASK_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    BITMAPMASK_PIPELINE: 'BitmapMaskPipeline',\r\n\r\n    /**\r\n     * The Light 2D Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.LIGHT_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    LIGHT_PIPELINE: 'Light2D',\r\n\r\n    /**\r\n     * The Point Light Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.POINTLIGHT_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    POINTLIGHT_PIPELINE: 'PointLightPipeline',\r\n\r\n    /**\r\n     * The Single Texture Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.SINGLE_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    SINGLE_PIPELINE: 'SinglePipeline',\r\n\r\n    /**\r\n     * The Multi Texture Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.MULTI_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    MULTI_PIPELINE: 'MultiPipeline',\r\n\r\n    /**\r\n     * The Rope Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.ROPE_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ROPE_PIPELINE: 'RopePipeline',\r\n\r\n    /**\r\n     * The Graphics and Shapes Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.GRAPHICS_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    GRAPHICS_PIPELINE: 'GraphicsPipeline',\r\n\r\n    /**\r\n     * The Post FX Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.POSTFX_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    POSTFX_PIPELINE: 'PostFXPipeline',\r\n\r\n    /**\r\n     * The Utility Pipeline.\r\n     *\r\n     * @name Phaser.Renderer.WebGL.Pipelines.UTILITY_PIPELINE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    UTILITY_PIPELINE: 'UtilityPipeline'\r\n};\r\n\r\nmodule.exports = PIPELINE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline After Flush Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline right after it has issued a drawArrays command\r\n * and cleared its vertex count.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#AFTER_FLUSH\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that has flushed.\r\n * @param {boolean} isPostFlush - Was this flush invoked as part of a post-process, or not?\r\n */\r\nmodule.exports = 'pipelineafterflush';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline Before Flush Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline right before it is about to\r\n * flush and issue a bufferData and drawArrays command.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#BEFORE_FLUSH\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that is about to flush.\r\n * @param {boolean} isPostFlush - Was this flush invoked as part of a post-process, or not?\r\n */\r\nmodule.exports = 'pipelinebeforeflush';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline Bind Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline when it is bound by the Pipeline Manager.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#BIND\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that was bound.\r\n * @param {Phaser.Renderer.WebGL.WebGLShader} currentShader - The shader that was set as being current.\r\n */\r\nmodule.exports = 'pipelinebind';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline Boot Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline when it has completed its `boot` phase.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#BOOT\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that booted.\r\n */\r\nmodule.exports = 'pipelineboot';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline Destroy Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline when it is starting its destroy process.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#DESTROY\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that has flushed.\r\n */\r\nmodule.exports = 'pipelinedestroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline ReBind Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline when it is re-bound by the Pipeline Manager.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#REBIND\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that was rebound.\r\n * @param {Phaser.Renderer.WebGL.WebGLShader} currentShader - The shader that was set as being current.\r\n */\r\nmodule.exports = 'pipelinerebind';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The WebGLPipeline Resize Event.\r\n *\r\n * This event is dispatched by a WebGLPipeline when it is resized, usually as a result\r\n * of the Renderer resizing.\r\n *\r\n * @event Phaser.Renderer.WebGL.Pipelines.Events#RESIZE\r\n * @since 3.50.0\r\n *\r\n * @param {number} width - The new width of the pipeline.\r\n * @param {number} height - The new height of the pipeline.\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The pipeline that was resized.\r\n */\r\nmodule.exports = 'pipelineresize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer.WebGL.Pipelines.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AFTER_FLUSH: require('./AFTER_FLUSH_EVENT'),\r\n    BEFORE_FLUSH: require('./BEFORE_FLUSH_EVENT'),\r\n    BIND: require('./BIND_EVENT'),\r\n    BOOT: require('./BOOT_EVENT'),\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    REBIND: require('./REBIND_EVENT'),\r\n    RESIZE: require('./RESIZE_EVENT')\r\n\r\n};\r\n","module.exports = [\n    '#define SHADER_NAME PHASER_ADD_BLEND_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler1;',\n    'uniform sampler2D uMainSampler2;',\n    'uniform float uStrength;',\n    '',\n    'varying vec2 outTexCoord;',\n    '',\n    'void main ()',\n    '{',\n    '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);',\n    '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);',\n    '',\n    '    gl_FragColor = frame1 + frame2 * uStrength;',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_BITMAP_MASK_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform vec2 uResolution;',\n    'uniform sampler2D uMainSampler;',\n    'uniform sampler2D uMaskSampler;',\n    'uniform bool uInvertMaskAlpha;',\n    '',\n    'void main ()',\n    '{',\n    '    vec2 uv = gl_FragCoord.xy / uResolution;',\n    '    vec4 mainColor = texture2D(uMainSampler, uv);',\n    '    vec4 maskColor = texture2D(uMaskSampler, uv);',\n    '    float alpha = mainColor.a;',\n    '',\n    '    if (!uInvertMaskAlpha)',\n    '    {',\n    '        alpha *= (maskColor.a);',\n    '    }',\n    '    else',\n    '    {',\n    '        alpha *= (1.0 - maskColor.a);',\n    '    }',\n    '',\n    '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_BITMAP_MASK_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'attribute vec2 inPosition;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_Position = vec4(inPosition, 0.0, 1.0);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_COLORMATRIX_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler;',\n    'uniform float uColorMatrix[20];',\n    'uniform float uAlpha;',\n    '',\n    'varying vec2 outTexCoord;',\n    '',\n    'void main ()',\n    '{',\n    '    vec4 c = texture2D(uMainSampler, outTexCoord);',\n    '',\n    '    if (uAlpha == 0.0)',\n    '    {',\n    '        gl_FragColor = c;',\n    '',\n    '        return;',\n    '    }',\n    '',\n    '    if (c.a > 0.0)',\n    '    {',\n    '        c.rgb /= c.a;',\n    '    }',\n    '',\n    '    vec4 result;',\n    '',\n    '    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];',\n    '    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];',\n    '    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];',\n    '    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];',\n    '',\n    '    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);',\n    '',\n    '    rgb *= result.a;',\n    '',\n    '    gl_FragColor = vec4(rgb, result.a);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\r\n    '#define SHADER_NAME PHASER_COPY_FS',\r\n    '',\r\n    'precision mediump float;',\r\n    '',\r\n    'uniform sampler2D uMainSampler;',\r\n    'uniform float uBrightness;',\r\n    '',\r\n    'varying vec2 outTexCoord;',\r\n    '',\r\n    'void main ()',\r\n    '{',\r\n    '    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;',\r\n    '}',\r\n    ''\r\n].join('\\n');\r\n","module.exports = [\n    '#define SHADER_NAME PHASER_GRAPHICS_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'varying vec4 outColor;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_FragColor = vec4(outColor.bgr * outColor.a, outColor.a);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_GRAPHICS_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform mat4 uProjectionMatrix;',\n    '',\n    'attribute vec2 inPosition;',\n    'attribute vec4 inColor;',\n    '',\n    'varying vec4 outColor;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',\n    '',\n    '    outColor = inColor;',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_LIGHT_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'struct Light',\n    '{',\n    '    vec2 position;',\n    '    vec3 color;',\n    '    float intensity;',\n    '    float radius;',\n    '};',\n    '',\n    'const int kMaxLights = %LIGHT_COUNT%;',\n    '',\n    'uniform vec4 uCamera; /* x, y, rotation, zoom */',\n    'uniform vec2 uResolution;',\n    'uniform sampler2D uMainSampler;',\n    'uniform sampler2D uNormSampler;',\n    'uniform vec3 uAmbientLightColor;',\n    'uniform Light uLights[kMaxLights];',\n    'uniform mat3 uInverseRotationMatrix;',\n    '',\n    'varying vec2 outTexCoord;',\n    'varying vec4 outTint;',\n    '',\n    'void main()',\n    '{',\n    '    vec3 finalColor = vec3(0.0, 0.0, 0.0);',\n    '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.bgr * outTint.a, outTint.a);',\n    '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;',\n    '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));',\n    '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;',\n    '',\n    '    for (int index = 0; index < kMaxLights; ++index)',\n    '    {',\n    '        Light light = uLights[index];',\n    '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);',\n    '        vec3 lightNormal = normalize(lightDir);',\n    '        float distToSurf = length(lightDir) * uCamera.w;',\n    '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);',\n    '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;',\n    '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);',\n    '        vec3 diffuse = light.color * diffuseFactor;',\n    '        finalColor += (attenuation * diffuse) * light.intensity;',\n    '    }',\n    '',\n    '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);',\n    '',\n    '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_LINEAR_BLEND_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler1;',\n    'uniform sampler2D uMainSampler2;',\n    'uniform float uStrength;',\n    '',\n    'varying vec2 outTexCoord;',\n    '',\n    'void main ()',\n    '{',\n    '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);',\n    '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);',\n    '',\n    '    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_MULTI_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler[%count%];',\n    '',\n    'varying vec2 outTexCoord;',\n    'varying float outTexId;',\n    'varying float outTintEffect;',\n    'varying vec4 outTint;',\n    '',\n    'void main ()',\n    '{',\n    '    vec4 texture;',\n    '',\n    '    %forloop%',\n    '',\n    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',\n    '',\n    '    //  Multiply texture tint',\n    '    vec4 color = texture * texel;',\n    '',\n    '    if (outTintEffect == 1.0)',\n    '    {',\n    '        //  Solid color + texture alpha',\n    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',\n    '    }',\n    '    else if (outTintEffect == 2.0)',\n    '    {',\n    '        //  Solid color, no texture',\n    '        color = texel;',\n    '    }',\n    '',\n    '    gl_FragColor = color;',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_MULTI_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform mat4 uProjectionMatrix;',\n    '',\n    'attribute vec2 inPosition;',\n    'attribute vec2 inTexCoord;',\n    'attribute float inTexId;',\n    'attribute float inTintEffect;',\n    'attribute vec4 inTint;',\n    '',\n    'varying vec2 outTexCoord;',\n    'varying float outTexId;',\n    'varying float outTintEffect;',\n    'varying vec4 outTint;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',\n    '',\n    '    outTexCoord = inTexCoord;',\n    '    outTexId = inTexId;',\n    '    outTint = inTint;',\n    '    outTintEffect = inTintEffect;',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_POINTLIGHT_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform vec2 uResolution;',\n    'uniform float uCameraZoom;',\n    '',\n    'varying vec4 lightPosition;',\n    'varying vec4 lightColor;',\n    'varying float lightRadius;',\n    'varying float lightAttenuation;',\n    '',\n    'void main ()',\n    '{',\n    '    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);',\n    '',\n    '    float distToSurf = length(center - gl_FragCoord.xy);',\n    '',\n    '    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);',\n    '',\n    '    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);',\n    '',\n    '    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;',\n    '',\n    '    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_POINTLIGHT_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform mat4 uProjectionMatrix;',\n    '',\n    'attribute vec2 inPosition;',\n    'attribute vec2 inLightPosition;',\n    'attribute vec4 inLightColor;',\n    'attribute float inLightRadius;',\n    'attribute float inLightAttenuation;',\n    '',\n    'varying vec4 lightPosition;',\n    'varying vec4 lightColor;',\n    'varying float lightRadius;',\n    'varying float lightAttenuation;',\n    '',\n    'void main ()',\n    '{',\n    '    lightColor = inLightColor;',\n    '    lightRadius = inLightRadius;',\n    '    lightAttenuation = inLightAttenuation;',\n    '    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);',\n    '',\n    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_QUAD_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'attribute vec2 inPosition;',\n    'attribute vec2 inTexCoord;',\n    '',\n    'varying vec2 outFragCoord;',\n    'varying vec2 outTexCoord;',\n    '',\n    'void main ()',\n    '{',\n    '    outFragCoord = inPosition.xy * 0.5 + 0.5;',\n    '    outTexCoord = inTexCoord;',\n    '',\n    '    gl_Position = vec4(inPosition, 0, 1);',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_SINGLE_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler;',\n    '',\n    'varying vec2 outTexCoord;',\n    'varying float outTintEffect;',\n    'varying vec4 outTint;',\n    '',\n    'void main ()',\n    '{',\n    '    vec4 texture = texture2D(uMainSampler, outTexCoord);',\n    '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);',\n    '',\n    '    //  Multiply texture tint',\n    '    vec4 color = texture * texel;',\n    '',\n    '    if (outTintEffect == 1.0)',\n    '    {',\n    '        //  Solid color + texture alpha',\n    '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);',\n    '    }',\n    '    else if (outTintEffect == 2.0)',\n    '    {',\n    '        //  Solid color, no texture',\n    '        color = texel;',\n    '    }',\n    '',\n    '    gl_FragColor = color;',\n    '}',\n    ''\n].join('\\n');\n","module.exports = [\n    '#define SHADER_NAME PHASER_SINGLE_VS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform mat4 uProjectionMatrix;',\n    '',\n    'attribute vec2 inPosition;',\n    'attribute vec2 inTexCoord;',\n    'attribute float inTexId;',\n    'attribute float inTintEffect;',\n    'attribute vec4 inTint;',\n    '',\n    'varying vec2 outTexCoord;',\n    'varying float outTintEffect;',\n    'varying vec4 outTint;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);',\n    '',\n    '    outTexCoord = inTexCoord;',\n    '    outTint = inTint;',\n    '    outTintEffect = inTintEffect;',\n    '}',\n    ''\n].join('\\n');\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager has successfully entered fullscreen mode.\r\n *\r\n * @event Phaser.Scale.Events#ENTER_FULLSCREEN\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'enterfullscreen';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager tried to enter fullscreen mode but failed.\r\n *\r\n * @event Phaser.Scale.Events#FULLSCREEN_FAILED\r\n * @since 3.17.0\r\n */\r\nmodule.exports = 'fullscreenfailed';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager tried to enter fullscreen mode, but it is unsupported by the browser.\r\n *\r\n * @event Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'fullscreenunsupported';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager was in fullscreen mode, but has since left, either directly via game code,\r\n * or via a user gestured, such as pressing the ESC key.\r\n *\r\n * @event Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'leavefullscreen';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Orientation Change Event.\r\n *\r\n * This event is dispatched whenever the Scale Manager detects an orientation change event from the browser.\r\n *\r\n * @event Phaser.Scale.Events#ORIENTATION_CHANGE\r\n * @since 3.16.1\r\n *\r\n * @param {string} orientation - The new orientation value. Either `Phaser.Scale.Orientation.LANDSCAPE` or `Phaser.Scale.Orientation.PORTRAIT`.\r\n */\r\nmodule.exports = 'orientationchange';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Scale Manager Resize Event.\r\n *\r\n * This event is dispatched whenever the Scale Manager detects a resize event from the browser.\r\n * It sends three parameters to the callback, each of them being Size components. You can read\r\n * the `width`, `height`, `aspectRatio` and other properties of these components to help with\r\n * scaling your own game content.\r\n *\r\n * @event Phaser.Scale.Events#RESIZE\r\n * @since 3.16.1\r\n *\r\n * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.\r\n * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size.\r\n * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.\r\n * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.\r\n * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.\r\n */\r\nmodule.exports = 'resize';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Scale.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ENTER_FULLSCREEN: require('./ENTER_FULLSCREEN_EVENT'),\r\n    FULLSCREEN_FAILED: require('./FULLSCREEN_FAILED_EVENT'),\r\n    FULLSCREEN_UNSUPPORTED: require('./FULLSCREEN_UNSUPPORTED_EVENT'),\r\n    LEAVE_FULLSCREEN: require('./LEAVE_FULLSCREEN_EVENT'),\r\n    ORIENTATION_CHANGE: require('./ORIENTATION_CHANGE_EVENT'),\r\n    RESIZE: require('./RESIZE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Texture Add Event.\r\n * \r\n * This event is dispatched by the Texture Manager when a texture is added to it.\r\n * \r\n * Listen to this event from within a Scene using: `this.textures.on('addtexture', listener)`.\r\n *\r\n * @event Phaser.Textures.Events#ADD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Texture that was added to the Texture Manager.\r\n * @param {Phaser.Textures.Texture} texture - A reference to the Texture that was added to the Texture Manager.\r\n */\r\nmodule.exports = 'addtexture';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Texture Load Error Event.\r\n * \r\n * This event is dispatched by the Texture Manager when a texture it requested to load failed.\r\n * This only happens when base64 encoded textures fail. All other texture types are loaded via the Loader Plugin.\r\n * \r\n * Listen to this event from within a Scene using: `this.textures.on('onerror', listener)`.\r\n *\r\n * @event Phaser.Textures.Events#ERROR\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Texture that failed to load into the Texture Manager.\r\n */\r\nmodule.exports = 'onerror';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Texture Load Event.\r\n * \r\n * This event is dispatched by the Texture Manager when a texture has finished loading on it.\r\n * This only happens for base64 encoded textures. All other texture types are loaded via the Loader Plugin.\r\n * \r\n * Listen to this event from within a Scene using: `this.textures.on('onload', listener)`.\r\n * \r\n * This event is dispatched after the [ADD]{@linkcode Phaser.Textures.Events#event:ADD} event.\r\n *\r\n * @event Phaser.Textures.Events#LOAD\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Texture that was loaded by the Texture Manager.\r\n * @param {Phaser.Textures.Texture} texture - A reference to the Texture that was loaded by the Texture Manager.\r\n */\r\nmodule.exports = 'onload';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This internal event signifies that the Texture Manager is now ready and the Game can continue booting.\r\n * \r\n * When a Phaser Game instance is booting for the first time, the Texture Manager has to wait on a couple of non-blocking\r\n * async events before it's fully ready to carry on. When those complete the Texture Manager emits this event via the Game\r\n * instance, which tells the Game to carry on booting.\r\n *\r\n * @event Phaser.Textures.Events#READY\r\n * @since 3.16.1\r\n */\r\nmodule.exports = 'ready';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Texture Remove Event.\r\n * \r\n * This event is dispatched by the Texture Manager when a texture is removed from it.\r\n * \r\n * Listen to this event from within a Scene using: `this.textures.on('removetexture', listener)`.\r\n * \r\n * If you have any Game Objects still using the removed texture, they will start throwing\r\n * errors the next time they try to render. Be sure to clear all use of the texture in this event handler.\r\n *\r\n * @event Phaser.Textures.Events#REMOVE\r\n * @since 3.0.0\r\n * \r\n * @param {string} key - The key of the Texture that was removed from the Texture Manager.\r\n */\r\nmodule.exports = 'removetexture';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Textures.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ADD: require('./ADD_EVENT'),\r\n    ERROR: require('./ERROR_EVENT'),\r\n    LOAD: require('./LOAD_EVENT'),\r\n    READY: require('./READY_EVENT'),\r\n    REMOVE: require('./REMOVE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Deep Copy the given object or array.\r\n *\r\n * @function Phaser.Utils.Objects.DeepCopy\r\n * @since 3.50.0\r\n *\r\n * @param {object} obj - The object to deep copy.\r\n *\r\n * @return {object} A deep copy of the original object.\r\n */\r\nvar DeepCopy = function (inObject)\r\n{\r\n    var outObject;\r\n    var value;\r\n    var key;\r\n\r\n    if (typeof inObject !== 'object' || inObject === null)\r\n    {\r\n        //  inObject is not an object\r\n        return inObject;\r\n    }\r\n\r\n    //  Create an array or object to hold the values\r\n    outObject = Array.isArray(inObject) ? [] : {};\r\n\r\n    for (key in inObject)\r\n    {\r\n        value = inObject[key];\r\n\r\n        //  Recursively (deep) copy for nested objects, including arrays\r\n        outObject[key] = DeepCopy(value);\r\n    }\r\n\r\n    return outObject;\r\n};\r\n\r\nmodule.exports = DeepCopy;\r\n"],"names":["pngHead","pngEnd","magenta","CanvasPool","CanvasFeatures","supportInverseAlpha","supportNewBlendModes","module","exports","importScripts","undefined","document","Image","onload","yellow","context","create","getContext","globalCompositeOperation","drawImage","getImageData","data","remove","src","this","fillStyle","fillRect","s1","putImageData","s2","checkInverseAlpha","CameraEvents","CanvasSnapshot","Class","CONST","EventEmitter","Events","GetBlendModes","ScaleEvents","TextureEvents","TransformMatrix","CanvasRenderer","Extends","initialize","game","call","gameConfig","config","clearBeforeRender","backgroundColor","antialias","roundPixels","type","CANVAS","drawCount","width","height","gameCanvas","canvas","contextOptions","alpha","transparent","desynchronized","gameContext","currentContext","blendModes","snapshotState","x","y","getPixel","callback","encoder","_tempMatrix1","_tempMatrix2","_tempMatrix3","isBooted","init","textures","once","READY","boot","baseSize","scale","on","RESIZE","onResize","resize","gameSize","emit","resetTransform","setTransform","setBlendMode","blendMode","setContext","ctx","setAlpha","globalAlpha","preRender","clearRect","rgba","save","PRE_RENDER","render","scene","children","camera","childCount","length","RENDER","cx","cy","cw","ch","sys","customViewports","beginPath","rect","clip","mask","preRenderCanvas","_maskCamera","renderToTexture","matrix","copyToContext","i","child","renderCanvas","postRenderCanvas","flashEffect","fadeEffect","dirty","restore","POST_RENDER","renderToGame","postRender","state","snapshotCanvas","encoderOptions","snapshotArea","snapshot","Math","min","snapshotPixel","batchSprite","sprite","frame","parentTransformMatrix","camMatrix","spriteMatrix","cd","canvasData","frameX","frameY","frameWidth","cutWidth","frameHeight","cutHeight","customPivot","res","source","resolution","displayOriginX","displayOriginY","isCropped","crop","_crop","flipX","flipY","updateCropUVs","abs","realWidth","realHeight","applyITRS","rotation","scaleX","scaleY","copyFrom","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","setToContext","imageSmoothingEnabled","scaleMode","image","destroy","removeAllListeners","modes","output","useNew","so","NORMAL","ADD","MULTIPLY","SCREEN","OVERLAY","DARKEN","LIGHTEN","COLOR_DODGE","COLOR_BURN","HARD_LIGHT","SOFT_LIGHT","DIFFERENCE","EXCLUSION","HUE","SATURATION","COLOR","LUMINOSITY","ERASE","SOURCE_IN","SOURCE_OUT","SOURCE_ATOP","DESTINATION_OVER","DESTINATION_IN","DESTINATION_OUT","DESTINATION_ATOP","LIGHTER","COPY","XOR","Color","GetFastValue","round","copyCanvas","createWebGL","image1","onerror","toDataURL","image2","sourceCanvas","gl","isFramebuffer","bufferWidth","drawingBufferWidth","bufferHeight","drawingBufferHeight","pixel","Uint8Array","destY","readPixels","RGBA","UNSIGNED_BYTE","pixels","imageData","py","px","sourceIndex","destIndex","CustomMap","BitmapMaskPipeline","GraphicsPipeline","LightPipeline","MultiPipeline","PointLightPipeline","RopePipeline","SinglePipeline","UtilityPipeline","PipelineManager","renderer","classes","UTILITY_PIPELINE","MULTI_PIPELINE","BITMAPMASK_PIPELINE","SINGLE_PIPELINE","ROPE_PIPELINE","LIGHT_PIPELINE","POINTLIGHT_PIPELINE","GRAPHICS_PIPELINE","postPipelineClasses","pipelines","current","previous","fullFrame1","fullFrame2","halfFrame1","halfFrame2","pipelineConfig","instance","pipelineName","_this","each","pipeline","add","get","pipelineClass","isPostFX","set","has","name","console","warn","manager","hasBooted","addPostPipeline","flush","contains","getPostPipeline","gameObject","pipelineClasses","newPipeline","removeClass","removePostPipelineClass","delete","currentShader","isCurrent","unbind","bind","updateProjectionMatrix","onBind","preBatch","hasPostPipeline","postPipelines","active","postBatch","preBatchCamera","postBatchCamera","program","currentProgram","copyFrame","target","brightness","clear","clearAlpha","setUtility","copyShader","copyToGame","drawFrame","colorMatrix","colorMatrixShader","blendFrames","source1","source2","strength","linearShader","blendFramesAdditive","addShader","clearFrame","blitFrame","eraseMode","copyFrameRect","forceZero","setMulti","rebind","disable","DEPTH_TEST","CULL_FACE","hasActiveStencilMask","DEPTH_BUFFER_BIT","STENCIL_TEST","STENCIL_BUFFER_BIT","viewport","entries","key","glReset","resetTextures","DeepCopy","Matrix4","RendererEvents","RenderTarget","Utils","WebGLShader","WebGLPipeline","view","vertexCount","vertexCapacity","vertexData","vertexBuffer","topology","TRIANGLES","bytes","vertexViewF32","vertexViewU32","currentUnit","renderTargets","currentRenderTarget","shaders","projectionMatrix","projectionWidth","projectionHeight","identity","targets","push","Array","isArray","minFilter","autoClear","setShadersFromConfig","vertexSize","batchSize","ArrayBuffer","Float32Array","Uint32Array","configVerts","createVertexBuffer","STATIC_DRAW","byteLength","DYNAMIC_DRAW","setVertexBuffer","onPreRender","onRender","onPostRender","BOOT","onBoot","setShader","shader","setAttributes","getShaderByName","vName","fName","aName","defaultVertShader","defaultFragShader","parseFragmentShaderMaxTextures","maxTextures","defaultAttribs","configShaders","len","newShaders","shaderEntry","vertShader","fragShader","attributes","setGameObject","setTextureSource","shouldFlush","amount","setProjectionMatrix","ortho","hasUniform","resetUniform","setMatrix4fv","val","globalWidth","globalHeight","wasBound","BIND","onActive","REBIND","onRebind","buffer","getParameter","ARRAY_BUFFER_BINDING","bindBuffer","ARRAY_BUFFER","onPreBatch","onDraw","onPostBatch","isPostFlush","BEFORE_FLUSH","onBeforeFlush","bufferData","bufferSubData","subarray","drawArrays","AFTER_FLUSH","onAfterFlush","onBatch","batchVert","u","v","unit","tintEffect","tint","vertexOffset","vertexComponentCount","batchQuad","x0","y0","x1","y1","x2","y2","x3","y3","u0","v0","u1","v1","tintTL","tintTR","tintBL","tintBR","texture","hasFlushed","setTexture2D","batchTri","drawFillRect","color","flipUV","whiteTexture","glTexture","floor","xw","yh","getTintAppendFloatAlphaAndSwap","bindTexture","activeTexture","TEXTURE0","TEXTURE_2D","bindRenderTarget","setTime","uniform","set1f","loop","getDuration","set2f","set3f","z","set4f","w","set1fv","arr","set2fv","set3fv","set4fv","set1iv","set2iv","set3iv","set4iv","set1i","set2i","set3i","set4i","setMatrix2fv","transpose","setMatrix3fv","DESTROY","deleteBuffer","off","ArrayRemove","GameEvents","IsSizePowerOfTwo","NOOP","WebGLSnapshot","WebGLRenderer","contextCreationConfig","depth","antialiasGL","premultipliedAlpha","stencil","failIfMajorPerformanceCaveat","powerPreference","preserveDrawingBuffer","contextCreation","maxTextureSize","maxLights","mipmapFilter","WEBGL","contextLost","currentActiveTexture","startActiveTexture","textureIndexes","tempTextures","textureZero","normalTexture","currentFramebuffer","fboStack","currentBlendMode","Infinity","currentScissorEnabled","currentScissor","scissorStack","contextLostHandler","contextRestoredHandler","supportedExtensions","instancedArraysExtension","vaoExtension","extensions","glFormats","compression","ETC1","PVRTC","S3TC","blankTexture","maskCount","maskStack","currentMask","currentCameraMask","glFuncMap","currentType","newType","nextTypeMatch","finalType","textureFlush","isTextureClean","defaultScissor","renderTarget","clearColor","isContextLost","Error","event","events","CONTEXT_LOST","preventDefault","CONTEXT_RESTORED","addEventListener","func","ONE","ONE_MINUS_SRC_ALPHA","equation","FUNC_ADD","DST_ALPHA","DST_COLOR","ONE_MINUS_SRC_COLOR","ZERO","FUNC_REVERSE_SUBTRACT","BYTE","SHORT","UNSIGNED_SHORT","FLOAT","mat2","uniformMatrix2fv","mat3","uniformMatrix3fv","mat4","uniformMatrix4fv","uniform1f","uniform1fv","uniform1i","uniform1iv","uniform2f","uniform2fv","uniform2i","uniform2iv","uniform3f","uniform3fv","uniform3i","uniform3iv","uniform4f","uniform4fv","uniform4i","uniform4iv","exts","getSupportedExtensions","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","extString","wkExtString","getExtension","angleString","indexOf","vaoString","enable","BLEND","redGL","greenGL","blueGL","alphaGL","checkShaderMax","t","deleteTexture","index","tempTexture","createTexture","texImage2D","TEXTURE1","BlendModes","pipelineManager","getFrame","bindFramebuffer","FRAMEBUFFER","SCISSOR_TEST","beginCapture","endCapture","resetProjectionMatrix","scissor","getAspectRatio","hasExtension","extensionName","pushScissor","setScissor","resetScissor","popScissor","pop","camMask","isStencil","resetViewport","blendModeId","force","SKIP_CHECK","blendEquation","blendFuncSeparate","blendFunc","addBlendMode","updateBlendMode","removeBlendMode","splice","setBlankTexture","textureSource","setTextureZero","glIndexCounter","glIndex","isNewNormalMap","normalMap","clearTextureZero","setNormalMap","clearNormalMap","unbindTextures","temp","all","pushFramebuffer","framebuffer","updateScissor","setViewport","setFramebuffer","renderTexture","popFramebuffer","setProgram","useProgram","resetProgram","createTextureFromSource","NEAREST","magFilter","wrap","CLAMP_TO_EDGE","pow","REPEAT","ScaleModes","LINEAR","createTexture2D","mipLevel","wrapT","wrapS","format","pma","forceSize","currentTexture","TEXTURE_BINDING_2D","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","generateMipmap","isAlphaPremultiplied","isRenderTexture","createFramebuffer","addDepthStencilBuffer","complete","depthStencilBuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","framebufferTexture2D","COLOR_ATTACHMENT0","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","createProgram","vertexShader","fragmentShader","vs","createShader","VERTEX_SHADER","fs","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","initialDataOrSize","bufferUsage","createBuffer","createIndexBuffer","indexBuffer","ELEMENT_ARRAY_BUFFER","reset","deleteFramebuffer","deleteProgram","preRenderCamera","preRenderWebGL","getTintFromFloats","getCurrentStencilMask","prev","stack","cameraMask","postRenderCamera","isRunning","isComplete","postRenderWebGL","COLOR_BUFFER_BIT","renderWebGL","snapshotFramebuffer","canvasToTexture","srcCanvas","dstTexture","noRepeat","updateCanvasTexture","createCanvasTexture","wrapping","createVideoTexture","srcVideo","videoWidth","videoHeight","updateVideoTexture","setTextureFilter","filter","glFilter","getMaxTextureSize","removeEventListener","WEBGL_CONST","uniforms","createAttributes","createUniforms","count","offset","result","element","size","glType","enum","typeSize","normalized","enabled","location","setAttribPointers","attribLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","disableVertexAttribArray","totalUniforms","ACTIVE_UNIFORMS","info","getActiveUniform","getUniformLocation","value1","value2","value3","value4","struct","substr","hasOwnProperty","setUniform1","setter","skipCheck","setUniform2","setUniform3","setUniform4","INT","UNSIGNED_INT","ShaderSourceFS","ShaderSourceVS","vertices","prototype","beginMask","maskedObject","bitmapMask","mainFramebuffer","endMask","maskFramebuffer","applyStencil","maskTexture","mainTexture","invertAlpha","Earcut","calcMatrix","tempTriangle","strokeTint","TL","TR","BL","BR","fillTint","currentFrame","firstQuad","prevQuad","polygonCache","batchFillRect","currentMatrix","parentMatrix","getX","getY","batchFillTriangle","tx0","ty0","tx1","ty1","tx2","ty2","batchStrokeTriangle","lineWidth","batchStrokePath","batchFillPath","path","polygonIndexArray","point","pathIndex","p0","p1","p2","pathOpen","pathLength","point0","point1","batchLine","ax","ay","bx","by","aLineWidth","bLineWidth","closePath","dx","dy","sqrt","al0","al1","bl0","bl1","lx0","ly0","lx1","ly1","lx2","ly2","lx3","ly3","brX","brY","blX","blY","trX","trY","tlX","tlY","first","LightShaderSourceFS","Vec2","LIGHT_COUNT","tempVec2","replace","toString","inverseRotationMatrix","defaultNormalMap","lightsActive","lightManager","lights","getLights","lightsCount","cameraMatrix","zoom","ambientColor","r","g","b","light","lightName","transformPoint","intensity","radius","currentNormalMapRotation","setNormalMapRotation","rot","c","cos","s","sin","getNormalMap","displayTexture","dataSource","displayFrame","tileset","batchTexture","textureWidth","textureHeight","srcX","srcY","srcWidth","srcHeight","uOffset","vOffset","skipFlip","textureUnit","batchTextureFrame","transformMatrix","fragmentShaderSource","isGLTexture","getXRound","getYRound","tx3","ty3","getTint","getTintAppendFloatAlpha","cameraAlpha","tintTopLeft","_alphaTL","tintTopRight","_alphaTR","tintBottomLeft","_alphaBL","tintBottomRight","_alphaBR","tintFill","cropWidth","cropHeight","ox","oy","PointLightShaderSourceFS","PointLightShaderSourceVS","batchPointLight","lightX","lightY","attenuation","a","batchLightVert","AddBlendFS","ColorMatrix","ColorMatrixFS","CopyFS","LinearBlendFS","QuadVS","setTargetUVs","diff","resetUVs","copyTexSubImage2D","getData","blendShader","fbo","setUVs","uA","vA","uB","vB","uC","vC","uD","vD","POSTFX_PIPELINE","join","ENTER_FULLSCREEN","FULLSCREEN_FAILED","FULLSCREEN_UNSUPPORTED","LEAVE_FULLSCREEN","ORIENTATION_CHANGE","ERROR","LOAD","REMOVE","inObject","outObject","value"],"sourceRoot":""}