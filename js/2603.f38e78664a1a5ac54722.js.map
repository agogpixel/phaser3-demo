{"version":3,"file":"js/2603.f38e78664a1a5ac54722.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/AlignTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/Angle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/Call.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/GetFirst.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/GetLast.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/GridAlign.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/IncAlpha.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/IncX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/IncXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/IncY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlaceOnCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlaceOnEllipse.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlaceOnLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlaceOnRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlaceOnTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PlayAnimation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PropertyValueInc.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/PropertyValueSet.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RandomCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RandomEllipse.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RandomLine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RandomRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RandomTriangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/Rotate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RotateAround.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/RotateAroundDistance.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/ScaleX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/ScaleXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/ScaleY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetAlpha.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetBlendMode.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetDepth.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetHitArea.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetOrigin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetRotation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScale.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScaleX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScaleY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScrollFactor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScrollFactorX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetScrollFactorY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetTint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetVisible.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SetY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/ShiftPosition.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/Shuffle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SmoothStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/SmootherStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/Spread.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/ToggleVisible.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/WrapInRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/actions/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/zone/Zone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/RotateLeft.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/RotateRight.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Shuffle.js"],"sourcesContent":["/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar QuickSet = require('../display/align/to/QuickSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties, and aligns them next to each other.\r\n *\r\n * The first item isn't moved. The second item is aligned next to the first, then the third next to the second, and so on.\r\n *\r\n * @function Phaser.Actions.AlignTo\r\n * @since 3.22.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} position - The position to align the items with. This is an align constant, such as `Phaser.Display.Align.LEFT_CENTER`.\r\n * @param {number} [offsetX=0] - Optional horizontal offset from the position.\r\n * @param {number} [offsetY=0] - Optional vertical offset from the position.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar AlignTo = function (items, position, offsetX, offsetY)\r\n{\r\n    var target = items[0];\r\n\r\n    for (var i = 1; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        QuickSet(item, target, position, offsetX, offsetY);\r\n\r\n        target = item;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = AlignTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `angle` property,\r\n * and then adds the given value to each of their `angle` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `Angle(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.Angle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `angle` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar Angle = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'angle', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = Angle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of objects and passes each of them to the given callback.\r\n *\r\n * @function Phaser.Actions.Call\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {Phaser.Types.Actions.CallCallback} callback - The callback to be invoked. It will be passed just one argument: the item from the array.\r\n * @param {*} context - The scope in which the callback will be invoked.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that was passed to this Action.\r\n */\r\nvar Call = function (items, callback, context)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        callback.call(context, item);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = Call;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of objects and returns the first element in the array that has properties which match\r\n * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`\r\n * then it would return the first item which had the property `scaleX` set to 0.5 and `alpha` set to 1.\r\n *\r\n * To use this with a Group: `GetFirst(group.getChildren(), compare, index)`\r\n *\r\n * @function Phaser.Actions.GetFirst\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be searched by this action.\r\n * @param {object} compare - The comparison object. Each property in this object will be checked against the items of the array.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n *\r\n * @return {?(object|Phaser.GameObjects.GameObject)} The first object in the array that matches the comparison object, or `null` if no match was found.\r\n */\r\nvar GetFirst = function (items, compare, index)\r\n{\r\n    if (index === undefined) { index = 0; }\r\n\r\n    for (var i = index; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        var match = true;\r\n\r\n        for (var property in compare)\r\n        {\r\n            if (item[property] !== compare[property])\r\n            {\r\n                match = false;\r\n            }\r\n        }\r\n\r\n        if (match)\r\n        {\r\n            return item;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = GetFirst;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of objects and returns the last element in the array that has properties which match\r\n * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`\r\n * then it would return the last item which had the property `scaleX` set to 0.5 and `alpha` set to 1.\r\n *\r\n * To use this with a Group: `GetLast(group.getChildren(), compare, index)`\r\n *\r\n * @function Phaser.Actions.GetLast\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be searched by this action.\r\n * @param {object} compare - The comparison object. Each property in this object will be checked against the items of the array.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n *\r\n * @return {?(object|Phaser.GameObjects.GameObject)} The last object in the array that matches the comparison object, or `null` if no match was found.\r\n */\r\nvar GetLast = function (items, compare, index)\r\n{\r\n    if (index === undefined) { index = 0; }\r\n\r\n    for (var i = index; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        var match = true;\r\n\r\n        for (var property in compare)\r\n        {\r\n            if (item[property] !== compare[property])\r\n            {\r\n                match = false;\r\n            }\r\n        }\r\n\r\n        if (match)\r\n        {\r\n            return item;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = GetLast;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AlignIn = require('../display/align/in/QuickSet');\r\nvar CONST = require('../display/align/const');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Zone = require('../gameobjects/zone/Zone');\r\n\r\nvar tempZone = new Zone({ sys: { queueDepthSort: NOOP, events: { once: NOOP } } }, 0, 0, 1, 1);\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then aligns them based on the grid configuration given to this action.\r\n *\r\n * @function Phaser.Actions.GridAlign\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {Phaser.Types.Actions.GridAlignConfig} options - The GridAlign Configuration object.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar GridAlign = function (items, options)\r\n{\r\n    if (options === undefined) { options = {}; }\r\n\r\n    var widthSet = options.hasOwnProperty('width');\r\n    var heightSet = options.hasOwnProperty('height');\r\n\r\n    var width = GetFastValue(options, 'width', -1);\r\n    var height = GetFastValue(options, 'height', -1);\r\n\r\n    var cellWidth = GetFastValue(options, 'cellWidth', 1);\r\n    var cellHeight = GetFastValue(options, 'cellHeight', cellWidth);\r\n\r\n    var position = GetFastValue(options, 'position', CONST.TOP_LEFT);\r\n    var x = GetFastValue(options, 'x', 0);\r\n    var y = GetFastValue(options, 'y', 0);\r\n\r\n    var cx = 0;\r\n    var cy = 0;\r\n    var w = (width * cellWidth);\r\n    var h = (height * cellHeight);\r\n\r\n    tempZone.setPosition(x, y);\r\n    tempZone.setSize(cellWidth, cellHeight);\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        AlignIn(items[i], tempZone, position);\r\n\r\n        if (widthSet && width === -1)\r\n        {\r\n            //  We keep laying them out horizontally until we've done them all\r\n            tempZone.x += cellWidth;\r\n        }\r\n        else if (heightSet && height === -1)\r\n        {\r\n            //  We keep laying them out vertically until we've done them all\r\n            tempZone.y += cellHeight;\r\n        }\r\n        else if (heightSet && !widthSet)\r\n        {\r\n            //  We keep laying them out until we hit the column limit\r\n            cy += cellHeight;\r\n            tempZone.y += cellHeight;\r\n\r\n            if (cy === h)\r\n            {\r\n                cy = 0;\r\n                cx += cellWidth;\r\n                tempZone.y = y;\r\n                tempZone.x += cellWidth;\r\n\r\n                if (cx === w)\r\n                {\r\n                    //  We've hit the column limit, so return, even if there are items left\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  We keep laying them out until we hit the column limit\r\n            cx += cellWidth;\r\n            tempZone.x += cellWidth;\r\n\r\n            if (cx === w)\r\n            {\r\n                cx = 0;\r\n                cy += cellHeight;\r\n                tempZone.x = x;\r\n                tempZone.y += cellHeight;\r\n\r\n                if (cy === h)\r\n                {\r\n                    //  We've hit the column limit, so return, even if there are items left\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = GridAlign;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `alpha` property,\r\n * and then adds the given value to each of their `alpha` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncAlpha(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncAlpha\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `alpha` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar IncAlpha = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'alpha', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = IncAlpha;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `x` property,\r\n * and then adds the given value to each of their `x` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `x` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar IncX = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'x', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = IncX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,\r\n * and then adds the given value to each of them.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncXY(group.getChildren(), x, y, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.IncXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} x - The amount to be added to the `x` property.\r\n * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar IncXY = function (items, x, y, stepX, stepY, index, direction)\r\n{\r\n    if (y === undefined || y === null) { y = x; }\r\n\r\n    PropertyValueInc(items, 'x', x, stepX, index, direction);\r\n\r\n    return PropertyValueInc(items, 'y', y, stepY, index, direction);\r\n};\r\n\r\nmodule.exports = IncXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `y` property,\r\n * and then adds the given value to each of their `y` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `IncY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.IncY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `y` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar IncY = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'y', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = IncY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of a Circle.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Circle` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.PlaceOnCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Circle} circle - The Circle to position the Game Objects on.\r\n * @param {number} [startAngle=0] - Optional angle to start position from, in radians.\r\n * @param {number} [endAngle=6.28] - Optional angle to stop position at, in radians.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlaceOnCircle = function (items, circle, startAngle, endAngle)\r\n{\r\n    if (startAngle === undefined) { startAngle = 0; }\r\n    if (endAngle === undefined) { endAngle = 6.28; }\r\n\r\n    var angle = startAngle;\r\n    var angleStep = (endAngle - startAngle) / items.length;\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].x = circle.x + (circle.radius * Math.cos(angle));\r\n        items[i].y = circle.y + (circle.radius * Math.sin(angle));\r\n\r\n        angle += angleStep;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlaceOnCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of an Ellipse.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Ellipse` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.PlaceOnEllipse\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to position the Game Objects on.\r\n * @param {number} [startAngle=0] - Optional angle to start position from, in radians.\r\n * @param {number} [endAngle=6.28] - Optional angle to stop position at, in radians.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlaceOnEllipse = function (items, ellipse, startAngle, endAngle)\r\n{\r\n    if (startAngle === undefined) { startAngle = 0; }\r\n    if (endAngle === undefined) { endAngle = 6.28; }\r\n\r\n    var angle = startAngle;\r\n    var angleStep = (endAngle - startAngle) / items.length;\r\n\r\n    var a = ellipse.width / 2;\r\n    var b = ellipse.height / 2;\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].x = ellipse.x + a * Math.cos(angle);\r\n        items[i].y = ellipse.y + b * Math.sin(angle);\r\n\r\n        angle += angleStep;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlaceOnEllipse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetPoints = require('../geom/line/GetPoints');\r\n\r\n/**\r\n * Positions an array of Game Objects on evenly spaced points of a Line.\r\n *\r\n * @function Phaser.Actions.PlaceOnLine\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Line} line - The Line to position the Game Objects on.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlaceOnLine = function (items, line)\r\n{\r\n    var points = GetPoints(line, items.length);\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n        var point = points[i];\r\n\r\n        item.x = point.x;\r\n        item.y = point.y;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlaceOnLine;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MarchingAnts = require('../geom/rectangle/MarchingAnts');\r\nvar RotateLeft = require('../utils/array/RotateLeft');\r\nvar RotateRight = require('../utils/array/RotateRight');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them on evenly spaced points around the perimeter of a Rectangle.\r\n * \r\n * Placement starts from the top-left of the rectangle, and proceeds in a clockwise direction.\r\n * If the `shift` parameter is given you can offset where placement begins.\r\n *\r\n * @function Phaser.Actions.PlaceOnRectangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to position the Game Objects on.\r\n * @param {number} [shift=0] - An optional positional offset.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlaceOnRectangle = function (items, rect, shift)\r\n{\r\n    if (shift === undefined) { shift = 0; }\r\n\r\n    var points = MarchingAnts(rect, false, items.length);\r\n\r\n    if (shift > 0)\r\n    {\r\n        RotateLeft(points, shift);\r\n    }\r\n    else if (shift < 0)\r\n    {\r\n        RotateRight(points, Math.abs(shift));\r\n    }\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].x = points[i].x;\r\n        items[i].y = points[i].y;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlaceOnRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BresenhamPoints = require('../geom/line/BresenhamPoints');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them on evenly spaced points around the edges of a Triangle.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Triangle` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.PlaceOnTriangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to position the Game Objects on.\r\n * @param {number} [stepRate=1] - An optional step rate, to increase or decrease the packing of the Game Objects on the lines.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlaceOnTriangle = function (items, triangle, stepRate)\r\n{\r\n    var p1 = BresenhamPoints({ x1: triangle.x1, y1: triangle.y1, x2: triangle.x2, y2: triangle.y2 }, stepRate);\r\n    var p2 = BresenhamPoints({ x1: triangle.x2, y1: triangle.y2, x2: triangle.x3, y2: triangle.y3 }, stepRate);\r\n    var p3 = BresenhamPoints({ x1: triangle.x3, y1: triangle.y3, x2: triangle.x1, y2: triangle.y1 }, stepRate);\r\n\r\n    //  Remove overlaps\r\n    p1.pop();\r\n    p2.pop();\r\n    p3.pop();\r\n\r\n    p1 = p1.concat(p2, p3);\r\n\r\n    var step = p1.length / items.length;\r\n    var p = 0;\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n        var point = p1[Math.floor(p)];\r\n\r\n        item.x = point.x;\r\n        item.y = point.y;\r\n\r\n        p += step;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlaceOnTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Play an animation on all Game Objects in the array that have an Animation component.\r\n *\r\n * You can pass either an animation key, or an animation configuration object for more control over the playback.\r\n *\r\n * @function Phaser.Actions.PlayAnimation\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\r\n * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar PlayAnimation = function (items, key, ignoreIfPlaying)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var gameObject = items[i];\r\n\r\n        if (gameObject.anims)\r\n        {\r\n            gameObject.anims.play(key, ignoreIfPlaying);\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PlayAnimation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,\r\n * and then adds the given value to it.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `PropertyValueInc(group.getChildren(), key, value, step)`\r\n *\r\n * @function Phaser.Actions.PropertyValueInc\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {string} key - The property to be updated.\r\n * @param {number} value - The amount to be added to the property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar PropertyValueInc = function (items, key, value, step, index, direction)\r\n{\r\n    if (step === undefined) { step = 0; }\r\n    if (index === undefined) { index = 0; }\r\n    if (direction === undefined) { direction = 1; }\r\n\r\n    var i;\r\n    var t = 0;\r\n    var end = items.length;\r\n\r\n    if (direction === 1)\r\n    {\r\n        //  Start to End\r\n        for (i = index; i < end; i++)\r\n        {\r\n            items[i][key] += value + (t * step);\r\n            t++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //  End to Start\r\n        for (i = index; i >= 0; i--)\r\n        {\r\n            items[i][key] += value + (t * step);\r\n            t++;\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PropertyValueInc;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `PropertyValueSet(group.getChildren(), key, value, step)`\r\n *\r\n * @function Phaser.Actions.PropertyValueSet\r\n * @since 3.3.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {string} key - The property to be updated.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar PropertyValueSet = function (items, key, value, step, index, direction)\r\n{\r\n    if (step === undefined) { step = 0; }\r\n    if (index === undefined) { index = 0; }\r\n    if (direction === undefined) { direction = 1; }\r\n\r\n    var i;\r\n    var t = 0;\r\n    var end = items.length;\r\n\r\n    if (direction === 1)\r\n    {\r\n        //  Start to End\r\n        for (i = index; i < end; i++)\r\n        {\r\n            items[i][key] = value + (t * step);\r\n            t++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //  End to Start\r\n        for (i = index; i >= 0; i--)\r\n        {\r\n            items[i][key] = value + (t * step);\r\n            t++;\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = PropertyValueSet;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Random = require('../geom/circle/Random');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them at random locations within the Circle.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Circle` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.RandomCircle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Circle} circle - The Circle to position the Game Objects within.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RandomCircle = function (items, circle)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        Random(circle, items[i]);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RandomCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Random = require('../geom/ellipse/Random');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them at random locations within the Ellipse.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Ellipse` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.RandomEllipse\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to position the Game Objects within.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RandomEllipse = function (items, ellipse)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        Random(ellipse, items[i]);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RandomEllipse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Random = require('../geom/line/Random');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them at random locations on the Line.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Line` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.RandomLine\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Line} line - The Line to position the Game Objects randomly on.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RandomLine = function (items, line)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        Random(line, items[i]);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RandomLine;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Random = require('../geom/rectangle/Random');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them at random locations within the Rectangle.\r\n *\r\n * @function Phaser.Actions.RandomRectangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to position the Game Objects within.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RandomRectangle = function (items, rect)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        Random(rect, items[i]);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RandomRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Random = require('../geom/triangle/Random');\r\n\r\n/**\r\n * Takes an array of Game Objects and positions them at random locations within the Triangle.\r\n * \r\n * If you wish to pass a `Phaser.GameObjects.Triangle` Shape to this function, you should pass its `geom` property.\r\n *\r\n * @function Phaser.Actions.RandomTriangle\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to position the Game Objects within.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RandomTriangle = function (items, triangle)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        Random(triangle, items[i]);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RandomTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `rotation` property,\r\n * and then adds the given value to each of their `rotation` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `Rotate(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.Rotate\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `rotation` property (in radians).\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar Rotate = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'rotation', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RotateAroundDistance = require('../math/RotateAroundDistance');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\n\r\n/**\r\n * Rotates each item around the given point by the given angle.\r\n *\r\n * @function Phaser.Actions.RotateAround\r\n * @since 3.0.0\r\n * @see Phaser.Math.RotateAroundDistance\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {object} point - Any object with public `x` and `y` properties.\r\n * @param {number} angle - The angle to rotate by, in radians.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RotateAround = function (items, point, angle)\r\n{\r\n    var x = point.x;\r\n    var y = point.y;\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        RotateAroundDistance(item, x, y, angle, Math.max(1, DistanceBetween(item.x, item.y, x, y)));\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RotateAround;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathRotateAroundDistance = require('../math/RotateAroundDistance');\r\n\r\n/**\r\n * Rotates an array of Game Objects around a point by the given angle and distance.\r\n *\r\n * @function Phaser.Actions.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {object} point - Any object with public `x` and `y` properties.\r\n * @param {number} angle - The angle to rotate by, in radians.\r\n * @param {number} distance - The distance from the point of rotation in pixels.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar RotateAroundDistance = function (items, point, angle, distance)\r\n{\r\n    var x = point.x;\r\n    var y = point.y;\r\n\r\n    //  There's nothing to do\r\n    if (distance === 0)\r\n    {\r\n        return items;\r\n    }\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        MathRotateAroundDistance(items[i], x, y, angle, distance);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = RotateAroundDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `scaleX` property,\r\n * and then adds the given value to each of their `scaleX` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.ScaleX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `scaleX` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar ScaleX = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'scaleX', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = ScaleX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have public `scaleX` and `scaleY` properties,\r\n * and then adds the given value to each of them.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleXY(group.getChildren(), scaleX, scaleY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.ScaleXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar ScaleXY = function (items, scaleX, scaleY, stepX, stepY, index, direction)\r\n{\r\n    if (scaleY === undefined || scaleY === null) { scaleY = scaleX; }\r\n\r\n    PropertyValueInc(items, 'scaleX', scaleX, stepX, index, direction);\r\n\r\n    return PropertyValueInc(items, 'scaleY', scaleY, stepY, index, direction);\r\n};\r\n\r\nmodule.exports = ScaleXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueInc = require('./PropertyValueInc');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have a public `scaleY` property,\r\n * and then adds the given value to each of their `scaleY` properties.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `ScaleY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.ScaleY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to be added to the `scaleY` property.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar ScaleY = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueInc(items, 'scaleY', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = ScaleY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `alpha`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetAlpha(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetAlpha\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetAlpha = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'alpha', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetAlpha;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `blendMode`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetBlendMode(group.getChildren(), value)`\r\n *\r\n * @function Phaser.Actions.SetBlendMode\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetBlendMode = function (items, value, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'blendMode', value, 0, index, direction);\r\n};\r\n\r\nmodule.exports = SetBlendMode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `depth`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetDepth(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetDepth\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetDepth = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'depth', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetDepth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Passes all provided Game Objects to the Input Manager to enable them for input with identical areas and callbacks.\r\n * \r\n * @see {@link Phaser.GameObjects.GameObject#setInteractive}\r\n *\r\n * @function Phaser.Actions.SetHitArea\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar SetHitArea = function (items, hitArea, hitAreaCallback)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].setInteractive(hitArea, hitAreaCallback);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = SetHitArea;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar PropertyValueSet = require('./PropertyValueSet');\n\n/**\n * Takes an array of Game Objects, or any objects that have the public properties `originX` and `originY`\n * and then sets them to the given values.\n *\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\n *\n * To use this with a Group: `SetOrigin(group.getChildren(), originX, originY, stepX, stepY)`\n *\n * @function Phaser.Actions.SetOrigin\n * @since 3.0.0\n *\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\n *\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\n * @param {number} originX - The amount to set the `originX` property to.\n * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\n * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\n * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\n *\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\n */\nvar SetOrigin = function (items, originX, originY, stepX, stepY, index, direction)\n{\n    if (originY === undefined || originY === null) { originY = originX; }\n\n    PropertyValueSet(items, 'originX', originX, stepX, index, direction);\n    PropertyValueSet(items, 'originY', originY, stepY, index, direction);\n\n    items.forEach(function (item)\n    {\n        item.updateDisplayOrigin();\n    });\n\n    return items;\n};\n\nmodule.exports = SetOrigin;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `rotation`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetRotation(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetRotation\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetRotation = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'rotation', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetRotation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `scaleX` and `scaleY`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScale(group.getChildren(), scaleX, scaleY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetScale\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} scaleX - The amount to set the `scaleX` property to.\r\n * @param {number} [scaleY] - The amount to set the `scaleY` property to. If `undefined` or `null` it uses the `scaleX` value.\r\n * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScale = function (items, scaleX, scaleY, stepX, stepY, index, direction)\r\n{\r\n    if (scaleY === undefined || scaleY === null) { scaleY = scaleX; }\r\n\r\n    PropertyValueSet(items, 'scaleX', scaleX, stepX, index, direction);\r\n\r\n    return PropertyValueSet(items, 'scaleY', scaleY, stepY, index, direction);\r\n};\r\n\r\nmodule.exports = SetScale;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scaleX`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScaleX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScaleX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScaleX = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'scaleX', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetScaleX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scaleY`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScaleY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScaleY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScaleY = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'scaleY', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetScaleY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `scrollFactorX` and `scrollFactorY`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScrollFactor(group.getChildren(), scrollFactorX, scrollFactorY, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetScrollFactor\r\n * @since 3.21.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} scrollFactorX - The amount to set the `scrollFactorX` property to.\r\n * @param {number} [scrollFactorY] - The amount to set the `scrollFactorY` property to. If `undefined` or `null` it uses the `scrollFactorX` value.\r\n * @param {number} [stepX=0] - This is added to the `scrollFactorX` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `scrollFactorY` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScrollFactor = function (items, scrollFactorX, scrollFactorY, stepX, stepY, index, direction)\r\n{\r\n    if (scrollFactorY === undefined || scrollFactorY === null) { scrollFactorY = scrollFactorX; }\r\n\r\n    PropertyValueSet(items, 'scrollFactorX', scrollFactorX, stepX, index, direction);\r\n\r\n    return PropertyValueSet(items, 'scrollFactorY', scrollFactorY, stepY, index, direction);\r\n};\r\n\r\nmodule.exports = SetScrollFactor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scrollFactorX`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScrollFactorX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScrollFactorX\r\n * @since 3.21.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScrollFactorX = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'scrollFactorX', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetScrollFactorX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `scrollFactorY`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetScrollFactorY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetScrollFactorY\r\n * @since 3.21.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetScrollFactorY = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'scrollFactorY', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetScrollFactorY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public method setTint() and then updates it to the given value(s). You can specify tint color per corner or provide only one color value for `topLeft` parameter, in which case whole item will be tinted with that color.\r\n *\r\n * @function Phaser.Actions.SetTint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.\r\n * @param {number} [topRight] - The tint to be applied to top-right corner of item.\r\n * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.\r\n * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar SetTint = function (items, topLeft, topRight, bottomLeft, bottomRight)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].setTint(topLeft, topRight, bottomLeft, bottomRight);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = SetTint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `visible`\r\n * and then sets it to the given value.\r\n *\r\n * To use this with a Group: `SetVisible(group.getChildren(), value)`\r\n *\r\n * @function Phaser.Actions.SetVisible\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {boolean} value - The value to set the property to.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetVisible = function (items, value, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'visible', value, 0, index, direction);\r\n};\r\n\r\nmodule.exports = SetVisible;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `x`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetX(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetX\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetX = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'x', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public properties `x` and `y`\r\n * and then sets them to the given values.\r\n *\r\n * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetXY(group.getChildren(), x, y, stepX, stepY)`\r\n *\r\n * @function Phaser.Actions.SetXY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} x - The amount to set the `x` property to.\r\n * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetXY = function (items, x, y, stepX, stepY, index, direction)\r\n{\r\n    if (y === undefined || y === null) { y = x; }\r\n\r\n    PropertyValueSet(items, 'x', x, stepX, index, direction);\r\n\r\n    return PropertyValueSet(items, 'y', y, stepY, index, direction);\r\n};\r\n\r\nmodule.exports = SetXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PropertyValueSet = require('./PropertyValueSet');\r\n\r\n/**\r\n * Takes an array of Game Objects, or any objects that have the public property `y`\r\n * and then sets it to the given value.\r\n *\r\n * The optional `step` property is applied incrementally, multiplied by each item in the array.\r\n *\r\n * To use this with a Group: `SetY(group.getChildren(), value, step)`\r\n *\r\n * @function Phaser.Actions.SetY\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - The array of items to be updated by this action.\r\n * @param {number} value - The amount to set the property to.\r\n * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of objects that were passed to this Action.\r\n */\r\nvar SetY = function (items, value, step, index, direction)\r\n{\r\n    return PropertyValueSet(items, 'y', value, step, index, direction);\r\n};\r\n\r\nmodule.exports = SetY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * Iterate through the items array changing the position of each element to be that of the element that came before\r\n * it in the array (or after it if direction = 1)\r\n * \r\n * The first items position is set to x/y.\r\n * \r\n * The final x/y coords are returned\r\n *\r\n * @function Phaser.Actions.ShiftPosition\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items]\r\n * @generic {Phaser.Math.Vector2} O - [output,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {number} x - The x coordinate to place the first item in the array at.\r\n * @param {number} y - The y coordinate to place the first item in the array at.\r\n * @param {number} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n * @param {(Phaser.Math.Vector2|object)} [output] - An optional objec to store the final objects position in.\r\n *\r\n * @return {Phaser.Math.Vector2} The output vector.\r\n */\r\nvar ShiftPosition = function (items, x, y, direction, output)\r\n{\r\n    if (direction === undefined) { direction = 0; }\r\n    if (output === undefined) { output = new Vector2(); }\r\n\r\n    var px;\r\n    var py;\r\n\r\n    if (items.length > 1)\r\n    {\r\n        var i;\r\n        var cx;\r\n        var cy;\r\n        var cur;\r\n\r\n        if (direction === 0)\r\n        {\r\n            //  Bottom to Top\r\n\r\n            var len = items.length - 1;\r\n\r\n            px = items[len].x;\r\n            py = items[len].y;\r\n\r\n            for (i = len - 1; i >= 0; i--)\r\n            {\r\n                //  Current item\r\n                cur = items[i];\r\n\r\n                //  Get current item x/y, to be passed to the next item in the list\r\n                cx = cur.x;\r\n                cy = cur.y;\r\n\r\n                //  Set current item to the previous items x/y\r\n                cur.x = px;\r\n                cur.y = py;\r\n\r\n                //  Set current as previous\r\n                px = cx;\r\n                py = cy;\r\n            }\r\n\r\n            //  Update the head item to the new x/y coordinates\r\n            items[len].x = x;\r\n            items[len].y = y;\r\n        }\r\n        else\r\n        {\r\n            //  Top to Bottom\r\n\r\n            px = items[0].x;\r\n            py = items[0].y;\r\n\r\n            for (i = 1; i < items.length; i++)\r\n            {\r\n                //  Current item\r\n                cur = items[i];\r\n\r\n                //  Get current item x/y, to be passed to the next item in the list\r\n                cx = cur.x;\r\n                cy = cur.y;\r\n\r\n                //  Set current item to the previous items x/y\r\n                cur.x = px;\r\n                cur.y = py;\r\n\r\n                //  Set current as previous\r\n                px = cx;\r\n                py = cy;\r\n            }\r\n\r\n            //  Update the head item to the new x/y coordinates\r\n            items[0].x = x;\r\n            items[0].y = y;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        px = items[0].x;\r\n        py = items[0].y;\r\n\r\n        items[0].x = x;\r\n        items[0].y = y;\r\n    }\r\n\r\n    //  Return the final set of coordinates as they're effectively lost from the shift and may be needed\r\n\r\n    output.x = px;\r\n    output.y = py;\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = ShiftPosition;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArrayShuffle = require('../utils/array/Shuffle');\r\n\r\n/**\r\n * Shuffles the array in place. The shuffled array is both modified and returned.\r\n *\r\n * @function Phaser.Actions.Shuffle\r\n * @since 3.0.0\r\n * @see Phaser.Utils.Array.Shuffle\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar Shuffle = function (items)\r\n{\r\n    return ArrayShuffle(items);\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathSmoothStep = require('../math/SmoothStep');\r\n\r\n/**\r\n * Smoothstep is a sigmoid-like interpolation and clamping function.\r\n * \r\n * The function depends on three parameters, the input x, the \"left edge\" and the \"right edge\", with the left edge being assumed smaller than the right edge. The function receives a real number x as an argument and returns 0 if x is less than or equal to the left edge, 1 if x is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial, between 0 and 1 otherwise. The slope of the smoothstep function is zero at both edges. This is convenient for creating a sequence of transitions using smoothstep to interpolate each segment as an alternative to using more sophisticated or expensive interpolation techniques.\r\n *\r\n * @function Phaser.Actions.SmoothStep\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - The property of the Game Object to interpolate.\r\n * @param {number} min - The minimum interpolation value.\r\n * @param {number} max - The maximum interpolation value.\r\n * @param {boolean} [inc=false] - Should the values be incremented? `true` or set (`false`)\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar SmoothStep = function (items, property, min, max, inc)\r\n{\r\n    if (inc === undefined) { inc = false; }\r\n\r\n    var step = Math.abs(max - min) / items.length;\r\n    var i;\r\n\r\n    if (inc)\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] += MathSmoothStep(i * step, min, max);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] = MathSmoothStep(i * step, min, max);\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MathSmootherStep = require('../math/SmootherStep');\r\n\r\n/**\r\n * Smootherstep is a sigmoid-like interpolation and clamping function.\r\n * \r\n * The function depends on three parameters, the input x, the \"left edge\" and the \"right edge\", with the left edge being assumed smaller than the right edge. The function receives a real number x as an argument and returns 0 if x is less than or equal to the left edge, 1 if x is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial, between 0 and 1 otherwise. The slope of the smoothstep function is zero at both edges. This is convenient for creating a sequence of transitions using smoothstep to interpolate each segment as an alternative to using more sophisticated or expensive interpolation techniques.\r\n *\r\n * @function Phaser.Actions.SmootherStep\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - The property of the Game Object to interpolate.\r\n * @param {number} min - The minimum interpolation value.\r\n * @param {number} max - The maximum interpolation value.\r\n * @param {boolean} [inc=false] - Should the values be incremented? `true` or set (`false`)\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar SmootherStep = function (items, property, min, max, inc)\r\n{\r\n    if (inc === undefined) { inc = false; }\r\n\r\n    var step = Math.abs(max - min) / items.length;\r\n    var i;\r\n\r\n    if (inc)\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] += MathSmootherStep(i * step, min, max);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] = MathSmootherStep(i * step, min, max);\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = SmootherStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects and then modifies their `property` so the value equals, or is incremented, by the\r\n * calculated spread value.\r\n * \r\n * The spread value is derived from the given `min` and `max` values and the total number of items in the array.\r\n * \r\n * For example, to cause an array of Sprites to change in alpha from 0 to 1 you could call:\r\n * \r\n * ```javascript\r\n * Phaser.Actions.Spread(itemsArray, 'alpha', 0, 1);\r\n * ```\r\n *\r\n * @function Phaser.Actions.Spread\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {string} property - The property of the Game Object to spread.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n * @param {boolean} [inc=false] - Should the values be incremented? `true` or set (`false`)\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that were passed to this Action.\r\n */\r\nvar Spread = function (items, property, min, max, inc)\r\n{\r\n    if (inc === undefined) { inc = false; }\r\n\r\n    var step = Math.abs(max - min) / items.length;\r\n    var i;\r\n\r\n    if (inc)\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] += i * step + min;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (i = 0; i < items.length; i++)\r\n        {\r\n            items[i][property] = i * step + min;\r\n        }\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = Spread;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Takes an array of Game Objects and toggles the visibility of each one.\r\n * Those previously `visible = false` will become `visible = true`, and vice versa.\r\n *\r\n * @function Phaser.Actions.ToggleVisible\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar ToggleVisible = function (items)\r\n{\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        items[i].visible = !items[i].visible;\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = ToggleVisible;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       samme <samme.npm@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Wrap = require('../math/Wrap');\r\n\r\n/**\r\n * Wrap each item's coordinates within a rectangle's area.\r\n *\r\n * @function Phaser.Actions.WrapInRectangle\r\n * @since 3.0.0\r\n * @see Phaser.Math.Wrap\r\n *\r\n * @generic {Phaser.GameObjects.GameObject[]} G - [items,$return]\r\n *\r\n * @param {(array|Phaser.GameObjects.GameObject[])} items - An array of Game Objects. The contents of this array are updated by this Action.\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle.\r\n * @param {number} [padding=0] - An amount added to each side of the rectangle during the operation.\r\n *\r\n * @return {(array|Phaser.GameObjects.GameObject[])} The array of Game Objects that was passed to this Action.\r\n */\r\nvar WrapInRectangle = function (items, rect, padding)\r\n{\r\n    if (padding === undefined)\r\n    {\r\n        padding = 0;\r\n    }\r\n\r\n    for (var i = 0; i < items.length; i++)\r\n    {\r\n        var item = items[i];\r\n\r\n        item.x = Wrap(item.x, rect.left - padding, rect.right + padding);\r\n        item.y = Wrap(item.y, rect.top - padding, rect.bottom + padding);\r\n    }\r\n\r\n    return items;\r\n};\r\n\r\nmodule.exports = WrapInRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Actions\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AlignTo: require('./AlignTo'),\r\n    Angle: require('./Angle'),\r\n    Call: require('./Call'),\r\n    GetFirst: require('./GetFirst'),\r\n    GetLast: require('./GetLast'),\r\n    GridAlign: require('./GridAlign'),\r\n    IncAlpha: require('./IncAlpha'),\r\n    IncX: require('./IncX'),\r\n    IncXY: require('./IncXY'),\r\n    IncY: require('./IncY'),\r\n    PlaceOnCircle: require('./PlaceOnCircle'),\r\n    PlaceOnEllipse: require('./PlaceOnEllipse'),\r\n    PlaceOnLine: require('./PlaceOnLine'),\r\n    PlaceOnRectangle: require('./PlaceOnRectangle'),\r\n    PlaceOnTriangle: require('./PlaceOnTriangle'),\r\n    PlayAnimation: require('./PlayAnimation'),\r\n    PropertyValueInc: require('./PropertyValueInc'),\r\n    PropertyValueSet: require('./PropertyValueSet'),\r\n    RandomCircle: require('./RandomCircle'),\r\n    RandomEllipse: require('./RandomEllipse'),\r\n    RandomLine: require('./RandomLine'),\r\n    RandomRectangle: require('./RandomRectangle'),\r\n    RandomTriangle: require('./RandomTriangle'),\r\n    Rotate: require('./Rotate'),\r\n    RotateAround: require('./RotateAround'),\r\n    RotateAroundDistance: require('./RotateAroundDistance'),\r\n    ScaleX: require('./ScaleX'),\r\n    ScaleXY: require('./ScaleXY'),\r\n    ScaleY: require('./ScaleY'),\r\n    SetAlpha: require('./SetAlpha'),\r\n    SetBlendMode: require('./SetBlendMode'),\r\n    SetDepth: require('./SetDepth'),\r\n    SetHitArea: require('./SetHitArea'),\r\n    SetOrigin: require('./SetOrigin'),\r\n    SetRotation: require('./SetRotation'),\r\n    SetScale: require('./SetScale'),\r\n    SetScaleX: require('./SetScaleX'),\r\n    SetScaleY: require('./SetScaleY'),\r\n    SetScrollFactor: require('./SetScrollFactor'),\r\n    SetScrollFactorX: require('./SetScrollFactorX'),\r\n    SetScrollFactorY: require('./SetScrollFactorY'),\r\n    SetTint: require('./SetTint'),\r\n    SetVisible: require('./SetVisible'),\r\n    SetX: require('./SetX'),\r\n    SetXY: require('./SetXY'),\r\n    SetY: require('./SetY'),\r\n    ShiftPosition: require('./ShiftPosition'),\r\n    Shuffle: require('./Shuffle'),\r\n    SmootherStep: require('./SmootherStep'),\r\n    SmoothStep: require('./SmoothStep'),\r\n    Spread: require('./Spread'),\r\n    ToggleVisible: require('./ToggleVisible'),\r\n    WrapInRectangle: require('./WrapInRectangle')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Circle = require('../../geom/circle/Circle');\r\nvar CircleContains = require('../../geom/circle/Contains');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * A Zone Game Object.\r\n *\r\n * A Zone is a non-rendering rectangular Game Object that has a position and size.\r\n * It has no texture and never displays, but does live on the display list and\r\n * can be moved, scaled and rotated like any other Game Object.\r\n *\r\n * Its primary use is for creating Drop Zones and Input Hit Areas and it has a couple of helper methods\r\n * specifically for this. It is also useful for object overlap checks, or as a base for your own\r\n * non-displaying Game Objects.\r\n\r\n * The default origin is 0.5, the center of the Zone, the same as with Game Objects.\r\n *\r\n * @class Zone\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} [width=1] - The width of the Game Object.\r\n * @param {number} [height=1] - The height of the Game Object.\r\n */\r\nvar Zone = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Origin,\r\n        Components.Transform,\r\n        Components.ScrollFactor,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Zone (scene, x, y, width, height)\r\n    {\r\n        if (width === undefined) { width = 1; }\r\n        if (height === undefined) { height = width; }\r\n\r\n        GameObject.call(this, scene, 'Zone');\r\n\r\n        this.setPosition(x, y);\r\n\r\n        /**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The Blend Mode of the Game Object.\r\n         * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into\r\n         * display lists without causing a batch flush.\r\n         *\r\n         * @name Phaser.GameObjects.Zone#blendMode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.blendMode = BlendModes.NORMAL;\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * @name Phaser.GameObjects.Zone#displayWidth\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * @name Phaser.GameObjects.Zone#displayHeight\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * @param {boolean} [resizeInput=true] - If this Zone has a Rectangle for a hit area this argument will resize the hit area as well.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSize: function (width, height, resizeInput)\r\n    {\r\n        if (resizeInput === undefined) { resizeInput = true; }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        var input = this.input;\r\n\r\n        if (resizeInput && input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = width;\r\n            input.hitArea.height = height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Game Object.\r\n     * Calling this will adjust the scale.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setDisplaySize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Zone to be a Circular Drop Zone.\r\n     * The circle is centered on this Zones `x` and `y` coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setCircleDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the Circle that will form the Drop Zone.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setCircleDropZone: function (radius)\r\n    {\r\n        return this.setDropZone(new Circle(0, 0, radius), CircleContains);\r\n    },\r\n\r\n    /**\r\n     * Sets this Zone to be a Rectangle Drop Zone.\r\n     * The rectangle is centered on this Zones `x` and `y` coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setRectangleDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the rectangle drop zone.\r\n     * @param {number} height - The height of the rectangle drop zone.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setRectangleDropZone: function (width, height)\r\n    {\r\n        return this.setDropZone(new Rectangle(0, 0, width, height), RectangleContains);\r\n    },\r\n\r\n    /**\r\n     * Allows you to define your own Geometry shape to be used as a Drop Zone.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setDropZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} hitArea - A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A function that will return `true` if the given x/y coords it is sent are within the shape.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDropZone: function (hitArea, hitAreaCallback)\r\n    {\r\n        if (hitArea === undefined)\r\n        {\r\n            this.setRectangleDropZone(this.width, this.height);\r\n        }\r\n        else if (!this.input)\r\n        {\r\n            this.setInteractive(hitArea, hitAreaCallback, true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Zone to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setAlpha\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Zone to a Container in Canvas.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#setBlendMode\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A Zone does not render.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#renderCanvas\r\n     * @private\r\n     * @since 3.53.0\r\n     *\r\n     * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n     * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n     */\r\n    renderCanvas: function (renderer, src, camera)\r\n    {\r\n        camera.addToRenderList(src);\r\n    },\r\n\r\n    /**\r\n     * A Zone does not render.\r\n     *\r\n     * @method Phaser.GameObjects.Zone#renderWebGL\r\n     * @private\r\n     * @since 3.53.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n     * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n     */\r\n    renderWebGL: function (renderer, src, camera)\r\n    {\r\n        camera.addToRenderList(src);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Zone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Moves the element at the start of the array to the end, shifting all items in the process.\r\n * The \"rotation\" happens to the left.\r\n *\r\n * @function Phaser.Utils.Array.RotateLeft\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the left. This array is modified in place.\r\n * @param {number} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */\r\nvar RotateLeft = function (array, total)\r\n{\r\n    if (total === undefined) { total = 1; }\r\n\r\n    var element = null;\r\n\r\n    for (var i = 0; i < total; i++)\r\n    {\r\n        element = array.shift();\r\n        array.push(element);\r\n    }\r\n\r\n    return element;\r\n};\r\n\r\nmodule.exports = RotateLeft;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Moves the element at the end of the array to the start, shifting all items in the process.\r\n * The \"rotation\" happens to the right.\r\n *\r\n * @function Phaser.Utils.Array.RotateRight\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the right. This array is modified in place.\r\n * @param {number} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */\r\nvar RotateRight = function (array, total)\r\n{\r\n    if (total === undefined) { total = 1; }\r\n\r\n    var element = null;\r\n\r\n    for (var i = 0; i < total; i++)\r\n    {\r\n        element = array.pop();\r\n        array.unshift(element);\r\n    }\r\n\r\n    return element;\r\n};\r\n\r\nmodule.exports = RotateRight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Shuffles the contents of the given array using the Fisher-Yates implementation.\r\n *\r\n * The original array is modified directly and returned.\r\n *\r\n * @function Phaser.Utils.Array.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [array,$return]\r\n *\r\n * @param {T[]} array - The array to shuffle. This array is modified in place.\r\n *\r\n * @return {T[]} The shuffled array.\r\n */\r\nvar Shuffle = function (array)\r\n{\r\n    for (var i = array.length - 1; i > 0; i--)\r\n    {\r\n        var j = Math.floor(Math.random() * (i + 1));\r\n        var temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n\r\n    return array;\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n"],"names":["QuickSet","module","exports","items","position","offsetX","offsetY","target","i","length","item","PropertyValueInc","value","step","index","direction","callback","context","call","compare","undefined","match","property","AlignIn","CONST","GetFastValue","NOOP","tempZone","sys","queueDepthSort","events","once","options","widthSet","hasOwnProperty","heightSet","width","height","cellWidth","cellHeight","TOP_LEFT","x","y","cx","cy","w","h","setPosition","setSize","stepX","stepY","circle","startAngle","endAngle","angle","angleStep","radius","Math","cos","sin","ellipse","a","b","GetPoints","line","points","point","MarchingAnts","RotateLeft","RotateRight","rect","shift","abs","BresenhamPoints","triangle","stepRate","p1","x1","y1","x2","y2","p2","x3","y3","p3","pop","concat","p","floor","key","ignoreIfPlaying","gameObject","anims","play","t","end","Random","RotateAroundDistance","DistanceBetween","max","MathRotateAroundDistance","distance","scaleX","scaleY","PropertyValueSet","hitArea","hitAreaCallback","setInteractive","originX","originY","forEach","updateDisplayOrigin","scrollFactorX","scrollFactorY","topLeft","topRight","bottomLeft","bottomRight","setTint","Vector2","output","px","py","cur","len","ArrayShuffle","MathSmoothStep","min","inc","MathSmootherStep","visible","Wrap","padding","left","right","top","bottom","AlignTo","Angle","Call","GetFirst","GetLast","GridAlign","IncAlpha","IncX","IncXY","IncY","PlaceOnCircle","PlaceOnEllipse","PlaceOnLine","PlaceOnRectangle","PlaceOnTriangle","PlayAnimation","RandomCircle","RandomEllipse","RandomLine","RandomRectangle","RandomTriangle","Rotate","RotateAround","ScaleX","ScaleXY","ScaleY","SetAlpha","SetBlendMode","SetDepth","SetHitArea","SetOrigin","SetRotation","SetScale","SetScaleX","SetScaleY","SetScrollFactor","SetScrollFactorX","SetScrollFactorY","SetTint","SetVisible","SetX","SetXY","SetY","ShiftPosition","Shuffle","SmootherStep","SmoothStep","Spread","ToggleVisible","WrapInRectangle","BlendModes","Circle","CircleContains","Class","Components","GameObject","Rectangle","RectangleContains","Zone","Extends","Mixins","Depth","GetBounds","Origin","Transform","ScrollFactor","Visible","initialize","scene","this","blendMode","NORMAL","displayWidth","get","set","displayHeight","resizeInput","input","customHitArea","setDisplaySize","setCircleDropZone","setDropZone","setRectangleDropZone","setAlpha","setBlendMode","renderCanvas","renderer","src","camera","addToRenderList","renderWebGL","array","total","element","push","unshift","j","random","temp"],"sourceRoot":""}