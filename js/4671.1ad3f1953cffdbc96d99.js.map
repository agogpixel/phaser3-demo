{"version":3,"file":"js/4671.1ad3f1953cffdbc96d99.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/CircleToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/Face.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/GenerateObjVerts.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/GenerateVerts.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/mesh/Vertex.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Contains.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/GetAABB.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/GetPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Perimeter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Polygon.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/polygon/Smooth.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/Union.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/easing/EaseMap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tweens/builders/GetEaseFunction.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/string/UppercaseFirst.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks for intersection between a circle and a rectangle.\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The circle to be checked.\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to be checked.\r\n *\r\n * @return {boolean} `true` if the two objects intersect, otherwise `false`.\r\n */\r\nvar CircleToRectangle = function (circle, rect)\r\n{\r\n    var halfWidth = rect.width / 2;\r\n    var halfHeight = rect.height / 2;\r\n\r\n    var cx = Math.abs(circle.x - rect.x - halfWidth);\r\n    var cy = Math.abs(circle.y - rect.y - halfHeight);\r\n    var xDist = halfWidth + circle.radius;\r\n    var yDist = halfHeight + circle.radius;\r\n\r\n    if (cx > xDist || cy > yDist)\r\n    {\r\n        return false;\r\n    }\r\n    else if (cx <= halfWidth || cy <= halfHeight)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        var xCornerDist = cx - halfWidth;\r\n        var yCornerDist = cy - halfHeight;\r\n        var xCornerDistSq = xCornerDist * xCornerDist;\r\n        var yCornerDistSq = yCornerDist * yCornerDist;\r\n        var maxCornerDistSq = circle.radius * circle.radius;\r\n\r\n        return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);\r\n    }\r\n};\r\n\r\nmodule.exports = CircleToRectangle;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Rectangle = require('../rectangle/Rectangle');\nvar Vector2 = require('../../math/Vector2');\n\n/**\n * Returns the length of the line.\n *\n * @ignore\n * @private\n *\n * @param {number} x1 - The x1 coordinate.\n * @param {number} y1 - The y1 coordinate.\n * @param {number} x2 - The x2 coordinate.\n * @param {number} y2 - The y2 coordinate.\n *\n * @return {number} The length of the line.\n */\nfunction GetLength (x1, y1, x2, y2)\n{\n    var x = x1 - x2;\n    var y = y1 - y2;\n    var magnitude = (x * x) + (y * y);\n\n    return Math.sqrt(magnitude);\n}\n\n/**\n * @classdesc\n * A Face Geometry Object.\n *\n * A Face is used by the Mesh Game Object. A Mesh consists of one, or more, faces that are\n * used to render the Mesh Game Objects in WebGL.\n *\n * A Face consists of 3 Vertex instances, for the 3 corners of the face and methods to help\n * you modify and test them.\n *\n * @class Face\n * @memberof Phaser.Geom.Mesh\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Geom.Mesh.Vertex} vertex1 - The first vertex of the Face.\n * @param {Phaser.Geom.Mesh.Vertex} vertex2 - The second vertex of the Face.\n * @param {Phaser.Geom.Mesh.Vertex} vertex3 - The third vertex of the Face.\n */\nvar Face = new Class({\n\n    initialize:\n\n    function Face (vertex1, vertex2, vertex3)\n    {\n        /**\n         * The first vertex in this Face.\n         *\n         * @name Phaser.Geom.Mesh.Face#vertex1\n         * @type {Phaser.Geom.Mesh.Vertex}\n         * @since 3.50.0\n         */\n        this.vertex1 = vertex1;\n\n        /**\n         * The second vertex in this Face.\n         *\n         * @name Phaser.Geom.Mesh.Face#vertex2\n         * @type {Phaser.Geom.Mesh.Vertex}\n         * @since 3.50.0\n         */\n        this.vertex2 = vertex2;\n\n        /**\n         * The third vertex in this Face.\n         *\n         * @name Phaser.Geom.Mesh.Face#vertex3\n         * @type {Phaser.Geom.Mesh.Vertex}\n         * @since 3.50.0\n         */\n        this.vertex3 = vertex3;\n\n        /**\n         * The bounds of this Face.\n         *\n         * Be sure to call the `Face.updateBounds` method _before_ using this property.\n         *\n         * @name Phaser.Geom.Mesh.Face#bounds\n         * @type {Phaser.Geom.Rectangle}\n         * @since 3.50.0\n         */\n        this.bounds = new Rectangle();\n\n        /**\n         * The face inCenter. Do not access directly, instead use the `getInCenter` method.\n         *\n         * @name Phaser.Geom.Mesh.Face#_inCenter\n         * @type {Phaser.Math.Vector2}\n         * @private\n         * @since 3.50.0\n         */\n        this._inCenter = new Vector2();\n    },\n\n    /**\n     * Calculates and returns the in-center position of this Face.\n     *\n     * @method Phaser.Geom.Mesh.Face#getInCenter\n     * @since 3.50.0\n     *\n     * @param {boolean} [local=true] Return the in center from the un-transformed vertex positions (`true`), or transformed? (`false`)\n     *\n     * @return {Phaser.Math.Vector2} A Vector2 containing the in center position of this Face.\n     */\n    getInCenter: function (local)\n    {\n        if (local === undefined) { local = true; }\n\n        var v1 = this.vertex1;\n        var v2 = this.vertex2;\n        var v3 = this.vertex3;\n\n        var v1x;\n        var v1y;\n\n        var v2x;\n        var v2y;\n\n        var v3x;\n        var v3y;\n\n        if (local)\n        {\n            v1x = v1.x;\n            v1y = v1.y;\n\n            v2x = v2.x;\n            v2y = v2.y;\n\n            v3x = v3.x;\n            v3y = v3.y;\n        }\n        else\n        {\n            v1x = v1.vx;\n            v1y = v1.vy;\n\n            v2x = v2.vx;\n            v2y = v2.vy;\n\n            v3x = v3.vx;\n            v3y = v3.vy;\n        }\n\n        var d1 = GetLength(v3x, v3y, v2x, v2y);\n        var d2 = GetLength(v1x, v1y, v3x, v3y);\n        var d3 = GetLength(v2x, v2y, v1x, v1y);\n\n        var p = d1 + d2 + d3;\n\n        return this._inCenter.set(\n            (v1x * d1 + v2x * d2 + v3x * d3) / p,\n            (v1y * d1 + v2y * d2 + v3y * d3) / p\n        );\n    },\n\n    /**\n     * Checks if the given coordinates are within this Face.\n     *\n     * You can optionally provide a transform matrix. If given, the Face vertices\n     * will be transformed first, before being checked against the coordinates.\n     *\n     * @method Phaser.Geom.Mesh.Face#contains\n     * @since 3.50.0\n     *\n     * @param {number} x - The horizontal position to check.\n     * @param {number} y - The vertical position to check.\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [calcMatrix] - Optional transform matrix to apply to the vertices before comparison.\n     *\n     * @return {boolean} `true` if the coordinates lay within this Face, otherwise `false`.\n     */\n    contains: function (x, y, calcMatrix)\n    {\n        var vertex1 = this.vertex1;\n        var vertex2 = this.vertex2;\n        var vertex3 = this.vertex3;\n\n        var v1x = vertex1.vx;\n        var v1y = vertex1.vy;\n\n        var v2x = vertex2.vx;\n        var v2y = vertex2.vy;\n\n        var v3x = vertex3.vx;\n        var v3y = vertex3.vy;\n\n        if (calcMatrix)\n        {\n            var a = calcMatrix.a;\n            var b = calcMatrix.b;\n            var c = calcMatrix.c;\n            var d = calcMatrix.d;\n            var e = calcMatrix.e;\n            var f = calcMatrix.f;\n\n            v1x = vertex1.vx * a + vertex1.vy * c + e;\n            v1y = vertex1.vx * b + vertex1.vy * d + f;\n\n            v2x = vertex2.vx * a + vertex2.vy * c + e;\n            v2y = vertex2.vx * b + vertex2.vy * d + f;\n\n            v3x = vertex3.vx * a + vertex3.vy * c + e;\n            v3y = vertex3.vx * b + vertex3.vy * d + f;\n        }\n\n        var t0x = v3x - v1x;\n        var t0y = v3y - v1y;\n\n        var t1x = v2x - v1x;\n        var t1y = v2y - v1y;\n\n        var t2x = x - v1x;\n        var t2y = y - v1y;\n\n        var dot00 = (t0x * t0x) + (t0y * t0y);\n        var dot01 = (t0x * t1x) + (t0y * t1y);\n        var dot02 = (t0x * t2x) + (t0y * t2y);\n        var dot11 = (t1x * t1x) + (t1y * t1y);\n        var dot12 = (t1x * t2x) + (t1y * t2y);\n\n        //  Compute barycentric coordinates\n        var bc = ((dot00 * dot11) - (dot01 * dot01));\n        var inv = (bc === 0) ? 0 : (1 / bc);\n        var u = ((dot11 * dot02) - (dot01 * dot12)) * inv;\n        var v = ((dot00 * dot12) - (dot01 * dot02)) * inv;\n\n        return (u >= 0 && v >= 0 && (u + v < 1));\n    },\n\n    /**\n     * Checks if the vertices in this Face are orientated counter-clockwise, or not.\n     *\n     * It checks the transformed position of the vertices, not the local one.\n     *\n     * @method Phaser.Geom.Mesh.Face#isCounterClockwise\n     * @since 3.50.0\n     *\n     * @param {number} z - The z-axis value to test against. Typically the `Mesh.modelPosition.z`.\n     *\n     * @return {boolean} `true` if the vertices in this Face run counter-clockwise, otherwise `false`.\n     */\n    isCounterClockwise: function (z)\n    {\n        var v1 = this.vertex1;\n        var v2 = this.vertex2;\n        var v3 = this.vertex3;\n\n        var d = (v2.vx - v1.vx) * (v3.vy - v1.vy) - (v2.vy - v1.vy) * (v3.vx - v1.vx);\n\n        return (z <= 0) ? d >= 0 : d < 0;\n    },\n\n    /**\n     * Loads the data from this Vertex into the given Typed Arrays.\n     *\n     * @method Phaser.Geom.Mesh.Face#load\n     * @since 3.50.0\n     *\n     * @param {Float32Array} F32 - A Float32 Array to insert the position, UV and unit data in to.\n     * @param {Uint32Array} U32 - A Uint32 Array to insert the color and alpha data in to.\n     * @param {number} offset - The index of the array to insert this Vertex to.\n     * @param {number} textureUnit - The texture unit currently in use.\n     * @param {number} tintEffect - The tint effect to use.\n     *\n     * @return {number} The new vertex index array offset.\n     */\n    load: function (F32, U32, offset, textureUnit, tintEffect)\n    {\n        offset = this.vertex1.load(F32, U32, offset, textureUnit, tintEffect);\n        offset = this.vertex2.load(F32, U32, offset, textureUnit, tintEffect);\n        offset = this.vertex3.load(F32, U32, offset, textureUnit, tintEffect);\n\n        return offset;\n    },\n\n    /**\n     * Transforms all Face vertices by the given matrix, storing the results in their `vx`, `vy` and `vz` properties.\n     *\n     * @method Phaser.Geom.Mesh.Face#transformCoordinatesLocal\n     * @since 3.50.0\n     *\n     * @param {Phaser.Math.Matrix4} transformMatrix - The transform matrix to apply to this vertex.\n     * @param {number} width - The width of the parent Mesh.\n     * @param {number} height - The height of the parent Mesh.\n     * @param {number} cameraZ - The z position of the MeshCamera.\n     *\n     * @return {this} This Face instance.\n     */\n    transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ)\n    {\n        this.vertex1.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);\n        this.vertex2.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);\n        this.vertex3.transformCoordinatesLocal(transformMatrix, width, height, cameraZ);\n\n        return this;\n    },\n\n    /**\n     * Updates the bounds of this Face, based on the translated values of the vertices.\n     *\n     * Call this method prior to accessing the `Face.bounds` property.\n     *\n     * @method Phaser.Geom.Mesh.Face#updateBounds\n     * @since 3.50.0\n     *\n     * @return {this} This Face instance.\n     */\n    updateBounds: function ()\n    {\n        var v1 = this.vertex1;\n        var v2 = this.vertex2;\n        var v3 = this.vertex3;\n\n        var bounds = this.bounds;\n\n        bounds.x = Math.min(v1.vx, v2.vx, v3.vx);\n        bounds.y = Math.min(v1.vy, v2.vy, v3.vy);\n        bounds.width = Math.max(v1.vx, v2.vx, v3.vx) - bounds.x;\n        bounds.height = Math.max(v1.vy, v2.vy, v3.vy) - bounds.y;\n\n        return this;\n    },\n\n    /**\n     * Checks if this Face is within the view of the given Camera.\n     *\n     * This method is called in the `MeshWebGLRenderer` function. It performs the following tasks:\n     *\n     * First, the `Vertex.update` method is called on each of the vertices. This populates them\n     * with the new translated values, updating their `tx`, `ty` and `ta` properties.\n     *\n     * Then it tests to see if this face is visible due to the alpha values, if not, it returns.\n     *\n     * After this, if `hideCCW` is set, it calls `isCounterClockwise` and returns if not.\n     *\n     * Finally, it will update the `Face.bounds` based on the newly translated vertex values\n     * and return the results of an intersection test between the bounds and the camera world view\n     * rectangle.\n     *\n     * @method Phaser.Geom.Mesh.Face#isInView\n     * @since 3.50.0\n     *\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against.\n     * @param {boolean} hideCCW - Test the counter-clockwise orientation of the verts?\n     * @param {number} z - The Cameras z position, used in the CCW test.\n     * @param {number} alpha - The alpha of the parent object.\n     * @param {number} a - The parent transform matrix data a component.\n     * @param {number} b - The parent transform matrix data b component.\n     * @param {number} c - The parent transform matrix data c component.\n     * @param {number} d - The parent transform matrix data d component.\n     * @param {number} e - The parent transform matrix data e component.\n     * @param {number} f - The parent transform matrix data f component.\n     * @param {boolean} roundPixels - Round the vertex position or not?\n     *\n     * @return {boolean} `true` if this Face can be seen by the Camera.\n     */\n    isInView: function (camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels)\n    {\n        var v1 = this.vertex1.update(a, b, c, d, e, f, roundPixels, alpha);\n        var v2 = this.vertex2.update(a, b, c, d, e, f, roundPixels, alpha);\n        var v3 = this.vertex3.update(a, b, c, d, e, f, roundPixels, alpha);\n\n        //  Alpha check first\n        if (v1.ta <= 0 && v2.ta <= 0 && v3.ta <= 0)\n        {\n            return false;\n        }\n\n        //  CCW check\n        if (hideCCW && !this.isCounterClockwise(z))\n        {\n            return false;\n        }\n\n        //  Bounds check\n        var bounds = this.bounds;\n\n        bounds.x = Math.min(v1.tx, v2.tx, v3.tx);\n        bounds.y = Math.min(v1.ty, v2.ty, v3.ty);\n        bounds.width = Math.max(v1.tx, v2.tx, v3.tx) - bounds.x;\n        bounds.height = Math.max(v1.ty, v2.ty, v3.ty) - bounds.y;\n\n        var cr = camera.x + camera.width;\n        var cb = camera.y + camera.height;\n\n        if (bounds.width <= 0 || bounds.height <= 0 || camera.width <= 0 || camera.height <= 0)\n        {\n            return false;\n        }\n\n        return !(bounds.right < camera.x || bounds.bottom < camera.y || bounds.x > cr || bounds.y > cb);\n    },\n\n    /**\n     * Translates the vertices of this Face by the given amounts.\n     *\n     * The actual vertex positions are adjusted, not their transformed position.\n     *\n     * Therefore, this updates the vertex data directly.\n     *\n     * @method Phaser.Geom.Mesh.Face#translate\n     * @since 3.50.0\n     *\n     * @param {number} x - The amount to horizontally translate by.\n     * @param {number} [y=0] - The amount to vertically translate by.\n     *\n     * @return {this} This Face instance.\n     */\n    translate: function (x, y)\n    {\n        if (y === undefined) { y = 0; }\n\n        var v1 = this.vertex1;\n        var v2 = this.vertex2;\n        var v3 = this.vertex3;\n\n        v1.x += x;\n        v1.y += y;\n\n        v2.x += x;\n        v2.y += y;\n\n        v3.x += x;\n        v3.y += y;\n\n        return this;\n    },\n\n    /**\n     * The x coordinate of this Face, based on the in center position of the Face.\n     *\n     * @name Phaser.Geom.Mesh.Face#x\n     * @type {number}\n     * @since 3.50.0\n     */\n    x: {\n\n        get: function ()\n        {\n            return this.getInCenter().x;\n        },\n\n        set: function (value)\n        {\n            var current = this.getInCenter();\n\n            this.translate(value - current.x, 0);\n        }\n\n    },\n\n    /**\n     * The y coordinate of this Face, based on the in center position of the Face.\n     *\n     * @name Phaser.Geom.Mesh.Face#y\n     * @type {number}\n     * @since 3.50.0\n     */\n    y: {\n\n        get: function ()\n        {\n            return this.getInCenter().y;\n        },\n\n        set: function (value)\n        {\n            var current = this.getInCenter();\n\n            this.translate(0, value - current.y);\n        }\n\n    },\n\n    /**\n     * Set the alpha value of this Face.\n     *\n     * Each vertex is given the same value. If you need to adjust the alpha on a per-vertex basis\n     * then use the `Vertex.alpha` property instead.\n     *\n     * When getting the alpha of this Face, it will return an average of the alpha\n     * component of all three vertices.\n     *\n     * @name Phaser.Geom.Mesh.Face#alpha\n     * @type {number}\n     * @since 3.50.0\n     */\n    alpha: {\n\n        get: function ()\n        {\n            var v1 = this.vertex1;\n            var v2 = this.vertex2;\n            var v3 = this.vertex3;\n\n            return (v1.alpha + v2.alpha + v3.alpha) / 3;\n        },\n\n        set: function (value)\n        {\n            this.vertex1.alpha = value;\n            this.vertex2.alpha = value;\n            this.vertex3.alpha = value;\n        }\n\n    },\n\n    /**\n     * The depth of this Face, which is an average of the z component of all three vertices.\n     *\n     * The depth is calculated based on the transformed z value, not the local one.\n     *\n     * @name Phaser.Geom.Mesh.Face#depth\n     * @type {number}\n     * @readonly\n     * @since 3.50.0\n     */\n    depth: {\n\n        get: function ()\n        {\n            var v1 = this.vertex1;\n            var v2 = this.vertex2;\n            var v3 = this.vertex3;\n\n            return (v1.vz + v2.vz + v3.vz) / 3;\n        }\n\n    },\n\n    /**\n     * Destroys this Face and nulls the references to the vertices.\n     *\n     * @method Phaser.Geom.Mesh.Face#destroy\n     * @since 3.50.0\n     */\n    destroy: function ()\n    {\n        this.vertex1 = null;\n        this.vertex2 = null;\n        this.vertex3 = null;\n    }\n\n});\n\nmodule.exports = Face;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Face = require('./Face');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar Vector3 = require('../../math/Vector3');\r\nvar Vertex = require('./Vertex');\r\n\r\nvar tempPosition = new Vector3();\r\nvar tempRotation = new Vector3();\r\nvar tempMatrix = new Matrix4();\r\n\r\n/**\r\n * This method will return an object containing Face and Vertex instances, generated\r\n * from the parsed triangulated OBJ Model data given to this function.\r\n *\r\n * The obj data should have been parsed in advance via the ParseObj function:\r\n *\r\n * ```javascript\r\n * var data = Phaser.Geom.Mesh.ParseObj(rawData, flipUV);\r\n *\r\n * var results = GenerateObjVerts(data);\r\n * ```\r\n *\r\n * Alternatively, you can parse obj files loaded via the OBJFile loader:\r\n *\r\n * ```javascript\r\n * preload ()\r\n * {\r\n *   this.load.obj('alien', 'assets/3d/alien.obj);\r\n * }\r\n *\r\n * var results = GenerateObjVerts(this.cache.obj.get('alien));\r\n * ```\r\n *\r\n * Make sure your 3D package has triangulated the model data prior to exporting it.\r\n *\r\n * You can use the data returned by this function to populate the vertices of a Mesh Game Object.\r\n *\r\n * You may add multiple models to a single Mesh, although they will act as one when\r\n * moved or rotated. You can scale the model data, should it be too small (or large) to visualize.\r\n * You can also offset the model via the `x`, `y` and `z` parameters.\r\n *\r\n * @function Phaser.Geom.Mesh.GenerateObjVerts\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Geom.Mesh.OBJData} data - The parsed OBJ model data.\r\n * @param {Phaser.GameObjects.Mesh} [mesh] - An optional Mesh Game Object. If given, the generated Faces will be automatically added to this Mesh. Set to `null` to skip.\r\n * @param {number} [scale=1] - An amount to scale the model data by. Use this if the model has exported too small, or large, to see.\r\n * @param {number} [x=0] - Translate the model x position by this amount.\r\n * @param {number} [y=0] - Translate the model y position by this amount.\r\n * @param {number} [z=0] - Translate the model z position by this amount.\r\n * @param {number} [rotateX=0] - Rotate the model on the x axis by this amount, in radians.\r\n * @param {number} [rotateY=0] - Rotate the model on the y axis by this amount, in radians.\r\n * @param {number} [rotateZ=0] - Rotate the model on the z axis by this amount, in radians.\r\n * @param {boolean} [zIsUp=true] - Is the z axis up (true), or is y axis up (false)?\r\n *\r\n * @return {Phaser.Types.Geom.Mesh.GenerateVertsResult} The parsed Face and Vertex objects.\r\n */\r\nvar GenerateObjVerts = function (data, mesh, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n    if (x === undefined) { x = 0; }\r\n    if (y === undefined) { y = 0; }\r\n    if (z === undefined) { z = 0; }\r\n    if (rotateX === undefined) { rotateX = 0; }\r\n    if (rotateY === undefined) { rotateY = 0; }\r\n    if (rotateZ === undefined) { rotateZ = 0; }\r\n    if (zIsUp === undefined) { zIsUp = true; }\r\n\r\n    var result = {\r\n        faces: [],\r\n        verts: []\r\n    };\r\n\r\n    var materials = data.materials;\r\n\r\n    tempPosition.set(x, y, z);\r\n    tempRotation.set(rotateX, rotateY, rotateZ);\r\n    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, zIsUp);\r\n\r\n    for (var m = 0; m < data.models.length; m++)\r\n    {\r\n        var model = data.models[m];\r\n\r\n        var vertices = model.vertices;\r\n        var textureCoords = model.textureCoords;\r\n        var faces = model.faces;\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            var face = faces[i];\r\n\r\n            var v1 = face.vertices[0];\r\n            var v2 = face.vertices[1];\r\n            var v3 = face.vertices[2];\r\n\r\n            var m1 = vertices[v1.vertexIndex];\r\n            var m2 = vertices[v2.vertexIndex];\r\n            var m3 = vertices[v3.vertexIndex];\r\n\r\n            var t1 = v1.textureCoordsIndex;\r\n            var t2 = v2.textureCoordsIndex;\r\n            var t3 = v3.textureCoordsIndex;\r\n\r\n            var uv1 = (t1 === -1) ? { u: 0, v: 1 } : textureCoords[t1];\r\n            var uv2 = (t2 === -1) ? { u: 0, v: 0 } : textureCoords[t2];\r\n            var uv3 = (t3 === -1) ? { u: 1, v: 1 } : textureCoords[t3];\r\n\r\n            var color = 0xffffff;\r\n\r\n            if (face.material !== '' && materials[face.material])\r\n            {\r\n                color = materials[face.material];\r\n            }\r\n\r\n            var vert1 = new Vertex(m1.x * scale, m1.y * scale, m1.z * scale, uv1.u, uv1.v, color).transformMat4(tempMatrix);\r\n            var vert2 = new Vertex(m2.x * scale, m2.y * scale, m2.z * scale, uv2.u, uv2.v, color).transformMat4(tempMatrix);\r\n            var vert3 = new Vertex(m3.x * scale, m3.y * scale, m3.z * scale, uv3.u, uv3.v, color).transformMat4(tempMatrix);\r\n\r\n            result.verts.push(vert1, vert2, vert3);\r\n            result.faces.push(new Face(vert1, vert2, vert3));\r\n        }\r\n    }\r\n\r\n    if (mesh)\r\n    {\r\n        mesh.faces = mesh.faces.concat(result.faces);\r\n        mesh.vertices = mesh.vertices.concat(result.verts);\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nmodule.exports = GenerateObjVerts;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Face = require('./Face');\r\nvar Vertex = require('./Vertex');\r\n\r\n/**\r\n * Generates a set of Face and Vertex objects by parsing the given data.\r\n *\r\n * This method will take vertex data in one of two formats, based on the `containsZ` parameter.\r\n *\r\n * If your vertex data are `x`, `y` pairs, then `containsZ` should be `false` (this is the default)\r\n *\r\n * If your vertex data is groups of `x`, `y` and `z` values, then the `containsZ` parameter must be true.\r\n *\r\n * The `uvs` parameter is a numeric array consisting of `u` and `v` pairs.\r\n *\r\n * The `normals` parameter is a numeric array consisting of `x`, `y` vertex normal values and, if `containsZ` is true, `z` values as well.\r\n *\r\n * The `indicies` parameter is an optional array that, if given, is an indexed list of vertices to be added.\r\n *\r\n * The `colors` parameter is an optional array, or single value, that if given sets the color of each vertex created.\r\n *\r\n * The `alphas` parameter is an optional array, or single value, that if given sets the alpha of each vertex created.\r\n *\r\n * When providing indexed data it is assumed that _all_ of the arrays are indexed, not just the vertices.\r\n *\r\n * The following example will create a 256 x 256 sized quad using an index array:\r\n *\r\n * ```javascript\r\n * const vertices = [\r\n *   -128, 128,\r\n *   128, 128,\r\n *   -128, -128,\r\n *   128, -128\r\n * ];\r\n *\r\n * const uvs = [\r\n *   0, 1,\r\n *   1, 1,\r\n *   0, 0,\r\n *   1, 0\r\n * ];\r\n *\r\n * const indices = [ 0, 2, 1, 2, 3, 1 ];\r\n *\r\n * GenerateVerts(vertices, uvs, indicies);\r\n * ```\r\n *\r\n * If the data is not indexed, it's assumed that the arrays all contain sequential data.\r\n *\r\n * @function Phaser.Geom.Mesh.GenerateVerts\r\n * @since 3.50.0\r\n *\r\n * @param {number[]} vertices - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.\r\n * @param {number[]} uvs - The UVs pairs array.\r\n * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\r\n * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component?\r\n * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\r\n * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\r\n * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\r\n *\r\n * @return {Phaser.Types.Geom.Mesh.GenerateVertsResult} The parsed Face and Vertex objects.\r\n */\r\nvar GenerateVerts = function (vertices, uvs, indicies, containsZ, normals, colors, alphas)\r\n{\r\n    if (containsZ === undefined) { containsZ = false; }\r\n    if (colors === undefined) { colors = 0xffffff; }\r\n    if (alphas === undefined) { alphas = 1; }\r\n\r\n    if (vertices.length !== uvs.length)\r\n    {\r\n        console.warn('GenerateVerts: vertices and uvs count not equal');\r\n        return;\r\n    }\r\n\r\n    var result = {\r\n        faces: [],\r\n        vertices: []\r\n    };\r\n\r\n    var i;\r\n\r\n    var x;\r\n    var y;\r\n    var z;\r\n\r\n    var u;\r\n    var v;\r\n\r\n    var color;\r\n    var alpha;\r\n\r\n    var normalX;\r\n    var normalY;\r\n    var normalZ;\r\n\r\n    var iInc = (containsZ) ? 3 : 2;\r\n\r\n    var isColorArray = Array.isArray(colors);\r\n    var isAlphaArray = Array.isArray(alphas);\r\n\r\n    if (Array.isArray(indicies) && indicies.length > 0)\r\n    {\r\n        for (i = 0; i < indicies.length; i++)\r\n        {\r\n            var index1 = indicies[i];\r\n            var index2 = indicies[i] * 2;\r\n            var index3 = indicies[i] * iInc;\r\n\r\n            x = vertices[index3];\r\n            y = vertices[index3 + 1];\r\n            z = (containsZ) ? vertices[index3 + 2] : 0;\r\n\r\n            u = uvs[index2];\r\n            v = uvs[index2 + 1];\r\n\r\n            color = (isColorArray) ? colors[index1] : colors;\r\n            alpha = (isAlphaArray) ? alphas[index1] : alphas;\r\n\r\n            normalX = 0;\r\n            normalY = 0;\r\n            normalZ = 0;\r\n\r\n            if (normals)\r\n            {\r\n                normalX = normals[index3];\r\n                normalY = normals[index3 + 1];\r\n                normalZ = (containsZ) ? normals[index3 + 2] : 0;\r\n            }\r\n\r\n            result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        var uvIndex = 0;\r\n        var colorIndex = 0;\r\n\r\n        for (i = 0; i < vertices.length; i += iInc)\r\n        {\r\n            x = vertices[i];\r\n            y = vertices[i + 1];\r\n            z = (containsZ) ? vertices[i + 2] : 0;\r\n\r\n            u = uvs[uvIndex];\r\n            v = uvs[uvIndex + 1];\r\n\r\n            color = (isColorArray) ? colors[colorIndex] : colors;\r\n            alpha = (isAlphaArray) ? alphas[colorIndex] : alphas;\r\n\r\n            normalX = 0;\r\n            normalY = 0;\r\n            normalZ = 0;\r\n\r\n            if (normals)\r\n            {\r\n                normalX = normals[i];\r\n                normalY = normals[i + 1];\r\n                normalZ = (containsZ) ? normals[i + 2] : 0;\r\n            }\r\n\r\n            result.vertices.push(new Vertex(x, y, z, u, v, color, alpha, normalX, normalY, normalZ));\r\n\r\n            uvIndex += 2;\r\n            colorIndex++;\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < result.vertices.length; i += 3)\r\n    {\r\n        var vert1 = result.vertices[i];\r\n        var vert2 = result.vertices[i + 1];\r\n        var vert3 = result.vertices[i + 2];\r\n\r\n        result.faces.push(new Face(vert1, vert2, vert3));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nmodule.exports = GenerateVerts;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Utils = require('../../renderer/webgl/Utils');\nvar Vector3 = require('../../math/Vector3');\n\n/**\n * @classdesc\n * A Vertex Geometry Object.\n *\n * This class consists of all the information required for a single vertex within a Face Geometry Object.\n *\n * Faces, and thus Vertex objects, are used by the Mesh Game Object in order to render objects in WebGL.\n *\n * @class Vertex\n * @memberof Phaser.Geom.Mesh\n * @constructor\n * @extends Phaser.Math.Vector3\n * @since 3.50.0\n *\n * @param {number} x - The x position of the vertex.\n * @param {number} y - The y position of the vertex.\n * @param {number} z - The z position of the vertex.\n * @param {number} u - The UV u coordinate of the vertex.\n * @param {number} v - The UV v coordinate of the vertex.\n * @param {number} [color=0xffffff] - The color value of the vertex.\n * @param {number} [alpha=1] - The alpha value of the vertex.\n * @param {number} [nx=0] - The x normal value of the vertex.\n * @param {number} [ny=0] - The y normal value of the vertex.\n * @param {number} [nz=0] - The z normal value of the vertex.\n */\nvar Vertex = new Class({\n\n    Extends: Vector3,\n\n    initialize:\n\n    function Vertex (x, y, z, u, v, color, alpha, nx, ny, nz)\n    {\n        if (color === undefined) { color = 0xffffff; }\n        if (alpha === undefined) { alpha = 1; }\n        if (nx === undefined) { nx = 0; }\n        if (ny === undefined) { ny = 0; }\n        if (nz === undefined) { nz = 0; }\n\n        Vector3.call(this, x, y, z);\n\n        /**\n         * The projected x coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#vx\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.vx = 0;\n\n        /**\n         * The projected y coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#vy\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.vy = 0;\n\n        /**\n         * The projected z coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#vz\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.vz = 0;\n\n        /**\n         * The projected x coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#nx\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.nx = nx;\n\n        /**\n         * The projected y coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#ny\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.ny = ny;\n\n        /**\n         * The projected z coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#nz\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.nz = nz;\n\n        /**\n         * UV u coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#u\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.u = u;\n\n        /**\n         * UV v coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#v\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.v = v;\n\n        /**\n         * The color value of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#color\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.color = color;\n\n        /**\n         * The alpha value of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#alpha\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.alpha = alpha;\n\n        /**\n         * The translated x coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#tx\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.tx = 0;\n\n        /**\n         * The translated y coordinate of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#ty\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.ty = 0;\n\n        /**\n         * The translated alpha value of this vertex.\n         *\n         * @name Phaser.Geom.Mesh.Vertex#ta\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.ta = 0;\n    },\n\n    /**\n     * Sets the U and V properties.\n     *\n     * @method Phaser.Geom.Mesh.Vertex#setUVs\n     * @since 3.50.0\n     *\n     * @param {number} u - The UV u coordinate of the vertex.\n     * @param {number} v - The UV v coordinate of the vertex.\n     *\n     * @return {this} This Vertex.\n     */\n    setUVs: function (u, v)\n    {\n        this.u = u;\n        this.v = v;\n\n        return this;\n    },\n\n    /**\n     * Transforms this vertex by the given matrix, storing the results in `vx`, `vy` and `vz`.\n     *\n     * @method Phaser.Geom.Mesh.Vertex#transformCoordinatesLocal\n     * @since 3.50.0\n     *\n     * @param {Phaser.Math.Matrix4} transformMatrix - The transform matrix to apply to this vertex.\n     * @param {number} width - The width of the parent Mesh.\n     * @param {number} height - The height of the parent Mesh.\n     * @param {number} cameraZ - The z position of the MeshCamera.\n     */\n    transformCoordinatesLocal: function (transformMatrix, width, height, cameraZ)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n\n        var m = transformMatrix.val;\n\n        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];\n        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];\n        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];\n        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];\n\n        this.vx = (tx / tw) * width;\n        this.vy = -(ty / tw) * height;\n\n        if (cameraZ <= 0)\n        {\n            this.vz = (tz / tw);\n        }\n        else\n        {\n            this.vz = -(tz / tw);\n        }\n    },\n\n    /**\n     * Updates this Vertex based on the given transform.\n     *\n     * @method Phaser.Geom.Mesh.Vertex#update\n     * @since 3.50.0\n     *\n     * @param {number} a - The parent transform matrix data a component.\n     * @param {number} b - The parent transform matrix data b component.\n     * @param {number} c - The parent transform matrix data c component.\n     * @param {number} d - The parent transform matrix data d component.\n     * @param {number} e - The parent transform matrix data e component.\n     * @param {number} f - The parent transform matrix data f component.\n     * @param {boolean} roundPixels - Round the vertex position or not?\n     * @param {number} alpha - The alpha of the parent object.\n     *\n     * @return {this} This Vertex.\n     */\n    update: function (a, b, c, d, e, f, roundPixels, alpha)\n    {\n        var tx = this.vx * a + this.vy * c + e;\n        var ty = this.vx * b + this.vy * d + f;\n\n        if (roundPixels)\n        {\n            tx = Math.round(tx);\n            ty = Math.round(ty);\n        }\n\n        this.tx = tx;\n        this.ty = ty;\n        this.ta = this.alpha * alpha;\n\n        return this;\n    },\n\n    /**\n     * Loads the data from this Vertex into the given Typed Arrays.\n     *\n     * @method Phaser.Geom.Mesh.Vertex#load\n     * @since 3.50.0\n     *\n     * @param {Float32Array} F32 - A Float32 Array to insert the position, UV and unit data in to.\n     * @param {Uint32Array} U32 - A Uint32 Array to insert the color and alpha data in to.\n     * @param {number} offset - The index of the array to insert this Vertex to.\n     * @param {number} textureUnit - The texture unit currently in use.\n     * @param {number} tintEffect - The tint effect to use.\n     *\n     * @return {number} The new array offset.\n     */\n    load: function (F32, U32, offset, textureUnit, tintEffect)\n    {\n        F32[++offset] = this.tx;\n        F32[++offset] = this.ty;\n        F32[++offset] = this.u;\n        F32[++offset] = this.v;\n        F32[++offset] = textureUnit;\n        F32[++offset] = tintEffect;\n        U32[++offset] = Utils.getTintAppendFloatAlpha(this.color, this.ta);\n\n        return offset;\n    }\n\n});\n\nmodule.exports = Vertex;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n// Checks whether the x and y coordinates are contained within this polygon.\r\n//  Adapted from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html by Jonas Raoni Soares Silva\r\n\r\n/**\r\n * Checks if a point is within the bounds of a Polygon.\r\n *\r\n * @function Phaser.Geom.Polygon.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to check against.\r\n * @param {number} x - The X coordinate of the point to check.\r\n * @param {number} y - The Y coordinate of the point to check.\r\n *\r\n * @return {boolean} `true` if the point is within the bounds of the Polygon, otherwise `false`.\r\n */\r\nvar Contains = function (polygon, x, y)\r\n{\r\n    var inside = false;\r\n\r\n    for (var i = -1, j = polygon.points.length - 1; ++i < polygon.points.length; j = i)\r\n    {\r\n        var ix = polygon.points[i].x;\r\n        var iy = polygon.points[i].y;\r\n\r\n        var jx = polygon.points[j].x;\r\n        var jy = polygon.points[j].y;\r\n\r\n        if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix))\r\n        {\r\n            inside = !inside;\r\n        }\r\n    }\r\n\r\n    return inside;\r\n};\r\n\r\nmodule.exports = Contains;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../rectangle/Rectangle');\r\n\r\n/**\r\n * Calculates the bounding AABB rectangle of a polygon.\r\n *\r\n * @function Phaser.Geom.Polygon.GetAABB\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The polygon that should be calculated.\r\n * @param {(Phaser.Geom.Rectangle|object)} [out] - The rectangle or object that has x, y, width, and height properties to store the result. Optional.\r\n *\r\n * @return {(Phaser.Geom.Rectangle|object)} The resulting rectangle or object that is passed in with position and dimensions of the polygon's AABB.\r\n */\r\nvar GetAABB = function (polygon, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    var minX = Infinity;\r\n    var minY = Infinity;\r\n    var maxX = -minX;\r\n    var maxY = -minY;\r\n    var p;\r\n\r\n    for (var i = 0; i < polygon.points.length; i++)\r\n    {\r\n        p = polygon.points[i];\r\n\r\n        minX = Math.min(minX, p.x);\r\n        minY = Math.min(minY, p.y);\r\n        maxX = Math.max(maxX, p.x);\r\n        maxY = Math.max(maxY, p.y);\r\n    }\r\n\r\n    out.x = minX;\r\n    out.y = minY;\r\n    out.width = maxX - minX;\r\n    out.height = maxY - minY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetAABB;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\nvar Line = require('../line/Line');\r\nvar Perimeter = require('./Perimeter');\r\n\r\n/**\r\n * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Polygon.GetPoints\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to get the points from.\r\n * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.\r\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the perimeter of the Polygon.\r\n */\r\nvar GetPoints = function (polygon, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    var points = polygon.points;\r\n    var perimeter = Perimeter(polygon);\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity && stepRate > 0)\r\n    {\r\n        quantity = perimeter / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var position = perimeter * (i / quantity);\r\n        var accumulatedPerimeter = 0;\r\n\r\n        for (var j = 0; j < points.length; j++)\r\n        {\r\n            var pointA = points[j];\r\n            var pointB = points[(j + 1) % points.length];\r\n            var line = new Line(\r\n                pointA.x,\r\n                pointA.y,\r\n                pointB.x,\r\n                pointB.y\r\n            );\r\n            var length = Length(line);\r\n\r\n            if (position < accumulatedPerimeter || position > accumulatedPerimeter + length)\r\n            {\r\n                accumulatedPerimeter += length;\r\n                continue;\r\n            }\r\n\r\n            var point = line.getPoint((position - accumulatedPerimeter) / length);\r\n            out.push(point);\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Length = require('../line/Length');\r\nvar Line = require('../line/Line');\r\n\r\n/**\r\n * Returns the perimeter of the given Polygon.\r\n *\r\n * @function Phaser.Geom.Polygon.Perimeter\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The Polygon to get the perimeter of.\r\n *\r\n * @return {number} The perimeter of the Polygon.\r\n */\r\nvar Perimeter = function (polygon)\r\n{\r\n    var points = polygon.points;\r\n    var perimeter = 0;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        var pointA = points[i];\r\n        var pointB = points[(i + 1) % points.length];\r\n        var line = new Line(\r\n            pointA.x,\r\n            pointA.y,\r\n            pointB.x,\r\n            pointB.y\r\n        );\r\n\r\n        perimeter += Length(line);\r\n    }\r\n\r\n    return perimeter;\r\n};\r\n\r\nmodule.exports = Perimeter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Contains = require('./Contains');\r\nvar GetPoints = require('./GetPoints');\r\nvar GEOM_CONST = require('../const');\r\n\r\n/**\r\n * @classdesc\r\n * A Polygon object\r\n *\r\n * The polygon is a closed shape consists of a series of connected straight lines defined by list of ordered points.\r\n * Several formats are supported to define the list of points, check the setTo method for details.\r\n * This is a geometry object allowing you to define and inspect the shape.\r\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\r\n * To render a Polygon you should look at the capabilities of the Graphics class.\r\n *\r\n * @class Polygon\r\n * @memberof Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|number[]|Phaser.Types.Math.Vector2Like[])} [points] - List of points defining the perimeter of this Polygon. Several formats are supported:\r\n * - A string containing paired x y values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\r\n * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\r\n * - An array of objects with public x y properties: `[obj1, obj2, ...]`\r\n * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n */\r\nvar Polygon = new Class({\r\n\r\n    initialize:\r\n\r\n    function Polygon (points)\r\n    {\r\n        /**\r\n         * The geometry constant type of this object: `GEOM_CONST.POLYGON`.\r\n         * Used for fast type comparisons.\r\n         *\r\n         * @name Phaser.Geom.Polygon#type\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.type = GEOM_CONST.POLYGON;\r\n\r\n        /**\r\n         * The area of this Polygon.\r\n         *\r\n         * @name Phaser.Geom.Polygon#area\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.area = 0;\r\n\r\n        /**\r\n         * An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]\r\n         *\r\n         * @name Phaser.Geom.Polygon#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        if (points)\r\n        {\r\n            this.setTo(points);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check to see if the Polygon contains the given x / y coordinates.\r\n     *\r\n     * @method Phaser.Geom.Polygon#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check within the polygon.\r\n     * @param {number} y - The y coordinate to check within the polygon.\r\n     *\r\n     * @return {boolean} `true` if the coordinates are within the polygon, otherwise `false`.\r\n     */\r\n    contains: function (x, y)\r\n    {\r\n        return Contains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets this Polygon to the given points.\r\n     *\r\n     * The points can be set from a variety of formats:\r\n     *\r\n     * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\r\n     * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`\r\n     * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n     * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n     * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n     *\r\n     * `setTo` may also be called without any arguments to remove all points.\r\n     *\r\n     * @method Phaser.Geom.Polygon#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number[]|Phaser.Types.Math.Vector2Like[])} [points] - Points defining the perimeter of this polygon. Please check function description above for the different supported formats.\r\n     *\r\n     * @return {this} This Polygon object.\r\n     */\r\n    setTo: function (points)\r\n    {\r\n        this.area = 0;\r\n        this.points = [];\r\n\r\n        if (typeof points === 'string')\r\n        {\r\n            points = points.split(' ');\r\n        }\r\n\r\n        if (!Array.isArray(points))\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var p;\r\n        var y0 = Number.MAX_VALUE;\r\n\r\n        //  The points argument is an array, so iterate through it\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            p = { x: 0, y: 0 };\r\n\r\n            if (typeof points[i] === 'number' || typeof points[i] === 'string')\r\n            {\r\n                p.x = parseFloat(points[i]);\r\n                p.y = parseFloat(points[i + 1]);\r\n                i++;\r\n            }\r\n            else if (Array.isArray(points[i]))\r\n            {\r\n                //  An array of arrays?\r\n                p.x = points[i][0];\r\n                p.y = points[i][1];\r\n            }\r\n            else\r\n            {\r\n                p.x = points[i].x;\r\n                p.y = points[i].y;\r\n            }\r\n\r\n            this.points.push(p);\r\n\r\n            //  Lowest boundary\r\n            if (p.y < y0)\r\n            {\r\n                y0 = p.y;\r\n            }\r\n        }\r\n\r\n        this.calculateArea(y0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates the area of the Polygon. This is available in the property Polygon.area\r\n     *\r\n     * @method Phaser.Geom.Polygon#calculateArea\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The area of the polygon.\r\n     */\r\n    calculateArea: function ()\r\n    {\r\n        if (this.points.length < 3)\r\n        {\r\n            this.area = 0;\r\n\r\n            return this.area;\r\n        }\r\n\r\n        var sum = 0;\r\n        var p1;\r\n        var p2;\r\n\r\n        for (var i = 0; i < this.points.length - 1; i++)\r\n        {\r\n            p1 = this.points[i];\r\n            p2 = this.points[i + 1];\r\n\r\n            sum += (p2.x - p1.x) * (p1.y + p2.y);\r\n        }\r\n\r\n        p1 = this.points[0];\r\n        p2 = this.points[this.points.length - 1];\r\n\r\n        sum += (p1.x - p2.x) * (p2.y + p1.y);\r\n\r\n        this.area = -sum * 0.5;\r\n\r\n        return this.area;\r\n    },\r\n\r\n    /**\r\n     * Returns an array of Point objects containing the coordinates of the points around the perimeter of the Polygon,\r\n     * based on the given quantity or stepRate values.\r\n     *\r\n     * @method Phaser.Geom.Polygon#getPoints\r\n     * @since 3.12.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n     * @param {number} [stepRate] - Sets the quantity by getting the perimeter of the Polygon and dividing it by the stepRate.\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the perimeter of the Polygon.\r\n     */\r\n    getPoints: function (quantity, step, output)\r\n    {\r\n        return GetPoints(this, quantity, step, output);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Polygon;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Igor Ognichenko <ognichenko.igor@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar copy = function (out, a)\r\n{\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n  \r\n    return out;\r\n};\r\n\r\n/**\r\n * Takes a Polygon object and applies Chaikin's smoothing algorithm on its points.\r\n *\r\n * @function Phaser.Geom.Polygon.Smooth\r\n * @since 3.13.0\r\n *\r\n * @generic {Phaser.Geom.Polygon} O - [polygon,$return]\r\n *\r\n * @param {Phaser.Geom.Polygon} polygon - The polygon to be smoothed. The polygon will be modified in-place and returned.\r\n *\r\n * @return {Phaser.Geom.Polygon} The input polygon.\r\n */\r\nvar Smooth = function (polygon)\r\n{\r\n    var i;\r\n    var points = [];\r\n    var data = polygon.points;\r\n\r\n    for (i = 0; i < data.length; i++)\r\n    {\r\n        points.push([ data[i].x, data[i].y ]);\r\n    }\r\n\r\n    var output = [];\r\n  \r\n    if (points.length > 0)\r\n    {\r\n        output.push(copy([ 0, 0 ], points[0]));\r\n    }\r\n  \r\n    for (i = 0; i < points.length - 1; i++)\r\n    {\r\n        var p0 = points[i];\r\n        var p1 = points[i + 1];\r\n        var p0x = p0[0];\r\n        var p0y = p0[1];\r\n        var p1x = p1[0];\r\n        var p1y = p1[1];\r\n\r\n        output.push([ 0.85 * p0x + 0.15 * p1x, 0.85 * p0y + 0.15 * p1y ]);\r\n        output.push([ 0.15 * p0x + 0.85 * p1x, 0.15 * p0y + 0.85 * p1y ]);\r\n    }\r\n  \r\n    if (points.length > 1)\r\n    {\r\n        output.push(copy([ 0, 0 ], points[points.length - 1]));\r\n    }\r\n  \r\n    return polygon.setTo(output);\r\n};\r\n\r\nmodule.exports = Smooth;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\n\r\n/**\r\n * Creates a new Rectangle or repositions and/or resizes an existing Rectangle so that it encompasses the two given Rectangles, i.e. calculates their union.\r\n *\r\n * @function Phaser.Geom.Rectangle.Union\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Rectangle} rectA - The first Rectangle to use.\r\n * @param {Phaser.Geom.Rectangle} rectB - The second Rectangle to use.\r\n * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the union in.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The modified `out` Rectangle, or a new Rectangle if none was provided.\r\n */\r\nvar Union = function (rectA, rectB, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    //  Cache vars so we can use one of the input rects as the output rect\r\n    var x = Math.min(rectA.x, rectB.x);\r\n    var y = Math.min(rectA.y, rectB.y);\r\n    var w = Math.max(rectA.right, rectB.right) - x;\r\n    var h = Math.max(rectA.bottom, rectB.bottom) - y;\r\n\r\n    return out.setTo(x, y, w, h);\r\n};\r\n\r\nmodule.exports = Union;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Back = require('./back');\r\nvar Bounce = require('./bounce');\r\nvar Circular = require('./circular');\r\nvar Cubic = require('./cubic');\r\nvar Elastic = require('./elastic');\r\nvar Expo = require('./expo');\r\nvar Linear = require('./linear');\r\nvar Quadratic = require('./quadratic');\r\nvar Quartic = require('./quartic');\r\nvar Quintic = require('./quintic');\r\nvar Sine = require('./sine');\r\nvar Stepped = require('./stepped');\r\n\r\n//  EaseMap\r\nmodule.exports = {\r\n\r\n    Power0: Linear,\r\n    Power1: Quadratic.Out,\r\n    Power2: Cubic.Out,\r\n    Power3: Quartic.Out,\r\n    Power4: Quintic.Out,\r\n\r\n    Linear: Linear,\r\n    Quad: Quadratic.Out,\r\n    Cubic: Cubic.Out,\r\n    Quart: Quartic.Out,\r\n    Quint: Quintic.Out,\r\n    Sine: Sine.Out,\r\n    Expo: Expo.Out,\r\n    Circ: Circular.Out,\r\n    Elastic: Elastic.Out,\r\n    Back: Back.Out,\r\n    Bounce: Bounce.Out,\r\n    Stepped: Stepped,\r\n\r\n    'Quad.easeIn': Quadratic.In,\r\n    'Cubic.easeIn': Cubic.In,\r\n    'Quart.easeIn': Quartic.In,\r\n    'Quint.easeIn': Quintic.In,\r\n    'Sine.easeIn': Sine.In,\r\n    'Expo.easeIn': Expo.In,\r\n    'Circ.easeIn': Circular.In,\r\n    'Elastic.easeIn': Elastic.In,\r\n    'Back.easeIn': Back.In,\r\n    'Bounce.easeIn': Bounce.In,\r\n\r\n    'Quad.easeOut': Quadratic.Out,\r\n    'Cubic.easeOut': Cubic.Out,\r\n    'Quart.easeOut': Quartic.Out,\r\n    'Quint.easeOut': Quintic.Out,\r\n    'Sine.easeOut': Sine.Out,\r\n    'Expo.easeOut': Expo.Out,\r\n    'Circ.easeOut': Circular.Out,\r\n    'Elastic.easeOut': Elastic.Out,\r\n    'Back.easeOut': Back.Out,\r\n    'Bounce.easeOut': Bounce.Out,\r\n\r\n    'Quad.easeInOut': Quadratic.InOut,\r\n    'Cubic.easeInOut': Cubic.InOut,\r\n    'Quart.easeInOut': Quartic.InOut,\r\n    'Quint.easeInOut': Quintic.InOut,\r\n    'Sine.easeInOut': Sine.InOut,\r\n    'Expo.easeInOut': Expo.InOut,\r\n    'Circ.easeInOut': Circular.InOut,\r\n    'Elastic.easeInOut': Elastic.InOut,\r\n    'Back.easeInOut': Back.InOut,\r\n    'Bounce.easeInOut': Bounce.InOut\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar EaseMap = require('../../math/easing/EaseMap');\r\nvar UppercaseFirst = require('../../utils/string/UppercaseFirst');\r\n\r\n/**\r\n * This internal function is used to return the correct ease function for a Tween.\r\n * \r\n * It can take a variety of input, including an EaseMap based string, or a custom function.\r\n *\r\n * @function Phaser.Tweens.Builders.GetEaseFunction\r\n * @since 3.0.0\r\n *\r\n * @param {(string|function)} ease - The ease to find. This can be either a string from the EaseMap, or a custom function.\r\n * @param {number[]} [easeParams] - An optional array of ease parameters to go with the ease.\r\n *\r\n * @return {function} The ease function.\r\n */\r\nvar GetEaseFunction = function (ease, easeParams)\r\n{\r\n    //  Default ease function\r\n    var easeFunction = EaseMap.Power0;\r\n\r\n    //  Prepare ease function\r\n    if (typeof ease === 'string')\r\n    {\r\n        //  String based look-up\r\n\r\n        //  1) They specified it correctly\r\n        if (EaseMap.hasOwnProperty(ease))\r\n        {\r\n            easeFunction = EaseMap[ease];\r\n        }\r\n        else\r\n        {\r\n            //  Do some string manipulation to try and find it\r\n            var direction = '';\r\n\r\n            if (ease.indexOf('.'))\r\n            {\r\n                //  quad.in = Quad.easeIn\r\n                //  quad.out = Quad.easeOut\r\n                //  quad.inout = Quad.easeInOut\r\n\r\n                direction = ease.substr(ease.indexOf('.') + 1);\r\n\r\n                if (direction.toLowerCase() === 'in')\r\n                {\r\n                    direction = 'easeIn';\r\n                }\r\n                else if (direction.toLowerCase() === 'out')\r\n                {\r\n                    direction = 'easeOut';\r\n                }\r\n                else if (direction.toLowerCase() === 'inout')\r\n                {\r\n                    direction = 'easeInOut';\r\n                }\r\n            }\r\n\r\n            ease = UppercaseFirst(ease.substr(0, ease.indexOf('.') + 1) + direction);\r\n\r\n            if (EaseMap.hasOwnProperty(ease))\r\n            {\r\n                easeFunction = EaseMap[ease];\r\n            }\r\n        }\r\n    }\r\n    else if (typeof ease === 'function')\r\n    {\r\n        //  Custom function\r\n        easeFunction = ease;\r\n    }\r\n    else if (Array.isArray(ease) && ease.length === 4)\r\n    {\r\n        //  Bezier function (TODO)\r\n    }\r\n\r\n    //  No custom ease parameters?\r\n    if (!easeParams)\r\n    {\r\n        //  Return ease function\r\n        return easeFunction;\r\n    }\r\n\r\n    var cloneParams = easeParams.slice(0);\r\n\r\n    cloneParams.unshift(0);\r\n\r\n    //  Return ease function with custom ease parameters\r\n    return function (v)\r\n    {\r\n        cloneParams[0] = v;\r\n\r\n        return easeFunction.apply(this, cloneParams);\r\n    };\r\n};\r\n\r\nmodule.exports = GetEaseFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Capitalizes the first letter of a string if there is one.\r\n * @example\r\n * UppercaseFirst('abc');\r\n * // returns 'Abc'\r\n * @example\r\n * UppercaseFirst('the happy family');\r\n * // returns 'The happy family'\r\n * @example\r\n * UppercaseFirst('');\r\n * // returns ''\r\n *\r\n * @function Phaser.Utils.String.UppercaseFirst\r\n * @since 3.0.0\r\n *\r\n * @param {string} str - The string to capitalize.\r\n *\r\n * @return {string} A new string, same as the first, but with the first letter capitalized.\r\n */\r\nvar UppercaseFirst = function (str)\r\n{\r\n    return str && str[0].toUpperCase() + str.slice(1);\r\n};\r\n\r\nmodule.exports = UppercaseFirst;\r\n"],"names":["module","exports","circle","rect","halfWidth","width","halfHeight","height","cx","Math","abs","x","cy","y","xDist","radius","yDist","xCornerDist","yCornerDist","Class","Rectangle","Vector2","GetLength","x1","y1","x2","y2","magnitude","sqrt","Face","initialize","vertex1","vertex2","vertex3","this","bounds","_inCenter","getInCenter","local","undefined","v1x","v1y","v2x","v2y","v3x","v3y","v1","v2","v3","vx","vy","d1","d2","d3","p","set","contains","calcMatrix","a","b","c","d","e","f","t0x","t0y","t1x","t1y","t2x","t2y","dot00","dot01","dot02","dot11","dot12","bc","inv","u","v","isCounterClockwise","z","load","F32","U32","offset","textureUnit","tintEffect","transformCoordinatesLocal","transformMatrix","cameraZ","updateBounds","min","max","isInView","camera","hideCCW","alpha","roundPixels","update","ta","tx","ty","cr","cb","right","bottom","translate","get","value","current","depth","vz","destroy","Matrix4","Vector3","Vertex","tempPosition","tempRotation","tempMatrix","data","mesh","scale","rotateX","rotateY","rotateZ","zIsUp","result","faces","verts","materials","fromRotationXYTranslation","m","models","length","model","vertices","textureCoords","i","face","m1","vertexIndex","m2","m3","t1","textureCoordsIndex","t2","t3","uv1","uv2","uv3","color","material","vert1","transformMat4","vert2","vert3","push","concat","uvs","indicies","containsZ","normals","colors","alphas","normalX","normalY","normalZ","iInc","isColorArray","Array","isArray","isAlphaArray","index1","index2","index3","uvIndex","colorIndex","console","warn","Utils","Extends","nx","ny","nz","call","setUVs","val","tz","tw","round","getTintAppendFloatAlpha","polygon","inside","j","points","ix","iy","jx","jy","out","minX","Infinity","minY","maxX","maxY","Length","Line","Perimeter","quantity","stepRate","perimeter","position","accumulatedPerimeter","pointA","pointB","line","point","getPoint","Contains","GetPoints","GEOM_CONST","Polygon","type","POLYGON","area","setTo","split","y0","Number","MAX_VALUE","parseFloat","calculateArea","p1","p2","sum","getPoints","step","output","copy","p0","p0x","p0y","p1x","p1y","rectA","rectB","w","h","Back","Bounce","Circular","Cubic","Elastic","Expo","Linear","Quadratic","Quartic","Quintic","Sine","Stepped","Power0","Power1","Out","Power2","Power3","Power4","Quad","Quart","Quint","Circ","In","InOut","EaseMap","UppercaseFirst","ease","easeParams","easeFunction","hasOwnProperty","direction","indexOf","substr","toLowerCase","cloneParams","slice","unshift","apply","str","toUpperCase"],"sourceRoot":""}