{"version":3,"file":"js/8236.5a79b227836609bdba72.js","mappings":";sHAMA,IAAIA,EAAQ,EAAQ,OAChBC,EAAmB,EAAQ,OAC3BC,EAAc,EAAQ,OACtBC,EAAe,EAAQ,OACvBC,EAAS,EAAQ,OACjBC,EAAc,EAAQ,OAiBtBC,EAAa,IAAIN,EAAM,CAEvBO,QAASJ,EAETK,WAEA,SAAqBC,EAAOC,GAExBP,EAAaQ,KAAKC,MAclBA,KAAKH,MAAQA,EAcbG,KAAKC,YAAc,KAUnBD,KAAKF,KAAOA,EAgBZE,KAAKE,MAAQ,EASbF,KAAKG,gBAAkB,KAWvBH,KAAKI,KAAO,GAYZJ,KAAKK,QAAS,EAWdL,KAAKM,UAAY,EAYjBN,KAAKO,KAAO,KAYZP,KAAKQ,YAAc,GAenBR,KAAKS,aAAe,EAWpBT,KAAKU,MAAQ,KAUbV,KAAKW,KAAO,KAaZX,KAAKY,eAAgB,EAErBZ,KAAKa,GAAGrB,EAAOsB,eAAgBd,KAAKe,aAAcf,MAClDA,KAAKa,GAAGrB,EAAOwB,mBAAoBhB,KAAKiB,iBAAkBjB,MAG1DH,EAAMqB,IAAIC,kBAcdC,UAAW,SAAUC,GAIjB,OAFArB,KAAKK,OAASgB,EAEPrB,MAcXsB,QAAS,SAAUD,GAIf,OAFArB,KAAKI,KAAOiB,EAELrB,MAoBXuB,SAAU,SAAUF,GAIhB,OAFArB,KAAKE,MAAQmB,EAENrB,MAYXwB,eAAgB,WAOZ,OALKxB,KAAKO,OAENP,KAAKO,KAAO,IAAIjB,EAAYU,OAGzBA,MAkDXyB,QAAS,SAAUC,EAAKL,GASpB,OAPKrB,KAAKO,OAENP,KAAKO,KAAO,IAAIjB,EAAYU,OAGhCA,KAAKO,KAAKoB,IAAID,EAAKL,GAEZrB,MAqBX4B,QAAS,SAAUF,EAAKL,GASpB,OAPKrB,KAAKO,OAENP,KAAKO,KAAO,IAAIjB,EAAYU,OAGhCA,KAAKO,KAAKsB,IAAIH,EAAKL,GAEZrB,MAoBX8B,WAAY,SAAUJ,GASlB,OAPK1B,KAAKO,OAENP,KAAKO,KAAO,IAAIjB,EAAYU,OAGhCA,KAAKO,KAAKwB,OAAOL,GAEV1B,MAiCXgC,QAAS,SAAUN,GAOf,OALK1B,KAAKO,OAENP,KAAKO,KAAO,IAAIjB,EAAYU,OAGzBA,KAAKO,KAAK0B,IAAIP,IAkCzBQ,eAAgB,SAAUC,EAASC,EAAiBC,GAIhD,OAFArC,KAAKH,MAAMqB,IAAIR,MAAM4B,OAAOtC,KAAMmC,EAASC,EAAiBC,GAErDrC,MAiBXuC,mBAAoB,WAOhB,OALIvC,KAAKU,QAELV,KAAKU,MAAM8B,SAAU,GAGlBxC,MA4BXyC,kBAAmB,WAMf,OAJAzC,KAAKH,MAAMqB,IAAIR,MAAMgC,MAAM1C,MAE3BA,KAAKU,WAAQiC,EAEN3C,MAcXe,aAAc,aAedE,iBAAkB,aAYlB2B,OAAQ,aAYRC,OAAQ,WAEJ,OAAOxD,EAAiBW,OAc5B8C,WAAY,SAAUC,GAElB,QAASrD,EAAWsD,cAAgBhD,KAAKQ,aAAsC,IAAtBR,KAAKS,cAAuBT,KAAKS,aAAesC,EAAOE,KAgBpHC,aAAc,WAQV,IALA,IAAIC,EAAQnD,KACRoD,EAASpD,KAAKG,gBAEdkD,EAAU,GAEPD,IAEHC,EAAQC,QAAQF,EAAOG,SAASJ,IAEhCA,EAAQC,EAEHA,EAAOjD,kBAMRiD,EAASA,EAAOjD,gBAaxB,OATIH,KAAKC,YAELoD,EAAQC,QAAQtD,KAAKC,YAAYsD,SAASJ,IAI1CE,EAAQC,QAAQtD,KAAKH,MAAMqB,IAAIjB,YAAYsD,SAASJ,IAGjDE,GA4BXG,iBAAkB,SAAUvD,GAuBxB,YArBoB0C,IAAhB1C,IAA6BA,EAAcD,KAAKH,MAAMqB,IAAIjB,aAE1DD,KAAKC,aAAeD,KAAKC,cAAgBA,GAEzCD,KAAKyD,wBAIJxD,EAAYyD,OAAO1D,QAEpBA,KAAKC,YAAcA,EAEnBA,EAAY0D,IAAI3D,MAAM,GAEtBC,EAAYkB,iBAEZnB,KAAK4D,KAAKpE,EAAOsB,eAAgBd,KAAMA,KAAKH,OAE5CI,EAAY4D,OAAOD,KAAKnE,EAAYqB,eAAgBd,KAAMA,KAAKH,QAG5DG,MAkBX8D,gBAAiB,WAOb,OALI9D,KAAKH,OAASG,KAAK+D,WAEnB/D,KAAKH,MAAMqB,IAAI8C,WAAWL,IAAI3D,MAG3BA,MAqBXyD,sBAAuB,WAEnB,IAAIxD,EAAcD,KAAKC,aAAeD,KAAKH,MAAMqB,IAAIjB,YAerD,OAbIA,EAAYyD,OAAO1D,QAEnBC,EAAYgE,OAAOjE,MAAM,GAEzBC,EAAYkB,iBAEZnB,KAAKC,YAAc,KAEnBD,KAAK4D,KAAKpE,EAAOwB,mBAAoBhB,KAAMA,KAAKH,OAEhDI,EAAY4D,OAAOD,KAAKnE,EAAYuB,mBAAoBhB,KAAMA,KAAKH,QAGhEG,MAkBXkE,qBAAsB,WAOlB,OALIlE,KAAKH,OAASG,KAAK+D,WAEnB/D,KAAKH,MAAMqB,IAAI8C,WAAWC,OAAOjE,MAG9BA,MAsBXmE,QAAS,SAAUC,GAGVpE,KAAKH,QAASG,KAAKY,qBAKN+B,IAAdyB,IAA2BA,GAAY,GAEvCpE,KAAKqE,YAELrE,KAAKqE,WAAWtE,KAAKC,MAGzBA,KAAK4D,KAAKpE,EAAO8E,QAAStE,KAAMoE,GAEhCpE,KAAKuE,qBAEDvE,KAAKwE,eAELxE,KAAKyE,mBAAkB,GAG3BzE,KAAKyD,wBACLzD,KAAKkE,uBAEDlE,KAAKU,QAELV,KAAKH,MAAMqB,IAAIR,MAAMgC,MAAM1C,MAE3BA,KAAKU,WAAQiC,GAGb3C,KAAKO,OAELP,KAAKO,KAAK4D,UAEVnE,KAAKO,UAAOoC,GAGZ3C,KAAKW,OAELX,KAAKW,KAAKwD,UAEVnE,KAAKW,UAAOgC,GAGhB3C,KAAKK,QAAS,EACdL,KAAK0E,SAAU,EAEf1E,KAAKH,WAAQ8C,EACb3C,KAAKG,qBAAkBwC,MAY/BjD,EAAWsD,YAAc,GAEzB2B,EAAOC,QAAUlF,G,SCz2BjBiF,EAAOC,QAAU,gB,UCAjBD,EAAOC,QAAU,W,UCAjBD,EAAOC,QAAU,oB,UCMjBD,EAAOC,QAAU,Y,SCHjBD,EAAOC,QAAU,W,UCHjBD,EAAOC,QAAU,S,UCMjBD,EAAOC,QAAU,Q,UCJjBD,EAAOC,QAAU,Q,UCHjBD,EAAOC,QAAU,U,UCCjBD,EAAOC,QAAU,W,UCAjBD,EAAOC,QAAU,Q,UCAjBD,EAAOC,QAAU,W,UCAjBD,EAAOC,QAAU,Y,gBCTjBD,EAAOC,QAAU,CAEb9D,eAAgB,EAAQ,MACxBwD,QAAS,EAAQ,OACjBtD,mBAAoB,EAAQ,OAC5B6D,eAAgB,EAAQ,OACxBC,cAAe,EAAQ,MACvBC,YAAa,EAAQ,OACrBC,WAAY,EAAQ,OACpBC,WAAY,EAAQ,OACpBC,aAAc,EAAQ,OACtBC,cAAe,EAAQ,OACvBC,WAAY,EAAQ,OACpBC,cAAe,EAAQ,OACvBC,eAAgB,EAAQ,Y","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/GameObject.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/ADDED_TO_SCENE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/DESTROY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/REMOVED_FROM_SCENE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_COMPLETE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_CREATED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_ERROR_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_LOOP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_PLAY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_SEEKED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_SEEKING_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_STOP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_TIMEOUT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/VIDEO_UNLOCKED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/events/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ComponentsToJSON = require('./components/ToJSON');\r\nvar DataManager = require('../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The base class that all Game Objects extend.\r\n * You don't create GameObjects directly and they cannot be added to the display list.\r\n * Instead, use them as the base for your own custom classes.\r\n *\r\n * @class GameObject\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\r\n */\r\nvar GameObject = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GameObject (scene, type)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene to which this Game Object belongs.\r\n         *\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * You should consider this property as being read-only. You cannot move a\r\n         * Game Object to another Scene by simply changing it.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Holds a reference to the Display List that contains this Game Object.\r\n         *\r\n         * This is set automatically when this Game Object is added to a Scene or Layer.\r\n         *\r\n         * You should treat this property as being read-only.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#displayList\r\n         * @type {(Phaser.GameObjects.DisplayList|Phaser.GameObjects.Layer)}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.displayList = null;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         *\r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         *\r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could change from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#state\r\n         * @type {(number|string)}\r\n         * @since 3.16.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * The parent Container of this Game Object, if it has one.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.4.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#tabIndex\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#renderFlags\r\n         * @type {number}\r\n         * @default 15\r\n         * @since 3.0.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\r\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * If this Game Object is enabled for Arcade or Matter Physics then this property will contain a reference to a Physics Body.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#body\r\n         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|MatterJS.BodyType)}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.5.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);\r\n        this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     *\r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     *\r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(number|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\r\n     * @since 3.0.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#incData\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(string|object)} key - The key to increase the value for.\r\n     * @param {*} [data] - The value to increase for the given key.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    incData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.inc(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toggleData\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(string|object)} key - The key to toggle the value for.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    toggleData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.toggle(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * Pass this Game Object to the Input Manager to enable it for Input.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @example\r\n     * sprite.setInteractive();\r\n     *\r\n     * @example\r\n     * sprite.setInteractive(new Phaser.Geom.Circle(45, 46, 45), Phaser.Geom.Circle.Contains);\r\n     *\r\n     * @example\r\n     * graphics.setInteractive(new Phaser.Geom.Rectangle(0, 0, 128, 128), Phaser.Geom.Rectangle.Contains);\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#setInteractive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not given it will try to create a Rectangle based on the texture frame.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The callback that determines if the pointer is within the Hit Area shape or not. If you provide a shape you must also provide a callback.\r\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function (hitArea, hitAreaCallback, dropZone)\r\n    {\r\n        this.scene.sys.input.enable(this, hitArea, hitAreaCallback, dropZone);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will disable it.\r\n     *\r\n     * An object that is disabled for input stops processing or being considered for\r\n     * input events, but can be turned back on again at any time by simply calling\r\n     * `setInteractive()` with no arguments provided.\r\n     *\r\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#disableInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        if (this.input)\r\n        {\r\n            this.input.enabled = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Game Object has previously been enabled for input, this will queue it\r\n     * for removal, causing it to no longer be interactive. The removal happens on\r\n     * the next game step, it is not immediate.\r\n     *\r\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\r\n     * removed from the Input Manager and cleared from this Game Object.\r\n     *\r\n     * If you wish to re-enable this Game Object at a later date you will need to\r\n     * re-create its InteractiveObject by calling `setInteractive` again.\r\n     *\r\n     * If you wish to only temporarily stop an object from receiving input then use\r\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\r\n     * this erases it completely.\r\n     *\r\n     * If you wish to resize a hit area, don't remove and then set it as being\r\n     * interactive. Instead, access the hitarea object directly and resize the shape\r\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\r\n     * shape is a Rectangle, which it is by default.)\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeInteractive\r\n     * @since 3.7.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        this.scene.sys.input.clear(this);\r\n\r\n        this.input = undefined;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is added to a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to add themselves into the Update List.\r\n     *\r\n     * You can also listen for the `ADDED_TO_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#addedToScene\r\n     * @since 3.50.0\r\n     */\r\n    addedToScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is removed from a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to removed themselves from the Update List.\r\n     *\r\n     * You can also listen for the `REMOVED_FROM_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removedFromScene\r\n     * @since 3.50.0\r\n     */\r\n    removedFromScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#getIndexList\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        if (this.displayList)\r\n        {\r\n            indexes.unshift(this.displayList.getIndex(child));\r\n        }\r\n        else\r\n        {\r\n            indexes.unshift(this.scene.sys.displayList.getIndex(child));\r\n        }\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Adds this Game Object to the given Display List.\r\n     *\r\n     * If no Display List is specified, it will default to the Display List owned by the Scene to which\r\n     * this Game Object belongs.\r\n     *\r\n     * A Game Object can only exist on one Display List at any given time, but may move freely between them.\r\n     *\r\n     * If this Game Object is already on another Display List when this method is called, it will first\r\n     * be removed from it, before being added to the new list.\r\n     *\r\n     * You can query which list it is on by looking at the `Phaser.GameObjects.GameObject#displayList` property.\r\n     *\r\n     * If a Game Object isn't on any display list, it will not be rendered. If you just wish to temporarly\r\n     * disable it from rendering, consider using the `setVisible` method, instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#addToDisplayList\r\n     * @fires Phaser.Scenes.Events#ADDED_TO_SCENE\r\n     * @fires Phaser.GameObjects.Events#ADDED_TO_SCENE\r\n     * @since 3.53.0\r\n     *\r\n     * @param {(Phaser.GameObjects.DisplayList|Phaser.GameObjects.Layer)} [displayList] - The Display List to add to. Defaults to the Scene Display List.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    addToDisplayList: function (displayList)\r\n    {\r\n        if (displayList === undefined) { displayList = this.scene.sys.displayList; }\r\n\r\n        if (this.displayList && this.displayList !== displayList)\r\n        {\r\n            this.removeFromDisplayList();\r\n        }\r\n\r\n        //  Don't repeat if it's already on this list\r\n        if (!displayList.exists(this))\r\n        {\r\n            this.displayList = displayList;\r\n\r\n            displayList.add(this, true);\r\n\r\n            displayList.queueDepthSort();\r\n\r\n            this.emit(Events.ADDED_TO_SCENE, this, this.scene);\r\n\r\n            displayList.events.emit(SceneEvents.ADDED_TO_SCENE, this, this.scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds this Game Object to the Update List belonging to the Scene.\r\n     *\r\n     * When a Game Object is added to the Update List it will have its `preUpdate` method called\r\n     * every game frame. This method is passed two parameters: `delta` and `time`.\r\n     *\r\n     * If you wish to run your own logic within `preUpdate` then you should always call\r\n     * `preUpdate.super(delta, time)` within it, or it may fail to process required operations,\r\n     * such as Sprite animations.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#addToUpdateList\r\n     * @since 3.53.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    addToUpdateList: function ()\r\n    {\r\n        if (this.scene && this.preUpdate)\r\n        {\r\n            this.scene.sys.updateList.add(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes this Game Object from the Display List it is currently on.\r\n     *\r\n     * A Game Object can only exist on one Display List at any given time, but may move freely removed\r\n     * and added back at a later stage.\r\n     *\r\n     * You can query which list it is on by looking at the `Phaser.GameObjects.GameObject#displayList` property.\r\n     *\r\n     * If a Game Object isn't on any Display List, it will not be rendered. If you just wish to temporarly\r\n     * disable it from rendering, consider using the `setVisible` method, instead.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeFromDisplayList\r\n     * @fires Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n     * @fires Phaser.GameObjects.Events#REMOVED_FROM_SCENE\r\n     * @since 3.53.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    removeFromDisplayList: function ()\r\n    {\r\n        var displayList = this.displayList || this.scene.sys.displayList;\r\n\r\n        if (displayList.exists(this))\r\n        {\r\n            displayList.remove(this, true);\r\n\r\n            displayList.queueDepthSort();\r\n\r\n            this.displayList = null;\r\n\r\n            this.emit(Events.REMOVED_FROM_SCENE, this, this.scene);\r\n\r\n            displayList.events.emit(SceneEvents.REMOVED_FROM_SCENE, this, this.scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes this Game Object from the Scene's Update List.\r\n     *\r\n     * When a Game Object is on the Update List, it will have its `preUpdate` method called\r\n     * every game frame. Calling this method will remove it from the list, preventing this.\r\n     *\r\n     * Removing a Game Object from the Update List will stop most internal functions working.\r\n     * For example, removing a Sprite from the Update List will prevent it from being able to\r\n     * run animations.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#removeFromUpdateList\r\n     * @since 3.53.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    removeFromUpdateList: function ()\r\n    {\r\n        if (this.scene && this.preUpdate)\r\n        {\r\n            this.scene.sys.updateList.remove(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Game Object removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\r\n     *\r\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.GameObject#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [fromScene=false] - `True` if this Game Object is being destroyed by the Scene, `false` if not.\r\n     */\r\n    destroy: function (fromScene)\r\n    {\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (fromScene === undefined) { fromScene = false; }\r\n\r\n        if (this.preDestroy)\r\n        {\r\n            this.preDestroy.call(this);\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this, fromScene);\r\n\r\n        this.removeAllListeners();\r\n\r\n        if (this.postPipelines)\r\n        {\r\n            this.resetPostPipeline(true);\r\n        }\r\n\r\n        this.removeFromDisplayList();\r\n        this.removeFromUpdateList();\r\n\r\n        if (this.input)\r\n        {\r\n            this.scene.sys.input.clear(this);\r\n\r\n            this.input = undefined;\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        if (this.body)\r\n        {\r\n            this.body.destroy();\r\n\r\n            this.body = undefined;\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.scene = undefined;\r\n        this.parentContainer = undefined;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\r\n *\r\n * @constant {number} RENDER_MASK\r\n * @memberof Phaser.GameObjects.GameObject\r\n * @default\r\n */\r\nGameObject.RENDER_MASK = 15;\r\n\r\nmodule.exports = GameObject;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Game Object Added to Scene Event.\n *\n * This event is dispatched when a Game Object is added to a Scene.\n *\n * Listen for it on a Game Object instance using `GameObject.on('addedtoscene', listener)`.\n *\n * @event Phaser.GameObjects.Events#ADDED_TO_SCENE\n * @since 3.50.0\n *\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the Scene.\n * @param {Phaser.Scene} scene - The Scene to which the Game Object was added.\n */\nmodule.exports = 'addedtoscene';\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Object Destroy Event.\r\n *\r\n * This event is dispatched when a Game Object instance is being destroyed.\r\n *\r\n * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#DESTROY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object which is being destroyed.\r\n * @param {boolean} fromScene - `True` if this Game Object is being destroyed by the Scene, `false` if not.\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Game Object Removed from Scene Event.\n *\n * This event is dispatched when a Game Object is removed from a Scene.\n *\n * Listen for it on a Game Object instance using `GameObject.on('removedfromscene', listener)`.\n *\n * @event Phaser.GameObjects.Events#REMOVED_FROM_SCENE\n * @since 3.50.0\n *\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the Scene.\n * @param {Phaser.Scene} scene - The Scene from which the Game Object was removed.\n */\nmodule.exports = 'removedfromscene';\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Complete Event.\r\n * \r\n * This event is dispatched when a Video finishes playback by reaching the end of its duration. It\r\n * is also dispatched if a video marker sequence is being played and reaches the end.\r\n * \r\n * Note that not all videos can fire this event. Live streams, for example, have no fixed duration,\r\n * so never technically 'complete'.\r\n * \r\n * If a video is stopped from playback, via the `Video.stop` method, it will emit the\r\n * `VIDEO_STOP` event instead of this one.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('complete', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed playback.\r\n */\r\nmodule.exports = 'complete';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Created Event.\r\n * \r\n * This event is dispatched when the texture for a Video has been created. This happens\r\n * when enough of the video source has been loaded that the browser is able to render a\r\n * frame from it.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('created', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_CREATED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.\r\n * @param {number} width - The width of the video.\r\n * @param {number} height - The height of the video.\r\n */\r\nmodule.exports = 'created';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Error Event.\r\n * \r\n * This event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('error', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_ERROR\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which threw the error.\r\n * @param {Event} event - The native DOM event the browser raised during playback.\r\n */\r\nmodule.exports = 'error';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Loop Event.\r\n * \r\n * This event is dispatched when a Video that is currently playing has looped. This only\r\n * happens if the `loop` parameter was specified, or the `setLoop` method was called,\r\n * and if the video has a fixed duration. Video streams, for example, cannot loop, as\r\n * they have no duration.\r\n * \r\n * Looping is based on the result of the Video `timeupdate` event. This event is not\r\n * frame-accurate, due to the way browsers work, so please do not rely on this loop\r\n * event to be time or frame precise.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('loop', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_LOOP\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which has looped.\r\n */\r\nmodule.exports = 'loop';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Play Event.\r\n * \r\n * This event is dispatched when a Video begins playback. For videos that do not require\r\n * interaction unlocking, this is usually as soon as the `Video.play` method is called.\r\n * However, for videos that require unlocking, it is fired once playback begins after\r\n * they've been unlocked.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('play', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_PLAY\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which started playback.\r\n */\r\nmodule.exports = 'play';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Seeked Event.\r\n * \r\n * This event is dispatched when a Video completes seeking to a new point in its timeline.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('seeked', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_SEEKED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which completed seeking.\r\n */\r\nmodule.exports = 'seeked';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Seeking Event.\r\n * \r\n * This event is dispatched when a Video _begins_ seeking to a new point in its timeline.\r\n * When the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('seeking', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_SEEKING\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which started seeking.\r\n */\r\nmodule.exports = 'seeking';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Stopped Event.\r\n * \r\n * This event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,\r\n * either directly via game code, or indirectly as the result of changing a video source or destroying it.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('stop', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_STOP\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which stopped playback.\r\n */\r\nmodule.exports = 'stop';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Timeout Event.\r\n * \r\n * This event is dispatched when a Video has exhausted its allocated time while trying to connect to a video\r\n * source to start playback.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('timeout', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which timed out.\r\n */\r\nmodule.exports = 'timeout';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Video Game Object Unlocked Event.\r\n * \r\n * This event is dispatched when a Video that was prevented from playback due to the browsers\r\n * Media Engagement Interaction policy, is unlocked by a user gesture.\r\n * \r\n * Listen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.\r\n *\r\n * @event Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n * @since 3.20.0\r\n * \r\n * @param {Phaser.GameObjects.Video} video - The Video Game Object which raised the event.\r\n */\r\nmodule.exports = 'unlocked';\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.GameObjects.Events\n */\n\nmodule.exports = {\n\n    ADDED_TO_SCENE: require('./ADDED_TO_SCENE_EVENT'),\n    DESTROY: require('./DESTROY_EVENT'),\n    REMOVED_FROM_SCENE: require('./REMOVED_FROM_SCENE_EVENT'),\n    VIDEO_COMPLETE: require('./VIDEO_COMPLETE_EVENT'),\n    VIDEO_CREATED: require('./VIDEO_CREATED_EVENT'),\n    VIDEO_ERROR: require('./VIDEO_ERROR_EVENT'),\n    VIDEO_LOOP: require('./VIDEO_LOOP_EVENT'),\n    VIDEO_PLAY: require('./VIDEO_PLAY_EVENT'),\n    VIDEO_SEEKED: require('./VIDEO_SEEKED_EVENT'),\n    VIDEO_SEEKING: require('./VIDEO_SEEKING_EVENT'),\n    VIDEO_STOP: require('./VIDEO_STOP_EVENT'),\n    VIDEO_TIMEOUT: require('./VIDEO_TIMEOUT_EVENT'),\n    VIDEO_UNLOCKED: require('./VIDEO_UNLOCKED_EVENT')\n\n};\n"],"names":["Class","ComponentsToJSON","DataManager","EventEmitter","Events","SceneEvents","GameObject","Extends","initialize","scene","type","call","this","displayList","state","parentContainer","name","active","tabIndex","data","renderFlags","cameraFilter","input","body","ignoreDestroy","on","ADDED_TO_SCENE","addedToScene","REMOVED_FROM_SCENE","removedFromScene","sys","queueDepthSort","setActive","value","setName","setState","setDataEnabled","setData","key","set","incData","inc","toggleData","toggle","getData","get","setInteractive","hitArea","hitAreaCallback","dropZone","enable","disableInteractive","enabled","removeInteractive","clear","undefined","update","toJSON","willRender","camera","RENDER_MASK","id","getIndexList","child","parent","indexes","unshift","getIndex","addToDisplayList","removeFromDisplayList","exists","add","emit","events","addToUpdateList","preUpdate","updateList","remove","removeFromUpdateList","destroy","fromScene","preDestroy","DESTROY","removeAllListeners","postPipelines","resetPostPipeline","visible","module","exports","VIDEO_COMPLETE","VIDEO_CREATED","VIDEO_ERROR","VIDEO_LOOP","VIDEO_PLAY","VIDEO_SEEKED","VIDEO_SEEKING","VIDEO_STOP","VIDEO_TIMEOUT","VIDEO_UNLOCKED"],"sourceRoot":""}