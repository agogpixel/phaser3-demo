{"version":3,"file":"js/phaser-data.bb81fa892f34e51c6cfa.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/data/DataManagerPlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/data/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/Class.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar DataManager = require('./DataManager');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.\r\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\r\n * or have a property called `events` that is an instance of it.\r\n *\r\n * @class DataManagerPlugin\r\n * @extends Phaser.Data.DataManager\r\n * @memberof Phaser.Data\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this DataManager belongs to.\r\n */\r\nvar DataManagerPlugin = new Class({\r\n\r\n    Extends: DataManager,\r\n\r\n    initialize:\r\n\r\n    function DataManagerPlugin (scene)\r\n    {\r\n        DataManager.call(this, scene, scene.sys.events);\r\n\r\n        /**\r\n         * A reference to the Scene that this DataManager belongs to.\r\n         *\r\n         * @name Phaser.Data.DataManagerPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene's Systems.\r\n         *\r\n         * @name Phaser.Data.DataManagerPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.events = this.systems.events;\r\n\r\n        this.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#shutdown\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Data.DataManagerPlugin#destroy\r\n     * @since 3.5.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        DataManager.prototype.destroy.call(this);\r\n\r\n        this.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('DataManagerPlugin', DataManagerPlugin, 'data');\r\n\r\nmodule.exports = DataManagerPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Data\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DataManager: require('./DataManager'),\r\n    DataManagerPlugin: require('./DataManagerPlugin'),\r\n    Events: require('./events')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @ignore\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @ignore\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n"],"names":["Class","DataManager","PluginCache","SceneEvents","DataManagerPlugin","Extends","initialize","scene","call","this","sys","events","systems","once","BOOT","boot","on","START","start","DESTROY","destroy","SHUTDOWN","shutdown","off","prototype","register","module","exports","Events","corePlugins","customPlugins","key","plugin","mapping","custom","undefined","data","hasOwnProperty","getProperty","definition","k","isClassDescriptor","def","Object","getOwnPropertyDescriptor","value","get","set","hasGetterOrSetter","enumerable","configurable","hasNonConfigurable","obj","prop","extend","ctor","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","length","base","apply","arguments","create","constructor","Mixins"],"sourceRoot":""}