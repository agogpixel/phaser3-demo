{"version":3,"file":"js/phaser-renderer.6d6142c484498f597fd5.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/GetCalcMatrix.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/pow2/IsSizePowerOfTwo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/canvas/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/canvas/utils/SetTransform.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/snapshot/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/PostFXPipeline.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/pipelines/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/renderer/webgl/shaders/PostFX-frag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Map.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('./components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\nvar result = { camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3 };\r\n\r\n/**\r\n * Calculates the Transform Matrix of the given Game Object and Camera, factoring in\r\n * the parent matrix if provided.\r\n *\r\n * Note that the object this results contains _references_ to the Transform Matrices,\r\n * not new instances of them. Therefore, you should use their values immediately, or\r\n * copy them to your own matrix, as they will be replaced as soon as another Game\r\n * Object is rendered.\r\n *\r\n * @function Phaser.GameObjects.GetCalcMatrix\r\n * @memberof Phaser.GameObjects\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} src - The Game Object to calculate the transform matrix for.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera being used to render the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - The transform matrix of the parent container, if any.\r\n *\r\n * @return {Phaser.Types.GameObjects.GetCalcMatrixResults} The results object containing the updated transform matrices.\r\n */\r\nvar GetCalcMatrix = function (src, camera, parentMatrix)\r\n{\r\n    var camMatrix = tempMatrix1;\r\n    var spriteMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        spriteMatrix.e = src.x;\r\n        spriteMatrix.f = src.y;\r\n    }\r\n    else\r\n    {\r\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n    }\r\n\r\n    //  Multiply by the Sprite matrix, store result in calcMatrix\r\n    camMatrix.multiply(spriteMatrix, calcMatrix);\r\n\r\n    return result;\r\n};\r\n\r\nmodule.exports = GetCalcMatrix;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given `width` and `height` are a power of two.\r\n * Useful for checking texture dimensions.\r\n *\r\n * @function Phaser.Math.Pow2.IsSize\r\n * @since 3.0.0\r\n *\r\n * @param {number} width - The width.\r\n * @param {number} height - The height.\r\n *\r\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\r\n */\r\nvar IsSizePowerOfTwo = function (width, height)\r\n{\r\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsSizePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer.Canvas\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CanvasRenderer: require('./CanvasRenderer'),\r\n    GetBlendModes: require('./utils/GetBlendModes'),\r\n    SetTransform: require('./utils/SetTransform')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../../gameobjects/GetCalcMatrix');\r\n\r\n/**\r\n * Takes a reference to the Canvas Renderer, a Canvas Rendering Context, a Game Object, a Camera and a parent matrix\r\n * and then performs the following steps:\r\n *\r\n * 1. Checks the alpha of the source combined with the Camera alpha. If 0 or less it aborts.\r\n * 2. Takes the Camera and Game Object matrix and multiplies them, combined with the parent matrix if given.\r\n * 3. Sets the blend mode of the context to be that used by the Game Object.\r\n * 4. Sets the alpha value of the context to be that used by the Game Object combined with the Camera.\r\n * 5. Saves the context state.\r\n * 6. Sets the final matrix values into the context via setTransform.\r\n * 7. If Renderer.antialias, or the frame.source.scaleMode is set, then imageSmoothingEnabled is set.\r\n *\r\n * This function is only meant to be used internally. Most of the Canvas Renderer classes use it.\r\n *\r\n * @function Phaser.Renderer.Canvas.SetTransform\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {CanvasRenderingContext2D} ctx - The canvas context to set the transform on.\r\n * @param {Phaser.GameObjects.GameObject} src - The Game Object being rendered. Can be any type that extends the base class.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A parent transform matrix to apply to the Game Object before rendering.\r\n *\r\n * @return {boolean} `true` if the Game Object context was set, otherwise `false`.\r\n */\r\nvar SetTransform = function (renderer, ctx, src, camera, parentMatrix)\r\n{\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha <= 0)\r\n    {\r\n        //  Nothing to see, so don't waste time calculating stuff\r\n        return false;\r\n    }\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    //  Blend Mode\r\n    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];\r\n\r\n    //  Alpha\r\n    ctx.globalAlpha = alpha;\r\n\r\n    ctx.save();\r\n\r\n    calcMatrix.setToContext(ctx);\r\n\r\n    ctx.imageSmoothingEnabled = !(!renderer.antialias || (src.frame && src.frame.source.scaleMode));\r\n\r\n    return true;\r\n};\r\n\r\nmodule.exports = SetTransform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Types.Renderer\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Canvas: require('./canvas'),\r\n    Events: require('./events'),\r\n    Snapshot: require('./snapshot'),\r\n    WebGL: require('./webgl')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Renderer.Snapshot\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Canvas: require('./CanvasSnapshot'),\r\n    WebGL: require('./WebGLSnapshot')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar WEBGL_CONST = require('./const');\r\nvar Extend = require('../../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Renderer.WebGL\r\n */\r\n\r\nvar WebGL = {\r\n\r\n    PipelineManager: require('./PipelineManager'),\r\n    Pipelines: require('./pipelines'),\r\n    RenderTarget: require('./RenderTarget'),\r\n    Utils: require('./Utils'),\r\n    WebGLPipeline: require('./WebGLPipeline'),\r\n    WebGLRenderer: require('./WebGLRenderer'),\r\n    WebGLShader: require('./WebGLShader')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\n\r\nWebGL = Extend(false, WebGL, WEBGL_CONST);\r\n\r\n//  Export it\r\n\r\nmodule.exports = WebGL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar ColorMatrix = require('../../../display/ColorMatrix');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ShaderSourceFS = require('../shaders/PostFX-frag.js');\r\nvar ShaderSourceVS = require('../shaders/Quad-vert.js');\r\nvar WebGLPipeline = require('../WebGLPipeline');\r\n\r\n/**\r\n * @classdesc\r\n * The Post FX Pipeline is a special kind of pipeline specifically for handling post\r\n * processing effects. Where-as a standard Pipeline allows you to control the process\r\n * of rendering Game Objects by configuring the shaders and attributes used to draw them,\r\n * a Post FX Pipeline is designed to allow you to apply processing _after_ the Game Object/s\r\n * have been rendered. Typical examples of post processing effects are bloom filters,\r\n * blurs, light effects and color manipulation.\r\n *\r\n * The pipeline works by creating a tiny vertex buffer with just one single hard-coded quad\r\n * in it. Game Objects can have a Post Pipeline set on them. Those objects are then rendered\r\n * using their standard pipeline, but are redirected to the Render Targets owned by the\r\n * post pipeline, which can then apply their own shaders and effects, before passing them\r\n * back to the main renderer.\r\n *\r\n * Please see the Phaser 3 examples for further details on this extensive subject.\r\n *\r\n * The default fragment shader it uses can be found in `shaders/src/PostFX.frag`.\r\n * The default vertex shader it uses can be found in `shaders/src/Quad.vert`.\r\n *\r\n * The default shader attributes for this pipeline are:\r\n *\r\n * `inPosition` (vec2, offset 0)\r\n * `inTexCoord` (vec2, offset 8)\r\n *\r\n * The vertices array layout is:\r\n *\r\n * -1,  1   B----C   1,  1\r\n *  0,  1   |   /|   1,  1\r\n *          |  / |\r\n *          | /  |\r\n *          |/   |\r\n * -1, -1   A----D   1, -1\r\n *  0,  0            1,  0\r\n *\r\n * A = -1, -1 (pos) and 0, 0 (uv)\r\n * B = -1,  1 (pos) and 0, 1 (uv)\r\n * C =  1,  1 (pos) and 1, 1 (uv)\r\n * D =  1, -1 (pos) and 1, 0 (uv)\r\n *\r\n * First tri: A, B, C\r\n * Second tri: A, C, D\r\n *\r\n * Array index:\r\n *\r\n * 0  = Tri 1 - Vert A - x pos\r\n * 1  = Tri 1 - Vert A - y pos\r\n * 2  = Tri 1 - Vert A - uv u\r\n * 3  = Tri 1 - Vert A - uv v\r\n *\r\n * 4  = Tri 1 - Vert B - x pos\r\n * 5  = Tri 1 - Vert B - y pos\r\n * 6  = Tri 1 - Vert B - uv u\r\n * 7  = Tri 1 - Vert B - uv v\r\n *\r\n * 8  = Tri 1 - Vert C - x pos\r\n * 9  = Tri 1 - Vert C - y pos\r\n * 10 = Tri 1 - Vert C - uv u\r\n * 11 = Tri 1 - Vert C - uv v\r\n *\r\n * 12 = Tri 2 - Vert A - x pos\r\n * 13 = Tri 2 - Vert A - y pos\r\n * 14 = Tri 2 - Vert A - uv u\r\n * 15 = Tri 2 - Vert A - uv v\r\n *\r\n * 16 = Tri 2 - Vert C - x pos\r\n * 17 = Tri 2 - Vert C - y pos\r\n * 18 = Tri 2 - Vert C - uv u\r\n * 19 = Tri 2 - Vert C - uv v\r\n *\r\n * 20 = Tri 2 - Vert D - x pos\r\n * 21 = Tri 2 - Vert D - y pos\r\n * 22 = Tri 2 - Vert D - uv u\r\n * 23 = Tri 2 - Vert D - uv v\r\n *\r\n * @class PostFXPipeline\r\n * @extends Phaser.Renderer.WebGL.WebGLPipeline\r\n * @memberof Phaser.Renderer.WebGL.Pipelines\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Types.Renderer.WebGL.WebGLPipelineConfig} config - The configuration options for this pipeline.\r\n */\r\nvar PostFXPipeline = new Class({\r\n\r\n    Extends: WebGLPipeline,\r\n\r\n    initialize:\r\n\r\n    function PostFXPipeline (config)\r\n    {\r\n        config.renderTarget = GetFastValue(config, 'renderTarget', 1);\r\n        config.fragShader = GetFastValue(config, 'fragShader', ShaderSourceFS);\r\n        config.vertShader = GetFastValue(config, 'vertShader', ShaderSourceVS);\r\n        config.attributes = GetFastValue(config, 'attributes', [\r\n            {\r\n                name: 'inPosition',\r\n                size: 2\r\n            },\r\n            {\r\n                name: 'inTexCoord',\r\n                size: 2\r\n            }\r\n        ]);\r\n        config.batchSize = 1;\r\n        config.vertices = [\r\n            -1, -1, 0, 0,\r\n            -1, 1, 0, 1,\r\n            1, 1, 1, 1,\r\n            -1, -1, 0, 0,\r\n            1, 1, 1, 1,\r\n            1, -1, 1, 0\r\n        ];\r\n\r\n        WebGLPipeline.call(this, config);\r\n\r\n        this.isPostFX = true;\r\n\r\n        /**\r\n         * If this post-pipeline belongs to a Game Object or Camera, this contains a reference to it.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.50.0\r\n         */\r\n        this.gameObject;\r\n\r\n        /**\r\n         * A Color Matrix instance belonging to this pipeline.\r\n         *\r\n         * Used during calls to the `drawFrame` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#colorMatrix\r\n         * @type {Phaser.Display.ColorMatrix}\r\n         * @since 3.50.0\r\n         */\r\n        this.colorMatrix = new ColorMatrix();\r\n\r\n        /**\r\n         * A reference to the Full Frame 1 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#fullFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame1;\r\n\r\n        /**\r\n         * A reference to the Full Frame 2 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is the full size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#fullFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.fullFrame2;\r\n\r\n        /**\r\n         * A reference to the Half Frame 1 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#halfFrame1\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame1;\r\n\r\n        /**\r\n         * A reference to the Half Frame 2 Render Target that belongs to the\r\n         * Utility Pipeline. This property is set during the `boot` method.\r\n         *\r\n         * This Render Target is half the size of the renderer.\r\n         *\r\n         * You can use this directly in Post FX Pipelines for multi-target effects.\r\n         * However, be aware that these targets are shared between all post fx pipelines.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#halfFrame2\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.halfFrame2;\r\n\r\n        if (this.renderer.isBooted)\r\n        {\r\n            this.manager = this.renderer.pipelines;\r\n\r\n            this.boot();\r\n        }\r\n    },\r\n\r\n    boot: function ()\r\n    {\r\n        WebGLPipeline.prototype.boot.call(this);\r\n\r\n        var utility = this.manager.UTILITY_PIPELINE;\r\n\r\n        this.fullFrame1 = utility.fullFrame1;\r\n        this.fullFrame2 = utility.fullFrame2;\r\n        this.halfFrame1 = utility.halfFrame1;\r\n        this.halfFrame2 = utility.halfFrame2;\r\n\r\n        this.set1i('uMainSampler', 0);\r\n    },\r\n\r\n    onDraw: function (renderTarget)\r\n    {\r\n        this.bindAndDraw(renderTarget);\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * The difference between this method and `drawFrame` is that this method\r\n     * uses a faster copy shader, where only the brightness can be modified.\r\n     * If you need color level manipulation, see `drawFrame` instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#copyFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    copyFrame: function (source, target, brightness, clear, clearAlpha)\r\n    {\r\n        this.manager.copyFrame(source, target, brightness, clear, clearAlpha);\r\n    },\r\n\r\n    /**\r\n     * Pops the framebuffer from the renderers FBO stack and sets that as the active target,\r\n     * then draws the `source` Render Target to it. It then resets the renderer textures.\r\n     *\r\n     * This should be done when you need to draw the _final_ results of a pipeline to the game\r\n     * canvas, or the next framebuffer in line on the FBO stack. You should only call this once\r\n     * in the `onDraw` handler and it should be the final thing called. Be careful not to call\r\n     * this if you need to actually use the pipeline shader, instead of the copy shader. In\r\n     * those cases, use the `bindAndDraw` method.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#copyToGame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The Render Target to draw from.\r\n     */\r\n    copyToGame: function (source)\r\n    {\r\n        this.manager.copyToGame(source);\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target, using the\r\n     * given Color Matrix.\r\n     *\r\n     * The difference between this method and `copyFrame` is that this method\r\n     * uses a color matrix shader, where you have full control over the luminance\r\n     * values used during the copy. If you don't need this, you can use the faster\r\n     * `copyFrame` method instead.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#drawFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    drawFrame: function (source, target, clearAlpha)\r\n    {\r\n        this.manager.drawFrame(source, target, clearAlpha, this.colorMatrix);\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using a linear blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#blendFrames\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    blendFrames: function (source1, source2, target, strength, clearAlpha)\r\n    {\r\n        this.manager.blendFrames(source1, source2, target, strength, clearAlpha);\r\n    },\r\n\r\n    /**\r\n     * Draws the `source1` and `source2` Render Targets to the `target` Render Target\r\n     * using an additive blend effect, which is controlled by the `strength` parameter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#blendFramesAdditive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source1 - The first source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source2 - The second source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The target Render Target.\r\n     * @param {number} [strength=1] - The strength of the blend.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    blendFramesAdditive: function (source1, source2, target, strength, clearAlpha)\r\n    {\r\n        this.manager.blendFramesAdditive(source1, source2, target, strength, clearAlpha);\r\n    },\r\n\r\n    /**\r\n     * Clears the given Render Target.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#clearFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The Render Target to clear.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    clearFrame: function (target, clearAlpha)\r\n    {\r\n        this.manager.clearFrame(target, clearAlpha);\r\n    },\r\n\r\n    /**\r\n     * Copy the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * The difference with this copy is that no resizing takes place. If the `source`\r\n     * Render Target is larger than the `target` then only a portion the same size as\r\n     * the `target` dimensions is copied across.\r\n     *\r\n     * You can optionally set the brightness factor of the copy.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#blitFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} [brightness=1] - The brightness value applied to the frame copy.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {boolean} [eraseMode=false] - Erase source from target using ERASE Blend Mode?\r\n     */\r\n    blitFrame: function (source, target, brightness, clear, clearAlpha, eraseMode)\r\n    {\r\n        this.manager.blitFrame(source, target, brightness, clear, clearAlpha, eraseMode);\r\n    },\r\n\r\n    /**\r\n     * Binds the `source` Render Target and then copies a section of it to the `target` Render Target.\r\n     *\r\n     * This method is extremely fast because it uses `gl.copyTexSubImage2D` and doesn't\r\n     * require the use of any shaders. Remember the coordinates are given in standard WebGL format,\r\n     * where x and y specify the lower-left corner of the section, not the top-left. Also, the\r\n     * copy entirely replaces the contents of the target texture, no 'merging' or 'blending' takes\r\n     * place.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#copyFrameRect\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The source Render Target.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} target - The target Render Target.\r\n     * @param {number} x - The x coordinate of the lower left corner where to start copying.\r\n     * @param {number} y - The y coordinate of the lower left corner where to start copying.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {boolean} [clear=true] - Clear the target before copying?\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     */\r\n    copyFrameRect: function (source, target, x, y, width, height, clear, clearAlpha)\r\n    {\r\n        this.manager.copyFrameRect(source, target, x, y, width, height, clear, clearAlpha);\r\n    },\r\n\r\n    /**\r\n     * Binds this pipeline and draws the `source` Render Target to the `target` Render Target.\r\n     *\r\n     * If no `target` is specified, it will pop the framebuffer from the Renderers FBO stack\r\n     * and use that instead, which should be done when you need to draw the final results of\r\n     * this pipeline to the game canvas.\r\n     *\r\n     * You can optionally set the shader to be used for the draw here, if this is a multi-shader\r\n     * pipeline. By default `currentShader` will be used. If you need to set a shader but not\r\n     * a target, just pass `null` as the `target` parameter.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.Pipelines.PostFXPipeline#bindAndDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} source - The Render Target to draw from.\r\n     * @param {Phaser.Renderer.WebGL.RenderTarget} [target] - The Render Target to draw to. If not set, it will pop the fbo from the stack.\r\n     * @param {boolean} [clear=true] - Clear the target before copying? Only used if `target` parameter is set.\r\n     * @param {boolean} [clearAlpha=true] - Clear the alpha channel when running `gl.clear` on the target?\r\n     * @param {Phaser.Renderer.WebGL.WebGLShader} [currentShader] - The shader to use during the draw.\r\n     */\r\n    bindAndDraw: function (source, target, clear, clearAlpha, currentShader)\r\n    {\r\n        if (clear === undefined) { clear = true; }\r\n        if (clearAlpha === undefined) { clearAlpha = true; }\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        this.bind(currentShader);\r\n\r\n        this.set1i('uMainSampler', 0);\r\n\r\n        if (target)\r\n        {\r\n            gl.viewport(0, 0, target.width, target.height);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.texture, 0);\r\n\r\n            if (clear)\r\n            {\r\n                if (clearAlpha)\r\n                {\r\n                    gl.clearColor(0, 0, 0, 0);\r\n                }\r\n                else\r\n                {\r\n                    gl.clearColor(0, 0, 0, 1);\r\n                }\r\n\r\n                gl.clear(gl.COLOR_BUFFER_BIT);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            renderer.popFramebuffer(false, false, false);\r\n\r\n            if (!renderer.currentFramebuffer)\r\n            {\r\n                gl.viewport(0, 0, renderer.width, renderer.height);\r\n            }\r\n        }\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, source.texture);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertexData, gl.STATIC_DRAW);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n        if (!target)\r\n        {\r\n            renderer.resetTextures();\r\n        }\r\n        else\r\n        {\r\n            gl.bindTexture(gl.TEXTURE_2D, null);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PostFXPipeline;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../../../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Renderer.WebGL.Pipelines\r\n */\r\n\r\nvar Pipelines = {\r\n\r\n    BitmapMaskPipeline: require('./BitmapMaskPipeline'),\r\n    Events: require('./events'),\r\n    GraphicsPipeline: require('./GraphicsPipeline'),\r\n    LightPipeline: require('./LightPipeline'),\r\n    MultiPipeline: require('./MultiPipeline'),\r\n    PointLightPipeline: require('./PointLightPipeline'),\r\n    PostFXPipeline: require('./PostFXPipeline'),\r\n    RopePipeline: require('./RopePipeline'),\r\n    SinglePipeline: require('./SinglePipeline'),\r\n    UtilityPipeline: require('./UtilityPipeline')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\n\r\nPipelines = Extend(false, Pipelines, CONST);\r\n\r\n//  Export it\r\n\r\nmodule.exports = Pipelines;\r\n","module.exports = [\n    '#define SHADER_NAME PHASER_POSTFX_FS',\n    '',\n    'precision mediump float;',\n    '',\n    'uniform sampler2D uMainSampler;',\n    '',\n    'varying vec2 outTexCoord;',\n    '',\n    'void main ()',\n    '{',\n    '    gl_FragColor = texture2D(uMainSampler, outTexCoord);',\n    '}',\n    ''\n].join('\\n');\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachMapCallback<E>\r\n *\r\n * @param {string} key - The key of the Map entry.\r\n * @param {E} entry - The value of the Map entry.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The keys of a Map can be arbitrary values.\r\n *\r\n * ```javascript\r\n * var map = new Map([\r\n *    [ 1, 'one' ],\r\n *    [ 2, 'two' ],\r\n *    [ 3, 'three' ]\r\n * ]);\r\n * ```\r\n *\r\n * @class Map\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic K\r\n * @generic V\r\n * @genericUse {V[]} - [elements]\r\n *\r\n * @param {Array.<*>} elements - An optional array of key-value pairs to populate this Map with.\r\n */\r\nvar Map = new Class({\r\n\r\n    initialize:\r\n\r\n    function Map (elements)\r\n    {\r\n        /**\r\n         * The entries in this Map.\r\n         *\r\n         * @genericUse {Object.<string, V>} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Map#entries\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = {};\r\n\r\n        /**\r\n         * The number of key / value pairs in this Map.\r\n         *\r\n         * @name Phaser.Structs.Map#size\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.size = 0;\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i][0], elements[i][1]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an element with a specified `key` and `value` to this Map.\r\n     * If the `key` already exists, the value will be replaced.\r\n     *\r\n     * @method Phaser.Structs.Map#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [value]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to be added to this Map.\r\n     * @param {*} value - The value of the element to be added to this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    set: function (key, value)\r\n    {\r\n        if (!this.has(key))\r\n        {\r\n            this.size++;\r\n        }\r\n\r\n        this.entries[key] = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the value associated to the `key`, or `undefined` if there is none.\r\n     *\r\n     * @method Phaser.Structs.Map#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to return from the `Map` object.\r\n     *\r\n     * @return {*} The element associated with the specified key or `undefined` if the key can't be found in this Map object.\r\n     */\r\n    get: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            return this.entries[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all the values stored in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array of the values stored in this Map.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element with the specified key exists or not.\r\n     *\r\n     * @method Phaser.Structs.Map#has\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     *\r\n     * @param {string} key - The key of the element to test for presence of in this Map.\r\n     *\r\n     * @return {boolean} Returns `true` if an element with the specified key exists in this Map, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return (this.entries.hasOwnProperty(key));\r\n    },\r\n\r\n    /**\r\n     * Delete the specified element from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to delete from this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    delete: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            delete this.entries[key];\r\n            this.size--;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all entries from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        Object.keys(this.entries).forEach(function (prop)\r\n        {\r\n            delete this.entries[prop];\r\n\r\n        }, this);\r\n\r\n        this.size = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns all entries keys in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#keys\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K[]} - [$return]\r\n     *\r\n     * @return {string[]} Array containing entries' keys.\r\n     */\r\n    keys: function ()\r\n    {\r\n        return Object.keys(this.entries);\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all entries.\r\n     *\r\n     * @method Phaser.Structs.Map#values\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An `Array` of entries.\r\n     */\r\n    values: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Map to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Map#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var entries = this.entries;\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.group('Map');\r\n\r\n        for (var key in entries)\r\n        {\r\n            console.log(key, entries[key]);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Iterates through all entries in this Map, passing each one to the given callback.\r\n     *\r\n     * If the callback returns `false`, the iteration will break.\r\n     *\r\n     * @method Phaser.Structs.Map#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachMapCallback.<V>} - [callback]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {EachMapCallback} callback - The callback which will receive the keys and entries held in this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    each: function (callback)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (callback(key, entries[key]) === false)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the value exists within this Map. Otherwise, returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Map#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V} - [value]\r\n     *\r\n     * @param {*} value - The value to search for.\r\n     *\r\n     * @return {boolean} `true` if the value is found, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (entries[key] === value)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Merges all new keys from the given Map into this one.\r\n     * If it encounters a key that already exists it will be skipped unless override is set to `true`.\r\n     *\r\n     * @method Phaser.Structs.Map#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]\r\n     *\r\n     * @param {Phaser.Structs.Map} map - The Map to merge in to this Map.\r\n     * @param {boolean} [override=false] - Set to `true` to replace values in this Map with those from the source map, or `false` to skip them.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    merge: function (map, override)\r\n    {\r\n        if (override === undefined) { override = false; }\r\n\r\n        var local = this.entries;\r\n        var source = map.entries;\r\n\r\n        for (var key in source)\r\n        {\r\n            if (local.hasOwnProperty(key) && override)\r\n            {\r\n                local[key] = source[key];\r\n            }\r\n            else\r\n            {\r\n                this.set(key, source[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Map;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n"],"names":["TransformMatrix","tempMatrix1","tempMatrix2","tempMatrix3","result","camera","sprite","calc","module","exports","src","parentMatrix","camMatrix","spriteMatrix","calcMatrix","applyITRS","x","y","rotation","scaleX","scaleY","copyFrom","matrix","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","width","height","CanvasRenderer","GetBlendModes","SetTransform","GetCalcMatrix","renderer","ctx","alpha","globalCompositeOperation","blendModes","blendMode","globalAlpha","save","setToContext","imageSmoothingEnabled","antialias","frame","source","scaleMode","Canvas","Events","Snapshot","WebGL","WEBGL_CONST","Extend","PipelineManager","Pipelines","RenderTarget","Utils","WebGLPipeline","WebGLRenderer","WebGLShader","Class","ColorMatrix","GetFastValue","ShaderSourceFS","ShaderSourceVS","PostFXPipeline","Extends","initialize","config","renderTarget","fragShader","vertShader","attributes","name","size","batchSize","vertices","call","this","isPostFX","gameObject","colorMatrix","fullFrame1","fullFrame2","halfFrame1","halfFrame2","isBooted","manager","pipelines","boot","prototype","utility","UTILITY_PIPELINE","set1i","onDraw","bindAndDraw","copyFrame","target","brightness","clear","clearAlpha","copyToGame","drawFrame","blendFrames","source1","source2","strength","blendFramesAdditive","clearFrame","blitFrame","eraseMode","copyFrameRect","currentShader","undefined","gl","bind","viewport","bindFramebuffer","FRAMEBUFFER","framebuffer","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_2D","texture","clearColor","COLOR_BUFFER_BIT","popFramebuffer","currentFramebuffer","activeTexture","TEXTURE0","bindTexture","bufferData","ARRAY_BUFFER","vertexData","STATIC_DRAW","drawArrays","TRIANGLES","resetTextures","CONST","BitmapMaskPipeline","GraphicsPipeline","LightPipeline","MultiPipeline","PointLightPipeline","RopePipeline","SinglePipeline","UtilityPipeline","join","Map","elements","entries","Array","isArray","i","length","set","key","value","has","get","getArray","output","push","hasOwnProperty","delete","Object","keys","forEach","prop","values","dump","console","group","log","groupEnd","each","callback","contains","merge","map","override","local"],"sourceRoot":""}