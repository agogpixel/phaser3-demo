{"version":3,"file":"js/phaser-curves.fc9ba7a9495ff42023b6.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/CubicBezierCurve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/Curve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/EllipseCurve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/LineCurve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/QuadraticBezierCurve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/SplineCurve.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/path/MoveTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/curves/path/Path.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/gameobjects/GameObjectFactory.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/rectangle/FromPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/CatmullRom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/DegToRad.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RadToDeg.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/CubicBezierInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/QuadraticBezierInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetValue.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../utils/Class');\r\nvar CubicBezier = require('../math/interpolation/CubicBezierInterpolation');\r\nvar Curve = require('./Curve');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A higher-order Bézier curve constructed of four points.\r\n *\r\n * @class CubicBezier\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|Phaser.Math.Vector2[])} p0 - Start point, or an array of point pairs.\r\n * @param {Phaser.Math.Vector2} p1 - Control Point 1.\r\n * @param {Phaser.Math.Vector2} p2 - Control Point 2.\r\n * @param {Phaser.Math.Vector2} p3 - End Point.\r\n */\r\nvar CubicBezierCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    function CubicBezierCurve (p0, p1, p2, p3)\r\n    {\r\n        Curve.call(this, 'CubicBezierCurve');\r\n\r\n        if (Array.isArray(p0))\r\n        {\r\n            p3 = new Vector2(p0[6], p0[7]);\r\n            p2 = new Vector2(p0[4], p0[5]);\r\n            p1 = new Vector2(p0[2], p0[3]);\r\n            p0 = new Vector2(p0[0], p0[1]);\r\n        }\r\n\r\n        /**\r\n         * The start point of this curve.\r\n         *\r\n         * @name Phaser.Curves.CubicBezier#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = p0;\r\n\r\n        /**\r\n         * The first control point of this curve.\r\n         *\r\n         * @name Phaser.Curves.CubicBezier#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p1 = p1;\r\n\r\n        /**\r\n         * The second control point of this curve.\r\n         *\r\n         * @name Phaser.Curves.CubicBezier#p2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p2 = p2;\r\n\r\n        /**\r\n         * The end point of this curve.\r\n         *\r\n         * @name Phaser.Curves.CubicBezier#p3\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p3 = p3;\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.CubicBezier#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.p0);\r\n    },\r\n\r\n    /**\r\n     * Returns the resolution of this curve.\r\n     *\r\n     * @method Phaser.Curves.CubicBezier#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - The amount of divisions used by this curve.\r\n     *\r\n     * @return {number} The resolution of the curve.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        return divisions;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.CubicBezier#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var p0 = this.p0;\r\n        var p1 = this.p1;\r\n        var p2 = this.p2;\r\n        var p3 = this.p3;\r\n\r\n        return out.set(CubicBezier(t, p0.x, p1.x, p2.x, p3.x), CubicBezier(t, p0.y, p1.y, p2.y, p3.y));\r\n    },\r\n\r\n    /**\r\n     * Draws this curve to the specified graphics object.\r\n     *\r\n     * @method Phaser.Curves.CubicBezier#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The graphics object this curve should be drawn to.\r\n     * @param {number} [pointsTotal=32] - The number of intermediary points that make up this curve. A higher number of points will result in a smoother curve.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The graphics object this curve was drawn to. Useful for method chaining.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        var points = this.getPoints(pointsTotal);\r\n\r\n        graphics.beginPath();\r\n        graphics.moveTo(this.p0.x, this.p0.y);\r\n\r\n        for (var i = 1; i < points.length; i++)\r\n        {\r\n            graphics.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        graphics.strokePath();\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON object that describes this curve.\r\n     *\r\n     * @method Phaser.Curves.CubicBezier#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            points: [\r\n                this.p0.x, this.p0.y,\r\n                this.p1.x, this.p1.y,\r\n                this.p2.x, this.p2.y,\r\n                this.p3.x, this.p3.y\r\n            ]\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Generates a curve from a JSON object.\r\n *\r\n * @function Phaser.Curves.CubicBezier.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.CubicBezier} The curve generated from the JSON object.\r\n */\r\nCubicBezierCurve.fromJSON = function (data)\r\n{\r\n    var points = data.points;\r\n\r\n    var p0 = new Vector2(points[0], points[1]);\r\n    var p1 = new Vector2(points[2], points[3]);\r\n    var p2 = new Vector2(points[4], points[5]);\r\n    var p3 = new Vector2(points[6], points[7]);\r\n\r\n    return new CubicBezierCurve(p0, p1, p2, p3);\r\n};\r\n\r\nmodule.exports = CubicBezierCurve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - The curve type.\r\n */\r\nvar Curve = new Class({\r\n\r\n    initialize:\r\n\r\n    function Curve (type)\r\n    {\r\n        /**\r\n         * String based identifier for the type of curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The default number of divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#defaultDivisions\r\n         * @type {number}\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultDivisions = 5;\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#arcLengthDivisions\r\n         * @type {number}\r\n         * @default 100\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 100;\r\n\r\n        /**\r\n         * An array of cached arc length values.\r\n         *\r\n         * @name Phaser.Curves.Curve#cacheArcLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheArcLengths = [];\r\n\r\n        /**\r\n         * Does the data of this curve need updating?\r\n         *\r\n         * @name Phaser.Curves.Curve#needsUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.needsUpdate = true;\r\n\r\n        /**\r\n         * For a curve on a Path, `false` means the Path will ignore this curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Curve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     * @param {number} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics.strokePoints(this.getPoints(pointsTotal));\r\n    },\r\n\r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @method Phaser.Curves.Curve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n     * @param {number} [accuracy=16] - The accuracy of the bounds calculations.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (!out) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        var len = this.getLength();\r\n\r\n        if (accuracy > len)\r\n        {\r\n            accuracy = len / 2;\r\n        }\r\n\r\n        //  The length of the curve in pixels\r\n        //  So we'll have 1 spaced point per 'accuracy' pixels\r\n\r\n        var spaced = Math.max(1, Math.round(len / accuracy));\r\n\r\n        return FromPoints(this.getSpacedPoints(spaced), out);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of points, spaced out X distance pixels apart.\r\n     * The smaller the distance, the larger the array will be.\r\n     *\r\n     * @method Phaser.Curves.Curve#getDistancePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} distance - The distance, in pixels, between each point along the curve.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n     */\r\n    getDistancePoints: function (distance)\r\n    {\r\n        var len = this.getLength();\r\n\r\n        var spaced = Math.max(1, len / distance);\r\n\r\n        return this.getSpacedPoints(spaced);\r\n    },\r\n\r\n    /**\r\n     * Get a point at the end of the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(1, out);\r\n    },\r\n\r\n    /**\r\n     * Get total curve arc length\r\n     *\r\n     * @method Phaser.Curves.Curve#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The total length of the curve.\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lengths = this.getLengths();\r\n\r\n        return lengths[lengths.length - 1];\r\n    },\r\n\r\n\r\n    /**\r\n     * Get a list of cumulative segment lengths.\r\n     *\r\n     * These lengths are\r\n     *\r\n     * - [0] 0\r\n     * - [1] The first segment\r\n     * - [2] The first and second segment\r\n     * - ...\r\n     * - [divisions] All segments\r\n     *\r\n     * @method Phaser.Curves.Curve#getLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions] - The number of divisions or segments.\r\n     *\r\n     * @return {number[]} An array of cumulative lengths.\r\n     */\r\n    getLengths: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.arcLengthDivisions; }\r\n\r\n        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)\r\n        {\r\n            return this.cacheArcLengths;\r\n        }\r\n\r\n        this.needsUpdate = false;\r\n\r\n        var cache = [];\r\n        var current;\r\n        var last = this.getPoint(0, this._tmpVec2A);\r\n        var sum = 0;\r\n\r\n        cache.push(0);\r\n\r\n        for (var p = 1; p <= divisions; p++)\r\n        {\r\n            current = this.getPoint(p / divisions, this._tmpVec2B);\r\n\r\n            sum += current.distance(last);\r\n\r\n            cache.push(sum);\r\n\r\n            last.copy(current);\r\n        }\r\n\r\n        this.cacheArcLengths = cache;\r\n\r\n        return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n    },\r\n\r\n    // Get point at relative position in curve according to arc length\r\n\r\n    // - u [0 .. 1]\r\n\r\n    /**\r\n     * Get a point at a relative position on the curve, by arc length.\r\n     *\r\n     * @method Phaser.Curves.Curve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The relative position, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getPoint(t, out);\r\n    },\r\n\r\n    // Get sequence of points using getPoint( t )\r\n\r\n    /**\r\n     * Get a sequence of evenly spaced points from the curve.\r\n     *\r\n     * You can pass `divisions`, `stepRate`, or neither.\r\n     *\r\n     * The number of divisions will be\r\n     *\r\n     * 1. `divisions`, if `divisions` > 0; or\r\n     * 2. `this.getLength / stepRate`, if `stepRate` > 0; or\r\n     * 3. `this.defaultDivisions`\r\n     *\r\n     * `1 + divisions` points will be returned.\r\n     *\r\n     * @method Phaser.Curves.Curve#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2[]} O - [out,$return]\r\n     *\r\n     * @param {number} [divisions] - The number of divisions to make.\r\n     * @param {number} [stepRate] - The curve distance between points, implying `divisions`.\r\n     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n     *\r\n     * @return {(array|Phaser.Math.Vector2[])} An array of Points from the curve.\r\n     */\r\n    getPoints: function (divisions, stepRate, out)\r\n    {\r\n        if (out === undefined) { out = []; }\r\n\r\n        //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n        if (!divisions)\r\n        {\r\n            if (!stepRate)\r\n            {\r\n                divisions = this.defaultDivisions;\r\n            }\r\n            else\r\n            {\r\n                divisions = this.getLength() / stepRate;\r\n            }\r\n        }\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            out.push(this.getPoint(d / divisions));\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Get a random point from the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A point object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    // Get sequence of points using getPointAt( u )\r\n\r\n    /**\r\n     * Get a sequence of equally spaced points (by arc distance) from the curve.\r\n     *\r\n     * `1 + divisions` points will be returned.\r\n     *\r\n     * @method Phaser.Curves.Curve#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=this.defaultDivisions] - The number of divisions to make.\r\n     * @param {number} [stepRate] - Step between points. Used to calculate the number of points to return when divisions is falsy. Ignored if divisions is positive.\r\n     * @param {(array|Phaser.Math.Vector2[])} [out] - An optional array to store the points in.\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} An array of points.\r\n     */\r\n    getSpacedPoints: function (divisions, stepRate, out)\r\n    {\r\n        if (out === undefined) { out = []; }\r\n\r\n        //  If divisions is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n        if (!divisions)\r\n        {\r\n            if (!stepRate)\r\n            {\r\n                divisions = this.defaultDivisions;\r\n            }\r\n            else\r\n            {\r\n                divisions = this.getLength() / stepRate;\r\n            }\r\n        }\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            var t = this.getUtoTmapping(d / divisions, null, divisions);\r\n\r\n            out.push(this.getPoint(t));\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Get a point at the start of the curve.\r\n     *\r\n     * @method Phaser.Curves.Curve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A point to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The point.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(0, out);\r\n    },\r\n\r\n    /**\r\n     * Get a unit vector tangent at a relative position on the curve.\r\n     * In case any sub curve does not implement its tangent derivation,\r\n     * 2 points a small delta apart will be used to find its gradient\r\n     * which seems to give a reasonable approximation\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The relative position on the curve, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var delta = 0.0001;\r\n        var t1 = t - delta;\r\n        var t2 = t + delta;\r\n\r\n        // Capping in case of danger\r\n\r\n        if (t1 < 0)\r\n        {\r\n            t1 = 0;\r\n        }\r\n\r\n        if (t2 > 1)\r\n        {\r\n            t2 = 1;\r\n        }\r\n\r\n        this.getPoint(t1, this._tmpVec2A);\r\n        this.getPoint(t2, out);\r\n\r\n        return out.subtract(this._tmpVec2A).normalize();\r\n    },\r\n\r\n    /**\r\n     * Get a unit vector tangent at a relative position on the curve, by arc length.\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangentAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The relative position on the curve, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The tangent vector.\r\n     */\r\n    getTangentAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getTangent(t, out);\r\n    },\r\n\r\n    /**\r\n     * Given a distance in pixels, get a t to find p.\r\n     *\r\n     * @method Phaser.Curves.Curve#getTFromDistance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} distance - The distance, in pixels.\r\n     * @param {number} [divisions] - Optional amount of divisions.\r\n     *\r\n     * @return {number} The distance.\r\n     */\r\n    getTFromDistance: function (distance, divisions)\r\n    {\r\n        if (distance <= 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return this.getUtoTmapping(0, distance, divisions);\r\n    },\r\n\r\n    /**\r\n     * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant.\r\n     *\r\n     * @method Phaser.Curves.Curve#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - A float between 0 and 1.\r\n     * @param {number} distance - The distance, in pixels.\r\n     * @param {number} [divisions] - Optional amount of divisions.\r\n     *\r\n     * @return {number} The equidistant value.\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var arcLengths = this.getLengths(divisions);\r\n\r\n        var i = 0;\r\n        var il = arcLengths.length;\r\n\r\n        var targetArcLength; // The targeted u distance value to get\r\n\r\n        if (distance)\r\n        {\r\n            //  Cannot overshoot the curve\r\n            targetArcLength = Math.min(distance, arcLengths[il - 1]);\r\n        }\r\n        else\r\n        {\r\n            targetArcLength = u * arcLengths[il - 1];\r\n        }\r\n\r\n        // binary search for the index with largest value smaller than target u distance\r\n\r\n        var low = 0;\r\n        var high = il - 1;\r\n        var comparison;\r\n\r\n        while (low <= high)\r\n        {\r\n            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n            comparison = arcLengths[i] - targetArcLength;\r\n\r\n            if (comparison < 0)\r\n            {\r\n                low = i + 1;\r\n            }\r\n            else if (comparison > 0)\r\n            {\r\n                high = i - 1;\r\n            }\r\n            else\r\n            {\r\n                high = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        i = high;\r\n\r\n        if (arcLengths[i] === targetArcLength)\r\n        {\r\n            return i / (il - 1);\r\n        }\r\n\r\n        // we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n        var lengthBefore = arcLengths[i];\r\n        var lengthAfter = arcLengths[i + 1];\r\n\r\n        var segmentLength = lengthAfter - lengthBefore;\r\n\r\n        // determine where we are between the 'before' and 'after' points\r\n\r\n        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\r\n\r\n        // add that fractional amount to t\r\n\r\n        return (i + segmentFraction) / (il - 1);\r\n    },\r\n\r\n    /**\r\n     * Calculate and cache the arc lengths.\r\n     *\r\n     * @method Phaser.Curves.Curve#updateArcLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Curves.Curve#getLengths()\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.needsUpdate = true;\r\n\r\n        this.getLengths();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar RadToDeg = require('../math/RadToDeg');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * An Elliptical Curve derived from the Base Curve class.\r\n * \r\n * See https://en.wikipedia.org/wiki/Elliptic_curve for more details.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Types.Curves.EllipseCurveConfig)} [x=0] - The x coordinate of the ellipse, or an Ellipse Curve configuration object.\r\n * @param {number} [y=0] - The y coordinate of the ellipse.\r\n * @param {number} [xRadius=0] - The horizontal radius of ellipse.\r\n * @param {number} [yRadius=0] - The vertical radius of ellipse.\r\n * @param {number} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n * @param {number} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n * @param {boolean} [clockwise=false] - Whether the ellipse angles are given as clockwise (`true`) or counter-clockwise (`false`).\r\n * @param {number} [rotation=0] - The rotation of the ellipse, in degrees.\r\n */\r\nvar EllipseCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    function EllipseCurve (x, y, xRadius, yRadius, startAngle, endAngle, clockwise, rotation)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var config = x;\r\n\r\n            x = GetValue(config, 'x', 0);\r\n            y = GetValue(config, 'y', 0);\r\n            xRadius = GetValue(config, 'xRadius', 0);\r\n            yRadius = GetValue(config, 'yRadius', xRadius);\r\n            startAngle = GetValue(config, 'startAngle', 0);\r\n            endAngle = GetValue(config, 'endAngle', 360);\r\n            clockwise = GetValue(config, 'clockwise', false);\r\n            rotation = GetValue(config, 'rotation', 0);\r\n        }\r\n        else\r\n        {\r\n            if (yRadius === undefined) { yRadius = xRadius; }\r\n            if (startAngle === undefined) { startAngle = 0; }\r\n            if (endAngle === undefined) { endAngle = 360; }\r\n            if (clockwise === undefined) { clockwise = false; }\r\n            if (rotation === undefined) { rotation = 0; }\r\n        }\r\n\r\n        Curve.call(this, 'EllipseCurve');\r\n\r\n        //  Center point\r\n\r\n        /**\r\n         * The center point of the ellipse. Used for calculating rotation.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = new Vector2(x, y);\r\n\r\n        /**\r\n         * The horizontal radius of the ellipse.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_xRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._xRadius = xRadius;\r\n\r\n        /**\r\n         * The vertical radius of the ellipse.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_yRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._yRadius = yRadius;\r\n\r\n        //  Radians\r\n\r\n        /**\r\n         * The starting angle of the ellipse in radians.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_startAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._startAngle = DegToRad(startAngle);\r\n\r\n        /**\r\n         * The end angle of the ellipse in radians.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_endAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._endAngle = DegToRad(endAngle);\r\n\r\n        /**\r\n         * Anti-clockwise direction.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_clockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._clockwise = clockwise;\r\n\r\n        /**\r\n         * The rotation of the arc.\r\n         *\r\n         * @name Phaser.Curves.Ellipse#_rotation\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._rotation = DegToRad(rotation);\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(0, out);\r\n    },\r\n\r\n    /**\r\n     * Get the resolution of the curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - Optional divisions value.\r\n     *\r\n     * @return {number} The curve resolution.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        return divisions * 2;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var twoPi = Math.PI * 2;\r\n        var deltaAngle = this._endAngle - this._startAngle;\r\n        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n\r\n        // ensures that deltaAngle is 0 .. 2 PI\r\n        while (deltaAngle < 0)\r\n        {\r\n            deltaAngle += twoPi;\r\n        }\r\n\r\n        while (deltaAngle > twoPi)\r\n        {\r\n            deltaAngle -= twoPi;\r\n        }\r\n\r\n        if (deltaAngle < Number.EPSILON)\r\n        {\r\n            if (samePoints)\r\n            {\r\n                deltaAngle = 0;\r\n            }\r\n            else\r\n            {\r\n                deltaAngle = twoPi;\r\n            }\r\n        }\r\n\r\n        if (this._clockwise && !samePoints)\r\n        {\r\n            if (deltaAngle === twoPi)\r\n            {\r\n                deltaAngle = - twoPi;\r\n            }\r\n            else\r\n            {\r\n                deltaAngle = deltaAngle - twoPi;\r\n            }\r\n        }\r\n\r\n        var angle = this._startAngle + t * deltaAngle;\r\n        var x = this.p0.x + this._xRadius * Math.cos(angle);\r\n        var y = this.p0.y + this._yRadius * Math.sin(angle);\r\n\r\n        if (this._rotation !== 0)\r\n        {\r\n            var cos = Math.cos(this._rotation);\r\n            var sin = Math.sin(this._rotation);\r\n\r\n            var tx = x - this.p0.x;\r\n            var ty = y - this.p0.y;\r\n\r\n            // Rotate the point about the center of the ellipse.\r\n            x = tx * cos - ty * sin + this.p0.x;\r\n            y = tx * sin + ty * cos + this.p0.y;\r\n        }\r\n\r\n        return out.set(x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setXRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The horizontal radius of this curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setXRadius: function (value)\r\n    {\r\n        this.xRadius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical radius of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setYRadius\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The vertical radius of this curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setYRadius: function (value)\r\n    {\r\n        this.yRadius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the width of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The width of this curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setWidth: function (value)\r\n    {\r\n        this.xRadius = value / 2;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the height of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setHeight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The height of this curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setHeight: function (value)\r\n    {\r\n        this.yRadius = value / 2;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the start angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setStartAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The start angle of this curve, in radians.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setStartAngle: function (value)\r\n    {\r\n        this.startAngle = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the end angle of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setEndAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The end angle of this curve, in radians.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setEndAngle: function (value)\r\n    {\r\n        this.endAngle = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if this curve extends clockwise or anti-clockwise.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setClockwise\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The clockwise state of this curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setClockwise: function (value)\r\n    {\r\n        this.clockwise = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of this curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The rotation of this curve, in radians.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    setRotation: function (value)\r\n    {\r\n        this.rotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The x coordinate of the center of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.p0.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.p0.x = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinate of the center of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.p0.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.p0.y = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#xRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    xRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._xRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._xRadius = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical radius of the ellipse.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#yRadius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    yRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._yRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._yRadius = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The start angle of the ellipse in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#startAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    startAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._startAngle);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._startAngle = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The end angle of the ellipse in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#endAngle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    endAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._endAngle);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._endAngle = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * `true` if the ellipse rotation is clockwise or `false` if anti-clockwise.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#clockwise\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    clockwise: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._clockwise;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._clockwise = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the ellipse, relative to the center, in degrees.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#angle\r\n     * @type {number}\r\n     * @since 3.14.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return RadToDeg(this._rotation);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._rotation = DegToRad(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The rotation of the ellipse, relative to the center, in radians.\r\n     *\r\n     * @name Phaser.Curves.Ellipse#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._rotation;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._rotation = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * JSON serialization of the curve.\r\n     *\r\n     * @method Phaser.Curves.Ellipse#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONEllipseCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            x: this.p0.x,\r\n            y: this.p0.y,\r\n            xRadius: this._xRadius,\r\n            yRadius: this._yRadius,\r\n            startAngle: RadToDeg(this._startAngle),\r\n            endAngle: RadToDeg(this._endAngle),\r\n            clockwise: this._clockwise,\r\n            rotation: RadToDeg(this._rotation)\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a curve from the provided Ellipse Curve Configuration object.\r\n *\r\n * @function Phaser.Curves.Ellipse.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONEllipseCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Ellipse} The ellipse curve constructed from the configuration object.\r\n */\r\nEllipseCurve.fromJSON = function (data)\r\n{\r\n    return new EllipseCurve(data);\r\n};\r\n\r\nmodule.exports = EllipseCurve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A LineCurve is a \"curve\" comprising exactly two points (a line segment).\r\n *\r\n * @class Line\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - The first endpoint.\r\n * @param {Phaser.Math.Vector2} [p1] - The second endpoint.\r\n */\r\nvar LineCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    //  vec2s or array\r\n    function LineCurve (p0, p1)\r\n    {\r\n        Curve.call(this, 'LineCurve');\r\n\r\n        if (Array.isArray(p0))\r\n        {\r\n            p1 = new Vector2(p0[2], p0[3]);\r\n            p0 = new Vector2(p0[0], p0[1]);\r\n        }\r\n\r\n        /**\r\n         * The first endpoint.\r\n         *\r\n         * @name Phaser.Curves.Line#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = p0;\r\n\r\n        /**\r\n         * The second endpoint.\r\n         *\r\n         * @name Phaser.Curves.Line#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p1 = p1;\r\n\r\n        //  Override default Curve.arcLengthDivisions\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Line#arcLengthDivisions\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 1;\r\n    },\r\n\r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * @method Phaser.Curves.Line#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - A Rectangle object to store the bounds in. If not given a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out)\r\n    {\r\n        if (out === undefined) { out = new Rectangle(); }\r\n\r\n        return FromPoints([ this.p0, this.p1 ], out);\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.Line#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.p0);\r\n    },\r\n\r\n    /**\r\n     * Gets the resolution of the line.\r\n     *\r\n     * @method Phaser.Curves.Line#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=1] - The number of divisions to consider.\r\n     *\r\n     * @return {number} The resolution. Equal to the number of divisions.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 1; }\r\n\r\n        return divisions;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.Line#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        if (t === 1)\r\n        {\r\n            return out.copy(this.p1);\r\n        }\r\n\r\n        out.copy(this.p1).subtract(this.p0).scale(t).add(this.p0);\r\n\r\n        return out;\r\n    },\r\n\r\n    // Line curve is linear, so we can overwrite default getPointAt\r\n\r\n    /**\r\n     * Gets a point at a given position on the line.\r\n     *\r\n     * @method Phaser.Curves.Line#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        return this.getPoint(u, out);\r\n    },\r\n\r\n    /**\r\n     * Gets the slope of the line as a unit vector.\r\n     *\r\n     * @method Phaser.Curves.Line#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} [t] - The relative position on the line, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The tangent vector.\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        out.copy(this.p1).subtract(this.p0).normalize();\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant.\r\n     *\r\n     * @method Phaser.Curves.Line#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - A float between 0 and 1.\r\n     * @param {number} distance - The distance, in pixels.\r\n     * @param {number} [divisions] - Optional amount of divisions.\r\n     *\r\n     * @return {number} The equidistant value.\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var t;\r\n\r\n        if (distance)\r\n        {\r\n            var arcLengths = this.getLengths(divisions);\r\n            var lineLength = arcLengths[arcLengths.length - 1];\r\n\r\n            //  Cannot overshoot the curve\r\n            var targetLineLength = Math.min(distance, lineLength);\r\n\r\n            t = targetLineLength / lineLength;\r\n        }\r\n        else\r\n        {\r\n            t = u;\r\n        }\r\n\r\n        return t;\r\n    },\r\n\r\n    //  Override default Curve.draw because this is better than calling getPoints on a line!\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Line#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics)\r\n    {\r\n        graphics.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y);\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Gets a JSON representation of the line.\r\n     *\r\n     * @method Phaser.Curves.Line#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            points: [\r\n                this.p0.x, this.p0.y,\r\n                this.p1.x, this.p1.y\r\n            ]\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Configures this line from a JSON representation.\r\n *\r\n * @function Phaser.Curves.Line.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Line} A new LineCurve object.\r\n */\r\nLineCurve.fromJSON = function (data)\r\n{\r\n    var points = data.points;\r\n\r\n    var p0 = new Vector2(points[0], points[1]);\r\n    var p1 = new Vector2(points[2], points[3]);\r\n\r\n    return new LineCurve(p0, p1);\r\n};\r\n\r\nmodule.exports = LineCurve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar QuadraticBezierInterpolation = require('../math/interpolation/QuadraticBezierInterpolation');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A quadratic Bézier curve constructed from two control points.\r\n *\r\n * @class QuadraticBezier\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @param {(Phaser.Math.Vector2|number[])} p0 - Start point, or an array of point pairs.\r\n * @param {Phaser.Math.Vector2} p1 - Control Point 1.\r\n * @param {Phaser.Math.Vector2} p2 - Control Point 2.\r\n */\r\nvar QuadraticBezier = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    function QuadraticBezier (p0, p1, p2)\r\n    {\r\n        Curve.call(this, 'QuadraticBezier');\r\n\r\n        if (Array.isArray(p0))\r\n        {\r\n            p2 = new Vector2(p0[4], p0[5]);\r\n            p1 = new Vector2(p0[2], p0[3]);\r\n            p0 = new Vector2(p0[0], p0[1]);\r\n        }\r\n\r\n        /**\r\n         * The start point.\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */\r\n        this.p0 = p0;\r\n\r\n        /**\r\n         * The first control point.\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p1\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */\r\n        this.p1 = p1;\r\n\r\n        /**\r\n         * The second control point.\r\n         *\r\n         * @name Phaser.Curves.QuadraticBezier#p2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.2.0\r\n         */\r\n        this.p2 = p2;\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getStartPoint\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.p0);\r\n    },\r\n\r\n    /**\r\n     * Get the resolution of the curve.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getResolution\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} divisions - Optional divisions value.\r\n     *\r\n     * @return {number} The curve resolution.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        return divisions;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#getPoint\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var p0 = this.p0;\r\n        var p1 = this.p1;\r\n        var p2 = this.p2;\r\n\r\n        return out.set(\r\n            QuadraticBezierInterpolation(t, p0.x, p1.x, p2.x),\r\n            QuadraticBezierInterpolation(t, p0.y, p1.y, p2.y)\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - `Graphics` object to draw onto.\r\n     * @param {number} [pointsTotal=32] - Number of points to be used for drawing the curve. Higher numbers result in smoother curve but require more processing.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} `Graphics` object that was drawn to.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        var points = this.getPoints(pointsTotal);\r\n\r\n        graphics.beginPath();\r\n        graphics.moveTo(this.p0.x, this.p0.y);\r\n\r\n        for (var i = 1; i < points.length; i++)\r\n        {\r\n            graphics.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        graphics.strokePath();\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Converts the curve into a JSON compatible object.\r\n     *\r\n     * @method Phaser.Curves.QuadraticBezier#toJSON\r\n     * @since 3.2.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: this.type,\r\n            points: [\r\n                this.p0.x, this.p0.y,\r\n                this.p1.x, this.p1.y,\r\n                this.p2.x, this.p2.y\r\n            ]\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a curve from a JSON object, e. g. created by `toJSON`.\r\n *\r\n * @function Phaser.Curves.QuadraticBezier.fromJSON\r\n * @since 3.2.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.QuadraticBezier} The created curve instance.\r\n */\r\nQuadraticBezier.fromJSON = function (data)\r\n{\r\n    var points = data.points;\r\n\r\n    var p0 = new Vector2(points[0], points[1]);\r\n    var p1 = new Vector2(points[2], points[3]);\r\n    var p2 = new Vector2(points[4], points[5]);\r\n\r\n    return new QuadraticBezier(p0, p1, p2);\r\n};\r\n\r\nmodule.exports = QuadraticBezier;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar CatmullRom = require('../math/CatmullRom');\r\nvar Class = require('../utils/Class');\r\nvar Curve = require('./Curve');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * Create a smooth 2d spline curve from a series of points.\r\n *\r\n * @class Spline\r\n * @extends Phaser.Curves.Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Math.Vector2[]|number[]|number[][])} [points] - The points that configure the curve.\r\n */\r\nvar SplineCurve = new Class({\r\n\r\n    Extends: Curve,\r\n\r\n    initialize:\r\n\r\n    function SplineCurve (points)\r\n    {\r\n        if (points === undefined) { points = []; }\r\n\r\n        Curve.call(this, 'SplineCurve');\r\n\r\n        /**\r\n         * The Vector2 points that configure the curve.\r\n         *\r\n         * @name Phaser.Curves.Spline#points\r\n         * @type {Phaser.Math.Vector2[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        this.addPoints(points);\r\n    },\r\n\r\n    /**\r\n     * Add a list of points to the current list of Vector2 points of the curve.\r\n     *\r\n     * @method Phaser.Curves.Spline#addPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Math.Vector2[]|number[]|number[][])} points - The points that configure the curve.\r\n     *\r\n     * @return {this} This curve object.\r\n     */\r\n    addPoints: function (points)\r\n    {\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            var p = new Vector2();\r\n\r\n            if (typeof points[i] === 'number')\r\n            {\r\n                p.x = points[i];\r\n                p.y = points[i + 1];\r\n                i++;\r\n            }\r\n            else if (Array.isArray(points[i]))\r\n            {\r\n                //  An array of arrays?\r\n                p.x = points[i][0];\r\n                p.y = points[i][1];\r\n            }\r\n            else\r\n            {\r\n                p.x = points[i].x;\r\n                p.y = points[i].y;\r\n            }\r\n\r\n            this.points.push(p);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Add a point to the current list of Vector2 points of the curve.\r\n     *\r\n     * @method Phaser.Curves.Spline#addPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of this curve\r\n     * @param {number} y - The y coordinate of this curve\r\n     *\r\n     * @return {Phaser.Math.Vector2} The new Vector2 added to the curve\r\n     */\r\n    addPoint: function (x, y)\r\n    {\r\n        var vec = new Vector2(x, y);\r\n\r\n        this.points.push(vec);\r\n\r\n        return vec;\r\n    },\r\n\r\n    /**\r\n     * Gets the starting point on the curve.\r\n     *\r\n     * @method Phaser.Curves.Spline#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.points[0]);\r\n    },\r\n\r\n    /**\r\n     * Get the resolution of the curve.\r\n     *\r\n     * @method Phaser.Curves.Spline#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} divisions - Optional divisions value.\r\n     *\r\n     * @return {number} The curve resolution.\r\n     */\r\n    getResolution: function (divisions)\r\n    {\r\n        return divisions * this.points.length;\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.Spline#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var points = this.points;\r\n\r\n        var point = (points.length - 1) * t;\r\n\r\n        var intPoint = Math.floor(point);\r\n\r\n        var weight = point - intPoint;\r\n\r\n        var p0 = points[(intPoint === 0) ? intPoint : intPoint - 1];\r\n        var p1 = points[intPoint];\r\n        var p2 = points[(intPoint > points.length - 2) ? points.length - 1 : intPoint + 1];\r\n        var p3 = points[(intPoint > points.length - 3) ? points.length - 1 : intPoint + 2];\r\n\r\n        return out.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\r\n    },\r\n\r\n    /**\r\n     * Exports a JSON object containing this curve data.\r\n     *\r\n     * @method Phaser.Curves.Spline#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} The JSON object containing this curve data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var points = [];\r\n\r\n        for (var i = 0; i < this.points.length; i++)\r\n        {\r\n            points.push(this.points[i].x);\r\n            points.push(this.points[i].y);\r\n        }\r\n\r\n        return {\r\n            type: this.type,\r\n            points: points\r\n        };\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Imports a JSON object containing this curve data.\r\n *\r\n * @function Phaser.Curves.Spline.fromJSON\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Curves.JSONCurve} data - The JSON object containing this curve data.\r\n *\r\n * @return {Phaser.Curves.Spline} The spline curve created.\r\n */\r\nSplineCurve.fromJSON = function (data)\r\n{\r\n    return new SplineCurve(data.points);\r\n};\r\n\r\nmodule.exports = SplineCurve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Curves\r\n */\r\n\r\nmodule.exports = {\r\n    Path: require('./path/Path'),\r\n    MoveTo: require('./path/MoveTo'),\r\n\r\n    CubicBezier: require('./CubicBezierCurve'),\r\n    Curve: require('./Curve'),\r\n    Ellipse: require('./EllipseCurve'),\r\n    Line: require('./LineCurve'),\r\n    QuadraticBezier: require('./QuadraticBezierCurve'),\r\n    Spline: require('./SplineCurve')\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A MoveTo Curve is a very simple curve consisting of only a single point.\r\n * Its intended use is to move the ending point in a Path.\r\n *\r\n * @class MoveTo\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - `x` pixel coordinate.\r\n * @param {number} [y=0] - `y` pixel coordinate.\r\n */\r\nvar MoveTo = new Class({\r\n\r\n    initialize:\r\n\r\n    function MoveTo (x, y)\r\n    {\r\n        /**\r\n         * Denotes that this Curve does not influence the bounds, points, and drawing of its parent Path. Must be `false` or some methods in the parent Path will throw errors.\r\n         *\r\n         * @name Phaser.Curves.MoveTo#active\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.active = false;\r\n\r\n        /**\r\n         * The lone point which this curve consists of.\r\n         *\r\n         * @name Phaser.Curves.MoveTo#p0\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.p0 = new Vector2(x, y);\r\n    },\r\n\r\n    /**\r\n     * Get point at relative position in curve according to length.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The position along the curve to return. Where 0 is the start and 1 is the end.\r\n     * @param {Phaser.Math.Vector2} [out] - A Vector2 object to store the result in. If not given will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The coordinates of the point on the curve. If an `out` object was given this will be returned.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.p0);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the point at given position in the curve. This will always return this curve's only point.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - The position in the path to retrieve, between 0 and 1. Not used.\r\n     * @param {Phaser.Math.Vector2} [out] - An optional vector in which to store the point.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The modified `out` vector, or a new `Vector2` if none was provided.\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        return this.getPoint(u, out);\r\n    },\r\n\r\n    /**\r\n     * Gets the resolution of this curve.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getResolution\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The resolution of this curve. For a MoveTo the value is always 1.\r\n     */\r\n    getResolution: function ()\r\n    {\r\n        return 1;\r\n    },\r\n\r\n    /**\r\n     * Gets the length of this curve.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The length of this curve. For a MoveTo the value is always 0.\r\n     */\r\n    getLength: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Converts this curve into a JSON-serializable object.\r\n     *\r\n     * @method Phaser.Curves.MoveTo#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONCurve} A primitive object with the curve's type and only point.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return {\r\n            type: 'MoveTo',\r\n            points: [\r\n                this.p0.x, this.p0.y\r\n            ]\r\n        };\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MoveTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CubicBezierCurve = require('../CubicBezierCurve');\r\nvar EllipseCurve = require('../EllipseCurve');\r\nvar GameObjectFactory = require('../../gameobjects/GameObjectFactory');\r\nvar LineCurve = require('../LineCurve');\r\nvar MovePathTo = require('./MoveTo');\r\nvar QuadraticBezierCurve = require('../QuadraticBezierCurve');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar SplineCurve = require('../SplineCurve');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * @classdesc\r\n * A Path combines multiple Curves into one continuous compound curve.\r\n * It does not matter how many Curves are in the Path or what type they are.\r\n *\r\n * A Curve in a Path does not have to start where the previous Curve ends - that is to say, a Path does not\r\n * have to be an uninterrupted curve. Only the order of the Curves influences the actual points on the Path.\r\n *\r\n * @class Path\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The X coordinate of the Path's starting point or a {@link Phaser.Types.Curves.JSONPath}.\r\n * @param {number} [y=0] - The Y coordinate of the Path's starting point.\r\n */\r\nvar Path = new Class({\r\n\r\n    initialize:\r\n\r\n    function Path (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        /**\r\n         * The name of this Path.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.Curves.Path#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The list of Curves which make up this Path.\r\n         *\r\n         * @name Phaser.Curves.Path#curves\r\n         * @type {Phaser.Curves.Curve[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.curves = [];\r\n\r\n        /**\r\n         * The cached length of each Curve in the Path.\r\n         *\r\n         * Used internally by {@link #getCurveLengths}.\r\n         *\r\n         * @name Phaser.Curves.Path#cacheLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheLengths = [];\r\n\r\n        /**\r\n         * Automatically closes the path.\r\n         *\r\n         * @name Phaser.Curves.Path#autoClose\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.autoClose = false;\r\n\r\n        /**\r\n         * The starting point of the Path.\r\n         *\r\n         * This is not necessarily equivalent to the starting point of the first Curve in the Path. In an empty Path, it's also treated as the ending point.\r\n         *\r\n         * @name Phaser.Curves.Path#startPoint\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.startPoint = new Vector2();\r\n\r\n        /**\r\n         * A temporary vector used to avoid object creation when adding a Curve to the Path.\r\n         *\r\n         * @name Phaser.Curves.Path#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * A temporary vector used to avoid object creation when adding a Curve to the Path.\r\n         *\r\n         * @name Phaser.Curves.Path#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n\r\n        if (typeof x === 'object')\r\n        {\r\n            this.fromJSON(x);\r\n        }\r\n        else\r\n        {\r\n            this.startPoint.set(x, y);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Appends a Curve to the end of the Path.\r\n     *\r\n     * The Curve does not have to start where the Path ends or, for an empty Path, at its defined starting point.\r\n     *\r\n     * @method Phaser.Curves.Path#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Curves.Curve} curve - The Curve to append.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    add: function (curve)\r\n    {\r\n        this.curves.push(curve);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a circular Ellipse Curve positioned at the end of the Path.\r\n     *\r\n     * @method Phaser.Curves.Path#circleTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {boolean} [clockwise=false] - `true` to create a clockwise circle as opposed to a counter-clockwise circle.\r\n     * @param {number} [rotation=0] - The rotation of the circle in degrees.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    circleTo: function (radius, clockwise, rotation)\r\n    {\r\n        if (clockwise === undefined) { clockwise = false; }\r\n\r\n        return this.ellipseTo(radius, radius, 0, 360, clockwise, rotation);\r\n    },\r\n\r\n    /**\r\n     * Ensures that the Path is closed.\r\n     *\r\n     * A closed Path starts and ends at the same point. If the Path is not closed, a straight Line Curve will be created from the ending point directly to the starting point. During the check, the actual starting point of the Path, i.e. the starting point of the first Curve, will be used as opposed to the Path's defined {@link startPoint}, which could differ.\r\n     *\r\n     * Calling this method on an empty Path will result in an error.\r\n     *\r\n     * @method Phaser.Curves.Path#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    closePath: function ()\r\n    {\r\n        // Add a line curve if start and end of lines are not connected\r\n        var startPoint = this.curves[0].getPoint(0);\r\n        var endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\r\n        if (!startPoint.equals(endPoint))\r\n        {\r\n            //  This will copy a reference to the vectors, which probably isn't sensible\r\n            this.curves.push(new LineCurve(endPoint, startPoint));\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a cubic bezier curve starting at the previous end point and ending at p3, using p1 and p2 as control points.\r\n     *\r\n     * @method Phaser.Curves.Path#cubicBezierTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - The x coordinate of the end point. Or, if a Vector2, the p1 value.\r\n     * @param {(number|Phaser.Math.Vector2)} y - The y coordinate of the end point. Or, if a Vector2, the p2 value.\r\n     * @param {(number|Phaser.Math.Vector2)} control1X - The x coordinate of the first control point. Or, if a Vector2, the p3 value.\r\n     * @param {number} [control1Y] - The y coordinate of the first control point. Not used if Vector2s are provided as the first 3 arguments.\r\n     * @param {number} [control2X] - The x coordinate of the second control point. Not used if Vector2s are provided as the first 3 arguments.\r\n     * @param {number} [control2Y] - The y coordinate of the second control point. Not used if Vector2s are provided as the first 3 arguments.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    cubicBezierTo: function (x, y, control1X, control1Y, control2X, control2Y)\r\n    {\r\n        var p0 = this.getEndPoint();\r\n        var p1;\r\n        var p2;\r\n        var p3;\r\n\r\n        //  Assume they're all Vector2s\r\n        if (x instanceof Vector2)\r\n        {\r\n            p1 = x;\r\n            p2 = y;\r\n            p3 = control1X;\r\n        }\r\n        else\r\n        {\r\n            p1 = new Vector2(control1X, control1Y);\r\n            p2 = new Vector2(control2X, control2Y);\r\n            p3 = new Vector2(x, y);\r\n        }\r\n\r\n        return this.add(new CubicBezierCurve(p0, p1, p2, p3));\r\n    },\r\n\r\n    //  Creates a quadratic bezier curve starting at the previous end point and ending at p2, using p1 as a control point\r\n\r\n    /**\r\n     * Creates a Quadratic Bezier Curve starting at the ending point of the Path.\r\n     *\r\n     * @method Phaser.Curves.Path#quadraticBezierTo\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2[])} x - The X coordinate of the second control point or, if it's a `Vector2`, the first control point.\r\n     * @param {number} [y] - The Y coordinate of the second control point or, if `x` is a `Vector2`, the second control point.\r\n     * @param {number} [controlX] - If `x` is not a `Vector2`, the X coordinate of the first control point.\r\n     * @param {number} [controlY] - If `x` is not a `Vector2`, the Y coordinate of the first control point.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    quadraticBezierTo: function (x, y, controlX, controlY)\r\n    {\r\n        var p0 = this.getEndPoint();\r\n        var p1;\r\n        var p2;\r\n\r\n        //  Assume they're all Vector2s\r\n        if (x instanceof Vector2)\r\n        {\r\n            p1 = x;\r\n            p2 = y;\r\n        }\r\n        else\r\n        {\r\n            p1 = new Vector2(controlX, controlY);\r\n            p2 = new Vector2(x, y);\r\n        }\r\n\r\n        return this.add(new QuadraticBezierCurve(p0, p1, p2));\r\n    },\r\n\r\n    /**\r\n     * Draws all Curves in the Path to a Graphics Game Object.\r\n     *\r\n     * @method Phaser.Curves.Path#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [out,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics Game Object to draw to.\r\n     * @param {number} [pointsTotal=32] - The number of points to draw for each Curve. Higher numbers result in a smoother curve but require more processing.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object which was drawn to.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            curve.draw(graphics, pointsTotal);\r\n        }\r\n\r\n        return graphics;\r\n    },\r\n\r\n    /**\r\n     * Creates an ellipse curve positioned at the previous end point, using the given parameters.\r\n     *\r\n     * @method Phaser.Curves.Path#ellipseTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [xRadius=0] - The horizontal radius of ellipse.\r\n     * @param {number} [yRadius=0] - The vertical radius of ellipse.\r\n     * @param {number} [startAngle=0] - The start angle of the ellipse, in degrees.\r\n     * @param {number} [endAngle=360] - The end angle of the ellipse, in degrees.\r\n     * @param {boolean} [clockwise=false] - Whether the ellipse angles are given as clockwise (`true`) or counter-clockwise (`false`).\r\n     * @param {number} [rotation=0] - The rotation of the ellipse, in degrees.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    ellipseTo: function (xRadius, yRadius, startAngle, endAngle, clockwise, rotation)\r\n    {\r\n        var ellipse = new EllipseCurve(0, 0, xRadius, yRadius, startAngle, endAngle, clockwise, rotation);\r\n\r\n        var end = this.getEndPoint(this._tmpVec2A);\r\n\r\n        //  Calculate where to center the ellipse\r\n        var start = ellipse.getStartPoint(this._tmpVec2B);\r\n\r\n        end.subtract(start);\r\n\r\n        ellipse.x = end.x;\r\n        ellipse.y = end.y;\r\n\r\n        return this.add(ellipse);\r\n    },\r\n\r\n    /**\r\n     * Creates a Path from a Path Configuration object.\r\n     *\r\n     * The provided object should be a {@link Phaser.Types.Curves.JSONPath}, as returned by {@link #toJSON}. Providing a malformed object may cause errors.\r\n     *\r\n     * @method Phaser.Curves.Path#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Curves.JSONPath} data - The JSON object containing the Path data.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    fromJSON: function (data)\r\n    {\r\n        //  data should be an object matching the Path.toJSON object structure.\r\n\r\n        this.curves = [];\r\n        this.cacheLengths = [];\r\n\r\n        this.startPoint.set(data.x, data.y);\r\n\r\n        this.autoClose = data.autoClose;\r\n\r\n        for (var i = 0; i < data.curves.length; i++)\r\n        {\r\n            var curve = data.curves[i];\r\n\r\n            switch (curve.type)\r\n            {\r\n                case 'LineCurve':\r\n                    this.add(LineCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'EllipseCurve':\r\n                    this.add(EllipseCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'SplineCurve':\r\n                    this.add(SplineCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'CubicBezierCurve':\r\n                    this.add(CubicBezierCurve.fromJSON(curve));\r\n                    break;\r\n\r\n                case 'QuadraticBezierCurve':\r\n                    this.add(QuadraticBezierCurve.fromJSON(curve));\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a Rectangle with a position and size matching the bounds of this Path.\r\n     *\r\n     * @method Phaser.Curves.Path#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in.\r\n     * @param {number} [accuracy=16] - The accuracy of the bounds calculations. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} The modified `out` Rectangle, or a new Rectangle if none was provided.\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (out === undefined) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        out.x = Number.MAX_VALUE;\r\n        out.y = Number.MAX_VALUE;\r\n\r\n        var bounds = new Rectangle();\r\n        var maxRight = MATH_CONST.MIN_SAFE_INTEGER;\r\n        var maxBottom = MATH_CONST.MIN_SAFE_INTEGER;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            curve.getBounds(bounds, accuracy);\r\n\r\n            out.x = Math.min(out.x, bounds.x);\r\n            out.y = Math.min(out.y, bounds.y);\r\n\r\n            maxRight = Math.max(maxRight, bounds.right);\r\n            maxBottom = Math.max(maxBottom, bounds.bottom);\r\n        }\r\n\r\n        out.right = maxRight;\r\n        out.bottom = maxBottom;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the length of the Path at the end of each Curve.\r\n     *\r\n     * The result of this method will be cached to avoid recalculating it in subsequent calls. The cache is only invalidated when the {@link #curves} array changes in length, leading to potential inaccuracies if a Curve in the Path is changed, or if a Curve is removed and another is added in its place.\r\n     *\r\n     * @method Phaser.Curves.Path#getCurveLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number[]} An array containing the length of the Path at the end of each one of its Curves.\r\n     */\r\n    getCurveLengths: function ()\r\n    {\r\n        // We use cache values if curves and cache array are same length\r\n\r\n        if (this.cacheLengths.length === this.curves.length)\r\n        {\r\n            return this.cacheLengths;\r\n        }\r\n\r\n        // Get length of sub-curve\r\n        // Push sums into cached array\r\n\r\n        var lengths = [];\r\n        var sums = 0;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            sums += this.curves[i].getLength();\r\n\r\n            lengths.push(sums);\r\n        }\r\n\r\n        this.cacheLengths = lengths;\r\n\r\n        return lengths;\r\n    },\r\n\r\n    /**\r\n     * Returns the ending point of the Path.\r\n     *\r\n     * A Path's ending point is equivalent to the ending point of the last Curve in the Path. For an empty Path, the ending point is at the Path's defined {@link #startPoint}.\r\n     *\r\n     * @method Phaser.Curves.Path#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - The object to store the point in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The modified `out` object, or a new Vector2 if none was provided.\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        if (this.curves.length > 0)\r\n        {\r\n            this.curves[this.curves.length - 1].getPoint(1, out);\r\n        }\r\n        else\r\n        {\r\n            out.copy(this.startPoint);\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Returns the total length of the Path.\r\n     *\r\n     * @see {@link #getCurveLengths}\r\n     *\r\n     * @method Phaser.Curves.Path#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The total length of the Path.\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lens = this.getCurveLengths();\r\n\r\n        return lens[lens.length - 1];\r\n    },\r\n\r\n    // To get accurate point with reference to\r\n    // entire path distance at time t,\r\n    // following has to be done:\r\n\r\n    // 1. Length of each sub path have to be known\r\n    // 2. Locate and identify type of curve\r\n    // 3. Get t for the curve\r\n    // 4. Return curve.getPointAt(t')\r\n\r\n    /**\r\n     * Calculates the coordinates of the point at the given normalized location (between 0 and 1) on the Path.\r\n     *\r\n     * The location is relative to the entire Path, not to an individual Curve. A location of 0.5 is always in the middle of the Path and is thus an equal distance away from both its starting and ending points. In a Path with one Curve, it would be in the middle of the Curve; in a Path with two Curves, it could be anywhere on either one of them depending on their lengths.\r\n     *\r\n     * @method Phaser.Curves.Path#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The location of the point to return, between 0 and 1.\r\n     * @param {Phaser.Math.Vector2} [out] - The object in which to store the calculated point.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} The modified `out` object, or a new `Vector2` if none was provided.\r\n     */\r\n    getPoint: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var d = t * this.getLength();\r\n        var curveLengths = this.getCurveLengths();\r\n        var i = 0;\r\n\r\n        while (i < curveLengths.length)\r\n        {\r\n            if (curveLengths[i] >= d)\r\n            {\r\n                var diff = curveLengths[i] - d;\r\n                var curve = this.curves[i];\r\n\r\n                var segmentLength = curve.getLength();\r\n                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;\r\n\r\n                return curve.getPointAt(u, out);\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        // loop where sum != 0, sum > d , sum+1 <d\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Get a sequence of points on the path.\r\n     *\r\n     * @method Phaser.Curves.Path#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=12] - The number of divisions per resolution per curve.\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} An array of Vector2 objects that containing the points along the Path.\r\n     */\r\n    getPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 12; }\r\n\r\n        var points = [];\r\n        var last;\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            var curve = this.curves[i];\r\n\r\n            if (!curve.active)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var resolution = curve.getResolution(divisions);\r\n\r\n            var pts = curve.getPoints(resolution);\r\n\r\n            for (var j = 0; j < pts.length; j++)\r\n            {\r\n                var point = pts[j];\r\n\r\n                if (last && last.equals(point))\r\n                {\r\n                    // ensures no consecutive points are duplicates\r\n                    continue;\r\n                }\r\n\r\n                points.push(point);\r\n\r\n                last = point;\r\n            }\r\n        }\r\n\r\n        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]))\r\n        {\r\n            points.push(points[0]);\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * Returns a randomly chosen point anywhere on the path. This follows the same rules as `getPoint` in that it may return a point on any Curve inside this path.\r\n     *\r\n     * When calling this method multiple times, the points are not guaranteed to be equally spaced spatially.\r\n     *\r\n     * @method Phaser.Curves.Path#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The modified `out` object, or a new `Vector2` if none was provided.\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    /**\r\n     * Divides this Path into a set of equally spaced points,\r\n     *\r\n     * The resulting points are equally spaced with respect to the points' position on the path, but not necessarily equally spaced spatially.\r\n     *\r\n     * @method Phaser.Curves.Path#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [divisions=40] - The amount of points to divide this Path into.\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} A list of the points this path was subdivided into.\r\n     */\r\n    getSpacedPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = 40; }\r\n\r\n        var points = [];\r\n\r\n        for (var i = 0; i <= divisions; i++)\r\n        {\r\n            points.push(this.getPoint(i / divisions));\r\n        }\r\n\r\n        if (this.autoClose)\r\n        {\r\n            points.push(points[0]);\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * Returns the starting point of the Path.\r\n     *\r\n     * @method Phaser.Curves.Path#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - `Vector2` instance that should be used for storing the result. If `undefined` a new `Vector2` will be created.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The modified `out` object, or a new Vector2 if none was provided.\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return out.copy(this.startPoint);\r\n    },\r\n\r\n    /**\r\n     * Gets a unit vector tangent at a relative position on the path.\r\n     *\r\n     * @method Phaser.Curves.Path#getTangent\r\n     * @since 3.23.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - The relative position on the path, [0..1].\r\n     * @param {Phaser.Math.Vector2} [out] - A vector to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var d = t * this.getLength();\r\n        var curveLengths = this.getCurveLengths();\r\n        var i = 0;\r\n\r\n        while (i < curveLengths.length)\r\n        {\r\n            if (curveLengths[i] >= d)\r\n            {\r\n                var diff = curveLengths[i] - d;\r\n                var curve = this.curves[i];\r\n\r\n                var segmentLength = curve.getLength();\r\n                var u = (segmentLength === 0) ? 0 : 1 - diff / segmentLength;\r\n\r\n                return curve.getTangentAt(u, out);\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Creates a line curve from the previous end point to x/y.\r\n     *\r\n     * @method Phaser.Curves.Path#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - The X coordinate of the line's end point, or a `Vector2` containing the entire end point.\r\n     * @param {number} [y] - The Y coordinate of the line's end point, if a number was passed as the X parameter.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    lineTo: function (x, y)\r\n    {\r\n        if (x instanceof Vector2)\r\n        {\r\n            this._tmpVec2B.copy(x);\r\n        }\r\n        else\r\n        {\r\n            this._tmpVec2B.set(x, y);\r\n        }\r\n\r\n        var end = this.getEndPoint(this._tmpVec2A);\r\n\r\n        return this.add(new LineCurve([ end.x, end.y, this._tmpVec2B.x, this._tmpVec2B.y ]));\r\n    },\r\n\r\n    /**\r\n     * Creates a spline curve starting at the previous end point, using the given points on the curve.\r\n     *\r\n     * @method Phaser.Curves.Path#splineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2[]} points - The points the newly created spline curve should consist of.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    splineTo: function (points)\r\n    {\r\n        points.unshift(this.getEndPoint());\r\n\r\n        return this.add(new SplineCurve(points));\r\n    },\r\n\r\n    /**\r\n     * Creates a \"gap\" in this path from the path's current end point to the given coordinates.\r\n     *\r\n     * After calling this function, this Path's end point will be equal to the given coordinates\r\n     *\r\n     * @method Phaser.Curves.Path#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Math.Vector2)} x - The X coordinate of the position to move the path's end point to, or a `Vector2` containing the entire new end point.\r\n     * @param {number} [y] - The Y coordinate of the position to move the path's end point to, if a number was passed as the X coordinate.\r\n     *\r\n     * @return {this} This Path object.\r\n     */\r\n    moveTo: function (x, y)\r\n    {\r\n        if (x instanceof Vector2)\r\n        {\r\n            return this.add(new MovePathTo(x.x, x.y));\r\n        }\r\n        else\r\n        {\r\n            return this.add(new MovePathTo(x, y));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Converts this Path to a JSON object containing the path information and its constituent curves.\r\n     *\r\n     * @method Phaser.Curves.Path#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Curves.JSONPath} The JSON object containing this path's data.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = [];\r\n\r\n        for (var i = 0; i < this.curves.length; i++)\r\n        {\r\n            out.push(this.curves[i].toJSON());\r\n        }\r\n\r\n        return {\r\n            type: 'Path',\r\n            x: this.startPoint.x,\r\n            y: this.startPoint.y,\r\n            autoClose: this.autoClose,\r\n            curves: out\r\n        };\r\n    },\r\n\r\n    /**\r\n     * cacheLengths must be recalculated.\r\n     *\r\n     * @method Phaser.Curves.Path#updateArcLengths\r\n     * @since 3.0.0\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.cacheLengths = [];\r\n\r\n        this.getCurveLengths();\r\n    },\r\n\r\n    /**\r\n     * Disposes of this Path, clearing its internal references to objects so they can be garbage-collected.\r\n     *\r\n     * @method Phaser.Curves.Path#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.curves.length = 0;\r\n        this.cacheLengths.length = 0;\r\n        this.startPoint = undefined;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Creates a new Path Object.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#path\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Path.\r\n * @param {number} y - The vertical position of this Path.\r\n *\r\n * @return {Phaser.Curves.Path} The Path Object that was created.\r\n */\r\nGameObjectFactory.register('path', function (x, y)\r\n{\r\n    return new Path(x, y);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n\r\nmodule.exports = Path;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Game Object Factory is a Scene plugin that allows you to quickly create many common\r\n * types of Game Objects and have them automatically registered with the Scene.\r\n *\r\n * Game Objects directly register themselves with the Factory and inject their own creation\r\n * methods into the class.\r\n *\r\n * @class GameObjectFactory\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object Factory belongs.\r\n */\r\nvar GameObjectFactory = new Class({\r\n\r\n    initialize:\r\n\r\n    function GameObjectFactory (scene)\r\n    {\r\n        /**\r\n         * The Scene to which this Game Object Factory belongs.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#scene\r\n         * @type {Phaser.Scene}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene.Systems.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @protected\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        /**\r\n         * A reference to the Scene Display List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Update List.\r\n         *\r\n         * @name Phaser.GameObjects.GameObjectFactory#updateList\r\n         * @type {Phaser.GameObjects.UpdateList}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.updateList;\r\n\r\n        this.events.once(SceneEvents.BOOT, this.boot, this);\r\n        this.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.displayList = this.systems.displayList;\r\n        this.updateList = this.systems.updateList;\r\n\r\n        this.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Game Object to this Scene.\r\n     *\r\n     * If the Game Object renders, it will be added to the Display List.\r\n     * If it has a `preUpdate` method, it will be added to the Update List.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {(Phaser.GameObjects.GameObject|Phaser.GameObjects.Group|Phaser.GameObjects.Layer)} G - [child,$return]\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.Group|Phaser.GameObjects.Layer)} child - The child to be added to this Scene.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that was added.\r\n     */\r\n    existing: function (child)\r\n    {\r\n        if (child.renderCanvas || child.renderWebGL)\r\n        {\r\n            this.displayList.add(child);\r\n        }\r\n\r\n        //  For when custom objects have overridden `preUpdate` but don't hook into the ADDED_TO_SCENE event:\r\n        //  Adding to the list multiple times is safe, as it won't add duplicates into the list anyway.\r\n        if (child.preUpdate)\r\n        {\r\n            this.updateList.add(child);\r\n        }\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.events = null;\r\n\r\n        this.displayList = null;\r\n        this.updateList = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method called directly by the Game Object factory functions.\r\n * With this method you can register a custom GameObject factory in the GameObjectFactory,\r\n * providing a name (`factoryType`) and the constructor (`factoryFunction`) in order\r\n * to be called when you call to Phaser.Scene.add[ factoryType ] method.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory.register\r\n * @static\r\n * @since 3.0.0\r\n *\r\n * @param {string} factoryType - The key of the factory that you will use to call to Phaser.Scene.add[ factoryType ] method.\r\n * @param {function} factoryFunction - The constructor function to be called when you invoke to the Phaser.Scene.add method.\r\n */\r\nGameObjectFactory.register = function (factoryType, factoryFunction)\r\n{\r\n    if (!GameObjectFactory.prototype.hasOwnProperty(factoryType))\r\n    {\r\n        GameObjectFactory.prototype[factoryType] = factoryFunction;\r\n    }\r\n};\r\n\r\n/**\r\n * Static method called directly by the Game Object factory functions.\r\n * With this method you can remove a custom GameObject factory registered in the GameObjectFactory,\r\n * providing a its `factoryType`.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory.remove\r\n * @static\r\n * @since 3.0.0\r\n *\r\n * @param {string} factoryType - The key of the factory that you want to remove from the GameObjectFactory.\r\n */\r\nGameObjectFactory.remove = function (factoryType)\r\n{\r\n    if (GameObjectFactory.prototype.hasOwnProperty(factoryType))\r\n    {\r\n        delete GameObjectFactory.prototype[factoryType];\r\n    }\r\n};\r\n\r\nPluginCache.register('GameObjectFactory', GameObjectFactory, 'add');\r\n\r\nmodule.exports = GameObjectFactory;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('./Rectangle');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n//  points is an array of Point-like objects,\r\n//  either 2 dimensional arrays, or objects with public x/y properties:\r\n//  var points = [\r\n//      [100, 200],\r\n//      [200, 400],\r\n//      { x: 30, y: 60 }\r\n//  ]\r\n\r\n/**\r\n * Constructs new Rectangle or repositions and resizes an existing Rectangle so that all of the given points are on or within its bounds.\r\n *\r\n * @function Phaser.Geom.Rectangle.FromPoints\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Rectangle} O - [out,$return]\r\n *\r\n * @param {array} points - An array of points (either arrays with two elements corresponding to the X and Y coordinate or an object with public `x` and `y` properties) which should be surrounded by the Rectangle.\r\n * @param {Phaser.Geom.Rectangle} [out] - Optional Rectangle to adjust.\r\n *\r\n * @return {Phaser.Geom.Rectangle} The adjusted `out` Rectangle, or a new Rectangle if none was provided.\r\n */\r\nvar FromPoints = function (points, out)\r\n{\r\n    if (out === undefined) { out = new Rectangle(); }\r\n\r\n    if (points.length === 0)\r\n    {\r\n        return out;\r\n    }\r\n\r\n    var minX = Number.MAX_VALUE;\r\n    var minY = Number.MAX_VALUE;\r\n\r\n    var maxX = MATH_CONST.MIN_SAFE_INTEGER;\r\n    var maxY = MATH_CONST.MIN_SAFE_INTEGER;\r\n\r\n    var p;\r\n    var px;\r\n    var py;\r\n\r\n    for (var i = 0; i < points.length; i++)\r\n    {\r\n        p = points[i];\r\n\r\n        if (Array.isArray(p))\r\n        {\r\n            px = p[0];\r\n            py = p[1];\r\n        }\r\n        else\r\n        {\r\n            px = p.x;\r\n            py = p.y;\r\n        }\r\n\r\n        minX = Math.min(minX, px);\r\n        minY = Math.min(minY, py);\r\n\r\n        maxX = Math.max(maxX, px);\r\n        maxY = Math.max(maxY, py);\r\n    }\r\n\r\n    out.x = minX;\r\n    out.y = minY;\r\n    out.width = maxX - minX;\r\n    out.height = maxY - minY;\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = FromPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a Catmull-Rom value from the given points, based on an alpha of 0.5.\r\n *\r\n * @function Phaser.Math.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The amount to interpolate by.\r\n * @param {number} p0 - The first control point.\r\n * @param {number} p1 - The second control point.\r\n * @param {number} p2 - The third control point.\r\n * @param {number} p3 - The fourth control point.\r\n *\r\n * @return {number} The Catmull-Rom value.\r\n */\r\nvar CatmullRom = function (t, p0, p1, p2, p3)\r\n{\r\n    var v0 = (p2 - p0) * 0.5;\r\n    var v1 = (p3 - p1) * 0.5;\r\n    var t2 = t * t;\r\n    var t3 = t * t2;\r\n\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n};\r\n\r\nmodule.exports = CatmullRom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {number} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle in radians, to the equivalent angle in degrees.\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {number} radians - The angle in radians to convert ot degrees.\r\n *\r\n * @return {number} The given angle converted to degrees.\r\n */\r\nvar RadToDeg = function (radians)\r\n{\r\n    return radians * CONST.RAD_TO_DEG;\r\n};\r\n\r\nmodule.exports = RadToDeg;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = {\r\n\r\n    /**\r\n     * The value of PI * 2.\r\n     * \r\n     * @name Phaser.Math.PI2\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    PI2: Math.PI * 2,\r\n\r\n    /**\r\n     * The value of PI * 0.5.\r\n     * \r\n     * @name Phaser.Math.TAU\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TAU: Math.PI * 0.5,\r\n\r\n    /**\r\n     * An epsilon value (1.0e-6)\r\n     * \r\n     * @name Phaser.Math.EPSILON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    EPSILON: 1.0e-6,\r\n\r\n    /**\r\n     * For converting degrees to radians (PI / 180)\r\n     * \r\n     * @name Phaser.Math.DEG_TO_RAD\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    DEG_TO_RAD: Math.PI / 180,\r\n\r\n    /**\r\n     * For converting radians to degrees (180 / PI)\r\n     * \r\n     * @name Phaser.Math.RAD_TO_DEG\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    RAD_TO_DEG: 180 / Math.PI,\r\n\r\n    /**\r\n     * An instance of the Random Number Generator.\r\n     * This is not set until the Game boots.\r\n     * \r\n     * @name Phaser.Math.RND\r\n     * @type {Phaser.Math.RandomDataGenerator}\r\n     * @since 3.0.0\r\n     */\r\n    RND: null,\r\n\r\n    /**\r\n     * The minimum safe integer this browser supports.\r\n     * We use a const for backward compatibility with Internet Explorer.\r\n     * \r\n     * @name Phaser.Math.MIN_SAFE_INTEGER\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\r\n    MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,\r\n\r\n    /**\r\n     * The maximum safe integer this browser supports.\r\n     * We use a const for backward compatibility with Internet Explorer.\r\n     * \r\n     * @name Phaser.Math.MAX_SAFE_INTEGER\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\r\n    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991\r\n\r\n};\r\n\r\nmodule.exports = MATH_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return 3 * k * k * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P3 (t, p)\r\n{\r\n    return t * t * t * p;\r\n}\r\n\r\n/**\r\n * A cubic bezier interpolation method.\r\n *\r\n * https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\r\n *\r\n * @function Phaser.Math.Interpolation.CubicBezier\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The first control point.\r\n * @param {number} p2 - The second control point.\r\n * @param {number} p3 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CubicBezierInterpolation = function (t, p0, p1, p2, p3)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\r\n};\r\n\r\nmodule.exports = CubicBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    return 2 * (1 - t) * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return t * t * p;\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\r\n\r\n/**\r\n * A quadratic bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.QuadraticBezier\r\n * @since 3.2.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The control point.\r\n * @param {number} p2 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar QuadraticBezierInterpolation = function (t, p0, p1, p2)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2);\r\n};\r\n\r\nmodule.exports = QuadraticBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n"],"names":["Class","CubicBezier","Curve","Vector2","CubicBezierCurve","Extends","initialize","p0","p1","p2","p3","call","this","Array","isArray","getStartPoint","out","undefined","copy","getResolution","divisions","getPoint","t","set","x","y","draw","graphics","pointsTotal","points","getPoints","beginPath","moveTo","i","length","lineTo","strokePath","toJSON","type","fromJSON","data","module","exports","FromPoints","Rectangle","defaultDivisions","arcLengthDivisions","cacheArcLengths","needsUpdate","active","_tmpVec2A","_tmpVec2B","strokePoints","getBounds","accuracy","len","getLength","spaced","Math","max","round","getSpacedPoints","getDistancePoints","distance","getEndPoint","getPointAt","lengths","getLengths","current","cache","last","sum","push","p","u","getUtoTmapping","stepRate","d","getRandomPoint","random","getTangent","delta","t1","t2","subtract","normalize","getTangentAt","getTFromDistance","targetArcLength","arcLengths","il","min","comparison","low","high","floor","lengthBefore","updateArcLengths","DegToRad","GetValue","RadToDeg","EllipseCurve","xRadius","yRadius","startAngle","endAngle","clockwise","rotation","config","_xRadius","_yRadius","_startAngle","_endAngle","_clockwise","_rotation","twoPi","PI","deltaAngle","samePoints","abs","Number","EPSILON","angle","cos","sin","tx","ty","setXRadius","value","setYRadius","setWidth","setHeight","setStartAngle","setEndAngle","setClockwise","setRotation","get","LineCurve","scale","add","lineLength","lineBetween","QuadraticBezierInterpolation","QuadraticBezier","CatmullRom","SplineCurve","addPoints","addPoint","vec","point","intPoint","weight","Path","MoveTo","Ellipse","Line","Spline","GameObjectFactory","MovePathTo","QuadraticBezierCurve","MATH_CONST","name","curves","cacheLengths","autoClose","startPoint","curve","circleTo","radius","ellipseTo","closePath","endPoint","equals","cubicBezierTo","control1X","control1Y","control2X","control2Y","quadraticBezierTo","controlX","controlY","ellipse","end","start","MAX_VALUE","bounds","maxRight","MIN_SAFE_INTEGER","maxBottom","right","bottom","getCurveLengths","sums","lens","curveLengths","diff","segmentLength","resolution","pts","j","splineTo","unshift","destroy","register","PluginCache","SceneEvents","scene","systems","sys","events","displayList","updateList","once","BOOT","boot","on","START","DESTROY","SHUTDOWN","shutdown","existing","child","renderCanvas","renderWebGL","preUpdate","off","factoryType","factoryFunction","prototype","hasOwnProperty","remove","px","py","minX","minY","maxX","maxY","width","height","v0","v1","CONST","degrees","DEG_TO_RAD","radians","RAD_TO_DEG","PI2","TAU","RND","MAX_SAFE_INTEGER","k","P0","P1","P2","P3","corePlugins","customPlugins","key","plugin","mapping","custom","source","defaultValue","indexOf","keys","split","parent"],"sourceRoot":""}