{"version":3,"file":"js/360.1edfac5e086a64a7da8c.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/dom/GetInnerHeight.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/dom/GetScreenOrientation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/dom/GetTarget.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/ScaleManager.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/const/CENTER_CONST.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/const/ORIENTATION_CONST.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/const/SCALE_MODE_CONST.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/const/ZOOM_CONST.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scale/const/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Attempts to determine the document inner height across iOS and standard devices.\r\n * Based on code by @tylerjpeterson\r\n *\r\n * @function Phaser.DOM.GetInnerHeight\r\n * @since 3.16.0\r\n *\r\n * @param {boolean} iOS - Is this running on iOS?\r\n *\r\n * @return {number} The inner height value.\r\n */\r\nvar GetInnerHeight = function (iOS)\r\n{\r\n\r\n    if (!iOS)\r\n    {\r\n        return window.innerHeight;\r\n    }\r\n\r\n    var axis = Math.abs(window.orientation);\r\n\r\n    var size = { w: 0, h: 0 };\r\n    \r\n    var ruler = document.createElement('div');\r\n\r\n    ruler.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0');\r\n\r\n    document.documentElement.appendChild(ruler);\r\n\r\n    size.w = (axis === 90) ? ruler.offsetHeight : window.innerWidth;\r\n    size.h = (axis === 90) ? window.innerWidth : ruler.offsetHeight;\r\n\r\n    document.documentElement.removeChild(ruler);\r\n\r\n    ruler = null;\r\n\r\n    if (Math.abs(window.orientation) !== 90)\r\n    {\r\n        return size.h;\r\n    }\r\n    else\r\n    {\r\n        return size.w;\r\n    }\r\n};\r\n\r\nmodule.exports = GetInnerHeight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../scale/const');\r\n\r\n/**\r\n * Attempts to determine the screen orientation using the Orientation API.\r\n *\r\n * @function Phaser.DOM.GetScreenOrientation\r\n * @since 3.16.0\r\n *\r\n * @param {number} width - The width of the viewport.\r\n * @param {number} height - The height of the viewport.\r\n *\r\n * @return {string} The orientation.\r\n */\r\nvar GetScreenOrientation = function (width, height)\r\n{\r\n    var screen = window.screen;\r\n    var orientation = (screen) ? screen.orientation || screen.mozOrientation || screen.msOrientation : false;\r\n\r\n    if (orientation && typeof orientation.type === 'string')\r\n    {\r\n        //  Screen Orientation API specification\r\n        return orientation.type;\r\n    }\r\n    else if (typeof orientation === 'string')\r\n    {\r\n        //  moz / ms-orientation are strings\r\n        return orientation;\r\n    }\r\n\r\n    if (typeof window.orientation === 'number')\r\n    {\r\n        //  Do this check first, as iOS supports this, but also has an incomplete window.screen implementation\r\n        //  This may change by device based on \"natural\" orientation.\r\n        return (window.orientation === 0 || window.orientation === 180) ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;\r\n    }\r\n    else if (window.matchMedia)\r\n    {\r\n        if (window.matchMedia('(orientation: portrait)').matches)\r\n        {\r\n            return CONST.ORIENTATION.PORTRAIT;\r\n        }\r\n        else if (window.matchMedia('(orientation: landscape)').matches)\r\n        {\r\n            return CONST.ORIENTATION.LANDSCAPE;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        return (height > width) ? CONST.ORIENTATION.PORTRAIT : CONST.ORIENTATION.LANDSCAPE;\r\n    }\r\n};\r\n\r\nmodule.exports = GetScreenOrientation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Attempts to get the target DOM element based on the given value, which can be either\r\n * a string, in which case it will be looked-up by ID, or an element node. If nothing\r\n * can be found it will return a reference to the document.body.\r\n *\r\n * @function Phaser.DOM.GetTarget\r\n * @since 3.16.0\r\n *\r\n * @param {HTMLElement} element - The DOM element to look-up.\r\n */\r\nvar GetTarget = function (element)\r\n{\r\n    var target;\r\n\r\n    if (element !== '')\r\n    {\r\n        if (typeof element === 'string')\r\n        {\r\n            //  Hopefully an element ID\r\n            target = document.getElementById(element);\r\n        }\r\n        else if (element && element.nodeType === 1)\r\n        {\r\n            //  Quick test for a HTMLElement\r\n            target = element;\r\n        }\r\n    }\r\n\r\n    //  Fallback to the document body. Covers an invalid ID and a non HTMLElement object.\r\n    if (!target)\r\n    {\r\n        //  Use the full window\r\n        target = document.body;\r\n    }\r\n\r\n    return target;\r\n};\r\n\r\nmodule.exports = GetTarget;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Class = require('../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetInnerHeight = require('../dom/GetInnerHeight');\r\nvar GetTarget = require('../dom/GetTarget');\r\nvar GetScreenOrientation = require('../dom/GetScreenOrientation');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Size = require('../structs/Size');\r\nvar SnapFloor = require('../math/snap/SnapFloor');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * The Scale Manager handles the scaling, resizing and alignment of the game canvas.\r\n *\r\n * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the\r\n * game configuration. You also define the parent container in the game config. If no parent is given,\r\n * it will default to using the document body. The Scale Manager will then look at the available space\r\n * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS\r\n * width and height properties, leaving the width and height of the canvas element itself untouched.\r\n * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'\r\n * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS\r\n * property, without the need for browser prefix handling.\r\n *\r\n * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed\r\n * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the\r\n * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions\r\n * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the\r\n * CSS you set-up on the page hosting your game, rather than taking control of it.\r\n *\r\n * #### Parent and Display canvas containment guidelines:\r\n *\r\n * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.\r\n *\r\n * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\r\n *\r\n * - The Parent element should _not_ apply a padding as this is not accounted for.\r\n *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\r\n *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\r\n *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\r\n *\r\n * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as\r\n *   they may be updated by the Scale Manager.\r\n *\r\n * #### Scale Modes\r\n *\r\n * The way the scaling is handled is determined by the `scaleMode` property. The default is `NONE`,\r\n * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are\r\n * responsible for all scaling. The other scaling modes afford you automatic scaling.\r\n *\r\n * If you wish to scale your game so that it always fits into the available space within the parent, you\r\n * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are\r\n * available. Here is a basic config showing how to set this scale mode:\r\n *\r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     mode: Phaser.Scale.FIT,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n *\r\n * Place the `scale` config object within your game config.\r\n *\r\n * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space\r\n * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping\r\n * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted\r\n * to fill all available space within the parent. You should be extremely careful about the size of the\r\n * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's\r\n * very easy to hit fill-rate limits quickly.\r\n *\r\n * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,\r\n * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes\r\n * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.\r\n *\r\n * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas\r\n * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments\r\n * where it's up to you to guide and help the canvas position itself, especially when built into rendering\r\n * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such\r\n * like, then it's up to you to ensure they are present in the html.\r\n *\r\n * #### Centering\r\n *\r\n * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being\r\n * properly configured and styled, as the centering offsets are based entirely on the available space\r\n * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,\r\n * or both. Here's an example:\r\n *\r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     autoCenter: Phaser.Scale.CENTER_BOTH,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n *\r\n * #### Fullscreen API\r\n *\r\n * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill\r\n * the entire display, removing all browser UI and anything else present on the screen. It will remain in this\r\n * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a\r\n * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser\r\n * to handle it. Some mobile browsers also support this.\r\n *\r\n * @class ScaleManager\r\n * @memberof Phaser.Scale\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\r\nvar ScaleManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function ScaleManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Phaser.Game instance.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#game\r\n         * @type {Phaser.Game}\r\n         * @readonly\r\n         * @since 3.15.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A reference to the HTML Canvas Element that Phaser uses to render the game.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * The DOM bounds of the canvas element.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvasBounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvasBounds = new Rectangle();\r\n\r\n        /**\r\n         * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.\r\n         *\r\n         * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default\r\n         * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parent\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.parent = null;\r\n\r\n        /**\r\n         * Is the parent element the browser window?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentIsWindow\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentIsWindow = false;\r\n\r\n        /**\r\n         * The Parent Size component.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentSize = new Size();\r\n\r\n        /**\r\n         * The Game Size component.\r\n         *\r\n         * The un-modified game size, as requested in the game config (the raw width / height),\r\n         * as used for world bounds, cameras, etc\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#gameSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.gameSize = new Size();\r\n\r\n        /**\r\n         * The Base Size component.\r\n         *\r\n         * The modified game size, which is the auto-rounded gameSize, used to set the canvas width and height\r\n         * (but not the CSS style)\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#baseSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.baseSize = new Size();\r\n\r\n        /**\r\n         * The Display Size component.\r\n         *\r\n         * The size used for the canvas style, factoring in the scale mode, parent and other values.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displaySize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.displaySize = new Size();\r\n\r\n        /**\r\n         * The game scale mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#scaleMode\r\n         * @type {Phaser.Scale.ScaleModeType}\r\n         * @since 3.16.0\r\n         */\r\n        this.scaleMode = CONST.SCALE_MODE.NONE;\r\n\r\n        /**\r\n         * The game zoom factor.\r\n         *\r\n         * This value allows you to multiply your games base size by the given zoom factor.\r\n         * This is then used when calculating the display size, even in `NONE` situations.\r\n         * If you don't want Phaser to touch the canvas style at all, this value should be 1.\r\n         *\r\n         * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based\r\n         * on the game size and available space within the parent.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#zoom\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.zoom = 1;\r\n\r\n        /**\r\n         * Internal flag set when the game zoom factor is modified.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_resetZoom\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this._resetZoom = false;\r\n\r\n        /**\r\n         * The scale factor between the baseSize and the canvasBounds.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displayScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.16.0\r\n         */\r\n        this.displayScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * If set, the canvas sizes will be automatically passed through Math.floor.\r\n         * This results in rounded pixel display values, which is important for performance on legacy\r\n         * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoRound\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoRound = false;\r\n\r\n        /**\r\n         * Automatically center the canvas within the parent? The different centering modes are:\r\n         *\r\n         * 1. No centering.\r\n         * 2. Center both horizontally and vertically.\r\n         * 3. Center horizontally.\r\n         * 4. Center vertically.\r\n         *\r\n         * Please be aware that in order to center the game canvas, you must have specified a parent\r\n         * that has a size set, or the canvas parent is the document.body.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoCenter\r\n         * @type {Phaser.Scale.CenterType}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoCenter = CONST.CENTER.NO_CENTER;\r\n\r\n        /**\r\n         * The current device orientation.\r\n         *\r\n         * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#orientation\r\n         * @type {Phaser.Scale.OrientationType}\r\n         * @since 3.16.0\r\n         */\r\n        this.orientation = CONST.ORIENTATION.LANDSCAPE;\r\n\r\n        /**\r\n         * A reference to the Device.Fullscreen object.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreen\r\n         * @type {Phaser.Device.Fullscreen}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreen;\r\n\r\n        /**\r\n         * The DOM Element which is sent into fullscreen mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreenTarget\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreenTarget = null;\r\n\r\n        /**\r\n         * Did Phaser create the fullscreen target div, or was it provided in the game config?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._createdFullscreenTarget = false;\r\n\r\n        /**\r\n         * The dirty state of the Scale Manager.\r\n         * Set if there is a change between the parent size and the current size.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#dirty\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * How many milliseconds should elapse before checking if the browser size has changed?\r\n         *\r\n         * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.\r\n         * However, older browsers fail to do this, or do it consistently, so we fall back to a\r\n         * more traditional 'size check' based on a time interval. You can control how often it is\r\n         * checked here.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#resizeInterval\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.resizeInterval = 500;\r\n\r\n        /**\r\n         * Internal size interval tracker.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_lastCheck\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._lastCheck = 0;\r\n\r\n        /**\r\n         * Internal flag to check orientation state.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_checkOrientation\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._checkOrientation = false;\r\n\r\n        /**\r\n         * Internal object containing our defined event listeners.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#listeners\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this.listeners = {\r\n\r\n            orientationChange: NOOP,\r\n            windowResize: NOOP,\r\n            fullScreenChange: NOOP,\r\n            fullScreenError: NOOP\r\n\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Called _before_ the canvas object is created and added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#preBoot\r\n     * @protected\r\n     * @listens Phaser.Core.Events#BOOT\r\n     * @since 3.16.0\r\n     */\r\n    preBoot: function ()\r\n    {\r\n        //  Parse the config to get the scaling values we need\r\n        this.parseConfig(this.game.config);\r\n\r\n        this.game.events.once(GameEvents.BOOT, this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now and the canvas has been added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#boot\r\n     * @protected\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.game;\r\n\r\n        this.canvas = game.canvas;\r\n\r\n        this.fullscreen = game.device.fullscreen;\r\n\r\n        if (this.scaleMode !== CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            this.displaySize.setAspectMode(this.scaleMode);\r\n        }\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            this.resize(this.width, this.height);\r\n        }\r\n        else\r\n        {\r\n            this.getParentBounds();\r\n\r\n            //  Only set the parent bounds if the parent has an actual size\r\n            if (this.parentSize.width > 0 && this.parentSize.height > 0)\r\n            {\r\n                this.displaySize.setParent(this.parentSize);\r\n            }\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        game.events.on(GameEvents.PRE_STEP, this.step, this);\r\n        game.events.once(GameEvents.READY, this.refresh, this);\r\n        game.events.once(GameEvents.DESTROY, this.destroy, this);\r\n\r\n        this.startListeners();\r\n    },\r\n\r\n    /**\r\n     * Parses the game configuration to set-up the scale defaults.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#parseConfig\r\n     * @protected\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    parseConfig: function (config)\r\n    {\r\n        //  Get the parent element, if any\r\n        this.getParent(config);\r\n\r\n        //  Get the size of the parent element\r\n        //  This can often set a height of zero (especially for un-styled divs)\r\n        this.getParentBounds();\r\n\r\n        var width = config.width;\r\n        var height = config.height;\r\n        var scaleMode = config.scaleMode;\r\n        var zoom = config.zoom;\r\n        var autoRound = config.autoRound;\r\n\r\n        //  If width = '100%', or similar value\r\n        if (typeof width === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentWidth = this.parentSize.width;\r\n\r\n            if (parentWidth === 0)\r\n            {\r\n                parentWidth = window.innerWidth;\r\n            }\r\n\r\n            var parentScaleX = parseInt(width, 10) / 100;\r\n\r\n            width = Math.floor(parentWidth * parentScaleX);\r\n        }\r\n\r\n        //  If height = '100%', or similar value\r\n        if (typeof height === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentHeight = this.parentSize.height;\r\n\r\n            if (parentHeight === 0)\r\n            {\r\n                parentHeight = window.innerHeight;\r\n            }\r\n\r\n            var parentScaleY = parseInt(height, 10) / 100;\r\n\r\n            height = Math.floor(parentHeight * parentScaleY);\r\n        }\r\n\r\n        this.scaleMode = scaleMode;\r\n\r\n        this.autoRound = autoRound;\r\n\r\n        this.autoCenter = config.autoCenter;\r\n\r\n        this.resizeInterval = config.resizeInterval;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.setSize(width, height);\r\n\r\n        if (zoom === CONST.ZOOM.MAX_ZOOM)\r\n        {\r\n            zoom = this.getMaxZoom();\r\n        }\r\n\r\n        this.zoom = zoom;\r\n\r\n        if (zoom !== 1)\r\n        {\r\n            this._resetZoom = true;\r\n        }\r\n\r\n        //  The modified game size\r\n        this.baseSize.setSize(width, height);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        if (config.minWidth > 0)\r\n        {\r\n            this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);\r\n        }\r\n\r\n        if (config.maxWidth > 0)\r\n        {\r\n            this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize(width, height);\r\n\r\n        this.orientation = GetScreenOrientation(width, height);\r\n    },\r\n\r\n    /**\r\n     * Determines the parent element of the game canvas, if any, based on the game configuration.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParent\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    getParent: function (config)\r\n    {\r\n        var parent = config.parent;\r\n\r\n        if (parent === null)\r\n        {\r\n            //  User is responsible for managing the parent\r\n            return;\r\n        }\r\n\r\n        this.parent = GetTarget(parent);\r\n        this.parentIsWindow = (this.parent === document.body);\r\n\r\n        if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE)\r\n        {\r\n            var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n            if (this.parentIsWindow || DOMRect.height === 0)\r\n            {\r\n                document.documentElement.style.height = '100%';\r\n                document.body.style.height = '100%';\r\n\r\n                DOMRect = this.parent.getBoundingClientRect();\r\n\r\n                //  The parent STILL has no height, clearly no CSS\r\n                //  has been set on it even though we fixed the body :(\r\n                if (!this.parentIsWindow && DOMRect.height === 0)\r\n                {\r\n                    this.parent.style.overflow = 'hidden';\r\n                    this.parent.style.width = '100%';\r\n                    this.parent.style.height = '100%';\r\n                }\r\n            }\r\n        }\r\n\r\n        //  And now get the fullscreenTarget\r\n        if (config.fullscreenTarget && !this.fullscreenTarget)\r\n        {\r\n            this.fullscreenTarget = GetTarget(config.fullscreenTarget);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParentBounds\r\n     * @since 3.16.0\r\n     *\r\n     * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.\r\n     */\r\n    getParentBounds: function ()\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var parentSize = this.parentSize;\r\n\r\n        // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\r\n\r\n        var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n        if (this.parentIsWindow && this.game.device.os.iOS)\r\n        {\r\n            DOMRect.height = GetInnerHeight(true);\r\n        }\r\n\r\n        var newWidth = DOMRect.width;\r\n        var newHeight = DOMRect.height;\r\n\r\n        if (parentSize.width !== newWidth || parentSize.height !== newHeight)\r\n        {\r\n            parentSize.setSize(newWidth, newHeight);\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Attempts to lock the orientation of the web browser using the Screen Orientation API.\r\n     *\r\n     * This API is only available on modern mobile browsers.\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#lockOrientation\r\n     * @since 3.16.0\r\n     *\r\n     * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.\r\n     *\r\n     * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.\r\n     */\r\n    lockOrientation: function (orientation)\r\n    {\r\n        var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;\r\n\r\n        if (lock)\r\n        {\r\n            return lock.call(screen, orientation);\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * This method will set the size of the Parent Size component, which is used in scaling\r\n     * and centering calculations. You only need to call this method if you have explicitly\r\n     * disabled the use of a parent in your game config, but still wish to take advantage of\r\n     * other Scale Manager features.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setParentSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} width - The new width of the parent.\r\n     * @param {number} height - The new height of the parent.\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setParentSize: function (width, height)\r\n    {\r\n        this.parentSize.setSize(width, height);\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * This method will set a new size for your game.\r\n     *\r\n     * It should only be used if you're looking to change the base size of your game and are using\r\n     * one of the Scale Manager scaling modes, i.e. `FIT`. If you're using `NONE` and wish to\r\n     * change the game and canvas size directly, then please use the `resize` method instead.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setGameSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setGameSize: function (width, height)\r\n    {\r\n        var autoRound = this.autoRound;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        var previousWidth = this.width;\r\n        var previousHeight = this.height;\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.resize(width, height);\r\n\r\n        //  The modified game size\r\n        this.baseSize.resize(width, height);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  Update the aspect ratio\r\n        this.displaySize.setAspectRatio(width / height);\r\n\r\n        this.canvas.width = this.baseSize.width;\r\n        this.canvas.height = this.baseSize.height;\r\n\r\n        return this.refresh(previousWidth, previousHeight);\r\n    },\r\n\r\n    /**\r\n     * Call this to modify the size of the Phaser canvas element directly.\r\n     * You should only use this if you are using the `NONE` scale mode,\r\n     * it will update all internal components completely.\r\n     *\r\n     * If all you want to do is change the size of the parent, see the `setParentSize` method.\r\n     *\r\n     * If all you want is to change the base size of the game, but still have the Scale Manager\r\n     * manage all the scaling (i.e. you're **not** using `NONE`), then see the `setGameSize` method.\r\n     *\r\n     * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given\r\n     * dimensions. It will then resize the canvas width and height to the values given, by\r\n     * directly setting the properties. Finally, if you have set the Scale Manager zoom value\r\n     * to anything other than 1 (the default), it will set the canvas CSS width and height to\r\n     * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).\r\n     *\r\n     * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and\r\n     * the margins are set, allowing the canvas to be centered based on its parent element\r\n     * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#resize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        var zoom = this.zoom;\r\n        var autoRound = this.autoRound;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        var previousWidth = this.width;\r\n        var previousHeight = this.height;\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.resize(width, height);\r\n\r\n        //  The modified game size\r\n        this.baseSize.resize(width, height);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize((width * zoom), (height * zoom));\r\n\r\n        this.canvas.width = this.baseSize.width;\r\n        this.canvas.height = this.baseSize.height;\r\n\r\n        var style = this.canvas.style;\r\n\r\n        var styleWidth = width * zoom;\r\n        var styleHeight = height * zoom;\r\n\r\n        if (autoRound)\r\n        {\r\n            styleWidth = Math.floor(styleWidth);\r\n            styleHeight = Math.floor(styleHeight);\r\n        }\r\n\r\n        if (styleWidth !== width || styleHeight !== height)\r\n        {\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        return this.refresh(previousWidth, previousHeight);\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom value of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} value - The new zoom value of the game.\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setZoom: function (value)\r\n    {\r\n        this.zoom = value;\r\n        this._resetZoom = true;\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom to be the maximum possible based on the _current_ parent size.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setMaxZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setMaxZoom: function ()\r\n    {\r\n        this.zoom = this.getMaxZoom();\r\n        this._resetZoom = true;\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Refreshes the internal scale values, bounds sizes and orientation checks.\r\n     *\r\n     * Once finished, dispatches the resize event.\r\n     *\r\n     * This is called automatically by the Scale Manager when the browser window size changes,\r\n     * as long as it is using a Scale Mode other than 'NONE'.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#refresh\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} [previousWidth] - The previous width of the game. Only set if the gameSize has changed.\r\n     * @param {number} [previousHeight] - The previous height of the game. Only set if the gameSize has changed.\r\n     *\r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    refresh: function (previousWidth, previousHeight)\r\n    {\r\n        if (previousWidth === undefined) { previousWidth = this.width; }\r\n        if (previousHeight === undefined) { previousHeight = this.height; }\r\n\r\n        this.updateScale();\r\n        this.updateBounds();\r\n        this.updateOrientation();\r\n\r\n        this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);\r\n\r\n        var domContainer = this.game.domContainer;\r\n\r\n        if (domContainer)\r\n        {\r\n            this.baseSize.setCSS(domContainer);\r\n\r\n            var canvasStyle = this.canvas.style;\r\n            var domStyle = domContainer.style;\r\n\r\n            domStyle.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')';\r\n\r\n            domStyle.marginLeft = canvasStyle.marginLeft;\r\n            domStyle.marginTop = canvasStyle.marginTop;\r\n        }\r\n\r\n        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, previousWidth, previousHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that checks the current screen orientation, only if the internal check flag is set.\r\n     *\r\n     * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateOrientation\r\n     * @fires Phaser.Scale.Events#ORIENTATION_CHANGE\r\n     * @since 3.16.0\r\n     */\r\n    updateOrientation: function ()\r\n    {\r\n        if (this._checkOrientation)\r\n        {\r\n            this._checkOrientation = false;\r\n\r\n            var newOrientation = GetScreenOrientation(this.width, this.height);\r\n\r\n            if (newOrientation !== this.orientation)\r\n            {\r\n                this.orientation = newOrientation;\r\n\r\n                this.emit(Events.ORIENTATION_CHANGE, newOrientation);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that manages updating the size components based on the scale mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateScale\r\n     * @since 3.16.0\r\n     */\r\n    updateScale: function ()\r\n    {\r\n        var style = this.canvas.style;\r\n\r\n        var width = this.gameSize.width;\r\n        var height = this.gameSize.height;\r\n\r\n        var styleWidth;\r\n        var styleHeight;\r\n\r\n        var zoom = this.zoom;\r\n        var autoRound = this.autoRound;\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            //  No scale\r\n            this.displaySize.setSize((width * zoom), (height * zoom));\r\n\r\n            styleWidth = this.displaySize.width;\r\n            styleHeight = this.displaySize.height;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            if (this._resetZoom)\r\n            {\r\n                style.width = styleWidth + 'px';\r\n                style.height = styleHeight + 'px';\r\n\r\n                this._resetZoom = false;\r\n            }\r\n        }\r\n        else if (this.scaleMode === CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            //  Resize to match parent\r\n\r\n            //  This will constrain using min/max\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            this.gameSize.setSize(this.displaySize.width, this.displaySize.height);\r\n\r\n            this.baseSize.setSize(this.displaySize.width, this.displaySize.height);\r\n\r\n            styleWidth = this.displaySize.width;\r\n            styleHeight = this.displaySize.height;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            this.canvas.width = styleWidth;\r\n            this.canvas.height = styleHeight;\r\n        }\r\n        else\r\n        {\r\n            //  All other scale modes\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            styleWidth = this.displaySize.width;\r\n            styleHeight = this.displaySize.height;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        //  Update the parentSize in case the canvas / style change modified it\r\n        this.getParentBounds();\r\n\r\n        //  Finally, update the centering\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Calculates and returns the largest possible zoom factor, based on the current\r\n     * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),\r\n     * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getMaxZoom\r\n     * @since 3.16.0\r\n     *\r\n     * @return {number} The maximum possible zoom factor. At a minimum this value is always at least 1.\r\n     */\r\n    getMaxZoom: function ()\r\n    {\r\n        var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);\r\n        var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);\r\n\r\n        return Math.max(Math.min(zoomH, zoomV), 1);\r\n    },\r\n\r\n    /**\r\n     * Calculates and updates the canvas CSS style in order to center it within the\r\n     * bounds of its parent. If you have explicitly set parent to be `null` in your\r\n     * game config then this method will likely give incorrect results unless you have called the\r\n     * `setParentSize` method first.\r\n     *\r\n     * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.\r\n     *\r\n     * If they have already been set by your own style sheet, or code, this will overwrite them.\r\n     *\r\n     * To prevent the Scale Manager from centering the canvas, either do not set the\r\n     * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateCenter\r\n     * @since 3.16.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        var autoCenter = this.autoCenter;\r\n\r\n        if (autoCenter === CONST.CENTER.NO_CENTER)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var canvas = this.canvas;\r\n\r\n        var style = canvas.style;\r\n\r\n        var bounds = canvas.getBoundingClientRect();\r\n\r\n        // var width = parseInt(canvas.style.width, 10) || canvas.width;\r\n        // var height = parseInt(canvas.style.height, 10) || canvas.height;\r\n\r\n        var width = bounds.width;\r\n        var height = bounds.height;\r\n\r\n        var offsetX = Math.floor((this.parentSize.width - width) / 2);\r\n        var offsetY = Math.floor((this.parentSize.height - height) / 2);\r\n\r\n        if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY)\r\n        {\r\n            offsetY = 0;\r\n        }\r\n        else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY)\r\n        {\r\n            offsetX = 0;\r\n        }\r\n\r\n        style.marginLeft = offsetX + 'px';\r\n        style.marginTop = offsetY + 'px';\r\n    },\r\n\r\n    /**\r\n     * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the\r\n     * canvas element being used to track input events.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateBounds\r\n     * @since 3.16.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var bounds = this.canvasBounds;\r\n        var clientRect = this.canvas.getBoundingClientRect();\r\n\r\n        bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);\r\n        bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);\r\n        bounds.width = clientRect.width;\r\n        bounds.height = clientRect.height;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformX\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageX - The DOM pageX value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformX: function (pageX)\r\n    {\r\n        return (pageX - this.canvasBounds.left) * this.displayScale.x;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageY value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformY\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageY - The DOM pageY value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformY: function (pageY)\r\n    {\r\n        return (pageY - this.canvasBounds.top) * this.displayScale.y;\r\n    },\r\n\r\n    /**\r\n     * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.\r\n     *\r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     *\r\n     * This method _must_ be called from a `pointerup` user-input gesture (**not** `pointerdown`). You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     *\r\n     * On touch devices, such as Android and iOS Safari, you should always use `pointerup` and NOT `pointerdown`,\r\n     * otherwise the request will fail unless the document in which your game is embedded has already received\r\n     * some form of touch input, which you cannot guarantee. Activating fullscreen via `pointerup` circumvents\r\n     * this issue.\r\n     *\r\n     * Performing an action that navigates to another page, or opens another tab, will automatically cancel\r\n     * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode directly from your game,\r\n     * i.e. by clicking an icon, call the `stopFullscreen` method.\r\n     *\r\n     * A browser can only send one DOM element into fullscreen. You can control which element this is by\r\n     * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.\r\n     * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will\r\n     * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.\r\n     * When it leaves fullscreen, the div will be removed.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    startFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (fullscreenOptions === undefined) { fullscreenOptions = { navigationUI: 'hide' }; }\r\n\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return;\r\n        }\r\n\r\n        if (!fullscreen.active)\r\n        {\r\n            var fsTarget = this.getFullscreenTarget();\r\n\r\n            if (fullscreen.keyboard)\r\n            {\r\n                fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);\r\n            }\r\n            else\r\n            {\r\n                fsTarget[fullscreen.request](fullscreenOptions);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The browser has successfully entered fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenSuccessHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     */\r\n    fullscreenSuccessHandler: function ()\r\n    {\r\n        this.getParentBounds();\r\n\r\n        this.refresh();\r\n\r\n        this.emit(Events.ENTER_FULLSCREEN);\r\n    },\r\n\r\n    /**\r\n     * The browser failed to enter fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenErrorHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     *\r\n     * @param {any} error - The DOM error event.\r\n     */\r\n    fullscreenErrorHandler: function (error)\r\n    {\r\n        this.removeFullscreenTarget();\r\n\r\n        this.emit(Events.FULLSCREEN_FAILED, error);\r\n    },\r\n\r\n    /**\r\n     * An internal method that gets the target element that is used when entering fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getFullscreenTarget\r\n     * @since 3.16.0\r\n     *\r\n     * @return {object} The fullscreen target element.\r\n     */\r\n    getFullscreenTarget: function ()\r\n    {\r\n        if (!this.fullscreenTarget)\r\n        {\r\n            var fsTarget = document.createElement('div');\r\n\r\n            fsTarget.style.margin = '0';\r\n            fsTarget.style.padding = '0';\r\n            fsTarget.style.width = '100%';\r\n            fsTarget.style.height = '100%';\r\n\r\n            this.fullscreenTarget = fsTarget;\r\n\r\n            this._createdFullscreenTarget = true;\r\n        }\r\n\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var canvasParent = this.canvas.parentNode;\r\n\r\n            canvasParent.insertBefore(this.fullscreenTarget, this.canvas);\r\n\r\n            this.fullscreenTarget.appendChild(this.canvas);\r\n        }\r\n\r\n        return this.fullscreenTarget;\r\n    },\r\n\r\n    /**\r\n     * Removes the fullscreen target that was added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#removeFullscreenTarget\r\n     * @since 3.17.0\r\n     */\r\n    removeFullscreenTarget: function ()\r\n    {\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var fsTarget = this.fullscreenTarget;\r\n\r\n            if (fsTarget && fsTarget.parentNode)\r\n            {\r\n                var parent = fsTarget.parentNode;\r\n\r\n                parent.insertBefore(this.canvas, fsTarget);\r\n\r\n                parent.removeChild(fsTarget);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calling this method will cancel fullscreen mode, if the browser has entered it.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopFullscreen\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @since 3.16.0\r\n     */\r\n    stopFullscreen: function ()\r\n    {\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return false;\r\n        }\r\n\r\n        if (fullscreen.active)\r\n        {\r\n            document[fullscreen.cancel]();\r\n        }\r\n\r\n        this.removeFullscreenTarget();\r\n\r\n        //  Get the parent size again as it will have changed\r\n        this.getParentBounds();\r\n\r\n        this.emit(Events.LEAVE_FULLSCREEN);\r\n\r\n        this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.\r\n     * If not in fullscreen, this will request the browser to enter fullscreen mode.\r\n     *\r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     *\r\n     * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#toggleFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     *\r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    toggleFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (this.fullscreen.active)\r\n        {\r\n            this.stopFullscreen();\r\n        }\r\n        else\r\n        {\r\n            this.startFullscreen(fullscreenOptions);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that starts the different DOM event listeners running.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startListeners\r\n     * @since 3.16.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var listeners = this.listeners;\r\n\r\n        listeners.orientationChange = function ()\r\n        {\r\n            _this.updateBounds();\r\n\r\n            _this._checkOrientation = true;\r\n            _this.dirty = true;\r\n        };\r\n\r\n        listeners.windowResize = function ()\r\n        {\r\n            _this.updateBounds();\r\n\r\n            _this.dirty = true;\r\n        };\r\n\r\n        //  Only dispatched on mobile devices\r\n        window.addEventListener('orientationchange', listeners.orientationChange, false);\r\n\r\n        window.addEventListener('resize', listeners.windowResize, false);\r\n\r\n        if (this.fullscreen.available)\r\n        {\r\n            listeners.fullScreenChange = function (event)\r\n            {\r\n                return _this.onFullScreenChange(event);\r\n            };\r\n\r\n            listeners.fullScreenError = function (event)\r\n            {\r\n                return _this.onFullScreenError(event);\r\n            };\r\n\r\n            var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n            vendors.forEach(function (prefix)\r\n            {\r\n                document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n                document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n            });\r\n\r\n            //  MS Specific\r\n            document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n            document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenchange event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenChange\r\n     * @protected\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenChange: function ()\r\n    {\r\n        if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement)\r\n        {\r\n            this.fullscreenSuccessHandler();\r\n        }\r\n        else\r\n        {\r\n            //  They pressed ESC while in fullscreen mode\r\n            this.stopFullscreen();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenerror event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenError\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenError: function ()\r\n    {\r\n        this.removeFullscreenTarget();\r\n    },\r\n\r\n    /**\r\n     * Internal method, called automatically by the game step.\r\n     * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#step\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck += delta;\r\n\r\n        if (this.dirty || this._lastCheck > this.resizeInterval)\r\n        {\r\n            //  Returns true if the parent bounds have changed size\r\n            if (this.getParentBounds())\r\n            {\r\n                this.refresh();\r\n            }\r\n\r\n            this.dirty = false;\r\n            this._lastCheck = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops all DOM event listeners.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopListeners\r\n     * @since 3.16.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        var listeners = this.listeners;\r\n\r\n        window.removeEventListener('orientationchange', listeners.orientationChange, false);\r\n        window.removeEventListener('resize', listeners.windowResize, false);\r\n\r\n        var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n        vendors.forEach(function (prefix)\r\n        {\r\n            document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n            document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n        });\r\n\r\n        //  MS Specific\r\n        document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n        document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n    },\r\n\r\n    /**\r\n     * Destroys this Scale Manager, releasing all references to external resources.\r\n     * Once destroyed, the Scale Manager cannot be used again.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.stopListeners();\r\n\r\n        this.game = null;\r\n        this.canvas = null;\r\n        this.canvasBounds = null;\r\n        this.parent = null;\r\n        this.fullscreenTarget = null;\r\n\r\n        this.parentSize.destroy();\r\n        this.gameSize.destroy();\r\n        this.baseSize.destroy();\r\n        this.displaySize.destroy();\r\n    },\r\n\r\n    /**\r\n     * Is the browser currently in fullscreen mode or not?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isFullscreen\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isFullscreen: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.fullscreen.active;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The game width.\r\n     *\r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The game height.\r\n     *\r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the device in a portrait orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isPortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isPortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.PORTRAIT);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the device in a landscape orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.LANDSCAPE);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions portrait? (i.e. taller than they are wide)\r\n     *\r\n     * This is different to the device itself being in a portrait orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGamePortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGamePortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.height > this.width);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions landscape? (i.e. wider than they are tall)\r\n     *\r\n     * This is different to the device itself being in a landscape orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGameLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGameLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.width > this.height);\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScaleManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for centering the game canvas.\r\n * \r\n * @namespace Phaser.Scale.Center\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for centering the game canvas.\r\n * \r\n * To find out what each mode does please see [Phaser.Scale.Center]{@link Phaser.Scale.Center}.\r\n * \r\n * @typedef {Phaser.Scale.Center} Phaser.Scale.CenterType\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * The game canvas is not centered within the parent by Phaser.\r\n     * You can still center it yourself via CSS.\r\n     * \r\n     * @name Phaser.Scale.Center.NO_CENTER\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    NO_CENTER: 0,\r\n\r\n    /**\r\n     * The game canvas is centered both horizontally and vertically within the parent.\r\n     * To do this, the parent has to have a bounds that can be calculated and not be empty.\r\n     * \r\n     * Centering is achieved by setting the margin left and top properties of the\r\n     * game canvas, and does not factor in any other CSS styles you may have applied.\r\n     * \r\n     * @name Phaser.Scale.Center.CENTER_BOTH\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    CENTER_BOTH: 1,\r\n\r\n    /**\r\n     * The game canvas is centered horizontally within the parent.\r\n     * To do this, the parent has to have a bounds that can be calculated and not be empty.\r\n     * \r\n     * Centering is achieved by setting the margin left and top properties of the\r\n     * game canvas, and does not factor in any other CSS styles you may have applied.\r\n     * \r\n     * @name Phaser.Scale.Center.CENTER_HORIZONTALLY\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    CENTER_HORIZONTALLY: 2,\r\n\r\n    /**\r\n     * The game canvas is centered both vertically within the parent.\r\n     * To do this, the parent has to have a bounds that can be calculated and not be empty.\r\n     * \r\n     * Centering is achieved by setting the margin left and top properties of the\r\n     * game canvas, and does not factor in any other CSS styles you may have applied.\r\n     * \r\n     * @name Phaser.Scale.Center.CENTER_VERTICALLY\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    CENTER_VERTICALLY: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for orientation.\r\n * \r\n * @namespace Phaser.Scale.Orientation\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for orientation.\r\n * \r\n * To find out what each mode does please see [Phaser.Scale.Orientation]{@link Phaser.Scale.Orientation}.\r\n * \r\n * @typedef {Phaser.Scale.Orientation} Phaser.Scale.OrientationType\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * A landscape orientation.\r\n     * \r\n     * @name Phaser.Scale.Orientation.LANDSCAPE\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    LANDSCAPE: 'landscape-primary',\r\n\r\n    /**\r\n     * A portrait orientation.\r\n     * \r\n     * @name Phaser.Scale.Orientation.PORTRAIT\r\n     * @type {string}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    PORTRAIT: 'portrait-primary'\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for the different scale modes available.\r\n * \r\n * @namespace Phaser.Scale.ScaleModes\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for the different scale modes available.\r\n * \r\n * To find out what each mode does please see [Phaser.Scale.ScaleModes]{@link Phaser.Scale.ScaleModes}.\r\n * \r\n * @typedef {Phaser.Scale.ScaleModes} Phaser.Scale.ScaleModeType\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * No scaling happens at all. The canvas is set to the size given in the game config and Phaser doesn't change it\r\n     * again from that point on. If you change the canvas size, either via CSS, or directly via code, then you need\r\n     * to call the Scale Managers `resize` method to give the new dimensions, or input events will stop working.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.NONE\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    NONE: 0,\r\n\r\n    /**\r\n     * The height is automatically adjusted based on the width.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.WIDTH_CONTROLS_HEIGHT\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    WIDTH_CONTROLS_HEIGHT: 1,\r\n\r\n    /**\r\n     * The width is automatically adjusted based on the height.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.HEIGHT_CONTROLS_WIDTH\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    HEIGHT_CONTROLS_WIDTH: 2,\r\n\r\n    /**\r\n     * The width and height are automatically adjusted to fit inside the given target area,\r\n     * while keeping the aspect ratio. Depending on the aspect ratio there may be some space\r\n     * inside the area which is not covered.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.FIT\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    FIT: 3,\r\n\r\n    /**\r\n     * The width and height are automatically adjusted to make the size cover the entire target\r\n     * area while keeping the aspect ratio. This may extend further out than the target size.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.ENVELOP\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    ENVELOP: 4,\r\n\r\n    /**\r\n     * The Canvas is resized to fit all available _parent_ space, regardless of aspect ratio.\r\n     * \r\n     * @name Phaser.Scale.ScaleModes.RESIZE\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    RESIZE: 5\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for zoom modes.\r\n * \r\n * @namespace Phaser.Scale.Zoom\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\n/**\r\n * Phaser Scale Manager constants for zoom modes.\r\n * \r\n * To find out what each mode does please see [Phaser.Scale.Zoom]{@link Phaser.Scale.Zoom}.\r\n * \r\n * @typedef {Phaser.Scale.Zoom} Phaser.Scale.ZoomType\r\n * @memberof Phaser.Scale\r\n * @since 3.16.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * The game canvas will not be zoomed by Phaser.\r\n     * \r\n     * @name Phaser.Scale.Zoom.NO_ZOOM\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    NO_ZOOM: 1,\r\n\r\n    /**\r\n     * The game canvas will be 2x zoomed by Phaser.\r\n     * \r\n     * @name Phaser.Scale.Zoom.ZOOM_2X\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    ZOOM_2X: 2,\r\n\r\n    /**\r\n     * The game canvas will be 4x zoomed by Phaser.\r\n     * \r\n     * @name Phaser.Scale.Zoom.ZOOM_4X\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    ZOOM_4X: 4,\r\n\r\n    /**\r\n     * Calculate the zoom value based on the maximum multiplied game size that will\r\n     * fit into the parent, or browser window if no parent is set.\r\n     * \r\n     * @name Phaser.Scale.Zoom.MAX_ZOOM\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.16.0\r\n     */\r\n    MAX_ZOOM: -1\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = {\r\n\r\n    CENTER: require('./CENTER_CONST'),\r\n    ORIENTATION: require('./ORIENTATION_CONST'),\r\n    SCALE_MODE: require('./SCALE_MODE_CONST'),\r\n    ZOOM: require('./ZOOM_CONST')\r\n\r\n};\r\n\r\nmodule.exports = CONST;\r\n"],"names":["module","exports","iOS","window","innerHeight","axis","Math","abs","orientation","size","w","h","ruler","document","createElement","setAttribute","documentElement","appendChild","offsetHeight","innerWidth","removeChild","CONST","width","height","screen","mozOrientation","msOrientation","type","ORIENTATION","PORTRAIT","LANDSCAPE","matchMedia","matches","element","target","getElementById","nodeType","body","Class","EventEmitter","Events","GameEvents","GetInnerHeight","GetTarget","GetScreenOrientation","NOOP","Rectangle","Size","SnapFloor","Vector2","ScaleManager","Extends","initialize","game","call","this","canvas","canvasBounds","parent","parentIsWindow","parentSize","gameSize","baseSize","displaySize","scaleMode","SCALE_MODE","NONE","zoom","_resetZoom","displayScale","autoRound","autoCenter","CENTER","NO_CENTER","fullscreen","fullscreenTarget","_createdFullscreenTarget","dirty","resizeInterval","_lastCheck","_checkOrientation","listeners","orientationChange","windowResize","fullScreenChange","fullScreenError","preBoot","parseConfig","config","events","once","BOOT","boot","device","RESIZE","setAspectMode","resize","getParentBounds","setParent","refresh","on","PRE_STEP","step","READY","DESTROY","destroy","startListeners","getParent","parentWidth","parentScaleX","parseInt","floor","parentHeight","parentScaleY","setSize","ZOOM","MAX_ZOOM","getMaxZoom","minWidth","setMin","minHeight","maxWidth","setMax","maxHeight","expandParent","DOMRect","getBoundingClientRect","style","overflow","os","newWidth","newHeight","lockOrientation","lock","mozLockOrientation","msLockOrientation","setParentSize","setGameSize","previousWidth","previousHeight","setAspectRatio","styleWidth","styleHeight","setZoom","value","setMaxZoom","undefined","updateScale","updateBounds","updateOrientation","set","domContainer","setCSS","canvasStyle","domStyle","transform","marginLeft","marginTop","emit","newOrientation","ORIENTATION_CHANGE","updateCenter","zoomH","zoomV","max","min","bounds","offsetX","offsetY","CENTER_HORIZONTALLY","CENTER_VERTICALLY","clientRect","x","left","pageXOffset","clientLeft","y","top","pageYOffset","clientTop","transformX","pageX","transformY","pageY","startFullscreen","fullscreenOptions","navigationUI","available","active","fsTarget","getFullscreenTarget","keyboard","request","Element","ALLOW_KEYBOARD_INPUT","FULLSCREEN_UNSUPPORTED","fullscreenSuccessHandler","ENTER_FULLSCREEN","fullscreenErrorHandler","error","removeFullscreenTarget","FULLSCREEN_FAILED","margin","padding","parentNode","insertBefore","stopFullscreen","cancel","LEAVE_FULLSCREEN","toggleFullscreen","_this","addEventListener","event","onFullScreenChange","onFullScreenError","forEach","prefix","fullscreenElement","webkitFullscreenElement","msFullscreenElement","mozFullScreenElement","time","delta","stopListeners","removeEventListener","removeAllListeners","isFullscreen","get","isPortrait","isLandscape","isGamePortrait","isGameLandscape","CENTER_BOTH","WIDTH_CONTROLS_HEIGHT","HEIGHT_CONTROLS_WIDTH","FIT","ENVELOP","NO_ZOOM","ZOOM_2X","ZOOM_4X"],"sourceRoot":""}