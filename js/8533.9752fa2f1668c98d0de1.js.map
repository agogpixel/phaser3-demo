{"version":3,"file":"js/8533.9752fa2f1668c98d0de1.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Average.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Bernstein.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Between.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/CatmullRom.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/CeilTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Difference.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Euler.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Factorial.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FloatBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FloorTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FromPercent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/GetSpeed.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/IsEven.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/IsEvenStrict.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Linear.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/MaxAdd.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Median.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/MinSub.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Percent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RadToDeg.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RandomXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Rotate.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RotateAroundDistance.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RotateTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RoundAwayFromZero.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RoundTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SinCosTableGenerator.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SmoothStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SmootherStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/ToXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Within.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Between.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/BetweenPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/BetweenPointsY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/BetweenY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/CounterClockwise.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Normalize.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Random.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/RandomDegrees.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Reverse.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/RotateTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/ShortestBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetweenPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetweenPointsSquared.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceChebyshev.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistancePower.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceSnake.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceSquared.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/easing/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/Ceil.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/Floor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/GreaterThan.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/LessThan.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/BezierInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/CatmullRomInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/CubicBezierInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/LinearInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/QuadraticBezierInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/SmoothStepInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/SmootherStepInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/pow2/GetPowerOfTwo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/pow2/IsSizePowerOfTwo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/pow2/IsValuePowerOfTwo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/pow2/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/random-data-generator/RandomDataGenerator.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/SnapCeil.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/SnapFloor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/SnapTo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the mean average of the given values.\r\n *\r\n * @function Phaser.Math.Average\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} values - The values to average.\r\n *\r\n * @return {number} The average value.\r\n */\r\nvar Average = function (values)\r\n{\r\n    var sum = 0;\r\n\r\n    for (var i = 0; i < values.length; i++)\r\n    {\r\n        sum += (+values[i]);\r\n    }\r\n\r\n    return sum / values.length;\r\n};\r\n\r\nmodule.exports = Average;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Factorial = require('./Factorial');\r\n\r\n/**\r\n * Calculates the Bernstein basis from the three factorial coefficients.\r\n *\r\n * @function Phaser.Math.Bernstein\r\n * @since 3.0.0\r\n *\r\n * @param {number} n - The first value.\r\n * @param {number} i - The second value.\r\n *\r\n * @return {number} The Bernstein basis of Factorial(n) / Factorial(i) / Factorial(n - i)\r\n */\r\nvar Bernstein = function (n, i)\r\n{\r\n    return Factorial(n) / Factorial(i) / Factorial(n - i);\r\n};\r\n\r\nmodule.exports = Bernstein;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random integer between the `min` and `max` values, inclusive.\r\n *\r\n * @function Phaser.Math.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The random integer.\r\n */\r\nvar Between = function (min, max)\r\n{\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a Catmull-Rom value from the given points, based on an alpha of 0.5.\r\n *\r\n * @function Phaser.Math.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The amount to interpolate by.\r\n * @param {number} p0 - The first control point.\r\n * @param {number} p1 - The second control point.\r\n * @param {number} p2 - The third control point.\r\n * @param {number} p3 - The fourth control point.\r\n *\r\n * @return {number} The Catmull-Rom value.\r\n */\r\nvar CatmullRom = function (t, p0, p1, p2, p3)\r\n{\r\n    var v0 = (p2 - p0) * 0.5;\r\n    var v1 = (p3 - p1) * 0.5;\r\n    var t2 = t * t;\r\n    var t3 = t * t2;\r\n\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n};\r\n\r\nmodule.exports = CatmullRom;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Ceils to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.CeilTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {number} [place=0] - The place to round to.\r\n * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar CeilTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.ceil(value * p) / p;\r\n};\r\n\r\nmodule.exports = CeilTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the positive difference of two given numbers.\r\n *\r\n * @function Phaser.Math.Difference\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first number in the calculation.\r\n * @param {number} b - The second number in the calculation.\r\n *\r\n * @return {number} The positive difference of the two given numbers.\r\n */\r\nvar Difference = function (a, b)\r\n{\r\n    return Math.abs(a - b);\r\n};\r\n\r\nmodule.exports = Difference;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\nvar Class = require('../utils/Class');\r\nvar Matrix4 = require('./Matrix4');\r\nvar NOOP = require('../utils/NOOP');\r\n\r\nvar tempMatrix = new Matrix4();\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * @class Euler\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {number} [x] - The x component.\r\n * @param {number} [y] - The y component.\r\n * @param {number} [z] - The z component.\r\n */\r\nvar Euler = new Class({\r\n\r\n    initialize:\r\n\r\n    function Euler (x, y, z, order)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (z === undefined) { z = 0; }\r\n        if (order === undefined) { order = Euler.DefaultOrder; }\r\n\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._order = order;\r\n\r\n        this.onChangeCallback = NOOP;\r\n    },\r\n\r\n    x: {\r\n        get: function ()\r\n        {\r\n            return this._x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._x = value;\r\n\r\n            this.onChangeCallback(this);\r\n        }\r\n    },\r\n\r\n    y: {\r\n        get: function ()\r\n        {\r\n            return this._y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._y = value;\r\n\r\n            this.onChangeCallback(this);\r\n        }\r\n    },\r\n\r\n    z: {\r\n        get: function ()\r\n        {\r\n            return this._z;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._z = value;\r\n\r\n            this.onChangeCallback(this);\r\n        }\r\n    },\r\n\r\n    order: {\r\n        get: function ()\r\n        {\r\n            return this._order;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._order = value;\r\n\r\n            this.onChangeCallback(this);\r\n        }\r\n    },\r\n\r\n    set: function (x, y, z, order)\r\n    {\r\n        if (order === undefined) { order = this._order; }\r\n\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._order = order;\r\n\r\n        this.onChangeCallback(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    copy: function (euler)\r\n    {\r\n        return this.set(euler.x, euler.y, euler.z, euler.order);\r\n    },\r\n\r\n    setFromQuaternion: function (quaternion, order, update)\r\n    {\r\n        if (order === undefined) { order = this._order; }\r\n        if (update === undefined) { update = false; }\r\n\r\n        tempMatrix.fromQuat(quaternion);\r\n\r\n        return this.setFromRotationMatrix(tempMatrix, order, update);\r\n    },\r\n\r\n    setFromRotationMatrix: function (matrix, order, update)\r\n    {\r\n        if (order === undefined) { order = this._order; }\r\n        if (update === undefined) { update = false; }\r\n\r\n        var elements = matrix.val;\r\n\r\n        //  Upper 3x3 of matrix is un-scaled rotation matrix\r\n        var m11 = elements[0];\r\n        var m12 = elements[4];\r\n        var m13 = elements[8];\r\n        var m21 = elements[1];\r\n        var m22 = elements[5];\r\n        var m23 = elements[9];\r\n        var m31 = elements[2];\r\n        var m32 = elements[6];\r\n        var m33 = elements[10];\r\n\r\n        var x = 0;\r\n        var y = 0;\r\n        var z = 0;\r\n        var epsilon = 0.99999;\r\n\r\n        switch (order)\r\n        {\r\n            case 'XYZ':\r\n            {\r\n                y = Math.asin(Clamp(m13, -1, 1));\r\n\r\n                if (Math.abs(m13) < epsilon)\r\n                {\r\n                    x = Math.atan2(-m23, m33);\r\n                    z = Math.atan2(-m12, m11);\r\n                }\r\n                else\r\n                {\r\n                    x = Math.atan2(m32, m22);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case 'YXZ':\r\n            {\r\n                x = Math.asin(-Clamp(m23, -1, 1));\r\n\r\n                if (Math.abs(m23) < epsilon)\r\n                {\r\n                    y = Math.atan2(m13, m33);\r\n                    z = Math.atan2(m21, m22);\r\n                }\r\n                else\r\n                {\r\n                    y = Math.atan2(-m31, m11);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case 'ZXY':\r\n            {\r\n                x = Math.asin(Clamp(m32, -1, 1));\r\n\r\n                if (Math.abs(m32) < epsilon)\r\n                {\r\n                    y = Math.atan2(-m31, m33);\r\n                    z = Math.atan2(-m12, m22);\r\n                }\r\n                else\r\n                {\r\n                    z = Math.atan2(m21, m11);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case 'ZYX':\r\n            {\r\n                y = Math.asin(-Clamp(m31, -1, 1));\r\n\r\n                if (Math.abs(m31) < epsilon)\r\n                {\r\n                    x = Math.atan2(m32, m33);\r\n                    z = Math.atan2(m21, m11);\r\n                }\r\n                else\r\n                {\r\n                    z = Math.atan2(-m12, m22);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case 'YZX':\r\n            {\r\n                z = Math.asin(Clamp(m21, -1, 1));\r\n\r\n                if (Math.abs(m21) < epsilon)\r\n                {\r\n                    x = Math.atan2(-m23, m22);\r\n                    y = Math.atan2(-m31, m11);\r\n                }\r\n                else\r\n                {\r\n                    y = Math.atan2(m13, m33);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case 'XZY':\r\n            {\r\n                z = Math.asin(-Clamp(m12, -1, 1));\r\n\r\n                if (Math.abs(m12) < epsilon)\r\n                {\r\n                    x = Math.atan2(m32, m22);\r\n                    y = Math.atan2(m13, m11);\r\n                }\r\n                else\r\n                {\r\n                    x = Math.atan2(-m23, m33);\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._x = x;\r\n        this._y = y;\r\n        this._z = z;\r\n        this._order = order;\r\n\r\n        if (update)\r\n        {\r\n            this.onChangeCallback(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nEuler.RotationOrders = [ 'XYZ', 'YXZ', 'ZXY', 'ZYX', 'YZX', 'XZY' ];\r\n\r\nEuler.DefaultOrder = 'XYZ';\r\n\r\nmodule.exports = Euler;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates the factorial of a given number for integer values greater than 0.\r\n *\r\n * @function Phaser.Math.Factorial\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - A positive integer to calculate the factorial of.\r\n *\r\n * @return {number} The factorial of the given number.\r\n */\r\nvar Factorial = function (value)\r\n{\r\n    if (value === 0)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    var res = value;\r\n\r\n    while (--value)\r\n    {\r\n        res *= value;\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\nmodule.exports = Factorial;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a random floating point number between the two given bounds, minimum inclusive, maximum exclusive.\r\n *\r\n * @function Phaser.Math.FloatBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} min - The lower bound for the float, inclusive.\r\n * @param {number} max - The upper bound for the float exclusive.\r\n *\r\n * @return {number} A random float within the given range.\r\n */\r\nvar FloatBetween = function (min, max)\r\n{\r\n    return Math.random() * (max - min) + min;\r\n};\r\n\r\nmodule.exports = FloatBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Floors to some place comparative to a `base`, default is 10 for decimal place.\r\n *\r\n * The `place` is represented by the power applied to `base` to get that place.\r\n *\r\n * @function Phaser.Math.FloorTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {number} [place=0] - The place to round to.\r\n * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar FloorTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.floor(value * p) / p;\r\n};\r\n\r\nmodule.exports = FloorTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent + min;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a per-ms speed from a distance and time (given in seconds).\r\n *\r\n * @function Phaser.Math.GetSpeed\r\n * @since 3.0.0\r\n *\r\n * @param {number} distance - The distance.\r\n * @param {number} time - The time, in seconds.\r\n *\r\n * @return {number} The speed, in distance per ms.\r\n *\r\n * @example\r\n * // 400px over 1 second is 0.4 px/ms\r\n * Phaser.Math.GetSpeed(400, 1) // -> 0.4\r\n */\r\nvar GetSpeed = function (distance, time)\r\n{\r\n    return (distance / time) / 1000;\r\n};\r\n\r\nmodule.exports = GetSpeed;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number.\r\n *\r\n * @function Phaser.Math.IsEven\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEven = function (value)\r\n{\r\n    // Use abstract equality == for \"is number\" test\r\n\r\n    // eslint-disable-next-line eqeqeq\r\n    return (value == parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEven;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check if a given value is an even number using a strict type check.\r\n *\r\n * @function Phaser.Math.IsEvenStrict\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to perform the check with.\r\n *\r\n * @return {boolean} Whether the number is even or not.\r\n */\r\nvar IsEvenStrict = function (value)\r\n{\r\n    // Use strict equality === for \"is number\" test\r\n    return (value === parseFloat(value)) ? !(value % 2) : void 0;\r\n};\r\n\r\nmodule.exports = IsEvenStrict;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculates a linear (interpolation) value over t.\r\n *\r\n * @function Phaser.Math.Linear\r\n * @since 3.0.0\r\n *\r\n * @param {number} p0 - The first point.\r\n * @param {number} p1 - The second point.\r\n * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.\r\n *\r\n * @return {number} The step t% of the way between p0 and p1.\r\n */\r\nvar Linear = function (p0, p1, t)\r\n{\r\n    return (p1 - p0) * t + p0;\r\n};\r\n\r\nmodule.exports = Linear;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Add an `amount` to a `value`, limiting the maximum result to `max`.\r\n *\r\n * @function Phaser.Math.MaxAdd\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to add to.\r\n * @param {number} amount - The amount to add.\r\n * @param {number} max - The maximum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MaxAdd = function (value, amount, max)\r\n{\r\n    return Math.min(value + amount, max);\r\n};\r\n\r\nmodule.exports = MaxAdd;\r\n","/**\r\n * @author       Vladislav Forsh <vlad@robowhale.com>\r\n * @copyright    2021 RoboWhale\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the median of the given values. The values are sorted and the middle value is returned.\r\n * In case of an even number of values, the average of the two middle values is returned.\r\n *\r\n * @function Phaser.Math.Median\r\n * @since 3.54.0\r\n *\r\n * @param {number[]} values - The values to average.\r\n *\r\n * @return {number} The median value.\r\n */\r\nvar Median = function (values)\r\n{\r\n    var valuesNum = values.length;\r\n    if (valuesNum === 0)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    values.sort(function (a, b) { return a - b; });\r\n\r\n    var halfIndex = Math.floor(valuesNum / 2);\r\n\r\n    return valuesNum % 2 === 0\r\n        ? (values[halfIndex] + values[halfIndex - 1]) / 2\r\n        : values[halfIndex];\r\n};\r\n\r\nmodule.exports = Median;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Subtract an `amount` from `value`, limiting the minimum result to `min`.\r\n *\r\n * @function Phaser.Math.MinSub\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to subtract from.\r\n * @param {number} amount - The amount to subtract.\r\n * @param {number} min - The minimum value to return.\r\n *\r\n * @return {number} The resulting value.\r\n */\r\nvar MinSub = function (value, amount, min)\r\n{\r\n    return Math.max(value - amount, min);\r\n};\r\n\r\nmodule.exports = MinSub;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Work out what percentage `value` is of the range between `min` and `max`.\r\n * If `max` isn't given then it will return the percentage of `value` to `min`.\r\n *\r\n * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.\r\n *\r\n * @function Phaser.Math.Percent\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to determine the percentage of.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n * @param {number} [upperMax] - The mid-way point in the range that represents 100%.\r\n *\r\n * @return {number} A value between 0 and 1 representing the percentage.\r\n */\r\nvar Percent = function (value, min, max, upperMax)\r\n{\r\n    if (max === undefined) { max = min + 1; }\r\n\r\n    var percentage = (value - min) / (max - min);\r\n\r\n    if (percentage > 1)\r\n    {\r\n        if (upperMax !== undefined)\r\n        {\r\n            percentage = ((upperMax - value)) / (upperMax - max);\r\n\r\n            if (percentage < 0)\r\n            {\r\n                percentage = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            percentage = 1;\r\n        }\r\n    }\r\n    else if (percentage < 0)\r\n    {\r\n        percentage = 0;\r\n    }\r\n\r\n    return percentage;\r\n};\r\n\r\nmodule.exports = Percent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle in radians, to the equivalent angle in degrees.\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {number} radians - The angle in radians to convert ot degrees.\r\n *\r\n * @return {number} The given angle converted to degrees.\r\n */\r\nvar RadToDeg = function (radians)\r\n{\r\n    return radians * CONST.RAD_TO_DEG;\r\n};\r\n\r\nmodule.exports = RadToDeg;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Compute a random unit vector.\r\n *\r\n * Computes random values for the given vector between -1 and 1 that can be used to represent a direction.\r\n *\r\n * Optionally accepts a scale value to scale the resulting vector by.\r\n *\r\n * @function Phaser.Math.RandomXY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Math.Vector2} vector - The Vector to compute random values for.\r\n * @param {number} [scale=1] - The scale of the random values.\r\n *\r\n * @return {Phaser.Math.Vector2} The given Vector.\r\n */\r\nvar RandomXY = function (vector, scale)\r\n{\r\n    if (scale === undefined) { scale = 1; }\r\n\r\n    var r = Math.random() * 2 * Math.PI;\r\n\r\n    vector.x = Math.cos(r) * scale;\r\n    vector.y = Math.sin(r) * scale;\r\n\r\n    return vector;\r\n};\r\n\r\nmodule.exports = RandomXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a given point by a given angle around the origin (0, 0), in an anti-clockwise direction.\r\n *\r\n * @function Phaser.Math.Rotate\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} angle - The angle to be rotated by in an anticlockwise direction.\r\n *\r\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle in an anticlockwise direction.\r\n */\r\nvar Rotate = function (point, angle)\r\n{\r\n    var x = point.x;\r\n    var y = point.y;\r\n\r\n    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));\r\n    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = Rotate;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.\r\n *\r\n * In polar notation, this maps a point from (r, t) to (distance, t + angle), vs. the origin (x, y).\r\n *\r\n * @function Phaser.Math.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Types.Math.Vector2Like} T - [point,$return]\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n * @param {number} distance - The distance from (x, y) to place the point at.\r\n *\r\n * @return {Phaser.Types.Math.Vector2Like} The given point.\r\n */\r\nvar RotateAroundDistance = function (point, x, y, angle, distance)\r\n{\r\n    var t = angle + Math.atan2(point.y - y, point.x - x);\r\n\r\n    point.x = x + (distance * Math.cos(t));\r\n    point.y = y + (distance * Math.sin(t));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAroundDistance;\r\n","/**\n * @author       samme\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Position a `point` at the given `angle` and `distance` to (`x`, `y`).\n *\n * @function Phaser.Math.RotateTo\n * @since 3.24.0\n *\n * @generic {Phaser.Types.Math.Vector2Like} T - [point,$return]\n *\n * @param {Phaser.Types.Math.Vector2Like} point - The point to be positioned.\n * @param {number} x - The horizontal coordinate to position from.\n * @param {number} y - The vertical coordinate to position from.\n * @param {number} angle - The angle of rotation in radians.\n * @param {number} distance - The distance from (x, y) to place the point at.\n *\n * @return {Phaser.Types.Math.Vector2Like} The given point.\n */\nvar RotateTo = function (point, x, y, angle, distance)\n{\n    point.x = x + (distance * Math.cos(angle));\n    point.y = y + (distance * Math.sin(angle));\n\n    return point;\n};\n\nmodule.exports = RotateTo;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.\r\n *\r\n * @function Phaser.Math.RoundAwayFromZero\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to round.\r\n *\r\n * @return {number} The rounded number, rounded away from zero.\r\n */\r\nvar RoundAwayFromZero = function (value)\r\n{\r\n    // \"Opposite\" of truncate.\r\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\r\n};\r\n\r\nmodule.exports = RoundAwayFromZero;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a value to the given precision.\r\n * \r\n * For example:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456, 0) = 123\r\n * RoundTo(123.456, 1) = 120\r\n * RoundTo(123.456, 2) = 100\r\n * ```\r\n * \r\n * To round the decimal, i.e. to round to precision, pass in a negative `place`:\r\n * \r\n * ```javascript\r\n * RoundTo(123.456789, 0) = 123\r\n * RoundTo(123.456789, -1) = 123.5\r\n * RoundTo(123.456789, -2) = 123.46\r\n * RoundTo(123.456789, -3) = 123.457\r\n * ```\r\n *\r\n * @function Phaser.Math.RoundTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to round.\r\n * @param {number} [place=0] - The place to round to. Positive to round the units, negative to round the decimal.\r\n * @param {number} [base=10] - The base to round in. Default is 10 for decimal.\r\n *\r\n * @return {number} The rounded value.\r\n */\r\nvar RoundTo = function (value, place, base)\r\n{\r\n    if (place === undefined) { place = 0; }\r\n    if (base === undefined) { base = 10; }\r\n\r\n    var p = Math.pow(base, -place);\r\n\r\n    return Math.round(value * p) / p;\r\n};\r\n\r\nmodule.exports = RoundTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Generate a series of sine and cosine values.\r\n *\r\n * @function Phaser.Math.SinCosTableGenerator\r\n * @since 3.0.0\r\n *\r\n * @param {number} length - The number of values to generate.\r\n * @param {number} [sinAmp=1] - The sine value amplitude.\r\n * @param {number} [cosAmp=1] - The cosine value amplitude.\r\n * @param {number} [frequency=1] - The frequency of the values.\r\n *\r\n * @return {Phaser.Types.Math.SinCosTable} The generated values.\r\n */\r\nvar SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)\r\n{\r\n    if (sinAmp === undefined) { sinAmp = 1; }\r\n    if (cosAmp === undefined) { cosAmp = 1; }\r\n    if (frequency === undefined) { frequency = 1; }\r\n\r\n    frequency *= Math.PI / length;\r\n\r\n    var cos = [];\r\n    var sin = [];\r\n\r\n    for (var c = 0; c < length; c++)\r\n    {\r\n        cosAmp -= sinAmp * frequency;\r\n        sinAmp += cosAmp * frequency;\r\n\r\n        cos[c] = cosAmp;\r\n        sin[c] = sinAmp;\r\n    }\r\n\r\n    return {\r\n        sin: sin,\r\n        cos: cos,\r\n        length: length\r\n    };\r\n};\r\n\r\nmodule.exports = SinCosTableGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmoothStep = function (x, min, max)\r\n{\r\n    if (x <= min)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (x >= max)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    x = (x - min) / (max - min);\r\n\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smoother interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.\r\n *\r\n * @function Phaser.Math.SmootherStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmootherStep = function (x, min, max)\r\n{\r\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\r\n\r\n    return x * x * x * (x * (x * 6 - 15) + 10);\r\n};\r\n\r\nmodule.exports = SmootherStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('./Vector2');\r\n\r\n/**\r\n * Returns a Vector2 containing the x and y position of the given index in a `width` x `height` sized grid.\r\n * \r\n * For example, in a 6 x 4 grid, index 16 would equal x: 4 y: 2.\r\n * \r\n * If the given index is out of range an empty Vector2 is returned.\r\n *\r\n * @function Phaser.Math.ToXY\r\n * @since 3.19.0\r\n *\r\n * @param {number} index - The position within the grid to get the x/y value for.\r\n * @param {number} width - The width of the grid.\r\n * @param {number} height - The height of the grid.\r\n * @param {Phaser.Math.Vector2} [out] - An optional Vector2 to store the result in. If not given, a new Vector2 instance will be created.\r\n *\r\n * @return {Phaser.Math.Vector2} A Vector2 where the x and y properties contain the given grid index.\r\n */\r\nvar ToXY = function (index, width, height, out)\r\n{\r\n    if (out === undefined) { out = new Vector2(); }\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n    var total = width * height;\r\n\r\n    if (index > 0 && index <= total)\r\n    {\r\n        if (index > width - 1)\r\n        {\r\n            y = Math.floor(index / width);\r\n            x = index - (y * width);\r\n        }\r\n        else\r\n        {\r\n            x = index;\r\n        }\r\n    }\r\n\r\n    return out.set(x, y);\r\n};\r\n\r\nmodule.exports = ToXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the two values are within the given `tolerance` of each other.\r\n *\r\n * @function Phaser.Math.Within\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value to use in the calculation.\r\n * @param {number} b - The second value to use in the calculation.\r\n * @param {number} tolerance - The tolerance. Anything equal to or less than this value is considered as being within range.\r\n *\r\n * @return {boolean} Returns `true` if `a` is less than or equal to the tolerance of `b`.\r\n */\r\nvar Within = function (a, b, tolerance)\r\n{\r\n    return (Math.abs(a - b) <= tolerance);\r\n};\r\n\r\nmodule.exports = Within;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * @function Phaser.Math.Angle.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar Between = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * Calculates the angle of the vector from the first point to the second point.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} point1 - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPoints = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\r\n};\r\n\r\nmodule.exports = BetweenPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.BetweenPoints} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPointsY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} point1 - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPointsY = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.x - point1.x, point2.y - point1.y);\r\n};\r\n\r\nmodule.exports = BetweenPointsY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * The difference between this method and {@link Phaser.Math.Angle.Between} is that this assumes the y coordinate\r\n * travels down the screen.\r\n *\r\n * @function Phaser.Math.Angle.BetweenY\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenY = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(x2 - x1, y2 - y1);\r\n};\r\n\r\nmodule.exports = BetweenY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const');\r\n\r\n/**\r\n * Takes an angle in Phasers default clockwise format and converts it so that\r\n * 0 is North, 90 is West, 180 is South and 270 is East,\r\n * therefore running counter-clockwise instead of clockwise.\r\n * \r\n * You can pass in the angle from a Game Object using:\r\n * \r\n * ```javascript\r\n * var converted = CounterClockwise(gameobject.rotation);\r\n * ```\r\n * \r\n * All values for this function are in radians.\r\n *\r\n * @function Phaser.Math.Angle.CounterClockwise\r\n * @since 3.16.0\r\n *\r\n * @param {number} angle - The angle to convert, in radians.\r\n *\r\n * @return {number} The converted angle, in radians.\r\n */\r\nvar CounterClockwise = function (angle)\r\n{\r\n    if (angle > Math.PI)\r\n    {\r\n        angle -= CONST.PI2;\r\n    }\r\n\r\n    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);\r\n};\r\n\r\nmodule.exports = CounterClockwise;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Normalize an angle to the [0, 2pi] range.\r\n *\r\n * @function Phaser.Math.Angle.Normalize\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to normalize, in radians.\r\n *\r\n * @return {number} The normalized angle, in radians.\r\n */\r\nvar Normalize = function (angle)\r\n{\r\n    angle = angle % (2 * Math.PI);\r\n\r\n    if (angle >= 0)\r\n    {\r\n        return angle;\r\n    }\r\n    else\r\n    {\r\n        return angle + 2 * Math.PI;\r\n    }\r\n};\r\n\r\nmodule.exports = Normalize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       @samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FloatBetween = require('../FloatBetween');\r\n\r\n/**\r\n * Returns a random angle in the range [-pi, pi].\r\n *\r\n * @function Phaser.Math.Angle.Random\r\n * @since 3.23.0\r\n *\r\n * @return {number} The angle, in radians.\r\n */\r\nvar Random = function ()\r\n{\r\n    return FloatBetween(-Math.PI, Math.PI);\r\n};\r\n\r\nmodule.exports = Random;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       @samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FloatBetween = require('../FloatBetween');\r\n\r\n/**\r\n * Returns a random angle in the range [-180, 180].\r\n *\r\n * @function Phaser.Math.Angle.RandomDegrees\r\n * @since 3.23.0\r\n *\r\n * @return {number} The angle, in degrees.\r\n */\r\nvar RandomDegrees = function ()\r\n{\r\n    return FloatBetween(-180, 180);\r\n};\r\n\r\nmodule.exports = RandomDegrees;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Normalize = require('./Normalize');\r\n\r\n/**\r\n * Reverse the given angle.\r\n *\r\n * @function Phaser.Math.Angle.Reverse\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle - The angle to reverse, in radians.\r\n *\r\n * @return {number} The reversed angle, in radians.\r\n */\r\nvar Reverse = function (angle)\r\n{\r\n    return Normalize(angle + Math.PI);\r\n};\r\n\r\nmodule.exports = Reverse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MATH_CONST = require('../const');\r\n\r\n/**\r\n * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.\r\n *\r\n * @function Phaser.Math.Angle.RotateTo\r\n * @since 3.0.0\r\n *\r\n * @param {number} currentAngle - The current angle, in radians.\r\n * @param {number} targetAngle - The target angle to rotate to, in radians.\r\n * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\r\n *\r\n * @return {number} The adjusted angle.\r\n */\r\nvar RotateTo = function (currentAngle, targetAngle, lerp)\r\n{\r\n    if (lerp === undefined) { lerp = 0.05; }\r\n\r\n    if (currentAngle === targetAngle)\r\n    {\r\n        return currentAngle;\r\n    }\r\n\r\n    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))\r\n    {\r\n        currentAngle = targetAngle;\r\n    }\r\n    else\r\n    {\r\n        if (Math.abs(targetAngle - currentAngle) > Math.PI)\r\n        {\r\n            if (targetAngle < currentAngle)\r\n            {\r\n                targetAngle += MATH_CONST.PI2;\r\n            }\r\n            else\r\n            {\r\n                targetAngle -= MATH_CONST.PI2;\r\n            }\r\n        }\r\n\r\n        if (targetAngle > currentAngle)\r\n        {\r\n            currentAngle += lerp;\r\n        }\r\n        else if (targetAngle < currentAngle)\r\n        {\r\n            currentAngle -= lerp;\r\n        }\r\n    }\r\n\r\n    return currentAngle;\r\n};\r\n\r\nmodule.exports = RotateTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Gets the shortest angle between `angle1` and `angle2`.\r\n *\r\n * Both angles must be in the range -180 to 180, which is the same clamped\r\n * range that `sprite.angle` uses, so you can pass in two sprite angles to\r\n * this method and get the shortest angle back between the two of them.\r\n *\r\n * The angle returned will be in the same range. If the returned angle is\r\n * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\r\n * a clockwise rotation.\r\n *\r\n * @function Phaser.Math.Angle.ShortestBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} angle1 - The first angle in the range -180 to 180.\r\n * @param {number} angle2 - The second angle in the range -180 to 180.\r\n *\r\n * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\r\n */\r\nvar ShortestBetween = function (angle1, angle2)\r\n{\r\n    var difference = angle2 - angle1;\r\n\r\n    if (difference === 0)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    var times = Math.floor((difference - (-180)) / 360);\r\n\r\n    return difference - (times * 360);\r\n\r\n};\r\n\r\nmodule.exports = ShortestBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Angle\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./Between'),\r\n    BetweenPoints: require('./BetweenPoints'),\r\n    BetweenPointsY: require('./BetweenPointsY'),\r\n    BetweenY: require('./BetweenY'),\r\n    CounterClockwise: require('./CounterClockwise'),\r\n    Normalize: require('./Normalize'),\r\n    Random: require('./Random'),\r\n    RandomDegrees: require('./RandomDegrees'),\r\n    Reverse: require('./Reverse'),\r\n    RotateTo: require('./RotateTo'),\r\n    ShortestBetween: require('./ShortestBetween'),\r\n    Wrap: require('./Wrap'),\r\n    WrapDegrees: require('./WrapDegrees')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two points.\r\n *\r\n * @function Phaser.Math.Distance.BetweenPoints\r\n * @since 3.22.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} a - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} b - The second point.\r\n *\r\n * @return {number} The distance between the points.\r\n */\r\nvar DistanceBetweenPoints = function (a, b)\r\n{\r\n    var dx = a.x - b.x;\r\n    var dy = a.y - b.y;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetweenPoints;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the squared distance between two points.\r\n *\r\n * @function Phaser.Math.Distance.BetweenPointsSquared\r\n * @since 3.22.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} a - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} b - The second point.\r\n *\r\n * @return {number} The squared distance between the points.\r\n */\r\nvar DistanceBetweenPointsSquared = function (a, b)\r\n{\r\n    var dx = a.x - b.x;\r\n    var dy = a.y - b.y;\r\n\r\n    return dx * dx + dy * dy;\r\n};\r\n\r\nmodule.exports = DistanceBetweenPointsSquared;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the Chebyshev distance between two sets of coordinates (points).\r\n *\r\n * Chebyshev distance (or chessboard distance) is the maximum of the horizontal and vertical distances.\r\n * It's the effective distance when movement can be horizontal, vertical, or diagonal.\r\n *\r\n * @function Phaser.Math.Distance.Chebyshev\r\n * @since 3.22.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar ChebyshevDistance = function (x1, y1, x2, y2)\r\n{\r\n    return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\r\n};\r\n\r\nmodule.exports = ChebyshevDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points) to the power of `pow`.\r\n *\r\n * @function Phaser.Math.Distance.Power\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n * @param {number} pow - The exponent.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistancePower = function (x1, y1, x2, y2, pow)\r\n{\r\n    if (pow === undefined) { pow = 2; }\r\n\r\n    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\r\n};\r\n\r\nmodule.exports = DistancePower;\r\n","/**\r\n * @author       samme\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the snake distance between two sets of coordinates (points).\r\n *\r\n * Snake distance (rectilinear distance, Manhattan distance) is the sum of the horizontal and vertical distances.\r\n * It's the effective distance when movement is allowed only horizontally or vertically (but not both).\r\n *\r\n * @function Phaser.Math.Distance.Snake\r\n * @since 3.22.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar SnakeDistance = function (x1, y1, x2, y2)\r\n{\r\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n};\r\n\r\nmodule.exports = SnakeDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points), squared.\r\n *\r\n * @function Phaser.Math.Distance.Squared\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point, squared.\r\n */\r\nvar DistanceSquared = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return dx * dx + dy * dy;\r\n};\r\n\r\nmodule.exports = DistanceSquared;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Distance\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Between: require('./DistanceBetween'),\r\n    BetweenPoints: require('./DistanceBetweenPoints'),\r\n    BetweenPointsSquared: require('./DistanceBetweenPointsSquared'),\r\n    Chebyshev: require('./DistanceChebyshev'),\r\n    Power: require('./DistancePower'),\r\n    Snake: require('./DistanceSnake'),\r\n    Squared: require('./DistanceSquared')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Easing\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Back: require('./back'),\r\n    Bounce: require('./bounce'),\r\n    Circular: require('./circular'),\r\n    Cubic: require('./cubic'),\r\n    Elastic: require('./elastic'),\r\n    Expo: require('./expo'),\r\n    Linear: require('./linear'),\r\n    Quadratic: require('./quadratic'),\r\n    Quartic: require('./quartic'),\r\n    Quintic: require('./quintic'),\r\n    Sine: require('./sine'),\r\n    Stepped: require('./stepped')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy ceiling of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The fuzzy ceiling of the value.\r\n */\r\nvar Ceil = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.ceil(value - epsilon);\r\n};\r\n\r\nmodule.exports = Ceil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the fuzzy floor of the given value.\r\n *\r\n * @function Phaser.Math.Fuzzy.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {number} The floor of the value.\r\n */\r\nvar Floor = function (value, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return Math.floor(value + epsilon);\r\n};\r\n\r\nmodule.exports = Floor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily greater than `b`.\r\n *\r\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.GreaterThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\r\n */\r\nvar GreaterThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a > b - epsilon;\r\n};\r\n\r\nmodule.exports = GreaterThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily less than `b`.\r\n *\r\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.LessThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\r\n */\r\nvar LessThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a < b + epsilon;\r\n};\r\n\r\nmodule.exports = LessThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Fuzzy\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./Ceil'),\r\n    Equal: require('./Equal'),\r\n    Floor: require('./Floor'),\r\n    GreaterThan: require('./GreaterThan'),\r\n    LessThan: require('./LessThan')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Math\r\n */\r\n\r\nvar PhaserMath = {\r\n\r\n    //  Collections of functions\r\n    Angle: require('./angle/'),\r\n    Distance: require('./distance/'),\r\n    Easing: require('./easing/'),\r\n    Fuzzy: require('./fuzzy/'),\r\n    Interpolation: require('./interpolation/'),\r\n    Pow2: require('./pow2/'),\r\n    Snap: require('./snap/'),\r\n\r\n    //  Expose the RNG Class\r\n    RandomDataGenerator: require('./random-data-generator/RandomDataGenerator'),\r\n\r\n    //  Single functions\r\n    Average: require('./Average'),\r\n    Bernstein: require('./Bernstein'),\r\n    Between: require('./Between'),\r\n    CatmullRom: require('./CatmullRom'),\r\n    CeilTo: require('./CeilTo'),\r\n    Clamp: require('./Clamp'),\r\n    DegToRad: require('./DegToRad'),\r\n    Difference: require('./Difference'),\r\n    Euler: require('./Euler'),\r\n    Factorial: require('./Factorial'),\r\n    FloatBetween: require('./FloatBetween'),\r\n    FloorTo: require('./FloorTo'),\r\n    FromPercent: require('./FromPercent'),\r\n    GetSpeed: require('./GetSpeed'),\r\n    IsEven: require('./IsEven'),\r\n    IsEvenStrict: require('./IsEvenStrict'),\r\n    Linear: require('./Linear'),\r\n    MaxAdd: require('./MaxAdd'),\r\n    Median: require('./Median'),\r\n    MinSub: require('./MinSub'),\r\n    Percent: require('./Percent'),\r\n    RadToDeg: require('./RadToDeg'),\r\n    RandomXY: require('./RandomXY'),\r\n    RandomXYZ: require('./RandomXYZ'),\r\n    RandomXYZW: require('./RandomXYZW'),\r\n    Rotate: require('./Rotate'),\r\n    RotateAround: require('./RotateAround'),\r\n    RotateAroundDistance: require('./RotateAroundDistance'),\r\n    RotateTo: require('./RotateTo'),\r\n    RoundAwayFromZero: require('./RoundAwayFromZero'),\r\n    RoundTo: require('./RoundTo'),\r\n    SinCosTableGenerator: require('./SinCosTableGenerator'),\r\n    SmootherStep: require('./SmootherStep'),\r\n    SmoothStep: require('./SmoothStep'),\r\n    ToXY: require('./ToXY'),\r\n    TransformXY: require('./TransformXY'),\r\n    Within: require('./Within'),\r\n    Wrap: require('./Wrap'),\r\n\r\n    //  Vector classes\r\n    Vector2: require('./Vector2'),\r\n    Vector3: require('./Vector3'),\r\n    Vector4: require('./Vector4'),\r\n    Matrix3: require('./Matrix3'),\r\n    Matrix4: require('./Matrix4'),\r\n    Quaternion: require('./Quaternion'),\r\n    RotateVec3: require('./RotateVec3')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\n\r\nPhaserMath = Extend(false, PhaserMath, CONST);\r\n\r\n//  Export it\r\n\r\nmodule.exports = PhaserMath;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bernstein = require('../Bernstein');\r\n\r\n/**\r\n * A bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Bezier\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar BezierInterpolation = function (v, k)\r\n{\r\n    var b = 0;\r\n    var n = v.length - 1;\r\n\r\n    for (var i = 0; i <= n; i++)\r\n    {\r\n        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);\r\n    }\r\n\r\n    return b;\r\n};\r\n\r\nmodule.exports = BezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CatmullRom = require('../CatmullRom');\r\n\r\n/**\r\n * A Catmull-Rom interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.CatmullRom\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CatmullRomInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (v[0] === v[m])\r\n    {\r\n        if (k < 0)\r\n        {\r\n            i = Math.floor(f = m * (1 + k));\r\n        }\r\n\r\n        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);\r\n    }\r\n    else\r\n    {\r\n        if (k < 0)\r\n        {\r\n            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);\r\n        }\r\n\r\n        if (k > 1)\r\n        {\r\n            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);\r\n        }\r\n\r\n        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);\r\n    }\r\n};\r\n\r\nmodule.exports = CatmullRomInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return 3 * k * k * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P3 (t, p)\r\n{\r\n    return t * t * t * p;\r\n}\r\n\r\n/**\r\n * A cubic bezier interpolation method.\r\n *\r\n * https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\r\n *\r\n * @function Phaser.Math.Interpolation.CubicBezier\r\n * @since 3.0.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The first control point.\r\n * @param {number} p2 - The second control point.\r\n * @param {number} p3 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar CubicBezierInterpolation = function (t, p0, p1, p2, p3)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\r\n};\r\n\r\nmodule.exports = CubicBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Linear = require('../Linear');\r\n\r\n/**\r\n * A linear interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.Linear\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Linear_interpolation}\r\n *\r\n * @param {number[]} v - The input array of values to interpolate between.\r\n * @param {!number} k - The percentage of interpolation, between 0 and 1.\r\n *\r\n * @return {!number} The interpolated value.\r\n */\r\nvar LinearInterpolation = function (v, k)\r\n{\r\n    var m = v.length - 1;\r\n    var f = m * k;\r\n    var i = Math.floor(f);\r\n\r\n    if (k < 0)\r\n    {\r\n        return Linear(v[0], v[1], f);\r\n    }\r\n    else if (k > 1)\r\n    {\r\n        return Linear(v[m], v[m - 1], m - f);\r\n    }\r\n    else\r\n    {\r\n        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);\r\n    }\r\n};\r\n\r\nmodule.exports = LinearInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P0 (t, p)\r\n{\r\n    var k = 1 - t;\r\n\r\n    return k * k * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P1 (t, p)\r\n{\r\n    return 2 * (1 - t) * t * p;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction P2 (t, p)\r\n{\r\n    return t * t * p;\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\r\n\r\n/**\r\n * A quadratic bezier interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.QuadraticBezier\r\n * @since 3.2.0\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} p0 - The start point.\r\n * @param {number} p1 - The control point.\r\n * @param {number} p2 - The end point.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar QuadraticBezierInterpolation = function (t, p0, p1, p2)\r\n{\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2);\r\n};\r\n\r\nmodule.exports = QuadraticBezierInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmoothStep = require('../SmoothStep');\r\n\r\n/**\r\n * A Smooth Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmoothStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmoothStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmoothStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmoothStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmootherStep = require('../SmootherStep');\r\n\r\n/**\r\n * A Smoother Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmootherStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmootherStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmootherStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmootherStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Interpolation\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Bezier: require('./BezierInterpolation'),\r\n    CatmullRom: require('./CatmullRomInterpolation'),\r\n    CubicBezier: require('./CubicBezierInterpolation'),\r\n    Linear: require('./LinearInterpolation'),\r\n    QuadraticBezier: require('./QuadraticBezierInterpolation'),\r\n    SmoothStep: require('./SmoothStepInterpolation'),\r\n    SmootherStep: require('./SmootherStepInterpolation')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the nearest power of 2 to the given `value`.\r\n *\r\n * @function Phaser.Math.Pow2.GetNext\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value.\r\n *\r\n * @return {number} The nearest power of 2 to `value`.\r\n */\r\nvar GetPowerOfTwo = function (value)\r\n{\r\n    var index = Math.log(value) / 0.6931471805599453;\r\n\r\n    return (1 << Math.ceil(index));\r\n};\r\n\r\nmodule.exports = GetPowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given `width` and `height` are a power of two.\r\n * Useful for checking texture dimensions.\r\n *\r\n * @function Phaser.Math.Pow2.IsSize\r\n * @since 3.0.0\r\n *\r\n * @param {number} width - The width.\r\n * @param {number} height - The height.\r\n *\r\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\r\n */\r\nvar IsSizePowerOfTwo = function (width, height)\r\n{\r\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsSizePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tests the value and returns `true` if it is a power of two.\r\n *\r\n * @function Phaser.Math.Pow2.IsValue\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to check if it's a power of two.\r\n *\r\n * @return {boolean} Returns `true` if `value` is a power of two, otherwise `false`.\r\n */\r\nvar IsValuePowerOfTwo = function (value)\r\n{\r\n    return (value > 0 && (value & (value - 1)) === 0);\r\n};\r\n\r\nmodule.exports = IsValuePowerOfTwo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Pow2\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    GetNext: require('./GetPowerOfTwo'),\r\n    IsSize: require('./IsSizePowerOfTwo'),\r\n    IsValue: require('./IsValuePowerOfTwo')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A seeded Random Data Generator.\r\n * \r\n * Access via `Phaser.Math.RND` which is an instance of this class pre-defined\r\n * by Phaser. Or, create your own instance to use as you require.\r\n * \r\n * The `Math.RND` generator is seeded by the Game Config property value `seed`.\r\n * If no such config property exists, a random number is used.\r\n * \r\n * If you create your own instance of this class you should provide a seed for it.\r\n * If no seed is given it will use a 'random' one based on Date.now.\r\n *\r\n * @class RandomDataGenerator\r\n * @memberof Phaser.Math\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(string|string[])} [seeds] - The seeds to use for the random number generator.\r\n */\r\nvar RandomDataGenerator = new Class({\r\n\r\n    initialize:\r\n\r\n    function RandomDataGenerator (seeds)\r\n    {\r\n        if (seeds === undefined) { seeds = [ (Date.now() * Math.random()).toString() ]; }\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#c\r\n         * @type {number}\r\n         * @default 1\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.c = 1;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s0\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s0 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s1\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s1 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#s2\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.s2 = 0;\r\n\r\n        /**\r\n         * Internal var.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#n\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.2.0\r\n         */\r\n        this.n = 0;\r\n\r\n        /**\r\n         * Signs to choose from.\r\n         *\r\n         * @name Phaser.Math.RandomDataGenerator#signs\r\n         * @type {number[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.signs = [ -1, 1 ];\r\n\r\n        if (seeds)\r\n        {\r\n            this.init(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Private random helper.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rnd\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @return {number} A random number.\r\n     */\r\n    rnd: function ()\r\n    {\r\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\r\n\r\n        this.c = t | 0;\r\n        this.s0 = this.s1;\r\n        this.s1 = this.s2;\r\n        this.s2 = t - this.c;\r\n\r\n        return this.s2;\r\n    },\r\n\r\n    /**\r\n     * Internal method that creates a seed hash.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#hash\r\n     * @since 3.0.0\r\n     * @private\r\n     *\r\n     * @param {string} data - The value to hash.\r\n     *\r\n     * @return {number} The hashed value.\r\n     */\r\n    hash: function (data)\r\n    {\r\n        var h;\r\n        var n = this.n;\r\n\r\n        data = data.toString();\r\n\r\n        for (var i = 0; i < data.length; i++)\r\n        {\r\n            n += data.charCodeAt(i);\r\n            h = 0.02519603282416938 * n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            h *= n;\r\n            n = h >>> 0;\r\n            h -= n;\r\n            n += h * 0x100000000;// 2^32\r\n        }\r\n\r\n        this.n = n;\r\n\r\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\r\n    },\r\n\r\n    /**\r\n     * Initialize the state of the random data generator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.\r\n     */\r\n    init: function (seeds)\r\n    {\r\n        if (typeof seeds === 'string')\r\n        {\r\n            this.state(seeds);\r\n        }\r\n        else\r\n        {\r\n            this.sow(seeds);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Reset the seed of the random data generator.\r\n     *\r\n     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.\r\n     */\r\n    sow: function (seeds)\r\n    {\r\n        // Always reset to default seed\r\n        this.n = 0xefc8249d;\r\n        this.s0 = this.hash(' ');\r\n        this.s1 = this.hash(' ');\r\n        this.s2 = this.hash(' ');\r\n        this.c = 1;\r\n\r\n        if (!seeds)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Apply any seeds\r\n        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)\r\n        {\r\n            var seed = seeds[i];\r\n\r\n            this.s0 -= this.hash(seed);\r\n            this.s0 += ~~(this.s0 < 0);\r\n            this.s1 -= this.hash(seed);\r\n            this.s1 += ~~(this.s1 < 0);\r\n            this.s2 -= this.hash(seed);\r\n            this.s2 += ~~(this.s2 < 0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integer\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random integer between 0 and 2^32.\r\n     */\r\n    integer: function ()\r\n    {\r\n        // 2^32\r\n        return this.rnd() * 0x100000000;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#frac\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 1.\r\n     */\r\n    frac: function ()\r\n    {\r\n        // 2^-53\r\n        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between 0 and 2^32.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#real\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between 0 and 2^32.\r\n     */\r\n    real: function ()\r\n    {\r\n        return this.integer() + this.frac();\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#integerInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    integerInRange: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random integer between and including min and max.\r\n     * This method is an alias for RandomDataGenerator.integerInRange.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#between\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    between: function (min, max)\r\n    {\r\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between min and max.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#realInRange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random number between min and max.\r\n     */\r\n    realInRange: function (min, max)\r\n    {\r\n        return this.frac() * (max - min) + min;\r\n    },\r\n\r\n    /**\r\n     * Returns a random real number between -1 and 1.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#normal\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random real number between -1 and 1.\r\n     */\r\n    normal: function ()\r\n    {\r\n        return 1 - (2 * this.frac());\r\n    },\r\n\r\n    /**\r\n     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#uuid\r\n     * @since 3.0.0\r\n     *\r\n     * @return {string} A valid RFC4122 version4 ID hex string\r\n     */\r\n    uuid: function ()\r\n    {\r\n        var a = '';\r\n        var b = '';\r\n\r\n        for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')\r\n        {\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n\r\n        return b;\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#pick\r\n     * @since 3.0.0\r\n     * \r\n     * @generic T\r\n     * @genericUse {T[]} - [array]\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {T[]} array - The array to pick a random element from.\r\n     *\r\n     * @return {T} A random member of the array.\r\n     */\r\n    pick: function (array)\r\n    {\r\n        return array[this.integerInRange(0, array.length - 1)];\r\n    },\r\n\r\n    /**\r\n     * Returns a sign to be used with multiplication operator.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#sign\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} -1 or +1.\r\n     */\r\n    sign: function ()\r\n    {\r\n        return this.pick(this.signs);\r\n    },\r\n\r\n    /**\r\n     * Returns a random element from within the given array, favoring the earlier entries.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#weightedPick\r\n     * @since 3.0.0\r\n     *\r\n     * @generic T\r\n     * @genericUse {T[]} - [array]\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {T[]} array - The array to pick a random element from.\r\n     *\r\n     * @return {T} A random member of the array.\r\n     */\r\n    weightedPick: function (array)\r\n    {\r\n        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];\r\n    },\r\n\r\n    /**\r\n     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#timestamp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} min - The minimum value in the range.\r\n     * @param {number} max - The maximum value in the range.\r\n     *\r\n     * @return {number} A random timestamp between min and max.\r\n     */\r\n    timestamp: function (min, max)\r\n    {\r\n        return this.realInRange(min || 946684800000, max || 1577862000000);\r\n    },\r\n\r\n    /**\r\n     * Returns a random angle between -180 and 180.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#angle\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -180 and 180.\r\n     */\r\n    angle: function ()\r\n    {\r\n        return this.integerInRange(-180, 180);\r\n    },\r\n\r\n    /**\r\n     * Returns a random rotation in radians, between -3.141 and 3.141\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#rotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} A random number between -3.141 and 3.141\r\n     */\r\n    rotation: function ()\r\n    {\r\n        return this.realInRange(-3.1415926, 3.1415926);\r\n    },\r\n\r\n    /**\r\n     * Gets or Sets the state of the generator. This allows you to retain the values\r\n     * that the generator is using between games, i.e. in a game save file.\r\n     *\r\n     * To seed this generator with a previously saved state you can pass it as the\r\n     * `seed` value in your game config, or call this method directly after Phaser has booted.\r\n     *\r\n     * Call this method with no parameters to return the current state.\r\n     *\r\n     * If providing a state it should match the same format that this method\r\n     * returns, which is a string with a header `!rnd` followed by the `c`,\r\n     * `s0`, `s1` and `s2` values respectively, each comma-delimited.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#state\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [state] - Generator state to be set.\r\n     *\r\n     * @return {string} The current state of the generator.\r\n     */\r\n    state: function (state)\r\n    {\r\n        if (typeof state === 'string' && state.match(/^!rnd/))\r\n        {\r\n            state = state.split(',');\r\n\r\n            this.c = parseFloat(state[1]);\r\n            this.s0 = parseFloat(state[2]);\r\n            this.s1 = parseFloat(state[3]);\r\n            this.s2 = parseFloat(state[4]);\r\n        }\r\n\r\n        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');\r\n    },\r\n\r\n    /**\r\n     * Shuffles the given array, using the current seed.\r\n     *\r\n     * @method Phaser.Math.RandomDataGenerator#shuffle\r\n     * @since 3.7.0\r\n     *\r\n     * @generic T\r\n     * @genericUse {T[]} - [array,$return]\r\n     *\r\n     * @param {T[]} [array] - The array to be shuffled.\r\n     *\r\n     * @return {T[]} The shuffled array.\r\n     */\r\n    shuffle: function (array)\r\n    {\r\n        var len = array.length - 1;\r\n\r\n        for (var i = len; i > 0; i--)\r\n        {\r\n            var randomIndex = Math.floor(this.frac() * (i + 1));\r\n            var itemAtIndex = array[randomIndex];\r\n\r\n            array[randomIndex] = array[i];\r\n            array[i] = itemAtIndex;\r\n        }\r\n\r\n        return array;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RandomDataGenerator;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using ceil.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `15`.\r\n * As will `14` snap to `15`... but `16` will snap to `20`.\r\n *\r\n * @function Phaser.Math.Snap.Ceil\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapCeil = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.ceil(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapCeil;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using floor.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\r\n * As will `14` snap to `10`... but `16` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapFloor = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapFloor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using rounding.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10` whereas `14` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.To\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapTo = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.round(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapTo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Math.Snap\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Ceil: require('./SnapCeil'),\r\n    Floor: require('./SnapFloor'),\r\n    To: require('./SnapTo')\r\n\r\n};\r\n"],"names":["module","exports","values","sum","i","length","Factorial","n","min","max","Math","floor","random","t","p0","p1","p2","p3","v0","v1","t2","value","place","base","undefined","p","pow","ceil","a","b","abs","Clamp","Class","Matrix4","NOOP","tempMatrix","Euler","initialize","x","y","z","order","DefaultOrder","this","_x","_y","_z","_order","onChangeCallback","get","set","copy","euler","setFromQuaternion","quaternion","update","fromQuat","setFromRotationMatrix","matrix","elements","val","m11","m12","m13","m21","m22","m23","m31","m32","m33","epsilon","asin","atan2","RotationOrders","res","percent","distance","time","parseFloat","amount","valuesNum","sort","halfIndex","upperMax","percentage","CONST","radians","RAD_TO_DEG","vector","scale","r","PI","cos","sin","point","angle","round","sinAmp","cosAmp","frequency","c","Vector2","index","width","height","out","tolerance","x1","y1","x2","y2","point1","point2","PI2","TAU","FloatBetween","Normalize","MATH_CONST","currentAngle","targetAngle","lerp","angle1","angle2","difference","Between","BetweenPoints","BetweenPointsY","BetweenY","CounterClockwise","Random","RandomDegrees","Reverse","RotateTo","ShortestBetween","Wrap","WrapDegrees","dx","dy","sqrt","BetweenPointsSquared","Chebyshev","Power","Snake","Squared","Back","Bounce","Circular","Cubic","Elastic","Expo","Linear","Quadratic","Quartic","Quintic","Sine","Stepped","Ceil","Equal","Floor","GreaterThan","LessThan","Extend","PhaserMath","Angle","Distance","Easing","Fuzzy","Interpolation","Pow2","Snap","RandomDataGenerator","Average","Bernstein","CatmullRom","CeilTo","DegToRad","Difference","FloorTo","FromPercent","GetSpeed","IsEven","IsEvenStrict","MaxAdd","Median","MinSub","Percent","RadToDeg","RandomXY","RandomXYZ","RandomXYZW","Rotate","RotateAround","RotateAroundDistance","RoundAwayFromZero","RoundTo","SinCosTableGenerator","SmootherStep","SmoothStep","ToXY","TransformXY","Within","Vector3","Vector4","Matrix3","Quaternion","RotateVec3","v","k","m","f","P0","P1","P2","P3","Bezier","CubicBezier","QuadraticBezier","log","GetNext","IsSize","IsValue","seeds","Date","now","toString","s0","s1","s2","signs","init","rnd","hash","data","h","charCodeAt","state","sow","seed","integer","frac","real","integerInRange","realInRange","between","normal","uuid","pick","array","sign","weightedPick","timestamp","rotation","match","split","join","shuffle","randomIndex","itemAtIndex","gap","start","divide","To"],"sourceRoot":""}