{"version":3,"file":"js/phaser-physics.0ce1294843db5e0730ba.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/CircleToCircle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/intersects/CircleToRectangle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/DegToRad.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FromPercent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RadToDeg.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RotateAroundDistance.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SmoothStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SmootherStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Wrap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/BetweenPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceSquared.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/GreaterThan.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/fuzzy/LessThan.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/ArcadeImage.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/ArcadePhysics.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/ArcadeSprite.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/Body.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/Collider.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/Factory.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/GetOverlapX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/GetOverlapY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/PhysicsGroup.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/ProcessX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/ProcessY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/SeparateX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/SeparateY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/StaticBody.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/StaticPhysicsGroup.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/World.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Acceleration.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Angular.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Bounce.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Debug.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Drag.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Enable.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Friction.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Gravity.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Immovable.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Mass.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/OverlapCirc.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/OverlapRect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Pushable.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Size.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/Velocity.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/components/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/const.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/COLLIDE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/OVERLAP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/PAUSE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/RESUME_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/TILE_COLLIDE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/TILE_OVERLAP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/WORLD_BOUNDS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/WORLD_STEP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/ProcessTileCallbacks.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/ProcessTileSeparationX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/ProcessTileSeparationY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/SeparateTile.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/TileCheckX.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/TileCheckY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/TileIntersectsBody.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/arcade/tilemap/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/BodyBounds.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/CustomMain.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/Factory.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/MatterGameObject.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/MatterImage.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/MatterPhysics.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/MatterSprite.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/MatterTileBody.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/PhysicsEditorParser.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/PhysicsJSONParser.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/PointerConstraint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/World.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Bounce.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Collision.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Force.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Friction.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Gravity.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Mass.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Sensor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/SetBody.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Sleep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Static.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Transform.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/Velocity.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/components/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/AFTER_ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/AFTER_REMOVE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/AFTER_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/BEFORE_ADD_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/BEFORE_REMOVE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/BEFORE_UPDATE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/COLLISION_ACTIVE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/COLLISION_END_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/COLLISION_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/DRAG_END_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/DRAG_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/DRAG_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/PAUSE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/RESUME_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/SLEEP_END_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/SLEEP_START_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/body/Body.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/body/Composite.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/body/World.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Detector.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Grid.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Pair.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Pairs.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Query.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/Resolver.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/collision/SAT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/constraint/Constraint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Common.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Engine.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Events.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Matter.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Metrics.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Plugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/core/Sleeping.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/factory/Bodies.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/factory/Composites.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/geometry/Axes.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/geometry/Bounds.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/geometry/Svg.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/geometry/Vector.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/geometry/Vertices.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/plugins/MatterAttractors.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/plugins/MatterCollisionEvents.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/lib/plugins/MatterWrap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/physics/matter-js/poly-decomp/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/RTree.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tilemaps/components/GetTilesWithin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/tilemaps/components/GetTilesWithinWorldXY.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/GetAll.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/QuickSelect.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Range.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/SafeRange.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/Clone.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/Merge.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\n\r\n/**\r\n * Checks if two Circles intersect.\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n *\r\n * @return {boolean} `true` if the two Circles intersect, otherwise `false`.\r\n */\r\nvar CircleToCircle = function (circleA, circleB)\r\n{\r\n    return (DistanceBetween(circleA.x, circleA.y, circleB.x, circleB.y) <= (circleA.radius + circleB.radius));\r\n};\r\n\r\nmodule.exports = CircleToCircle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks for intersection between a circle and a rectangle.\r\n *\r\n * @function Phaser.Geom.Intersects.CircleToRectangle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The circle to be checked.\r\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to be checked.\r\n *\r\n * @return {boolean} `true` if the two objects intersect, otherwise `false`.\r\n */\r\nvar CircleToRectangle = function (circle, rect)\r\n{\r\n    var halfWidth = rect.width / 2;\r\n    var halfHeight = rect.height / 2;\r\n\r\n    var cx = Math.abs(circle.x - rect.x - halfWidth);\r\n    var cy = Math.abs(circle.y - rect.y - halfHeight);\r\n    var xDist = halfWidth + circle.radius;\r\n    var yDist = halfHeight + circle.radius;\r\n\r\n    if (cx > xDist || cy > yDist)\r\n    {\r\n        return false;\r\n    }\r\n    else if (cx <= halfWidth || cy <= halfHeight)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        var xCornerDist = cx - halfWidth;\r\n        var yCornerDist = cy - halfHeight;\r\n        var xCornerDistSq = xCornerDist * xCornerDist;\r\n        var yCornerDistSq = yCornerDist * yCornerDist;\r\n        var maxCornerDistSq = circle.radius * circle.radius;\r\n\r\n        return (xCornerDistSq + yCornerDistSq <= maxCornerDistSq);\r\n    }\r\n};\r\n\r\nmodule.exports = CircleToRectangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle from degrees, to the equivalent angle in radians.\r\n *\r\n * @function Phaser.Math.DegToRad\r\n * @since 3.0.0\r\n *\r\n * @param {number} degrees - The angle (in degrees) to convert to radians.\r\n *\r\n * @return {number} The given angle converted to radians.\r\n */\r\nvar DegToRad = function (degrees)\r\n{\r\n    return degrees * CONST.DEG_TO_RAD;\r\n};\r\n\r\nmodule.exports = DegToRad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent + min;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Convert the given angle in radians, to the equivalent angle in degrees.\r\n *\r\n * @function Phaser.Math.RadToDeg\r\n * @since 3.0.0\r\n *\r\n * @param {number} radians - The angle in radians to convert ot degrees.\r\n *\r\n * @return {number} The given angle converted to degrees.\r\n */\r\nvar RadToDeg = function (radians)\r\n{\r\n    return radians * CONST.RAD_TO_DEG;\r\n};\r\n\r\nmodule.exports = RadToDeg;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.\r\n *\r\n * In polar notation, this maps a point from (r, t) to (distance, t + angle), vs. the origin (x, y).\r\n *\r\n * @function Phaser.Math.RotateAroundDistance\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Types.Math.Vector2Like} T - [point,$return]\r\n *\r\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\r\n * @param {number} x - The horizontal coordinate to rotate around.\r\n * @param {number} y - The vertical coordinate to rotate around.\r\n * @param {number} angle - The angle of rotation in radians.\r\n * @param {number} distance - The distance from (x, y) to place the point at.\r\n *\r\n * @return {Phaser.Types.Math.Vector2Like} The given point.\r\n */\r\nvar RotateAroundDistance = function (point, x, y, angle, distance)\r\n{\r\n    var t = angle + Math.atan2(point.y - y, point.x - x);\r\n\r\n    point.x = x + (distance * Math.cos(t));\r\n    point.y = y + (distance * Math.sin(t));\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = RotateAroundDistance;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmoothStep = function (x, min, max)\r\n{\r\n    if (x <= min)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (x >= max)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    x = (x - min) / (max - min);\r\n\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smoother interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.\r\n *\r\n * @function Phaser.Math.SmootherStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmootherStep = function (x, min, max)\r\n{\r\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\r\n\r\n    return x * x * x * (x * (x * 6 - 15) + 10);\r\n};\r\n\r\nmodule.exports = SmootherStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Wrap the given `value` between `min` and `max.\r\n *\r\n * @function Phaser.Math.Wrap\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to wrap.\r\n * @param {number} min - The minimum value.\r\n * @param {number} max - The maximum value.\r\n *\r\n * @return {number} The wrapped value.\r\n */\r\nvar Wrap = function (value, min, max)\r\n{\r\n    var range = max - min;\r\n\r\n    return (min + ((((value - min) % range) + range) % range));\r\n};\r\n\r\nmodule.exports = Wrap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\r\n *\r\n * Calculates the angle of the vector from the first point to the second point.\r\n *\r\n * @function Phaser.Math.Angle.BetweenPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Math.Vector2Like} point1 - The first point.\r\n * @param {Phaser.Types.Math.Vector2Like} point2 - The second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar BetweenPoints = function (point1, point2)\r\n{\r\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\r\n};\r\n\r\nmodule.exports = BetweenPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points), squared.\r\n *\r\n * @function Phaser.Math.Distance.Squared\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point, squared.\r\n */\r\nvar DistanceSquared = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return dx * dx + dy * dy;\r\n};\r\n\r\nmodule.exports = DistanceSquared;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily greater than `b`.\r\n *\r\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.GreaterThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\r\n */\r\nvar GreaterThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a > b - epsilon;\r\n};\r\n\r\nmodule.exports = GreaterThan;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check whether `a` is fuzzily less than `b`.\r\n *\r\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\r\n *\r\n * @function Phaser.Math.Fuzzy.LessThan\r\n * @since 3.0.0\r\n *\r\n * @param {number} a - The first value.\r\n * @param {number} b - The second value.\r\n * @param {number} [epsilon=0.0001] - The epsilon.\r\n *\r\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\r\n */\r\nvar LessThan = function (a, b, epsilon)\r\n{\r\n    if (epsilon === undefined) { epsilon = 0.0001; }\r\n\r\n    return a < b + epsilon;\r\n};\r\n\r\nmodule.exports = LessThan;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('./components');\nvar Image = require('../../gameobjects/image/Image');\n\n/**\n * @classdesc\n * An Arcade Physics Image is an Image with an Arcade Physics body and related components.\n * The body can be dynamic or static.\n *\n * The main difference between an Arcade Image and an Arcade Sprite is that you cannot animate an Arcade Image.\n *\n * @class Image\n * @extends Phaser.GameObjects.Image\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.Physics.Arcade.Components.Acceleration\n * @extends Phaser.Physics.Arcade.Components.Angular\n * @extends Phaser.Physics.Arcade.Components.Bounce\n * @extends Phaser.Physics.Arcade.Components.Debug\n * @extends Phaser.Physics.Arcade.Components.Drag\n * @extends Phaser.Physics.Arcade.Components.Enable\n * @extends Phaser.Physics.Arcade.Components.Friction\n * @extends Phaser.Physics.Arcade.Components.Gravity\n * @extends Phaser.Physics.Arcade.Components.Immovable\n * @extends Phaser.Physics.Arcade.Components.Mass\n * @extends Phaser.Physics.Arcade.Components.Pushable\n * @extends Phaser.Physics.Arcade.Components.Size\n * @extends Phaser.Physics.Arcade.Components.Velocity\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.Texture\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar ArcadeImage = new Class({\n\n    Extends: Image,\n\n    Mixins: [\n        Components.Acceleration,\n        Components.Angular,\n        Components.Bounce,\n        Components.Debug,\n        Components.Drag,\n        Components.Enable,\n        Components.Friction,\n        Components.Gravity,\n        Components.Immovable,\n        Components.Mass,\n        Components.Pushable,\n        Components.Size,\n        Components.Velocity\n    ],\n\n    initialize:\n\n    function ArcadeImage (scene, x, y, texture, frame)\n    {\n        Image.call(this, scene, x, y, texture, frame);\n\n        /**\n         * This Game Object's Physics Body.\n         *\n         * @name Phaser.Physics.Arcade.Image#body\n         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)}\n         * @default null\n         * @since 3.0.0\n         */\n        this.body = null;\n    }\n\n});\n\nmodule.exports = ArcadeImage;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\r\nvar Factory = require('./Factory');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar OverlapCirc = require('./components/OverlapCirc');\r\nvar OverlapRect = require('./components/OverlapRect');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar SceneEvents = require('../../scene/events');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar World = require('./World');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\r\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\r\n *\r\n * You can access it from within a Scene using `this.physics`.\r\n *\r\n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n *\r\n * @class ArcadePhysics\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\r\n */\r\nvar ArcadePhysics = new Class({\r\n\r\n    initialize:\r\n\r\n    function ArcadePhysics (scene)\r\n    {\r\n        /**\r\n         * The Scene that this Plugin belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#config\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldConfig}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = this.getConfig();\r\n\r\n        /**\r\n         * The physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world;\r\n\r\n        /**\r\n         * An object holding the Arcade Physics factory methods.\r\n         *\r\n         * @name Phaser.Physics.Arcade.ArcadePhysics#add\r\n         * @type {Phaser.Physics.Arcade.Factory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.world = new World(this.scene, this.config);\r\n        this.add = new Factory(this.world);\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            this.world = new World(this.scene, this.config);\r\n            this.add = new Factory(this.world);\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        if (!GetFastValue(this.config, 'customUpdate', false))\r\n        {\r\n            eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\r\n        }\r\n\r\n        eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Causes `World.update` to be automatically called each time the Scene\r\n     * emits and `UPDATE` event. This is the default setting, so only needs\r\n     * calling if you have specifically disabled it.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#enableUpdate\r\n     * @since 3.50.0\r\n     */\r\n    enableUpdate: function ()\r\n    {\r\n        this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world);\r\n    },\r\n\r\n    /**\r\n     * Causes `World.update` to **not** be automatically called each time the Scene\r\n     * emits and `UPDATE` event.\r\n     *\r\n     * If you wish to run the World update at your own rate, or from your own\r\n     * component, then you should call this method to disable the built-in link,\r\n     * and then call `World.update(delta, time)` accordingly.\r\n     *\r\n     * Note that `World.postUpdate` is always automatically called when the Scene\r\n     * emits a `POST_UPDATE` event, regardless of this setting.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#disableUpdate\r\n     * @since 3.50.0\r\n     */\r\n    disableUpdate: function ()\r\n    {\r\n        this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world);\r\n    },\r\n\r\n    /**\r\n     * Creates the physics configuration for the current Scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ArcadeWorldConfig} The physics configuration.\r\n     */\r\n    getConfig: function ()\r\n    {\r\n        var gameConfig = this.systems.game.config.physics;\r\n        var sceneConfig = this.systems.settings.physics;\r\n\r\n        var config = Merge(\r\n            GetFastValue(sceneConfig, 'arcade', {}),\r\n            GetFastValue(gameConfig, 'arcade', {})\r\n        );\r\n\r\n        return config;\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#overlap\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n     *\r\n     * If you don't require separation then use {@link #overlap} instead.\r\n     *\r\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n     *\r\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n     *\r\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n     *\r\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\r\n     * objects are passed to it.\r\n     *\r\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n     * dynamic maps, this method can prove very useful.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    pause: function ()\r\n    {\r\n        return this.world.pause();\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation (if paused).\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} The simulation.\r\n     */\r\n    resume: function ()\r\n    {\r\n        return this.world.resume();\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to accelerate towards.\r\n     * @param {number} y - The y coordinate to accelerate towards.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        gameObject.body.acceleration.setToPolar(angle, speed);\r\n\r\n        if (xSpeedMax !== undefined && ySpeedMax !== undefined)\r\n        {\r\n            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\r\n        }\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\r\n     *\r\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\r\n     *\r\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\r\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\r\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\r\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\r\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax)\r\n    {\r\n        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\r\n    },\r\n\r\n    /**\r\n     * Finds the Body or Game Object closest to a source point or object.\r\n     *\r\n     * If a `targets` argument is passed, this method finds the closest of those.\r\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n     *\r\n     * If no `targets` argument is passed, this method finds the closest Dynamic Body.\r\n     *\r\n     * If two or more targets are the exact same distance from the source point, only the first target\r\n     * is returned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n     *\r\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target closest to the given source point.\r\n     */\r\n    closest: function (source, targets)\r\n    {\r\n        if (!targets)\r\n        {\r\n            targets = this.world.bodies.entries;\r\n        }\r\n\r\n        var min = Number.MAX_VALUE;\r\n        var closest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n        var len = targets.length;\r\n\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var target = targets[i];\r\n            var body = target.body || target;\r\n\r\n            if (source === target || source === body || source === body.gameObject || source === body.center)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var distance = DistanceSquared(x, y, body.center.x, body.center.y);\r\n\r\n            if (distance < min)\r\n            {\r\n                closest = target;\r\n                min = distance;\r\n            }\r\n        }\r\n\r\n        return closest;\r\n    },\r\n\r\n    /**\r\n     * Finds the Body or Game Object farthest from a source point or object.\r\n     *\r\n     * If a `targets` argument is passed, this method finds the farthest of those.\r\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\r\n     *\r\n     * If no `targets` argument is passed, this method finds the farthest Dynamic Body.\r\n     *\r\n     * If two or more targets are the exact same distance from the source point, only the first target\r\n     * is returned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\r\n     *\r\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target farthest from the given source point.\r\n     */\r\n    furthest: function (source, targets)\r\n    {\r\n        if (!targets)\r\n        {\r\n            targets = this.world.bodies.entries;\r\n        }\r\n\r\n        var max = -1;\r\n        var farthest = null;\r\n        var x = source.x;\r\n        var y = source.y;\r\n        var len = targets.length;\r\n\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var target = targets[i];\r\n            var body = target.body || target;\r\n\r\n            if (source === target || source === body || source === body.gameObject || source === body.center)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var distance = DistanceSquared(x, y, body.center.x, body.center.y);\r\n\r\n            if (distance > max)\r\n            {\r\n                farthest = target;\r\n                max = distance;\r\n            }\r\n\r\n        }\r\n\r\n        return farthest;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the x/y coordinates at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {number} x - The x coordinate to move towards.\r\n     * @param {number} y - The y coordinate to move towards.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveTo: function (gameObject, x, y, speed, maxTime)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (maxTime === undefined) { maxTime = 0; }\r\n\r\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\r\n\r\n        if (maxTime > 0)\r\n        {\r\n            //  We know how many pixels we need to move, but how fast?\r\n            speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\r\n        }\r\n\r\n        gameObject.body.velocity.setToPolar(angle, speed);\r\n\r\n        return angle;\r\n    },\r\n\r\n    /**\r\n     * Move the given display object towards the destination object at a steady velocity.\r\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\r\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\r\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\r\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\r\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\r\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\r\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\r\n     *\r\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\r\n     */\r\n    moveToObject: function (gameObject, destination, speed, maxTime)\r\n    {\r\n        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\r\n    },\r\n\r\n    /**\r\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromAngle: function (angle, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(DegToRad(angle), speed);\r\n    },\r\n\r\n    /**\r\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\r\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rotation - The angle in radians.\r\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared\r\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\r\n     *\r\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\r\n     */\r\n    velocityFromRotation: function (rotation, speed, vec2)\r\n    {\r\n        if (speed === undefined) { speed = 60; }\r\n        if (vec2 === undefined) { vec2 = new Vector2(); }\r\n\r\n        return vec2.setToPolar(rotation, speed);\r\n    },\r\n\r\n    /**\r\n     * This method will search the given rectangular area and return an array of all physics bodies that\r\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n     *\r\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n     * contained within it.\r\n     *\r\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n     * otherwise the search is O(N) for Dynamic Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the area to search within.\r\n     * @param {number} y - The top-left y coordinate of the area to search within.\r\n     * @param {number} width - The width of the area to search within.\r\n     * @param {number} height - The height of the area to search within.\r\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n     */\r\n    overlapRect: function (x, y, width, height, includeDynamic, includeStatic)\r\n    {\r\n        return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);\r\n    },\r\n\r\n    /**\r\n     * This method will search the given circular area and return an array of all physics bodies that\r\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n     *\r\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n     * contained within it.\r\n     *\r\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\r\n     * otherwise the search is O(N) for Dynamic Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapCirc\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the area to search within.\r\n     * @param {number} y - The y coordinate of the center of the area to search within.\r\n     * @param {number} radius - The radius of the area to search within.\r\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n     */\r\n    overlapCirc: function (x, y, radius, includeDynamic, includeStatic)\r\n    {\r\n        return OverlapCirc(this.world, x, y, radius, includeDynamic, includeStatic);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            //  Already destroyed\r\n            return;\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\r\n        eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.add.destroy();\r\n        this.world.destroy();\r\n\r\n        this.add = null;\r\n        this.world = null;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\r\n\r\nmodule.exports = ArcadePhysics;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('./components');\nvar Sprite = require('../../gameobjects/sprite/Sprite');\n\n/**\n * @classdesc\n * An Arcade Physics Sprite is a Sprite with an Arcade Physics body and related components.\n * The body can be dynamic or static.\n *\n * The main difference between an Arcade Sprite and an Arcade Image is that you cannot animate an Arcade Image.\n * If you do not require animation then you can safely use Arcade Images instead of Arcade Sprites.\n *\n * @class Sprite\n * @extends Phaser.GameObjects.Sprite\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.Physics.Arcade.Components.Acceleration\n * @extends Phaser.Physics.Arcade.Components.Angular\n * @extends Phaser.Physics.Arcade.Components.Bounce\n * @extends Phaser.Physics.Arcade.Components.Debug\n * @extends Phaser.Physics.Arcade.Components.Drag\n * @extends Phaser.Physics.Arcade.Components.Enable\n * @extends Phaser.Physics.Arcade.Components.Friction\n * @extends Phaser.Physics.Arcade.Components.Gravity\n * @extends Phaser.Physics.Arcade.Components.Immovable\n * @extends Phaser.Physics.Arcade.Components.Mass\n * @extends Phaser.Physics.Arcade.Components.Pushable\n * @extends Phaser.Physics.Arcade.Components.Size\n * @extends Phaser.Physics.Arcade.Components.Velocity\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.Texture\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar ArcadeSprite = new Class({\n\n    Extends: Sprite,\n\n    Mixins: [\n        Components.Acceleration,\n        Components.Angular,\n        Components.Bounce,\n        Components.Debug,\n        Components.Drag,\n        Components.Enable,\n        Components.Friction,\n        Components.Gravity,\n        Components.Immovable,\n        Components.Mass,\n        Components.Pushable,\n        Components.Size,\n        Components.Velocity\n    ],\n\n    initialize:\n\n    function ArcadeSprite (scene, x, y, texture, frame)\n    {\n        Sprite.call(this, scene, x, y, texture, frame);\n\n        /**\n         * This Game Object's Physics Body.\n         *\n         * @name Phaser.Physics.Arcade.Sprite#body\n         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)}\n         * @default null\n         * @since 3.0.0\n         */\n        this.body = null;\n    }\n\n});\n\nmodule.exports = ArcadeSprite;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Benjamin D. Richards <benjamindrichards@gmail.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar RadToDeg = require('../../math/RadToDeg');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Dynamic Arcade Body.\r\n *\r\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\r\n *\r\n * @class Body\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\r\n */\r\nvar Body = new Class({\r\n\r\n    initialize:\r\n\r\n    function Body (world, gameObject)\r\n    {\r\n        var width = (gameObject.displayWidth) ? gameObject.displayWidth : 64;\r\n        var height = (gameObject.displayHeight) ? gameObject.displayHeight : 64;\r\n\r\n        /**\r\n         * The Arcade Physics simulation this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Game Object this Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameObject = gameObject;\r\n\r\n        /**\r\n         * Transformations applied to this Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#transform\r\n         * @type {object}\r\n         * @since 3.4.0\r\n         */\r\n        this.transform = {\r\n            x: gameObject.x,\r\n            y: gameObject.y,\r\n            rotation: gameObject.angle,\r\n            scaleX: gameObject.scaleX,\r\n            scaleY: gameObject.scaleY,\r\n            displayOriginX: gameObject.displayOriginX,\r\n            displayOriginY: gameObject.displayOriginY\r\n        };\r\n\r\n        /**\r\n         * Whether the Body is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowBody = world.defaults.debugShowBody;\r\n\r\n        /**\r\n         * Whether the Body's velocity is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugShowVelocity\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowVelocity = world.defaults.debugShowVelocity;\r\n\r\n        /**\r\n         * The color of this Body on the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#debugBodyColor\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugBodyColor = world.defaults.bodyDebugColor;\r\n\r\n        /**\r\n         * Whether this Body is updated by the physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enable = true;\r\n\r\n        /**\r\n         * Whether this Body is circular (true) or rectangular (false).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.isCircle = false;\r\n\r\n        /**\r\n         * If this Body is circular, this is the unscaled radius of the Body, as set by setCircle(), in source pixels.\r\n         * The true radius is equal to `halfWidth`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setCircle\r\n         */\r\n        this.radius = 0;\r\n\r\n        /**\r\n         * The offset of this Body's position from its Game Object's position, in source pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setOffset\r\n         */\r\n        this.offset = new Vector2();\r\n\r\n        /**\r\n         * The position of this Body within the simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2(\r\n            gameObject.x - gameObject.scaleX * gameObject.displayOriginX,\r\n            gameObject.y - gameObject.scaleY * gameObject.displayOriginY\r\n        );\r\n\r\n        /**\r\n         * The position of this Body during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#prev\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.prev = this.position.clone();\r\n\r\n        /**\r\n         * The position of this Body during the previous frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#prevFrame\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.20.0\r\n         */\r\n        this.prevFrame = this.position.clone();\r\n\r\n        /**\r\n         * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowRotation\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowRotation = true;\r\n\r\n        /**\r\n         * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\r\n         * The Body's rotation controls the `angle` of its Game Object.\r\n         * It doesn't rotate the Body's own geometry, which is always an axis-aligned rectangle or a circle.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = gameObject.angle;\r\n\r\n        /**\r\n         * The Body rotation, in degrees, during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#preRotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.preRotation = gameObject.angle;\r\n\r\n        /**\r\n         * The width of the Body, in pixels.\r\n         * If the Body is circular, this is also the diameter.\r\n         * If you wish to change the width use the `Body.setSize` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#width\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Body, in pixels.\r\n         * If the Body is circular, this is also the diameter.\r\n         * If you wish to change the height use the `Body.setSize` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#height\r\n         * @type {number}\r\n         * @readonly\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The unscaled width of the Body, in source pixels, as set by setSize().\r\n         * The default is the width of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceWidth = width;\r\n\r\n        /**\r\n         * The unscaled height of the Body, in source pixels, as set by setSize().\r\n         * The default is the height of the Body's Game Object's texture frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#sourceHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#setSize\r\n         */\r\n        this.sourceHeight = height;\r\n\r\n        if (gameObject.frame)\r\n        {\r\n            this.sourceWidth = gameObject.frame.realWidth;\r\n            this.sourceHeight = gameObject.frame.realHeight;\r\n        }\r\n\r\n        /**\r\n         * Half the Body's width, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth = Math.abs(width / 2);\r\n\r\n        /**\r\n         * Half the Body's height, in pixels.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight = Math.abs(height / 2);\r\n\r\n        /**\r\n         * The center of the Body.\r\n         * The midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n\r\n        /**\r\n         * The Body's velocity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.velocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's change in position (due to velocity) at the last step, in pixels.\r\n         *\r\n         * The size of this value depends on the simulation's step rate.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#newVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.newVelocity = new Vector2();\r\n\r\n        /**\r\n         * The Body's absolute maximum change in position, in pixels per step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#deltaMax\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.deltaMax = new Vector2();\r\n\r\n        /**\r\n         * The Body's change in velocity, in pixels per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#acceleration\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.acceleration = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's velocity is affected by its `drag`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowDrag\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.allowDrag = true;\r\n\r\n        /**\r\n         * When `useDamping` is false (the default), this is absolute loss of velocity due to movement, in pixels per second squared.\r\n         *\r\n         * When `useDamping` is true, this is a damping multiplier between 0 and 1.\r\n         * A value of 0 means the Body stops instantly.\r\n         * A value of 0.01 mean the Body keeps 1% of its velocity per second, losing 99%.\r\n         * A value of 0.1 means the Body keeps 10% of its velocity per second, losing 90%.\r\n         * A value of 1 means the Body loses no velocity.\r\n         * You can use very small values (e.g., 0.001) to stop the Body quickly.\r\n         *\r\n         * The x and y components are applied separately.\r\n         *\r\n         * Drag is applied only when `acceleration` is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#drag\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.drag = new Vector2();\r\n\r\n        /**\r\n         * Whether this Body's position is affected by gravity (local or world).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#allowGravity\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.Body#gravity\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.allowGravity = true;\r\n\r\n        /**\r\n         * Acceleration due to gravity (specific to this Body), in pixels per second squared.\r\n         * Total gravity is the sum of this vector and the simulation's `gravity`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#gravity\r\n         */\r\n        this.gravity = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision, relative to 1.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = new Vector2();\r\n\r\n        /**\r\n         * Rebound following a collision with the world boundary, relative to 1.\r\n         * If null, `bounce` is used instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#worldBounce\r\n         * @type {?Phaser.Math.Vector2}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.worldBounce = null;\r\n\r\n        /**\r\n         * The rectangle used for world boundary collisions.\r\n         *\r\n         * By default it is set to the world boundary rectangle. Or, if this Body was\r\n         * created by a Physics Group, then whatever rectangle that Group defined.\r\n         *\r\n         * You can also change it by using the `Body.setBoundsRectangle` method.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customBoundsRectangle\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.20\r\n         */\r\n        this.customBoundsRectangle = world.bounds;\r\n\r\n        //  If true this Body will dispatch events\r\n\r\n        /**\r\n         * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#WORLD_BOUNDS\r\n         */\r\n        this.onWorldBounds = false;\r\n\r\n        /**\r\n         * Whether the simulation emits a `collide` event when this Body collides with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#COLLIDE\r\n         */\r\n        this.onCollide = false;\r\n\r\n        /**\r\n         * Whether the simulation emits an `overlap` event when this Body overlaps with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.Physics.Arcade.World#OVERLAP\r\n         */\r\n        this.onOverlap = false;\r\n\r\n        /**\r\n         * The Body's absolute maximum velocity, in pixels per second.\r\n         * The horizontal and vertical components are applied separately.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxVelocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocity = new Vector2(10000, 10000);\r\n\r\n        /**\r\n         * The maximum speed this Body is allowed to reach, in pixels per second.\r\n         *\r\n         * If not negative it limits the scalar value of speed.\r\n         *\r\n         * Any negative value means no maximum is being applied (the default).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxSpeed\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.16.0\r\n         */\r\n        this.maxSpeed = -1;\r\n\r\n        /**\r\n         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\r\n         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\r\n         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\r\n         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#friction\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.friction = new Vector2(1, 0);\r\n\r\n        /**\r\n         * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n         * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n         * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n         * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n         *\r\n         * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n         * they are used as a multiplier on the velocity. Values such as 0.05 will give a nice slow\r\n         * deceleration.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#useDamping\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.10.0\r\n         */\r\n        this.useDamping = false;\r\n\r\n        /**\r\n         * The rate of change of this Body's `rotation`, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularVelocity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularVelocity = 0;\r\n\r\n        /**\r\n         * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularAcceleration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularAcceleration = 0;\r\n\r\n        /**\r\n         * Loss of angular velocity due to angular movement, in degrees per second.\r\n         *\r\n         * Angular drag is applied only when angular acceleration is zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angularDrag\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angularDrag = 0;\r\n\r\n        /**\r\n         * The Body's maximum angular velocity, in degrees per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#maxAngular\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxAngular = 1000;\r\n\r\n        /**\r\n         * The Body's inertia, relative to a default unit (1).\r\n         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.mass = 1;\r\n\r\n        /**\r\n         * The calculated angle of this Body's velocity vector, in radians, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#speed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.speed = 0;\r\n\r\n        /**\r\n         * The direction of the Body's velocity, as calculated during the last step.\r\n         * This is a numeric constant value (FACING_UP, FACING_DOWN, FACING_LEFT, FACING_RIGHT).\r\n         * If the Body is moving on both axes, this describes motion on the vertical axis only.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#facing\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.FACING_UP\r\n         * @see Phaser.Physics.Arcade.FACING_DOWN\r\n         * @see Phaser.Physics.Arcade.FACING_LEFT\r\n         * @see Phaser.Physics.Arcade.FACING_RIGHT\r\n         */\r\n        this.facing = CONST.FACING_NONE;\r\n\r\n        /**\r\n         * Whether this Body can be moved by collisions with another Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#immovable\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.immovable = false;\r\n\r\n        /**\r\n         * Sets if this Body can be pushed by another Body.\r\n         *\r\n         * A body that cannot be pushed will reflect back all of the velocity it is given to the\r\n         * colliding body. If that body is also not pushable, then the separation will be split\r\n         * between them evenly.\r\n         *\r\n         * If you want your body to never move or seperate at all, see the `setImmovable` method.\r\n         *\r\n         * By default, Dynamic Bodies are always pushable.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#pushable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.50.0\r\n         * @see Phaser.GameObjects.Components.Pushable#setPushable\r\n         */\r\n        this.pushable = true;\r\n\r\n        /**\r\n         * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#moves\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.moves = true;\r\n\r\n        /**\r\n         * A flag disabling the default horizontal separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateX = false;\r\n\r\n        /**\r\n         * A flag disabling the default vertical separation of colliding bodies.\r\n         * Pass your own `collideCallback` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateY = false;\r\n\r\n        /**\r\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapX = 0;\r\n\r\n        /**\r\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapY = 0;\r\n\r\n        /**\r\n         * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapR = 0;\r\n\r\n        /**\r\n         * Whether this Body is overlapped with another and both are not moving, on at least one axis.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.embedded = false;\r\n\r\n        /**\r\n         * Whether this Body interacts with the world boundary.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#collideWorldBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.collideWorldBounds = false;\r\n\r\n        /**\r\n         * Whether this Body is checked for collisions and for which directions.\r\n         * You can set `checkCollision.none = true` to disable collision checks.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#checkCollision\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\r\n\r\n        /**\r\n         * Whether this Body is colliding with a Body or Static Body and in which direction.\r\n         * In a collision where both bodies have zero velocity, `embedded` will be set instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#touching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#blocked\r\n         * @see Phaser.Physics.Arcade.Body#embedded\r\n         */\r\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * This Body's `touching` value during the previous step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#wasTouching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#touching\r\n         */\r\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether this Body is colliding with a Static Body, a tile, or the world boundary.\r\n         * In a collision with a Static Body, if this Body has zero velocity then `embedded` will be set instead.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#blocked\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         *\r\n         * @see Phaser.Physics.Arcade.Body#embedded\r\n         * @see Phaser.Physics.Arcade.Body#touching\r\n         */\r\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#syncBounds\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Components.GetBounds#getBounds\r\n         */\r\n        this.syncBounds = false;\r\n\r\n        /**\r\n         * The Body's physics type (dynamic or static).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#physicsType\r\n         * @type {number}\r\n         * @readonly\r\n         * @default Phaser.Physics.Arcade.DYNAMIC_BODY\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.DYNAMIC_BODY;\r\n\r\n        /**\r\n         * Cached horizontal scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sx\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sx = gameObject.scaleX;\r\n\r\n        /**\r\n         * Cached vertical scale of the Body's Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_sy\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._sy = gameObject.scaleY;\r\n\r\n        /**\r\n         * The calculated change in the Body's horizontal position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dx = 0;\r\n\r\n        /**\r\n         * The calculated change in the Body's vertical position during the last step.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._dy = 0;\r\n\r\n        /**\r\n         * The final calculated change in the Body's horizontal position as of `postUpdate`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_tx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.22.0\r\n         */\r\n        this._tx = 0;\r\n\r\n        /**\r\n         * The final calculated change in the Body's vertical position as of `postUpdate`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_ty\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.22.0\r\n         */\r\n        this._ty = 0;\r\n\r\n        /**\r\n         * Stores the Game Object's bounds.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Body#_bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = new Rectangle();\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\r\n     * The Body's `position` isn't changed.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateBounds\r\n     * @since 3.0.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var sprite = this.gameObject;\r\n\r\n        //  Container?\r\n\r\n        var transform = this.transform;\r\n\r\n        if (sprite.parentContainer)\r\n        {\r\n            var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\r\n\r\n            transform.x = matrix.tx;\r\n            transform.y = matrix.ty;\r\n            transform.rotation = RadToDeg(matrix.rotation);\r\n            transform.scaleX = matrix.scaleX;\r\n            transform.scaleY = matrix.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n        else\r\n        {\r\n            transform.x = sprite.x;\r\n            transform.y = sprite.y;\r\n            transform.rotation = sprite.angle;\r\n            transform.scaleX = sprite.scaleX;\r\n            transform.scaleY = sprite.scaleY;\r\n            transform.displayOriginX = sprite.displayOriginX;\r\n            transform.displayOriginY = sprite.displayOriginY;\r\n        }\r\n\r\n        var recalc = false;\r\n\r\n        if (this.syncBounds)\r\n        {\r\n            var b = sprite.getBounds(this._bounds);\r\n\r\n            this.width = b.width;\r\n            this.height = b.height;\r\n            recalc = true;\r\n        }\r\n        else\r\n        {\r\n            var asx = Math.abs(transform.scaleX);\r\n            var asy = Math.abs(transform.scaleY);\r\n\r\n            if (this._sx !== asx || this._sy !== asy)\r\n            {\r\n                this.width = this.sourceWidth * asx;\r\n                this.height = this.sourceHeight * asy;\r\n                this._sx = asx;\r\n                this._sy = asy;\r\n                recalc = true;\r\n            }\r\n        }\r\n\r\n        if (recalc)\r\n        {\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n            this.updateCenter();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `center` from its `position`, `width`, and `height`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateCenter\r\n     * @since 3.0.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n    },\r\n\r\n    /**\r\n     * Updates the Body's `position`, `width`, `height`, and `center` from its Game Object and `offset`.\r\n     *\r\n     * You don't need to call this for Dynamic Bodies, as it happens automatically during the physics step.\r\n     * But you could use it if you have modified the Body offset or Game Object transform and need to immediately\r\n     * read the Body's new `position` or `center`.\r\n     *\r\n     * To resynchronize the Body with its Game Object, use `reset()` instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#updateFromGameObject\r\n     * @since 3.24.0\r\n     */\r\n    updateFromGameObject: function ()\r\n    {\r\n        this.updateBounds();\r\n\r\n        var transform = this.transform;\r\n\r\n        this.position.x = transform.x + transform.scaleX * (this.offset.x - transform.displayOriginX);\r\n        this.position.y = transform.y + transform.scaleY * (this.offset.y - transform.displayOriginY);\r\n\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Prepares the Body for a physics step by resetting the `wasTouching`, `touching` and `blocked` states.\r\n     *\r\n     * This method is only called if the physics world is going to run a step this frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#resetFlags\r\n     * @since 3.18.0\r\n     *\r\n     * @param {boolean} [clear=false] - Set the `wasTouching` values to their defaults.\r\n     */\r\n    resetFlags: function (clear)\r\n    {\r\n        if (clear === undefined)\r\n        {\r\n            clear = false;\r\n        }\r\n\r\n        //  Store and reset collision flags\r\n        var wasTouching = this.wasTouching;\r\n        var touching = this.touching;\r\n        var blocked = this.blocked;\r\n\r\n        if (clear)\r\n        {\r\n            wasTouching.none = true;\r\n            wasTouching.up = false;\r\n            wasTouching.down = false;\r\n            wasTouching.left = false;\r\n            wasTouching.right = false;\r\n        }\r\n        else\r\n        {\r\n            wasTouching.none = touching.none;\r\n            wasTouching.up = touching.up;\r\n            wasTouching.down = touching.down;\r\n            wasTouching.left = touching.left;\r\n            wasTouching.right = touching.right;\r\n        }\r\n\r\n        touching.none = true;\r\n        touching.up = false;\r\n        touching.down = false;\r\n        touching.left = false;\r\n        touching.right = false;\r\n\r\n        blocked.none = true;\r\n        blocked.up = false;\r\n        blocked.down = false;\r\n        blocked.left = false;\r\n        blocked.right = false;\r\n\r\n        this.overlapR = 0;\r\n        this.overlapX = 0;\r\n        this.overlapY = 0;\r\n\r\n        this.embedded = false;\r\n    },\r\n\r\n    /**\r\n     * Syncs the position body position with the parent Game Object.\r\n     *\r\n     * This method is called every game frame, regardless if the world steps or not.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#preUpdate\r\n     * @since 3.17.0\r\n     *\r\n     * @param {boolean} willStep - Will this Body run an update as well?\r\n     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (willStep, delta)\r\n    {\r\n        if (willStep)\r\n        {\r\n            this.resetFlags();\r\n        }\r\n\r\n        this.updateFromGameObject();\r\n\r\n        this.rotation = this.transform.rotation;\r\n        this.preRotation = this.rotation;\r\n\r\n        if (this.moves)\r\n        {\r\n            this.prev.x = this.position.x;\r\n            this.prev.y = this.position.y;\r\n            this.prevFrame.x = this.position.x;\r\n            this.prevFrame.y = this.position.y;\r\n        }\r\n\r\n        if (willStep)\r\n        {\r\n            this.update(delta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Performs a single physics step and updates the body velocity, angle, speed and other properties.\r\n     *\r\n     * This method can be called multiple times per game frame, depending on the physics step rate.\r\n     *\r\n     * The results are synced back to the Game Object in `postUpdate`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#update\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_BOUNDS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\r\n     */\r\n    update: function (delta)\r\n    {\r\n        this.prev.x = this.position.x;\r\n        this.prev.y = this.position.y;\r\n\r\n        if (this.moves)\r\n        {\r\n            this.world.updateMotion(this, delta);\r\n\r\n            var vx = this.velocity.x;\r\n            var vy = this.velocity.y;\r\n\r\n            this.newVelocity.set(vx * delta, vy * delta);\r\n\r\n            this.position.add(this.newVelocity);\r\n\r\n            this.updateCenter();\r\n\r\n            this.angle = Math.atan2(vy, vx);\r\n            this.speed = Math.sqrt(vx * vx + vy * vy);\r\n\r\n            //  Now the update will throw collision checks at the Body\r\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\r\n\r\n            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds)\r\n            {\r\n                this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\r\n            }\r\n        }\r\n\r\n        this._dx = this.position.x - this.prev.x;\r\n        this._dy = this.position.y - this.prev.y;\r\n    },\r\n\r\n    /**\r\n     * Feeds the Body results back into the parent Game Object.\r\n     *\r\n     * This method is called every game frame, regardless if the world steps or not.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#postUpdate\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        var dx = this.position.x - this.prevFrame.x;\r\n        var dy = this.position.y - this.prevFrame.y;\r\n\r\n        if (this.moves)\r\n        {\r\n            var mx = this.deltaMax.x;\r\n            var my = this.deltaMax.y;\r\n\r\n            if (mx !== 0 && dx !== 0)\r\n            {\r\n                if (dx < 0 && dx < -mx)\r\n                {\r\n                    dx = -mx;\r\n                }\r\n                else if (dx > 0 && dx > mx)\r\n                {\r\n                    dx = mx;\r\n                }\r\n            }\r\n\r\n            if (my !== 0 && dy !== 0)\r\n            {\r\n                if (dy < 0 && dy < -my)\r\n                {\r\n                    dy = -my;\r\n                }\r\n                else if (dy > 0 && dy > my)\r\n                {\r\n                    dy = my;\r\n                }\r\n            }\r\n\r\n            this.gameObject.x += dx;\r\n            this.gameObject.y += dy;\r\n        }\r\n\r\n        if (dx < 0)\r\n        {\r\n            this.facing = CONST.FACING_LEFT;\r\n        }\r\n        else if (dx > 0)\r\n        {\r\n            this.facing = CONST.FACING_RIGHT;\r\n        }\r\n\r\n        if (dy < 0)\r\n        {\r\n            this.facing = CONST.FACING_UP;\r\n        }\r\n        else if (dy > 0)\r\n        {\r\n            this.facing = CONST.FACING_DOWN;\r\n        }\r\n\r\n        if (this.allowRotation)\r\n        {\r\n            this.gameObject.angle += this.deltaZ();\r\n        }\r\n\r\n        this._tx = dx;\r\n        this._ty = dy;\r\n    },\r\n\r\n    /**\r\n     * Sets a custom collision boundary rectangle. Use if you want to have a custom\r\n     * boundary instead of the world boundaries.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBoundsRectangle\r\n     * @since 3.20\r\n     *\r\n     * @param {?Phaser.Geom.Rectangle} [bounds] - The new boundary rectangle. Pass `null` to use the World bounds.\r\n     *\r\n     * @return {this} This Body object.\r\n     */\r\n    setBoundsRectangle: function (bounds)\r\n    {\r\n        this.customBoundsRectangle = (!bounds) ? this.world.bounds : bounds;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks for collisions between this Body and the world boundary and separates them.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#checkWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if this Body is colliding with the world boundary.\r\n     */\r\n    checkWorldBounds: function ()\r\n    {\r\n        var pos = this.position;\r\n        var bounds = this.customBoundsRectangle;\r\n        var check = this.world.checkCollision;\r\n\r\n        var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x;\r\n        var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y;\r\n\r\n        var wasSet = false;\r\n\r\n        if (pos.x < bounds.x && check.left)\r\n        {\r\n            pos.x = bounds.x;\r\n            this.velocity.x *= bx;\r\n            this.blocked.left = true;\r\n            wasSet = true;\r\n        }\r\n        else if (this.right > bounds.right && check.right)\r\n        {\r\n            pos.x = bounds.right - this.width;\r\n            this.velocity.x *= bx;\r\n            this.blocked.right = true;\r\n            wasSet = true;\r\n        }\r\n\r\n        if (pos.y < bounds.y && check.up)\r\n        {\r\n            pos.y = bounds.y;\r\n            this.velocity.y *= by;\r\n            this.blocked.up = true;\r\n            wasSet = true;\r\n        }\r\n        else if (this.bottom > bounds.bottom && check.down)\r\n        {\r\n            pos.y = bounds.bottom - this.height;\r\n            this.velocity.y *= by;\r\n            this.blocked.down = true;\r\n            wasSet = true;\r\n        }\r\n\r\n        if (wasSet)\r\n        {\r\n            this.blocked.none = false;\r\n            this.updateCenter();\r\n        }\r\n\r\n        return wasSet;\r\n    },\r\n\r\n    /**\r\n     * Sets the offset of the Body's position from its Game Object's position.\r\n     * The Body's `position` isn't changed until the next `preUpdate`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal offset, in source pixels.\r\n     * @param {number} [y=x] - The vertical offset, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setOffset: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.offset.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body, as a rectangle.\r\n     * Modifies the Body `offset` if `center` is true (the default).\r\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n     * @param {number} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n     * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setSize: function (width, height, center)\r\n    {\r\n        if (center === undefined) { center = true; }\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        if (!width && gameObject.frame)\r\n        {\r\n            width = gameObject.frame.realWidth;\r\n        }\r\n\r\n        if (!height && gameObject.frame)\r\n        {\r\n            height = gameObject.frame.realHeight;\r\n        }\r\n\r\n        this.sourceWidth = width;\r\n        this.sourceHeight = height;\r\n\r\n        this.width = this.sourceWidth * this._sx;\r\n        this.height = this.sourceHeight * this._sy;\r\n\r\n        this.halfWidth = Math.floor(this.width / 2);\r\n        this.halfHeight = Math.floor(this.height / 2);\r\n\r\n        this.updateCenter();\r\n\r\n        if (center && gameObject.getCenter)\r\n        {\r\n            var ox = (gameObject.width - width) / 2;\r\n            var oy = (gameObject.height - height) / 2;\r\n\r\n            this.offset.set(ox, oy);\r\n        }\r\n\r\n        this.isCircle = false;\r\n        this.radius = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sizes and positions this Body, as a circle.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the Body, in source pixels.\r\n     * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\r\n     * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCircle: function (radius, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        if (radius > 0)\r\n        {\r\n            this.isCircle = true;\r\n            this.radius = radius;\r\n\r\n            this.sourceWidth = radius * 2;\r\n            this.sourceHeight = radius * 2;\r\n\r\n            this.width = this.sourceWidth * this._sx;\r\n            this.height = this.sourceHeight * this._sy;\r\n\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n\r\n            this.offset.set(offsetX, offsetY);\r\n\r\n            this.updateCenter();\r\n        }\r\n        else\r\n        {\r\n            this.isCircle = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Body's parent Game Object to the given coordinates and resets this Body at the new coordinates.\r\n     * If the Body had any velocity or acceleration it is lost as a result of calling this.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position to place the Game Object.\r\n     * @param {number} y - The vertical position to place the Game Object.\r\n     */\r\n    reset: function (x, y)\r\n    {\r\n        this.stop();\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        if (gameObject.getTopLeft)\r\n        {\r\n            gameObject.getTopLeft(this.position);\r\n        }\r\n        else\r\n        {\r\n            this.position.set(x, y);\r\n        }\r\n\r\n        this.prev.copy(this.position);\r\n        this.prevFrame.copy(this.position);\r\n\r\n        this.rotation = gameObject.angle;\r\n        this.preRotation = gameObject.angle;\r\n\r\n        this.updateBounds();\r\n        this.updateCenter();\r\n        this.resetFlags(true);\r\n    },\r\n\r\n    /**\r\n     * Sets acceleration, velocity, and speed to zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.velocity.set(0);\r\n        this.acceleration.set(0);\r\n        this.speed = 0;\r\n        this.angularVelocity = 0;\r\n        this.angularAcceleration = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Copies the coordinates of this Body's edges into an object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\r\n     */\r\n    getBounds: function (obj)\r\n    {\r\n        obj.x = this.x;\r\n        obj.y = this.y;\r\n        obj.right = this.right;\r\n        obj.bottom = this.bottom;\r\n\r\n        return obj;\r\n    },\r\n\r\n    /**\r\n     * Tests if the coordinates are within this Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate.\r\n     * @param {number} y - The vertical coordinate.\r\n     *\r\n     * @return {boolean} True if (x, y) is within this Body.\r\n     */\r\n    hitTest: function (x, y)\r\n    {\r\n        if (!this.isCircle)\r\n        {\r\n            return RectangleContains(this, x, y);\r\n        }\r\n\r\n        //  Check if x/y are within the bounds first\r\n        if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom)\r\n        {\r\n            var dx = (this.center.x - x) * (this.center.x - x);\r\n            var dy = (this.center.y - y) * (this.center.y - y);\r\n\r\n            return (dx + dy) <= (this.radius * this.radius);\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving down.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onFloor\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onFloor: function ()\r\n    {\r\n        return this.blocked.down;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving up.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onCeiling\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onCeiling: function ()\r\n    {\r\n        return this.blocked.up;\r\n    },\r\n\r\n    /**\r\n     * Whether this Body is touching a tile or the world boundary while moving left or right.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#onWall\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.Body#blocked\r\n     *\r\n     * @return {boolean} True if touching.\r\n     */\r\n    onWall: function ()\r\n    {\r\n        return (this.blocked.left || this.blocked.right);\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's horizontal position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsX: function ()\r\n    {\r\n        return (this._dx > 0) ? this._dx : -this._dx;\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this Body's vertical position from the previous step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaAbsY: function ()\r\n    {\r\n        return (this._dy > 0) ? this._dy : -this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's horizontal position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     *\r\n     * As a Body can update multiple times per step this may not hold the final\r\n     * delta value for the Body. In this case, please see the `deltaXFinal` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaX: function ()\r\n    {\r\n        return this._dx;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's vertical position from the previous step.\r\n     * This value is set during the Body's update phase.\r\n     *\r\n     * As a Body can update multiple times per step this may not hold the final\r\n     * delta value for the Body. In this case, please see the `deltaYFinal` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaY: function ()\r\n    {\r\n        return this._dy;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's horizontal position from the previous game update.\r\n     *\r\n     * This value is set during the `postUpdate` phase and takes into account the\r\n     * `deltaMax` and final position of the Body.\r\n     *\r\n     * Because this value is not calculated until `postUpdate`, you must listen for it\r\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n     * not be calculated by that point. If you _do_ use these values in `update` they\r\n     * will represent the delta from the _previous_ game frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaXFinal\r\n     * @since 3.22.0\r\n     *\r\n     * @return {number} The final delta x value.\r\n     */\r\n    deltaXFinal: function ()\r\n    {\r\n        return this._tx;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's vertical position from the previous game update.\r\n     *\r\n     * This value is set during the `postUpdate` phase and takes into account the\r\n     * `deltaMax` and final position of the Body.\r\n     *\r\n     * Because this value is not calculated until `postUpdate`, you must listen for it\r\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\r\n     * not be calculated by that point. If you _do_ use these values in `update` they\r\n     * will represent the delta from the _previous_ game frame.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaYFinal\r\n     * @since 3.22.0\r\n     *\r\n     * @return {number} The final delta y value.\r\n     */\r\n    deltaYFinal: function ()\r\n    {\r\n        return this._ty;\r\n    },\r\n\r\n    /**\r\n     * The change in this Body's rotation from the previous step, in degrees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The delta value.\r\n     */\r\n    deltaZ: function ()\r\n    {\r\n        return this.rotation - this.preRotation;\r\n    },\r\n\r\n    /**\r\n     * Disables this Body and marks it for deletion by the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enable = false;\r\n\r\n        if (this.world)\r\n        {\r\n            this.world.pendingDestroy.set(this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Draws this Body and its velocity, if enabled.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\r\n     */\r\n    drawDebug: function (graphic)\r\n    {\r\n        var pos = this.position;\r\n\r\n        var x = pos.x + this.halfWidth;\r\n        var y = pos.y + this.halfHeight;\r\n\r\n        if (this.debugShowBody)\r\n        {\r\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\r\n\r\n            if (this.isCircle)\r\n            {\r\n                graphic.strokeCircle(x, y, this.width / 2);\r\n            }\r\n            else\r\n            {\r\n                //  Only draw the sides where checkCollision is true, similar to debugger in layer\r\n                if (this.checkCollision.up)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);\r\n                }\r\n\r\n                if (this.checkCollision.right)\r\n                {\r\n                    graphic.lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);\r\n                }\r\n\r\n                if (this.checkCollision.down)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);\r\n                }\r\n\r\n                if (this.checkCollision.left)\r\n                {\r\n                    graphic.lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.debugShowVelocity)\r\n        {\r\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\r\n            graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Whether this Body will be drawn to the debug display.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\r\n     */\r\n    willDrawDebug: function ()\r\n    {\r\n        return (this.debugShowBody || this.debugShowVelocity);\r\n    },\r\n\r\n    /**\r\n     * Sets whether this Body collides with the world boundary.\r\n     *\r\n     * Optionally also sets the World Bounce and `onWorldBounds` values.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - `true` if the Body should collide with the world bounds, otherwise `false`.\r\n     * @param {number} [bounceX] - If given this replaces the Body's `worldBounce.x` value.\r\n     * @param {number} [bounceY] - If given this replaces the Body's `worldBounce.y` value.\r\n     * @param {boolean} [onWorldBounds] - If given this replaces the Body's `onWorldBounds` value.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setCollideWorldBounds: function (value, bounceX, bounceY, onWorldBounds)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.collideWorldBounds = value;\r\n\r\n        var setBounceX = (bounceX !== undefined);\r\n        var setBounceY = (bounceY !== undefined);\r\n\r\n        if (setBounceX || setBounceY)\r\n        {\r\n            if (!this.worldBounce)\r\n            {\r\n                this.worldBounce = new Vector2();\r\n            }\r\n\r\n            if (setBounceX)\r\n            {\r\n                this.worldBounce.x = bounceX;\r\n            }\r\n\r\n            if (setBounceY)\r\n            {\r\n                this.worldBounce.y = bounceY;\r\n            }\r\n        }\r\n\r\n        if (onWorldBounds !== undefined)\r\n        {\r\n            this.onWorldBounds = onWorldBounds;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocity: function (x, y)\r\n    {\r\n        this.velocity.set(x, y);\r\n\r\n        x = this.velocity.x;\r\n        y = this.velocity.y;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityX: function (value)\r\n    {\r\n        this.velocity.x = value;\r\n\r\n        var x = value;\r\n        var y = this.velocity.y;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setVelocityY: function (value)\r\n    {\r\n        this.velocity.y = value;\r\n\r\n        var x = this.velocity.x;\r\n        var y = value;\r\n\r\n        this.speed = Math.sqrt(x * x + y * y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's maximum velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} x - The horizontal velocity, in pixels per second.\r\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxVelocity: function (x, y)\r\n    {\r\n        this.maxVelocity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's maximum horizontal velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocityX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} value - The maximum horizontal velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxVelocityX: function (value)\r\n    {\r\n        this.maxVelocity.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's maximum vertical velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocityY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} value - The maximum vertical velocity, in pixels per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxVelocityY: function (value)\r\n    {\r\n        this.maxVelocity.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum speed the Body can move.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMaxSpeed\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMaxSpeed: function (value)\r\n    {\r\n        this.maxSpeed = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal bounce, relative to 1.\r\n     * @param {number} y - The vertical bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounce: function (x, y)\r\n    {\r\n        this.bounce.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceX: function (value)\r\n    {\r\n        this.bounce.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical bounce.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The bounce, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setBounceY: function (value)\r\n    {\r\n        this.bounce.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAcceleration: function (x, y)\r\n    {\r\n        this.acceleration.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationX: function (value)\r\n    {\r\n        this.acceleration.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAccelerationY: function (value)\r\n    {\r\n        this.acceleration.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowDrag\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowDrag\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowDrag: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables gravity's effect on this Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowGravity\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowGravity\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowGravity: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowGravity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables rotation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAllowRotation\r\n     * @since 3.9.0\r\n     * @see Phaser.Physics.Arcade.Body#allowRotation\r\n     *\r\n     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAllowRotation: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.allowRotation = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDrag: function (x, y)\r\n    {\r\n        this.drag.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Body is using `drag` for deceleration this property controls how the drag is applied.\r\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n     *\r\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDamping\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} value - `true` to use damping, or `false` to use drag.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDamping: function (value)\r\n    {\r\n        this.useDamping = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragX: function (value)\r\n    {\r\n        this.drag.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setDragY: function (value)\r\n    {\r\n        this.drag.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, in pixels per second squared.\r\n     * @param {number} y - The vertical component, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.gravity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityX: function (value)\r\n    {\r\n        this.gravity.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical gravity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The gravity, in pixels per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setGravityY: function (value)\r\n    {\r\n        this.gravity.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal component, relative to 1.\r\n     * @param {number} y - The vertical component, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFriction: function (x, y)\r\n    {\r\n        this.friction.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's horizontal friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionX: function (value)\r\n    {\r\n        this.friction.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's vertical friction.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The friction value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setFrictionY: function (value)\r\n    {\r\n        this.friction.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity, in degrees per second.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularVelocity: function (value)\r\n    {\r\n        this.angularVelocity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The acceleration, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularAcceleration: function (value)\r\n    {\r\n        this.angularAcceleration = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's angular drag.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The drag, in degrees per second squared.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setAngularDrag: function (value)\r\n    {\r\n        this.angularDrag = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's mass.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The mass value, relative to 1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        this.mass = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's `immovable` property.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - The value to assign to `immovable`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setImmovable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.immovable = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Body's `enable` property.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#setEnable\r\n     * @since 3.15.0\r\n     *\r\n     * @param {boolean} [value=true] - The value to assign to `enable`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\r\n     */\r\n    setEnable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.enable = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This is an internal handler, called by the `ProcessX` function as part\r\n     * of the collision step. You should almost never call this directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#processX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The amount to add to the Body position.\r\n     * @param {number} [vx] - The amount to add to the Body velocity.\r\n     * @param {boolean} [left] - Set the blocked.left value?\r\n     * @param {boolean} [right] - Set the blocked.right value?\r\n     */\r\n    processX: function (x, vx, left, right)\r\n    {\r\n        this.x += x;\r\n\r\n        this.updateCenter();\r\n\r\n        if (vx !== null)\r\n        {\r\n            this.velocity.x = vx;\r\n        }\r\n\r\n        var blocked = this.blocked;\r\n\r\n        if (left)\r\n        {\r\n            blocked.left = true;\r\n        }\r\n\r\n        if (right)\r\n        {\r\n            blocked.right = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This is an internal handler, called by the `ProcessY` function as part\r\n     * of the collision step. You should almost never call this directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Body#processY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} y - The amount to add to the Body position.\r\n     * @param {number} [vy] - The amount to add to the Body velocity.\r\n     * @param {boolean} [up] - Set the blocked.up value?\r\n     * @param {boolean} [down] - Set the blocked.down value?\r\n     */\r\n    processY: function (y, vy, up, down)\r\n    {\r\n        this.y += y;\r\n\r\n        this.updateCenter();\r\n\r\n        if (vy !== null)\r\n        {\r\n            this.velocity.y = vy;\r\n        }\r\n\r\n        var blocked = this.blocked;\r\n\r\n        if (up)\r\n        {\r\n            blocked.up = true;\r\n        }\r\n\r\n        if (down)\r\n        {\r\n            blocked.down = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Bodys horizontal position (left edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.x = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Bodys vertical position (top edge).\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.position.y = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The left edge of the Body. Identical to x.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#left\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right edge of the Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#right\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x + this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The top edge of the Body. Identical to y.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#top\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The bottom edge of this Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Body#bottom\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y + this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Body;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects\r\n * every step. If a collision, or overlap, occurs it will invoke the given callbacks.\r\n *\r\n * @class Collider\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade physics World that will manage the collisions.\r\n * @param {boolean} overlapOnly - Whether to check for collisions or overlap.\r\n * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.\r\n * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n * @param {any} callbackContext - The scope in which to call the callbacks.\r\n */\r\nvar Collider = new Class({\r\n\r\n    initialize:\r\n\r\n    function Collider (world, overlapOnly, object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        /**\r\n         * The world in which the bodies will collide.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The name of the collider (unused by Phaser).\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#name\r\n         * @type {string}\r\n         * @since 3.1.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * Whether the collider is active.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Whether to check for collisions or overlaps.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#overlapOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapOnly = overlapOnly;\r\n\r\n        /**\r\n         * The first object to check for collision.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#object1\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeColliderType}\r\n         * @since 3.0.0\r\n         */\r\n        this.object1 = object1;\r\n\r\n        /**\r\n         * The second object to check for collision.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#object2\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeColliderType}\r\n         * @since 3.0.0\r\n         */\r\n        this.object2 = object2;\r\n\r\n        /**\r\n         * The callback to invoke when the two objects collide.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#collideCallback\r\n         * @type {ArcadePhysicsCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideCallback = collideCallback;\r\n\r\n        /**\r\n         * If a processCallback exists it must return true or collision checking will be skipped.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#processCallback\r\n         * @type {ArcadePhysicsCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.processCallback = processCallback;\r\n\r\n        /**\r\n         * The context the collideCallback and processCallback will run in.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Collider#callbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.callbackContext = callbackContext;\r\n    },\r\n\r\n    /**\r\n     * A name for the Collider.\r\n     *\r\n     * Phaser does not use this value, it's for your own reference.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#setName\r\n     * @since 3.1.0\r\n     *\r\n     * @param {string} name - The name to assign to the Collider.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} This Collider instance.\r\n     */\r\n    setName: function (name)\r\n    {\r\n        this.name = name;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by World as part of its step processing, initial operation of collision checking.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#update\r\n     * @since 3.0.0\r\n     */\r\n    update: function ()\r\n    {\r\n        this.world.collideObjects(\r\n            this.object1,\r\n            this.object2,\r\n            this.collideCallback,\r\n            this.processCallback,\r\n            this.callbackContext,\r\n            this.overlapOnly\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Removes Collider from World and disposes of its resources.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Collider#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.world.removeCollider(this);\r\n\r\n        this.active = false;\r\n\r\n        this.world = null;\r\n\r\n        this.object1 = null;\r\n        this.object2 = null;\r\n\r\n        this.collideCallback = null;\r\n        this.processCallback = null;\r\n        this.callbackContext = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Collider;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcadeImage = require('./ArcadeImage');\r\nvar ArcadeSprite = require('./ArcadeSprite');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar PhysicsGroup = require('./PhysicsGroup');\r\nvar StaticPhysicsGroup = require('./StaticPhysicsGroup');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.\r\n * Objects that are created by this Factory are automatically added to the physics world.\r\n *\r\n * @class Factory\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics World instance.\r\n */\r\nvar Factory = new Class({\r\n\r\n    initialize:\r\n\r\n    function Factory (world)\r\n    {\r\n        /**\r\n         * A reference to the Arcade Physics World.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * A reference to the Scene this Arcade Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = world.scene;\r\n\r\n        /**\r\n         * A reference to the Scene.Systems this Arcade Physics instance belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Factory#sys\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.sys = world.scene.sys;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Physics Collider object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#collider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for collision.\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    collider: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Physics Collider Overlap object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for overlap.\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    overlap: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);\r\n    },\r\n\r\n    /**\r\n     * Adds an Arcade Physics Body to the given Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#existing\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.GameObject} G - [gameObject,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A Game Object.\r\n     * @param {boolean} [isStatic=false] - Create a Static body (true) or Dynamic body (false).\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.GameObjectWithBody} The Game Object.\r\n     */\r\n    existing: function (gameObject, isStatic)\r\n    {\r\n        var type = (isStatic) ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;\r\n\r\n        this.world.enableBody(gameObject, type);\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Image object with a Static body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ImageWithStaticBody} The Image object that was created.\r\n     */\r\n    staticImage: function (x, y, key, frame)\r\n    {\r\n        var image = new ArcadeImage(this.scene, x, y, key, frame);\r\n\r\n        this.sys.displayList.add(image);\r\n\r\n        this.world.enableBody(image, CONST.STATIC_BODY);\r\n\r\n        return image;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Image object with a Dynamic body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#image\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ImageWithDynamicBody} The Image object that was created.\r\n     */\r\n    image: function (x, y, key, frame)\r\n    {\r\n        var image = new ArcadeImage(this.scene, x, y, key, frame);\r\n\r\n        this.sys.displayList.add(image);\r\n\r\n        this.world.enableBody(image, CONST.DYNAMIC_BODY);\r\n\r\n        return image;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Sprite object with a Static body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticSprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.SpriteWithStaticBody} The Sprite object that was created.\r\n     */\r\n    staticSprite: function (x, y, key, frame)\r\n    {\r\n        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\r\n\r\n        this.sys.displayList.add(sprite);\r\n        this.sys.updateList.add(sprite);\r\n\r\n        this.world.enableBody(sprite, CONST.STATIC_BODY);\r\n\r\n        return sprite;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Arcade Sprite object with a Dynamic body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#sprite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Game Object in the world.\r\n     * @param {number} y - The vertical position of this Game Object in the world.\r\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.SpriteWithDynamicBody} The Sprite object that was created.\r\n     */\r\n    sprite: function (x, y, key, frame)\r\n    {\r\n        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\r\n\r\n        this.sys.displayList.add(sprite);\r\n        this.sys.updateList.add(sprite);\r\n\r\n        this.world.enableBody(sprite, CONST.DYNAMIC_BODY);\r\n\r\n        return sprite;\r\n    },\r\n\r\n    /**\r\n     * Creates a Static Physics Group object.\r\n     * All Game Objects created by this Group will automatically be static Arcade Physics objects.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#staticGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n     * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticGroup} The Static Group object that was created.\r\n     */\r\n    staticGroup: function (children, config)\r\n    {\r\n        return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));\r\n    },\r\n\r\n    /**\r\n     * Creates a Physics Group object.\r\n     * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#group\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n     * @param {Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} The Group object that was created.\r\n     */\r\n    group: function (children, config)\r\n    {\r\n        return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));\r\n    },\r\n\r\n    /**\r\n     * Destroys this Factory.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Factory#destroy\r\n     * @since 3.5.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.world = null;\r\n        this.scene = null;\r\n        this.sys = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Factory;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\r\nvar GetOverlapX = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = 0;\r\n    var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;\r\n\r\n    if (body1._dx === 0 && body2._dx === 0)\r\n    {\r\n        //  They overlap but neither of them are moving\r\n        body1.embedded = true;\r\n        body2.embedded = true;\r\n    }\r\n    else if (body1._dx > body2._dx)\r\n    {\r\n        //  Body1 is moving right and / or Body2 is moving left\r\n        overlap = body1.right - body2.x;\r\n\r\n        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.right === false || body2.checkCollision.left === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.right = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.left = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.right = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.left = true;\r\n            }\r\n        }\r\n    }\r\n    else if (body1._dx < body2._dx)\r\n    {\r\n        //  Body1 is moving left and/or Body2 is moving right\r\n        overlap = body1.x - body2.width - body2.x;\r\n\r\n        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.left === false || body2.checkCollision.right === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.left = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.right = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.left = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.right = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\r\n    body1.overlapX = overlap;\r\n    body2.overlapX = overlap;\r\n\r\n    return overlap;\r\n};\r\n\r\nmodule.exports = GetOverlapX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties\r\n * accordingly, including: `touching.up`, `touching.down`, `touching.none` and `overlapY'.\r\n *\r\n * @function Phaser.Physics.Arcade.GetOverlapY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\r\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\r\n *\r\n * @return {number} The amount of overlap.\r\n */\r\nvar GetOverlapY = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = 0;\r\n    var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;\r\n\r\n    if (body1._dy === 0 && body2._dy === 0)\r\n    {\r\n        //  They overlap but neither of them are moving\r\n        body1.embedded = true;\r\n        body2.embedded = true;\r\n    }\r\n    else if (body1._dy > body2._dy)\r\n    {\r\n        //  Body1 is moving down and/or Body2 is moving up\r\n        overlap = body1.bottom - body2.y;\r\n\r\n        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.down === false || body2.checkCollision.up === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.down = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.up = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.down = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.up = true;\r\n            }\r\n        }\r\n    }\r\n    else if (body1._dy < body2._dy)\r\n    {\r\n        //  Body1 is moving up and/or Body2 is moving down\r\n        overlap = body1.y - body2.bottom;\r\n\r\n        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.up === false || body2.checkCollision.down === false)\r\n        {\r\n            overlap = 0;\r\n        }\r\n        else\r\n        {\r\n            body1.touching.none = false;\r\n            body1.touching.up = true;\r\n\r\n            body2.touching.none = false;\r\n            body2.touching.down = true;\r\n\r\n            if (body2.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body1.blocked.none = false;\r\n                body1.blocked.up = true;\r\n            }\r\n\r\n            if (body1.physicsType === CONST.STATIC_BODY && !overlapOnly)\r\n            {\r\n                body2.blocked.none = false;\r\n                body2.blocked.down = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    //  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is\r\n    body1.overlapY = overlap;\r\n    body2.overlapY = overlap;\r\n\r\n    return overlap;\r\n};\r\n\r\nmodule.exports = GetOverlapY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcadeSprite = require('./ArcadeSprite');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Group = require('../../gameobjects/group/Group');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * An Arcade Physics Group object.\r\n *\r\n * The primary use of a Physics Group is a way to collect together physics enable objects\r\n * that share the same intrinsic structure into a single pool. They can they be easily\r\n * compared against other Groups, or Game Objects.\r\n *\r\n * All Game Objects created by, or added to this Group will automatically be given **dynamic**\r\n * Arcade Physics bodies (if they have no body already) and the bodies will receive the\r\n * Groups {@link Phaser.Physics.Arcade.Group#defaults default values}.\r\n *\r\n * You should not pass objects into this Group that should not receive a body. For example,\r\n * do not add basic Geometry or Tilemap Layers into a Group, as they will not behave in the\r\n * way you may expect. Groups should all ideally have objects of the same type in them.\r\n *\r\n * If you wish to create a Group filled with Static Bodies, please see {@link Phaser.Physics.Arcade.StaticGroup}.\r\n *\r\n * @class Group\r\n * @extends Phaser.GameObjects.Group\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The physics simulation.\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\r\n */\r\nvar PhysicsGroup = new Class({\r\n\r\n    Extends: Group,\r\n\r\n    initialize:\r\n\r\n    function PhysicsGroup (world, scene, children, config)\r\n    {\r\n        if (!children && !config)\r\n        {\r\n            config = {\r\n                internalCreateCallback: this.createCallbackHandler,\r\n                internalRemoveCallback: this.removeCallbackHandler\r\n            };\r\n        }\r\n        else if (IsPlainObject(children))\r\n        {\r\n            //  children is a plain object, so swizzle them:\r\n            config = children;\r\n            children = null;\r\n\r\n            config.internalCreateCallback = this.createCallbackHandler;\r\n            config.internalRemoveCallback = this.removeCallbackHandler;\r\n        }\r\n        else if (Array.isArray(children) && IsPlainObject(children[0]))\r\n        {\r\n            //  children is an array of plain objects (i.e., configs)\r\n            config = children[0];\r\n\r\n            var _this = this;\r\n\r\n            children.forEach(function (singleConfig)\r\n            {\r\n                singleConfig.internalCreateCallback = _this.createCallbackHandler;\r\n                singleConfig.internalRemoveCallback = _this.removeCallbackHandler;\r\n            });\r\n\r\n            children = null;\r\n        }\r\n        else\r\n        {\r\n            // config is not defined and children is not a plain object nor an array of plain objects\r\n            config = {\r\n                internalCreateCallback: this.createCallbackHandler,\r\n                internalRemoveCallback: this.removeCallbackHandler\r\n            };\r\n        }\r\n\r\n        /**\r\n         * The physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The class to create new Group members from.\r\n         *\r\n         * This should be either `Phaser.Physics.Arcade.Image`, `Phaser.Physics.Arcade.Sprite`, or a class extending one of those.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#classType\r\n         * @type {Function}\r\n         * @default ArcadeSprite\r\n         * @since 3.0.0\r\n         */\r\n        config.classType = GetFastValue(config, 'classType', ArcadeSprite);\r\n\r\n        /**\r\n         * The physics type of the Group's members.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#physicsType\r\n         * @type {number}\r\n         * @default Phaser.Physics.Arcade.DYNAMIC_BODY\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.DYNAMIC_BODY;\r\n\r\n        /**\r\n         * Default physics properties applied to Game Objects added to the Group or created by the Group. Derived from the `config` argument.\r\n         *\r\n         * You can remove the default values by setting this property to `{}`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#defaults\r\n         * @type {Phaser.Types.Physics.Arcade.PhysicsGroupDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            setCollideWorldBounds: GetFastValue(config, 'collideWorldBounds', false),\r\n            setBoundsRectangle: GetFastValue(config, 'customBoundsRectangle', null),\r\n            setAccelerationX: GetFastValue(config, 'accelerationX', 0),\r\n            setAccelerationY: GetFastValue(config, 'accelerationY', 0),\r\n            setAllowDrag: GetFastValue(config, 'allowDrag', true),\r\n            setAllowGravity: GetFastValue(config, 'allowGravity', true),\r\n            setAllowRotation: GetFastValue(config, 'allowRotation', true),\r\n            setBounceX: GetFastValue(config, 'bounceX', 0),\r\n            setBounceY: GetFastValue(config, 'bounceY', 0),\r\n            setDragX: GetFastValue(config, 'dragX', 0),\r\n            setDragY: GetFastValue(config, 'dragY', 0),\r\n            setEnable: GetFastValue(config, 'enable', true),\r\n            setGravityX: GetFastValue(config, 'gravityX', 0),\r\n            setGravityY: GetFastValue(config, 'gravityY', 0),\r\n            setFrictionX: GetFastValue(config, 'frictionX', 0),\r\n            setFrictionY: GetFastValue(config, 'frictionY', 0),\r\n            setMaxVelocityX: GetFastValue(config, 'maxVelocityX', 10000),\r\n            setMaxVelocityY: GetFastValue(config, 'maxVelocityY', 10000),\r\n            setVelocityX: GetFastValue(config, 'velocityX', 0),\r\n            setVelocityY: GetFastValue(config, 'velocityY', 0),\r\n            setAngularVelocity: GetFastValue(config, 'angularVelocity', 0),\r\n            setAngularAcceleration: GetFastValue(config, 'angularAcceleration', 0),\r\n            setAngularDrag: GetFastValue(config, 'angularDrag', 0),\r\n            setMass: GetFastValue(config, 'mass', 1),\r\n            setImmovable: GetFastValue(config, 'immovable', false)\r\n        };\r\n\r\n        Group.call(this, scene, children, config);\r\n\r\n        /**\r\n         * A textual representation of this Game Object.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.Physics.Arcade.Group#type\r\n         * @type {string}\r\n         * @default 'PhysicsGroup'\r\n         * @since 3.21.0\r\n         */\r\n        this.type = 'PhysicsGroup';\r\n    },\r\n\r\n    /**\r\n     * Enables a Game Object's Body and assigns `defaults`. Called when a Group member is added or created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#createCallbackHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object being added.\r\n     */\r\n    createCallbackHandler: function (child)\r\n    {\r\n        if (!child.body)\r\n        {\r\n            this.world.enableBody(child, CONST.DYNAMIC_BODY);\r\n        }\r\n\r\n        var body = child.body;\r\n\r\n        for (var key in this.defaults)\r\n        {\r\n            body[key](this.defaults[key]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disables a Game Object's Body. Called when a Group member is removed.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#removeCallbackHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object being removed.\r\n     */\r\n    removeCallbackHandler: function (child)\r\n    {\r\n        if (child.body)\r\n        {\r\n            this.world.disableBody(child);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the velocity of each Group member.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity.\r\n     * @param {number} y - The vertical velocity.\r\n     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (x, y), the second (x + step, y + step), and so on.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */\r\n    setVelocity: function (x, y, step)\r\n    {\r\n        if (step === undefined) { step = 0; }\r\n\r\n        var items = this.getChildren();\r\n\r\n        for (var i = 0; i < items.length; i++)\r\n        {\r\n            items[i].body.velocity.set(x + (i * step), y + (i * step));\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal velocity of each Group member.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity value.\r\n     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (x), the second (x + step), and so on.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */\r\n    setVelocityX: function (value, step)\r\n    {\r\n        if (step === undefined) { step = 0; }\r\n\r\n        var items = this.getChildren();\r\n\r\n        for (var i = 0; i < items.length; i++)\r\n        {\r\n            items[i].body.velocity.x = value + (i * step);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical velocity of each Group member.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Group#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The velocity value.\r\n     * @param {number} [step=0] - The velocity increment. When set, the first member receives velocity (y), the second (y + step), and so on.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Group} This Physics Group object.\r\n     */\r\n    setVelocityY: function (value, step)\r\n    {\r\n        if (step === undefined) { step = 0; }\r\n\r\n        var items = this.getChildren();\r\n\r\n        for (var i = 0; i < items.length; i++)\r\n        {\r\n            items[i].body.velocity.y = value + (i * step);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PhysicsGroup;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar body1;\r\nvar body2;\r\nvar body1Pushable;\r\nvar body2Pushable;\r\nvar body1MassImpact;\r\nvar body2MassImpact;\r\nvar body1FullImpact;\r\nvar body2FullImpact;\r\nvar body1MovingLeft;\r\nvar body1MovingRight;\r\nvar body1Stationary;\r\nvar body2MovingLeft;\r\nvar body2MovingRight;\r\nvar body2Stationary;\r\nvar body1OnLeft;\r\nvar body2OnLeft;\r\nvar overlap;\r\n\r\n/**\r\n * Sets all of the local processing values and calculates the velocity exchanges.\r\n *\r\n * Then runs `BlockCheck` and returns the value from it.\r\n *\r\n * This method is called by `Phaser.Physics.Arcade.SeparateX` and should not be\r\n * called directly.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.Set\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} b1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} b2 - The second Body to separate.\r\n * @param {number} ov - The overlap value.\r\n *\r\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\r\n */\r\nvar Set = function (b1, b2, ov)\r\n{\r\n    body1 = b1;\r\n    body2 = b2;\r\n\r\n    var v1 = body1.velocity.x;\r\n    var v2 = body2.velocity.x;\r\n\r\n    body1Pushable = body1.pushable;\r\n    body1MovingLeft = body1._dx < 0;\r\n    body1MovingRight = body1._dx > 0;\r\n    body1Stationary = body1._dx === 0;\r\n    body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);\r\n    body1FullImpact = v2 - v1 * body1.bounce.x;\r\n\r\n    body2Pushable = body2.pushable;\r\n    body2MovingLeft = body2._dx < 0;\r\n    body2MovingRight = body2._dx > 0;\r\n    body2Stationary = body2._dx === 0;\r\n    body2OnLeft = !body1OnLeft;\r\n    body2FullImpact = v1 - v2 * body2.bounce.x;\r\n\r\n    //  negative delta = up, positive delta = down (inc. gravity)\r\n    overlap = Math.abs(ov);\r\n\r\n    return BlockCheck();\r\n};\r\n\r\n/**\r\n * Blocked Direction checks, because it doesn't matter if an object can be pushed\r\n * or not, blocked is blocked.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.BlockCheck\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\r\n */\r\nvar BlockCheck = function ()\r\n{\r\n    //  Body1 is moving right and Body2 is blocked from going right any further\r\n    if (body1MovingRight && body1OnLeft && body2.blocked.right)\r\n    {\r\n        body1.processX(-overlap, body1FullImpact, false, true);\r\n\r\n        return 1;\r\n    }\r\n\r\n    //  Body1 is moving up and Body2 is blocked from going up any further\r\n    if (body1MovingLeft && body2OnLeft && body2.blocked.left)\r\n    {\r\n        body1.processX(overlap, body1FullImpact, true);\r\n\r\n        return 1;\r\n    }\r\n\r\n    //  Body2 is moving right and Body1 is blocked from going right any further\r\n    if (body2MovingRight && body2OnLeft && body1.blocked.right)\r\n    {\r\n        body2.processX(-overlap, body2FullImpact, false, true);\r\n\r\n        return 2;\r\n    }\r\n\r\n    //  Body2 is moving up and Body1 is blocked from going up any further\r\n    if (body2MovingLeft && body1OnLeft && body1.blocked.left)\r\n    {\r\n        body2.processX(overlap, body2FullImpact, true);\r\n\r\n        return 2;\r\n    }\r\n\r\n    return 0;\r\n};\r\n\r\n/**\r\n * The main check function. Runs through one of the four possible tests and returns the results.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.Check\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @return {boolean} `true` if a check passed, otherwise `false`.\r\n */\r\nvar Check = function ()\r\n{\r\n    var v1 = body1.velocity.x;\r\n    var v2 = body2.velocity.x;\r\n\r\n    var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1);\r\n    var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1);\r\n    var avg = (nv1 + nv2) * 0.5;\r\n\r\n    nv1 -= avg;\r\n    nv2 -= avg;\r\n\r\n    body1MassImpact = avg + nv1 * body1.bounce.x;\r\n    body2MassImpact = avg + nv2 * body2.bounce.x;\r\n\r\n    //  Body1 hits Body2 on the right hand side\r\n    if (body1MovingLeft && body2OnLeft)\r\n    {\r\n        return Run(0);\r\n    }\r\n\r\n    //  Body2 hits Body1 on the right hand side\r\n    if (body2MovingLeft && body1OnLeft)\r\n    {\r\n        return Run(1);\r\n    }\r\n\r\n    //  Body1 hits Body2 on the left hand side\r\n    if (body1MovingRight && body1OnLeft)\r\n    {\r\n        return Run(2);\r\n    }\r\n\r\n    //  Body2 hits Body1 on the left hand side\r\n    if (body2MovingRight && body2OnLeft)\r\n    {\r\n        return Run(3);\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * The main check function. Runs through one of the four possible tests and returns the results.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.Run\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} side - The side to test. As passed in by the `Check` function.\r\n *\r\n * @return {boolean} Always returns `true`.\r\n */\r\nvar Run = function (side)\r\n{\r\n    if (body1Pushable && body2Pushable)\r\n    {\r\n        //  Both pushable, or both moving at the same time, so equal rebound\r\n        overlap *= 0.5;\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingLeft && body2OnLeft\r\n            //  body2MovingRight && body2OnLeft\r\n            body1.processX(overlap, body1MassImpact);\r\n            body2.processX(-overlap, body2MassImpact);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingLeft && body1OnLeft\r\n            //  body1MovingRight && body1OnLeft\r\n            body1.processX(-overlap, body1MassImpact);\r\n            body2.processX(overlap, body2MassImpact);\r\n        }\r\n    }\r\n    else if (body1Pushable && !body2Pushable)\r\n    {\r\n        //  Body1 pushable, Body2 not\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingLeft && body2OnLeft\r\n            //  body2MovingRight && body2OnLeft\r\n            body1.processX(overlap, body1FullImpact, true);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingLeft && body1OnLeft\r\n            //  body1MovingRight && body1OnLeft\r\n            body1.processX(-overlap, body1FullImpact, false, true);\r\n        }\r\n    }\r\n    else if (!body1Pushable && body2Pushable)\r\n    {\r\n        //  Body2 pushable, Body1 not\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingLeft && body2OnLeft\r\n            //  body2MovingRight && body2OnLeft\r\n            body2.processX(-overlap, body2FullImpact, false, true);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingLeft && body1OnLeft\r\n            //  body1MovingRight && body1OnLeft\r\n            body2.processX(overlap, body2FullImpact, true);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //  Neither body is pushable, so base it on movement\r\n\r\n        var halfOverlap = overlap * 0.5;\r\n\r\n        if (side === 0)\r\n        {\r\n            //  body1MovingLeft && body2OnLeft\r\n\r\n            if (body2Stationary)\r\n            {\r\n                body1.processX(overlap, 0, true);\r\n                body2.processX(0, null, false, true);\r\n            }\r\n            else if (body2MovingRight)\r\n            {\r\n                body1.processX(halfOverlap, 0, true);\r\n                body2.processX(-halfOverlap, 0, false, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body2 moving same direction as Body1\r\n                body1.processX(halfOverlap, body2.velocity.x, true);\r\n                body2.processX(-halfOverlap, null, false, true);\r\n            }\r\n        }\r\n        else if (side === 1)\r\n        {\r\n            //  body2MovingLeft && body1OnLeft\r\n\r\n            if (body1Stationary)\r\n            {\r\n                body1.processX(0, null, false, true);\r\n                body2.processX(overlap, 0, true);\r\n            }\r\n            else if (body1MovingRight)\r\n            {\r\n                body1.processX(-halfOverlap, 0, false, true);\r\n                body2.processX(halfOverlap, 0, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body1 moving same direction as Body2\r\n                body1.processX(-halfOverlap, null, false, true);\r\n                body2.processX(halfOverlap, body1.velocity.x, true);\r\n            }\r\n        }\r\n        else if (side === 2)\r\n        {\r\n            //  body1MovingRight && body1OnLeft\r\n\r\n            if (body2Stationary)\r\n            {\r\n                body1.processX(-overlap, 0, false, true);\r\n                body2.processX(0, null, true);\r\n            }\r\n            else if (body2MovingLeft)\r\n            {\r\n                body1.processX(-halfOverlap, 0, false, true);\r\n                body2.processX(halfOverlap, 0, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body2 moving same direction as Body1\r\n                body1.processX(-halfOverlap, body2.velocity.x, false, true);\r\n                body2.processX(halfOverlap, null, true);\r\n            }\r\n        }\r\n        else if (side === 3)\r\n        {\r\n            //  body2MovingRight && body2OnLeft\r\n\r\n            if (body1Stationary)\r\n            {\r\n                body1.processX(0, null, true);\r\n                body2.processX(-overlap, 0, false, true);\r\n            }\r\n            else if (body1MovingLeft)\r\n            {\r\n                body1.processX(halfOverlap, 0, true);\r\n                body2.processX(-halfOverlap, 0, false, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body1 moving same direction as Body2\r\n                body1.processX(halfOverlap, body2.velocity.y, true);\r\n                body2.processX(-halfOverlap, null, false, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * This function is run when Body1 is Immovable and Body2 is not.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.RunImmovableBody1\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} blockedState - The block state value.\r\n */\r\nvar RunImmovableBody1 = function (blockedState)\r\n{\r\n    if (blockedState === 1)\r\n    {\r\n        //  But Body2 cannot go anywhere either, so we cancel out velocity\r\n        //  Separation happened in the block check\r\n        body2.velocity.x = 0;\r\n    }\r\n    else if (body1OnLeft)\r\n    {\r\n        body2.processX(overlap, body2FullImpact, true);\r\n    }\r\n    else\r\n    {\r\n        body2.processX(-overlap, body2FullImpact, false, true);\r\n    }\r\n\r\n    //  This is special case code that handles things like vertically moving platforms you can ride\r\n    if (body1.moves)\r\n    {\r\n        body2.y += (body1.y - body1.prev.y) * body1.friction.y;\r\n        body2._dy = body2.y - body2.prev.y;\r\n    }\r\n};\r\n\r\n/**\r\n * This function is run when Body2 is Immovable and Body1 is not.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessX.RunImmovableBody2\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} blockedState - The block state value.\r\n */\r\nvar RunImmovableBody2 = function (blockedState)\r\n{\r\n    if (blockedState === 2)\r\n    {\r\n        //  But Body1 cannot go anywhere either, so we cancel out velocity\r\n        //  Separation happened in the block check\r\n        body1.velocity.x = 0;\r\n    }\r\n    else if (body2OnLeft)\r\n    {\r\n        body1.processX(overlap, body1FullImpact, true);\r\n    }\r\n    else\r\n    {\r\n        body1.processX(-overlap, body1FullImpact, false, true);\r\n    }\r\n\r\n    //  This is special case code that handles things like vertically moving platforms you can ride\r\n    if (body2.moves)\r\n    {\r\n        body1.y += (body2.y - body2.prev.y) * body2.friction.y;\r\n        body1._dy = body1.y - body1.prev.y;\r\n    }\r\n};\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade.ProcessX\r\n * @ignore\r\n */\r\n\r\nmodule.exports = {\r\n    BlockCheck: BlockCheck,\r\n    Check: Check,\r\n    Set: Set,\r\n    Run: Run,\r\n    RunImmovableBody1: RunImmovableBody1,\r\n    RunImmovableBody2: RunImmovableBody2\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar body1;\r\nvar body2;\r\nvar body1Pushable;\r\nvar body2Pushable;\r\nvar body1MassImpact;\r\nvar body2MassImpact;\r\nvar body1FullImpact;\r\nvar body2FullImpact;\r\nvar body1MovingUp;\r\nvar body1MovingDown;\r\nvar body1Stationary;\r\nvar body2MovingUp;\r\nvar body2MovingDown;\r\nvar body2Stationary;\r\nvar body1OnTop;\r\nvar body2OnTop;\r\nvar overlap;\r\n\r\n/**\r\n * Sets all of the local processing values and calculates the velocity exchanges.\r\n *\r\n * Then runs `BlockCheck` and returns the value from it.\r\n *\r\n * This method is called by `Phaser.Physics.Arcade.SeparateY` and should not be\r\n * called directly.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.Set\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} b1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} b2 - The second Body to separate.\r\n * @param {number} ov - The overlap value.\r\n *\r\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\r\n */\r\nvar Set = function (b1, b2, ov)\r\n{\r\n    body1 = b1;\r\n    body2 = b2;\r\n\r\n    var v1 = body1.velocity.y;\r\n    var v2 = body2.velocity.y;\r\n\r\n    body1Pushable = body1.pushable;\r\n    body1MovingUp = body1._dy < 0;\r\n    body1MovingDown = body1._dy > 0;\r\n    body1Stationary = body1._dy === 0;\r\n    body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);\r\n    body1FullImpact = v2 - v1 * body1.bounce.y;\r\n\r\n    body2Pushable = body2.pushable;\r\n    body2MovingUp = body2._dy < 0;\r\n    body2MovingDown = body2._dy > 0;\r\n    body2Stationary = body2._dy === 0;\r\n    body2OnTop = !body1OnTop;\r\n    body2FullImpact = v1 - v2 * body2.bounce.y;\r\n\r\n    //  negative delta = up, positive delta = down (inc. gravity)\r\n    overlap = Math.abs(ov);\r\n\r\n    return BlockCheck();\r\n};\r\n\r\n/**\r\n * Blocked Direction checks, because it doesn't matter if an object can be pushed\r\n * or not, blocked is blocked.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.BlockCheck\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\r\n */\r\nvar BlockCheck = function ()\r\n{\r\n    //  Body1 is moving down and Body2 is blocked from going down any further\r\n    if (body1MovingDown && body1OnTop && body2.blocked.down)\r\n    {\r\n        body1.processY(-overlap, body1FullImpact, false, true);\r\n\r\n        return 1;\r\n    }\r\n\r\n    //  Body1 is moving up and Body2 is blocked from going up any further\r\n    if (body1MovingUp && body2OnTop && body2.blocked.up)\r\n    {\r\n        body1.processY(overlap, body1FullImpact, true);\r\n\r\n        return 1;\r\n    }\r\n\r\n    //  Body2 is moving down and Body1 is blocked from going down any further\r\n    if (body2MovingDown && body2OnTop && body1.blocked.down)\r\n    {\r\n        body2.processY(-overlap, body2FullImpact, false, true);\r\n\r\n        return 2;\r\n    }\r\n\r\n    //  Body2 is moving up and Body1 is blocked from going up any further\r\n    if (body2MovingUp && body1OnTop && body1.blocked.up)\r\n    {\r\n        body2.processY(overlap, body2FullImpact, true);\r\n\r\n        return 2;\r\n    }\r\n\r\n    return 0;\r\n};\r\n\r\n/**\r\n * The main check function. Runs through one of the four possible tests and returns the results.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.Check\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @return {boolean} `true` if a check passed, otherwise `false`.\r\n */\r\nvar Check = function ()\r\n{\r\n    var v1 = body1.velocity.y;\r\n    var v2 = body2.velocity.y;\r\n\r\n    var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1);\r\n    var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1);\r\n    var avg = (nv1 + nv2) * 0.5;\r\n\r\n    nv1 -= avg;\r\n    nv2 -= avg;\r\n\r\n    body1MassImpact = avg + nv1 * body1.bounce.y;\r\n    body2MassImpact = avg + nv2 * body2.bounce.y;\r\n\r\n    //  Body1 hits Body2 on the bottom side\r\n    if (body1MovingUp && body2OnTop)\r\n    {\r\n        return Run(0);\r\n    }\r\n\r\n    //  Body2 hits Body1 on the bottom side\r\n    if (body2MovingUp && body1OnTop)\r\n    {\r\n        return Run(1);\r\n    }\r\n\r\n    //  Body1 hits Body2 on the top side\r\n    if (body1MovingDown && body1OnTop)\r\n    {\r\n        return Run(2);\r\n    }\r\n\r\n    //  Body2 hits Body1 on the top side\r\n    if (body2MovingDown && body2OnTop)\r\n    {\r\n        return Run(3);\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * The main check function. Runs through one of the four possible tests and returns the results.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.Run\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} side - The side to test. As passed in by the `Check` function.\r\n *\r\n * @return {boolean} Always returns `true`.\r\n */\r\nvar Run = function (side)\r\n{\r\n    if (body1Pushable && body2Pushable)\r\n    {\r\n        //  Both pushable, or both moving at the same time, so equal rebound\r\n        overlap *= 0.5;\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingUp && body2OnTop\r\n            //  body2MovingDown && body2OnTop\r\n            body1.processY(overlap, body1MassImpact);\r\n            body2.processY(-overlap, body2MassImpact);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingUp && body1OnTop\r\n            //  body1MovingDown && body1OnTop\r\n            body1.processY(-overlap, body1MassImpact);\r\n            body2.processY(overlap, body2MassImpact);\r\n        }\r\n    }\r\n    else if (body1Pushable && !body2Pushable)\r\n    {\r\n        //  Body1 pushable, Body2 not\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingUp && body2OnTop\r\n            //  body2MovingDown && body2OnTop\r\n            body1.processY(overlap, body1FullImpact, true);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingUp && body1OnTop\r\n            //  body1MovingDown && body1OnTop\r\n            body1.processY(-overlap, body1FullImpact, false, true);\r\n        }\r\n    }\r\n    else if (!body1Pushable && body2Pushable)\r\n    {\r\n        //  Body2 pushable, Body1 not\r\n\r\n        if (side === 0 || side === 3)\r\n        {\r\n            //  body1MovingUp && body2OnTop\r\n            //  body2MovingDown && body2OnTop\r\n            body2.processY(-overlap, body2FullImpact, false, true);\r\n        }\r\n        else\r\n        {\r\n            //  body2MovingUp && body1OnTop\r\n            //  body1MovingDown && body1OnTop\r\n            body2.processY(overlap, body2FullImpact, true);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        //  Neither body is pushable, so base it on movement\r\n\r\n        var halfOverlap = overlap * 0.5;\r\n\r\n        if (side === 0)\r\n        {\r\n            //  body1MovingUp && body2OnTop\r\n\r\n            if (body2Stationary)\r\n            {\r\n                body1.processY(overlap, 0, true);\r\n                body2.processY(0, null, false, true);\r\n            }\r\n            else if (body2MovingDown)\r\n            {\r\n                body1.processY(halfOverlap, 0, true);\r\n                body2.processY(-halfOverlap, 0, false, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body2 moving same direction as Body1\r\n                body1.processY(halfOverlap, body2.velocity.y, true);\r\n                body2.processY(-halfOverlap, null, false, true);\r\n            }\r\n        }\r\n        else if (side === 1)\r\n        {\r\n            //  body2MovingUp && body1OnTop\r\n\r\n            if (body1Stationary)\r\n            {\r\n                body1.processY(0, null, false, true);\r\n                body2.processY(overlap, 0, true);\r\n            }\r\n            else if (body1MovingDown)\r\n            {\r\n                body1.processY(-halfOverlap, 0, false, true);\r\n                body2.processY(halfOverlap, 0, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body1 moving same direction as Body2\r\n                body1.processY(-halfOverlap, null, false, true);\r\n                body2.processY(halfOverlap, body1.velocity.y, true);\r\n            }\r\n        }\r\n        else if (side === 2)\r\n        {\r\n            //  body1MovingDown && body1OnTop\r\n\r\n            if (body2Stationary)\r\n            {\r\n                body1.processY(-overlap, 0, false, true);\r\n                body2.processY(0, null, true);\r\n            }\r\n            else if (body2MovingUp)\r\n            {\r\n                body1.processY(-halfOverlap, 0, false, true);\r\n                body2.processY(halfOverlap, 0, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body2 moving same direction as Body1\r\n                body1.processY(-halfOverlap, body2.velocity.y, false, true);\r\n                body2.processY(halfOverlap, null, true);\r\n            }\r\n        }\r\n        else if (side === 3)\r\n        {\r\n            //  body2MovingDown && body2OnTop\r\n\r\n            if (body1Stationary)\r\n            {\r\n                body1.processY(0, null, true);\r\n                body2.processY(-overlap, 0, false, true);\r\n            }\r\n            else if (body1MovingUp)\r\n            {\r\n                body1.processY(halfOverlap, 0, true);\r\n                body2.processY(-halfOverlap, 0, false, true);\r\n            }\r\n            else\r\n            {\r\n                //  Body1 moving same direction as Body2\r\n                body1.processY(halfOverlap, body2.velocity.y, true);\r\n                body2.processY(-halfOverlap, null, false, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * This function is run when Body1 is Immovable and Body2 is not.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.RunImmovableBody1\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} blockedState - The block state value.\r\n */\r\nvar RunImmovableBody1 = function (blockedState)\r\n{\r\n    if (blockedState === 1)\r\n    {\r\n        //  But Body2 cannot go anywhere either, so we cancel out velocity\r\n        //  Separation happened in the block check\r\n        body2.velocity.y = 0;\r\n    }\r\n    else if (body1OnTop)\r\n    {\r\n        body2.processY(overlap, body2FullImpact, true);\r\n    }\r\n    else\r\n    {\r\n        body2.processY(-overlap, body2FullImpact, false, true);\r\n    }\r\n\r\n    //  This is special case code that handles things like horizontally moving platforms you can ride\r\n    if (body1.moves)\r\n    {\r\n        body2.x += (body1.x - body1.prev.x) * body1.friction.x;\r\n        body2._dx = body2.x - body2.prev.x;\r\n    }\r\n};\r\n\r\n/**\r\n * This function is run when Body2 is Immovable and Body1 is not.\r\n *\r\n * @function Phaser.Physics.Arcade.ProcessY.RunImmovableBody2\r\n * @ignore\r\n * @since 3.50.0\r\n *\r\n * @param {number} blockedState - The block state value.\r\n */\r\nvar RunImmovableBody2 = function (blockedState)\r\n{\r\n    if (blockedState === 2)\r\n    {\r\n        //  But Body1 cannot go anywhere either, so we cancel out velocity\r\n        //  Separation happened in the block check\r\n        body1.velocity.y = 0;\r\n    }\r\n    else if (body2OnTop)\r\n    {\r\n        body1.processY(overlap, body1FullImpact, true);\r\n    }\r\n    else\r\n    {\r\n        body1.processY(-overlap, body1FullImpact, false, true);\r\n    }\r\n\r\n    //  This is special case code that handles things like horizontally moving platforms you can ride\r\n    if (body2.moves)\r\n    {\r\n        body1.x += (body2.x - body2.prev.x) * body2.friction.x;\r\n        body1._dx = body1.x - body1.prev.x;\r\n    }\r\n};\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade.ProcessY\r\n * @ignore\r\n */\r\n\r\nmodule.exports = {\r\n    BlockCheck: BlockCheck,\r\n    Check: Check,\r\n    Set: Set,\r\n    Run: Run,\r\n    RunImmovableBody1: RunImmovableBody1,\r\n    RunImmovableBody2: RunImmovableBody2\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetOverlapX = require('./GetOverlapX');\r\nvar ProcessX = require('./ProcessX');\r\n\r\n/**\r\n * Separates two overlapping bodies on the X-axis (horizontally).\r\n *\r\n * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.\r\n *\r\n * The bodies won't be separated if there is no horizontal overlap between them, if they are static, or if either one uses custom logic for its separation.\r\n *\r\n * @function Phaser.Physics.Arcade.SeparateX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - If `true`, the bodies will only have their overlap data set and no separation will take place.\r\n * @param {number} bias - A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.\r\n *\r\n * @return {boolean} `true` if the two bodies overlap vertically, otherwise `false`.\r\n */\r\nvar SeparateX = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = GetOverlapX(body1, body2, overlapOnly, bias);\r\n\r\n    var body1Immovable = body1.immovable;\r\n    var body2Immovable = body2.immovable;\r\n\r\n    //  Can't separate two immovable bodies, or a body with its own custom separation logic\r\n    if (overlapOnly || overlap === 0 || (body1Immovable && body2Immovable) || body1.customSeparateX || body2.customSeparateX)\r\n    {\r\n        //  return true if there was some overlap, otherwise false\r\n        return (overlap !== 0) || (body1.embedded && body2.embedded);\r\n    }\r\n\r\n    var blockedState = ProcessX.Set(body1, body2, overlap);\r\n\r\n    if (!body1Immovable && !body2Immovable)\r\n    {\r\n        if (blockedState > 0)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return ProcessX.Check();\r\n    }\r\n    else if (body1Immovable)\r\n    {\r\n        ProcessX.RunImmovableBody1(blockedState);\r\n    }\r\n    else if (body2Immovable)\r\n    {\r\n        ProcessX.RunImmovableBody2(blockedState);\r\n    }\r\n\r\n    //  If we got this far then there WAS overlap, and separation is complete, so return true\r\n    return true;\r\n};\r\n\r\nmodule.exports = SeparateX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetOverlapY = require('./GetOverlapY');\r\nvar ProcessY = require('./ProcessY');\r\n\r\n/**\r\n * Separates two overlapping bodies on the Y-axis (vertically).\r\n *\r\n * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.\r\n *\r\n * The bodies won't be separated if there is no vertical overlap between them, if they are static, or if either one uses custom logic for its separation.\r\n *\r\n * @function Phaser.Physics.Arcade.SeparateY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\r\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\r\n * @param {boolean} overlapOnly - If `true`, the bodies will only have their overlap data set and no separation will take place.\r\n * @param {number} bias - A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.\r\n *\r\n * @return {boolean} `true` if the two bodies overlap vertically, otherwise `false`.\r\n */\r\nvar SeparateY = function (body1, body2, overlapOnly, bias)\r\n{\r\n    var overlap = GetOverlapY(body1, body2, overlapOnly, bias);\r\n\r\n    var body1Immovable = body1.immovable;\r\n    var body2Immovable = body2.immovable;\r\n\r\n    //  Can't separate two immovable bodies, or a body with its own custom separation logic\r\n    if (overlapOnly || overlap === 0 || (body1Immovable && body2Immovable) || body1.customSeparateY || body2.customSeparateY)\r\n    {\r\n        //  return true if there was some overlap, otherwise false\r\n        return (overlap !== 0) || (body1.embedded && body2.embedded);\r\n    }\r\n\r\n    var blockedState = ProcessY.Set(body1, body2, overlap);\r\n\r\n    if (!body1Immovable && !body2Immovable)\r\n    {\r\n        if (blockedState > 0)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return ProcessY.Check();\r\n    }\r\n    else if (body1Immovable)\r\n    {\r\n        ProcessY.RunImmovableBody1(blockedState);\r\n    }\r\n    else if (body2Immovable)\r\n    {\r\n        ProcessY.RunImmovableBody2(blockedState);\r\n    }\r\n\r\n    //  If we got this far then there WAS overlap, and separation is complete, so return true\r\n    return true;\r\n};\r\n\r\nmodule.exports = SeparateY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CircleContains = require('../../geom/circle/Contains');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar RectangleContains = require('../../geom/rectangle/Contains');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Static Arcade Physics Body.\r\n *\r\n * A Static Body never moves, and isn't automatically synchronized with its parent Game Object.\r\n * That means if you make any change to the parent's origin, position, or scale after creating or adding the body, you'll need to update the Static Body manually.\r\n *\r\n * A Static Body can collide with other Bodies, but is never moved by collisions.\r\n *\r\n * Its dynamic counterpart is {@link Phaser.Physics.Arcade.Body}.\r\n *\r\n * @class StaticBody\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Static Body belongs to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Static Body belongs to.\r\n */\r\nvar StaticBody = new Class({\r\n\r\n    initialize:\r\n\r\n    function StaticBody (world, gameObject)\r\n    {\r\n        var width = (gameObject.displayWidth) ? gameObject.displayWidth : 64;\r\n        var height = (gameObject.displayHeight) ? gameObject.displayHeight : 64;\r\n\r\n        /**\r\n         * The Arcade Physics simulation this Static Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Game Object this Static Body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gameObject\r\n         * @type {Phaser.GameObjects.GameObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameObject = gameObject;\r\n\r\n        /**\r\n         * Whether the Static Body's boundary is drawn to the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugShowBody\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugShowBody = world.defaults.debugShowStaticBody;\r\n\r\n        /**\r\n         * The color of this Static Body on the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#debugBodyColor\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugBodyColor = world.defaults.staticBodyDebugColor;\r\n\r\n        /**\r\n         * Whether this Static Body is updated by the physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#enable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enable = true;\r\n\r\n        /**\r\n         * Whether this Static Body's boundary is circular (`true`) or rectangular (`false`).\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#isCircle\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isCircle = false;\r\n\r\n        /**\r\n         * If this Static Body is circular, this is the radius of the boundary, as set by {@link Phaser.Physics.Arcade.StaticBody#setCircle}, in pixels.\r\n         * Equal to `halfWidth`.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#radius\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.radius = 0;\r\n\r\n        /**\r\n         * The offset set by {@link Phaser.Physics.Arcade.StaticBody#setCircle} or {@link Phaser.Physics.Arcade.StaticBody#setSize}.\r\n         *\r\n         * This doesn't affect the Static Body's position, because a Static Body does not follow its Game Object.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#offset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.offset = new Vector2();\r\n\r\n        /**\r\n         * The position of this Static Body within the simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2(gameObject.x - (width * gameObject.originX), gameObject.y - (height * gameObject.originY));\r\n\r\n        /**\r\n         * The width of the Static Body's boundary, in pixels.\r\n         * If the Static Body is circular, this is also the Static Body's diameter.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the Static Body's boundary, in pixels.\r\n         * If the Static Body is circular, this is also the Static Body's diameter.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * Half the Static Body's width, in pixels.\r\n         * If the Static Body is circular, this is also the Static Body's radius.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth = Math.abs(this.width / 2);\r\n\r\n        /**\r\n         * Half the Static Body's height, in pixels.\r\n         * If the Static Body is circular, this is also the Static Body's radius.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#halfHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight = Math.abs(this.height / 2);\r\n\r\n        /**\r\n         * The center of the Static Body's boundary.\r\n         * This is the midpoint of its `position` (top-left corner) and its bottom-right corner.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#center\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.center = new Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n\r\n        /**\r\n         * A constant zero velocity used by the Arcade Physics simulation for calculations.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#velocity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.velocity = Vector2.ZERO;\r\n\r\n        /**\r\n         * A constant `false` value expected by the Arcade Physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#allowGravity\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.allowGravity = false;\r\n\r\n        /**\r\n         * Gravitational force applied specifically to this Body. Values are in pixels per second squared. Always zero for a Static Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = Vector2.ZERO;\r\n\r\n        /**\r\n         * Rebound, or restitution, following a collision, relative to 1. Always zero for a Static Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#bounce\r\n         * @type {Phaser.Math.Vector2}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = Vector2.ZERO;\r\n\r\n        //  If true this Body will dispatch events\r\n\r\n        /**\r\n         * Whether the simulation emits a `worldbounds` event when this StaticBody collides with the world boundary.\r\n         * Always false for a Static Body. (Static Bodies never collide with the world boundary and never trigger a `worldbounds` event.)\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onWorldBounds\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onWorldBounds = false;\r\n\r\n        /**\r\n         * Whether the simulation emits a `collide` event when this StaticBody collides with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onCollide\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onCollide = false;\r\n\r\n        /**\r\n         * Whether the simulation emits an `overlap` event when this StaticBody overlaps with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#onOverlap\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.onOverlap = false;\r\n\r\n        /**\r\n         * The StaticBody's inertia, relative to a default unit (1). With `bounce`, this affects the exchange of momentum (velocities) during collisions.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#mass\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.mass = 1;\r\n\r\n        /**\r\n         * Whether this object can be moved by collisions with another body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#immovable\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.immovable = true;\r\n\r\n        /**\r\n         * Sets if this Body can be pushed by another Body.\r\n         *\r\n         * A body that cannot be pushed will reflect back all of the velocity it is given to the\r\n         * colliding body. If that body is also not pushable, then the separation will be split\r\n         * between them evenly.\r\n         *\r\n         * If you want your body to never move or seperate at all, see the `setImmovable` method.\r\n         *\r\n         * By default, Static Bodies are not pushable.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#pushable\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         * @see Phaser.GameObjects.Components.Pushable#setPushable\r\n         */\r\n        this.pushable = false;\r\n\r\n        /**\r\n         * A flag disabling the default horizontal separation of colliding bodies. Pass your own `collideHandler` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateX = false;\r\n\r\n        /**\r\n         * A flag disabling the default vertical separation of colliding bodies. Pass your own `collideHandler` to the collider.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customSeparateY = false;\r\n\r\n        /**\r\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapX = 0;\r\n\r\n        /**\r\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapY = 0;\r\n\r\n        /**\r\n         * The amount of overlap (before separation), if this StaticBody is circular and colliding with another circular body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#overlapR\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.overlapR = 0;\r\n\r\n        /**\r\n         * Whether this StaticBody has ever overlapped with another while both were not moving.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#embedded\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.embedded = false;\r\n\r\n        /**\r\n         * Whether this StaticBody interacts with the world boundary.\r\n         * Always false for a Static Body. (Static Bodies never collide with the world boundary.)\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#collideWorldBounds\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.collideWorldBounds = false;\r\n\r\n        /**\r\n         * Whether this StaticBody is checked for collisions and for which directions. You can set `checkCollision.none = false` to disable collision checks.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#checkCollision\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\r\n\r\n        /**\r\n         * This property is kept for compatibility with Dynamic Bodies.\r\n         * Avoid using it.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#touching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * This property is kept for compatibility with Dynamic Bodies.\r\n         * Avoid using it.\r\n         * The values are always false for a Static Body.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#wasTouching\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * This property is kept for compatibility with Dynamic Bodies.\r\n         * Avoid using it.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#blocked\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\r\n         * @since 3.0.0\r\n         */\r\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\r\n\r\n        /**\r\n         * The StaticBody's physics type (static by default).\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#physicsType\r\n         * @type {number}\r\n         * @default Phaser.Physics.Arcade.STATIC_BODY\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.STATIC_BODY;\r\n\r\n        /**\r\n         * The calculated change in the Static Body's horizontal position during the current step.\r\n         * For a static body this is always zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#_dx\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.10.0\r\n         */\r\n        this._dx = 0;\r\n\r\n        /**\r\n         * The calculated change in the Static Body's vertical position during the current step.\r\n         * For a static body this is always zero.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticBody#_dy\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.10.0\r\n         */\r\n        this._dy = 0;\r\n    },\r\n\r\n    /**\r\n     * Changes the Game Object this Body is bound to.\r\n     * First it removes its reference from the old Game Object, then sets the new one.\r\n     * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The new Game Object that will own this Body.\r\n     * @param {boolean} [update=true] - Reposition and resize this Body to match the new Game Object?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     */\r\n    setGameObject: function (gameObject, update)\r\n    {\r\n        if (gameObject && gameObject !== this.gameObject)\r\n        {\r\n            //  Remove this body from the old game object\r\n            this.gameObject.body = null;\r\n\r\n            gameObject.body = this;\r\n\r\n            //  Update our reference\r\n            this.gameObject = gameObject;\r\n        }\r\n\r\n        if (update)\r\n        {\r\n            this.updateFromGameObject();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Syncs the Static Body's position and size with its parent Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     * @since 3.1.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    updateFromGameObject: function ()\r\n    {\r\n        this.world.staticTree.remove(this);\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        gameObject.getTopLeft(this.position);\r\n\r\n        this.width = gameObject.displayWidth;\r\n        this.height = gameObject.displayHeight;\r\n\r\n        this.halfWidth = Math.abs(this.width / 2);\r\n        this.halfHeight = Math.abs(this.height / 2);\r\n\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Positions the Static Body at an offset from its Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setOffset\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal offset of the Static Body from the Game Object's `x`.\r\n     * @param {number} y - The vertical offset of the Static Body from the Game Object's `y`.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setOffset: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        this.position.x -= this.offset.x;\r\n        this.position.y -= this.offset.y;\r\n\r\n        this.offset.set(x, y);\r\n\r\n        this.position.x += this.offset.x;\r\n        this.position.y += this.offset.y;\r\n\r\n        this.updateCenter();\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the Static Body.\r\n     * When `center` is true, also repositions it.\r\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The width of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\r\n     * @param {number} [height] - The height of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\r\n     * @param {boolean} [center=true] - Place the Static Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setSize: function (width, height, center)\r\n    {\r\n        if (center === undefined) { center = true; }\r\n\r\n        var gameObject = this.gameObject;\r\n\r\n        if (!width && gameObject.frame)\r\n        {\r\n            width = gameObject.frame.realWidth;\r\n        }\r\n\r\n        if (!height && gameObject.frame)\r\n        {\r\n            height = gameObject.frame.realHeight;\r\n        }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.halfWidth = Math.floor(width / 2);\r\n        this.halfHeight = Math.floor(height / 2);\r\n\r\n        if (center && gameObject.getCenter)\r\n        {\r\n            var ox = gameObject.displayWidth / 2;\r\n            var oy = gameObject.displayHeight / 2;\r\n\r\n            this.position.x -= this.offset.x;\r\n            this.position.y -= this.offset.y;\r\n\r\n            this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\r\n\r\n            this.position.x += this.offset.x;\r\n            this.position.y += this.offset.y;\r\n        }\r\n\r\n        this.updateCenter();\r\n\r\n        this.isCircle = false;\r\n        this.radius = 0;\r\n\r\n        this.world.staticTree.insert(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Static Body to have a circular body and sets its size and position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the StaticBody, in pixels.\r\n     * @param {number} [offsetX] - The horizontal offset of the StaticBody from its Game Object, in pixels.\r\n     * @param {number} [offsetY] - The vertical offset of the StaticBody from its Game Object, in pixels.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setCircle: function (radius, offsetX, offsetY)\r\n    {\r\n        if (offsetX === undefined) { offsetX = this.offset.x; }\r\n        if (offsetY === undefined) { offsetY = this.offset.y; }\r\n\r\n        if (radius > 0)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.isCircle = true;\r\n\r\n            this.radius = radius;\r\n\r\n            this.width = radius * 2;\r\n            this.height = radius * 2;\r\n\r\n            this.halfWidth = Math.floor(this.width / 2);\r\n            this.halfHeight = Math.floor(this.height / 2);\r\n\r\n            this.offset.set(offsetX, offsetY);\r\n\r\n            this.updateCenter();\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n        else\r\n        {\r\n            this.isCircle = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the StaticBody's `center` from its `position` and dimensions.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#updateCenter\r\n     * @since 3.0.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\r\n    },\r\n\r\n    /**\r\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x coordinate to reset the body to. If not given will use the parent Game Object's coordinate.\r\n     * @param {number} [y] - The y coordinate to reset the body to. If not given will use the parent Game Object's coordinate.\r\n     */\r\n    reset: function (x, y)\r\n    {\r\n        var gameObject = this.gameObject;\r\n\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        this.world.staticTree.remove(this);\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        gameObject.getTopLeft(this.position);\r\n\r\n        this.updateCenter();\r\n\r\n        this.world.staticTree.insert(this);\r\n    },\r\n\r\n    /**\r\n     * NOOP function. A Static Body cannot be stopped.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    stop: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the x and y coordinates of the top left and bottom right points of the StaticBody.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - The object which will hold the coordinates of the bounds.\r\n     *\r\n     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} The same object that was passed with `x`, `y`, `right` and `bottom` values matching the respective values of the StaticBody.\r\n     */\r\n    getBounds: function (obj)\r\n    {\r\n        obj.x = this.x;\r\n        obj.y = this.y;\r\n        obj.right = this.right;\r\n        obj.bottom = this.bottom;\r\n\r\n        return obj;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a given x,y coordinate is colliding with this Static Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#hitTest\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check against this body.\r\n     * @param {number} y - The y coordinate to check against this body.\r\n     *\r\n     * @return {boolean} `true` if the given coordinate lies within this body, otherwise `false`.\r\n     */\r\n    hitTest: function (x, y)\r\n    {\r\n        return (this.isCircle) ? CircleContains(this, x, y) : RectangleContains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * NOOP\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#postUpdate\r\n     * @since 3.12.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this StaticBody's horizontal position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Always zero for a Static Body.\r\n     */\r\n    deltaAbsX: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The absolute (non-negative) change in this StaticBody's vertical position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Always zero for a Static Body.\r\n     */\r\n    deltaAbsY: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The change in this StaticBody's horizontal position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaX\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.\r\n     */\r\n    deltaX: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The change in this StaticBody's vertical position from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.\r\n     */\r\n    deltaY: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * The change in this StaticBody's rotation from the previous step. Always zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#deltaZ\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The change in this StaticBody's rotation from the previous step. Always zero.\r\n     */\r\n    deltaZ: function ()\r\n    {\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Disables this Body and marks it for destruction during the next step.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enable = false;\r\n\r\n        this.world.pendingDestroy.set(this);\r\n    },\r\n\r\n    /**\r\n     * Draws a graphical representation of the StaticBody for visual debugging purposes.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#drawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to use for the debug drawing of the StaticBody.\r\n     */\r\n    drawDebug: function (graphic)\r\n    {\r\n        var pos = this.position;\r\n\r\n        var x = pos.x + this.halfWidth;\r\n        var y = pos.y + this.halfHeight;\r\n\r\n        if (this.debugShowBody)\r\n        {\r\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor, 1);\r\n\r\n            if (this.isCircle)\r\n            {\r\n                graphic.strokeCircle(x, y, this.width / 2);\r\n            }\r\n            else\r\n            {\r\n                graphic.strokeRect(pos.x, pos.y, this.width, this.height);\r\n            }\r\n\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Indicates whether the StaticBody is going to be showing a debug visualization during postUpdate.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#willDrawDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Whether or not the StaticBody is going to show the debug visualization during postUpdate.\r\n     */\r\n    willDrawDebug: function ()\r\n    {\r\n        return this.debugShowBody;\r\n    },\r\n\r\n    /**\r\n     * Sets the Mass of the StaticBody. Will set the Mass to 0.1 if the value passed is less than or equal to zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticBody#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value to set the Mass to. Values of zero or less are changed to 0.1.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        if (value <= 0)\r\n        {\r\n            //  Causes havoc otherwise\r\n            value = 0.1;\r\n        }\r\n\r\n        this.mass = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The x coordinate of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.position.x = value;\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinate of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.world.staticTree.remove(this);\r\n\r\n            this.position.y = value;\r\n\r\n            this.world.staticTree.insert(this);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the left-most x coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#left\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right-most x coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#right\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.x + this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The highest y coordinate of the area of the StaticBody.\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#top\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The lowest y coordinate of the area of the StaticBody. (y + height)\r\n     *\r\n     * @name Phaser.Physics.Arcade.StaticBody#bottom\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.position.y + this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = StaticBody;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcadeSprite = require('./ArcadeSprite');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('./const');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Group = require('../../gameobjects/group/Group');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * An Arcade Physics Static Group object.\r\n *\r\n * All Game Objects created by or added to this Group will automatically be given static Arcade Physics bodies, if they have no body.\r\n *\r\n * Its dynamic counterpart is {@link Phaser.Physics.Arcade.Group}.\r\n *\r\n * @class StaticGroup\r\n * @extends Phaser.GameObjects.Group\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.World} world - The physics simulation.\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\r\n */\r\nvar StaticPhysicsGroup = new Class({\r\n\r\n    Extends: Group,\r\n\r\n    initialize:\r\n\r\n    function StaticPhysicsGroup (world, scene, children, config)\r\n    {\r\n        if (!children && !config)\r\n        {\r\n            config = {\r\n                internalCreateCallback: this.createCallbackHandler,\r\n                internalRemoveCallback: this.removeCallbackHandler,\r\n                createMultipleCallback: this.createMultipleCallbackHandler,\r\n                classType: ArcadeSprite\r\n            };\r\n        }\r\n        else if (IsPlainObject(children))\r\n        {\r\n            //  children is a plain object, so swizzle them:\r\n            config = children;\r\n            children = null;\r\n\r\n            config.internalCreateCallback = this.createCallbackHandler;\r\n            config.internalRemoveCallback = this.removeCallbackHandler;\r\n            config.createMultipleCallback = this.createMultipleCallbackHandler;\r\n            config.classType = GetFastValue(config, 'classType', ArcadeSprite);\r\n        }\r\n        else if (Array.isArray(children) && IsPlainObject(children[0]))\r\n        {\r\n            //  children is an array of plain objects\r\n            config = children;\r\n            children = null;\r\n\r\n            config.forEach(function (singleConfig)\r\n            {\r\n                singleConfig.internalCreateCallback = this.createCallbackHandler;\r\n                singleConfig.internalRemoveCallback = this.removeCallbackHandler;\r\n                singleConfig.createMultipleCallback = this.createMultipleCallbackHandler;\r\n                singleConfig.classType = GetFastValue(singleConfig, 'classType', ArcadeSprite);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            // config is not defined and children is not a plain object nor an array of plain objects\r\n            config = {\r\n                internalCreateCallback: this.createCallbackHandler,\r\n                internalRemoveCallback: this.removeCallbackHandler\r\n            };\r\n        }\r\n\r\n        /**\r\n         * The physics simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticGroup#world\r\n         * @type {Phaser.Physics.Arcade.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The scene this group belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticGroup#physicsType\r\n         * @type {number}\r\n         * @default Phaser.Physics.Arcade.STATIC_BODY\r\n         * @since 3.0.0\r\n         */\r\n        this.physicsType = CONST.STATIC_BODY;\r\n\r\n        Group.call(this, scene, children, config);\r\n\r\n        /**\r\n         * A textual representation of this Game Object.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.Physics.Arcade.StaticGroup#type\r\n         * @type {string}\r\n         * @default 'StaticPhysicsGroup'\r\n         * @since 3.21.0\r\n         */\r\n        this.type = 'StaticPhysicsGroup';\r\n    },\r\n\r\n    /**\r\n     * Adds a static physics body to the new group member (if it lacks one) and adds it to the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#createCallbackHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The new group member.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#enableBody\r\n     */\r\n    createCallbackHandler: function (child)\r\n    {\r\n        if (!child.body)\r\n        {\r\n            this.world.enableBody(child, CONST.STATIC_BODY);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disables the group member's physics body, removing it from the simulation.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#removeCallbackHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The group member being removed.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#disableBody\r\n     */\r\n    removeCallbackHandler: function (child)\r\n    {\r\n        if (child.body)\r\n        {\r\n            this.world.disableBody(child);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Refreshes the group.\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#createMultipleCallbackHandler\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} entries - The newly created group members.\r\n     *\r\n     * @see Phaser.Physics.Arcade.StaticGroup#refresh\r\n     */\r\n    createMultipleCallbackHandler: function ()\r\n    {\r\n        this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Resets each Body to the position of its parent Game Object.\r\n     * Body sizes aren't changed (use {@link Phaser.Physics.Arcade.Components.Enable#refreshBody} for that).\r\n     *\r\n     * @method Phaser.Physics.Arcade.StaticGroup#refresh\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.StaticGroup} This group.\r\n     *\r\n     * @see Phaser.Physics.Arcade.StaticBody#reset\r\n     */\r\n    refresh: function ()\r\n    {\r\n        var children = this.children.entries;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            children[i].body.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = StaticPhysicsGroup;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AngleBetweenPoints = require('../../math/angle/BetweenPoints');\r\nvar Body = require('./Body');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Class = require('../../utils/Class');\r\nvar Collider = require('./Collider');\r\nvar CONST = require('./const');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar FuzzyEqual = require('../../math/fuzzy/Equal');\r\nvar FuzzyGreaterThan = require('../../math/fuzzy/GreaterThan');\r\nvar FuzzyLessThan = require('../../math/fuzzy/LessThan');\r\nvar GetOverlapX = require('./GetOverlapX');\r\nvar GetOverlapY = require('./GetOverlapY');\r\nvar GetTilesWithinWorldXY = require('../../tilemaps/components/GetTilesWithinWorldXY');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar MATH_CONST = require('../../math/const');\r\nvar ProcessQueue = require('../../structs/ProcessQueue');\r\nvar ProcessTileCallbacks = require('./tilemap/ProcessTileCallbacks');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar RTree = require('../../structs/RTree');\r\nvar SeparateTile = require('./tilemap/SeparateTile');\r\nvar SeparateX = require('./SeparateX');\r\nvar SeparateY = require('./SeparateY');\r\nvar Set = require('../../structs/Set');\r\nvar StaticBody = require('./StaticBody');\r\nvar TileIntersectsBody = require('./tilemap/TileIntersectsBody');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * The Arcade Physics World.\r\n *\r\n * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\r\n *\r\n * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Arcade\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this World instance belongs.\r\n * @param {Phaser.Types.Physics.Arcade.ArcadeWorldConfig} config - An Arcade Physics Configuration object.\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene this simulation belongs to.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Dynamic Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies in this simulation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticBodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticBodies = new Set();\r\n\r\n        /**\r\n         * Static Bodies marked for deletion.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#pendingDestroy\r\n         * @type {Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>}\r\n         * @since 3.1.0\r\n         */\r\n        this.pendingDestroy = new Set();\r\n\r\n        /**\r\n         * This simulation's collision processors.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#colliders\r\n         * @type {Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>}\r\n         * @since 3.0.0\r\n         */\r\n        this.colliders = new ProcessQueue();\r\n\r\n        /**\r\n         * Acceleration of Bodies due to gravity, in pixels per second.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#gravity\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = new Vector2(GetValue(config, 'gravity.x', 0), GetValue(config, 'gravity.y', 0));\r\n\r\n        /**\r\n         * A boundary constraining Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#bounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.0.0\r\n         */\r\n        this.bounds = new Rectangle(\r\n            GetValue(config, 'x', 0),\r\n            GetValue(config, 'y', 0),\r\n            GetValue(config, 'width', scene.sys.scale.width),\r\n            GetValue(config, 'height', scene.sys.scale.height)\r\n        );\r\n\r\n        /**\r\n         * The boundary edges that Bodies can collide with.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#checkCollision\r\n         * @type {Phaser.Types.Physics.Arcade.CheckCollisionObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.checkCollision = {\r\n            up: GetValue(config, 'checkCollision.up', true),\r\n            down: GetValue(config, 'checkCollision.down', true),\r\n            left: GetValue(config, 'checkCollision.left', true),\r\n            right: GetValue(config, 'checkCollision.right', true)\r\n        };\r\n\r\n        /**\r\n         * The number of physics steps to be taken per second.\r\n         *\r\n         * This property is read-only. Use the `setFPS` method to modify it at run-time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#fps\r\n         * @readonly\r\n         * @type {number}\r\n         * @default 60\r\n         * @since 3.10.0\r\n         */\r\n        this.fps = GetValue(config, 'fps', 60);\r\n\r\n        /**\r\n         * Should Physics use a fixed update time-step (true) or sync to the render fps (false)?.\r\n         * False value of this property disables fps and timeScale properties.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#fixedStep\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.23.0\r\n         */\r\n        this.fixedStep = GetValue(config, 'fixedStep', true);\r\n\r\n        /**\r\n         * The amount of elapsed ms since the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_elapsed\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Internal frame time value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTime\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTime = 1 / this.fps;\r\n\r\n        /**\r\n         * Internal frame time ms value.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_frameTimeMS\r\n         * @private\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        /**\r\n         * The number of steps that took place in the last frame.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#stepsLastFrame\r\n         * @readonly\r\n         * @type {number}\r\n         * @since 3.10.0\r\n         */\r\n        this.stepsLastFrame = 0;\r\n\r\n        /**\r\n         * Scaling factor applied to the frame rate.\r\n         *\r\n         * - 1.0 = normal speed\r\n         * - 2.0 = half speed\r\n         * - 0.5 = double speed\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.10.0\r\n         */\r\n        this.timeScale = GetValue(config, 'timeScale', 1);\r\n\r\n        /**\r\n         * The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#OVERLAP_BIAS\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.0.0\r\n         */\r\n        this.OVERLAP_BIAS = GetValue(config, 'overlapBias', 4);\r\n\r\n        /**\r\n         * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\r\n         * Larger values favor separation.\r\n         * Smaller values favor no separation.\r\n         * The optimum value may be similar to the tile size.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#TILE_BIAS\r\n         * @type {number}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.TILE_BIAS = GetValue(config, 'tileBias', 16);\r\n\r\n        /**\r\n         * Always separate overlapping Bodies horizontally before vertically.\r\n         * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#forceX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.forceX = GetValue(config, 'forceX', false);\r\n\r\n        /**\r\n         * Whether the simulation advances with the game loop.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#isPaused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isPaused = GetValue(config, 'isPaused', false);\r\n\r\n        /**\r\n         * Temporary total of colliding Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_total\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._total = 0;\r\n\r\n        /**\r\n         * Enables the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = GetValue(config, 'debug', false);\r\n\r\n        /**\r\n         * The graphics object drawing the debug display.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        /**\r\n         * Default debug display settings for new Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#defaults\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            debugShowBody: GetValue(config, 'debugShowBody', true),\r\n            debugShowStaticBody: GetValue(config, 'debugShowStaticBody', true),\r\n            debugShowVelocity: GetValue(config, 'debugShowVelocity', true),\r\n            bodyDebugColor: GetValue(config, 'debugBodyColor', 0xff00ff),\r\n            staticBodyDebugColor: GetValue(config, 'debugStaticBodyColor', 0x0000ff),\r\n            velocityDebugColor: GetValue(config, 'debugVelocityColor', 0x00ff00)\r\n        };\r\n\r\n        /**\r\n         * The maximum number of items per node on the RTree.\r\n         *\r\n         * This is ignored if `useTree` is `false`. If you have a large number of bodies in\r\n         * your world then you may find search performance improves by increasing this value,\r\n         * to allow more items per node and less node division.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#maxEntries\r\n         * @type {number}\r\n         * @default 16\r\n         * @since 3.0.0\r\n         */\r\n        this.maxEntries = GetValue(config, 'maxEntries', 16);\r\n\r\n        /**\r\n         * Should this Arcade Physics World use an RTree for Dynamic bodies?\r\n         *\r\n         * An RTree is a fast way of spatially sorting of all the bodies in the world.\r\n         * However, at certain limits, the cost of clearing and inserting the bodies into the\r\n         * tree every frame becomes more expensive than the search speed gains it provides.\r\n         *\r\n         * If you have a large number of dynamic bodies in your world then it may be best to\r\n         * disable the use of the RTree by setting this property to `false` in the physics config.\r\n         *\r\n         * The number it can cope with depends on browser and device, but a conservative estimate\r\n         * of around 5,000 bodies should be considered the max before disabling it.\r\n         *\r\n         * This only applies to dynamic bodies. Static bodies are always kept in an RTree,\r\n         * because they don't have to be cleared every frame, so you benefit from the\r\n         * massive search speeds all the time.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#useTree\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.useTree = GetValue(config, 'useTree', true);\r\n\r\n        /**\r\n         * The spatial index of Dynamic Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#tree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.tree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * The spatial index of Static Bodies.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#staticTree\r\n         * @type {Phaser.Structs.RTree}\r\n         * @since 3.0.0\r\n         */\r\n        this.staticTree = new RTree(this.maxEntries);\r\n\r\n        /**\r\n         * Recycled input for tree searches.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#treeMinMax\r\n         * @type {Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax}\r\n         * @since 3.0.0\r\n         */\r\n        this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix used by bodies for calculations without them needing their own local copy.\r\n         *\r\n         * @name Phaser.Physics.Arcade.World#_tempMatrix2\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `enableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\r\n     * @param {number} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     */\r\n    enable: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.enable(child, bodyType);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.enableBody(child, bodyType);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.enableBody(entry, bodyType);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates an Arcade Physics Body on a single Game Object.\r\n     *\r\n     * If the Game Object already has a body, this method will simply add it back into the simulation.\r\n     *\r\n     * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\r\n     * acceleration. A static body remains fixed in place and as such is able to use an optimized search\r\n     * tree, making it ideal for static elements such as level objects. You can still collide and overlap\r\n     * with static bodies.\r\n     *\r\n     * Normally, rather than calling this method directly, you'd use the helper methods available in the\r\n     * Arcade Physics Factory, such as:\r\n     *\r\n     * ```javascript\r\n     * this.physics.add.image(x, y, textureKey);\r\n     * this.physics.add.sprite(x, y, textureKey);\r\n     * ```\r\n     *\r\n     * Calling factory methods encapsulates the creation of a Game Object and the creation of its\r\n     * body at the same time. If you are creating custom classes then you can pass them to this\r\n     * method to have their bodies created.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\r\n     * @param {number} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\r\n     */\r\n    enableBody: function (object, bodyType)\r\n    {\r\n        if (bodyType === undefined) { bodyType = CONST.DYNAMIC_BODY; }\r\n\r\n        if (!object.body)\r\n        {\r\n            if (bodyType === CONST.DYNAMIC_BODY)\r\n            {\r\n                object.body = new Body(this, object);\r\n            }\r\n            else if (bodyType === CONST.STATIC_BODY)\r\n            {\r\n                object.body = new StaticBody(this, object);\r\n            }\r\n        }\r\n\r\n        this.add(object.body);\r\n\r\n        return object;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Arcade Physics Body or StaticBody to the simulation.\r\n     *\r\n     * The body is enabled and added to the local search trees.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#add\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\r\n     *\r\n     * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\r\n     */\r\n    add: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.bodies.set(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.set(body);\r\n\r\n            this.staticTree.insert(body);\r\n        }\r\n\r\n        body.enable = true;\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\r\n     *\r\n     * The difference between this and the `disableBody` method is that you can pass arrays or Groups\r\n     * to this method.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\r\n     */\r\n    disable: function (object)\r\n    {\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entry = object[i];\r\n\r\n            if (entry.isParent)\r\n            {\r\n                var children = entry.getChildren();\r\n\r\n                for (var c = 0; c < children.length; c++)\r\n                {\r\n                    var child = children[c];\r\n\r\n                    if (child.isParent)\r\n                    {\r\n                        //  Handle Groups nested inside of Groups\r\n                        this.disable(child);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.disableBody(child.body);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.disableBody(entry.body);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enable` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\r\n     */\r\n    disableBody: function (body)\r\n    {\r\n        this.remove(body);\r\n\r\n        body.enable = false;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing Arcade Physics Body or StaticBody from the simulation.\r\n     *\r\n     * The body is disabled and removed from the local search trees.\r\n     *\r\n     * The body itself is not deleted, it just has its `enabled` property set to false, which\r\n     * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\r\n     */\r\n    remove: function (body)\r\n    {\r\n        if (body.physicsType === CONST.DYNAMIC_BODY)\r\n        {\r\n            this.tree.remove(body);\r\n            this.bodies.delete(body);\r\n        }\r\n        else if (body.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            this.staticBodies.delete(body);\r\n            this.staticTree.remove(body);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Graphics Game Object that the world will use to render the debug display to.\r\n     *\r\n     * This is called automatically when the World is instantiated if the `debug` config property\r\n     * was set to `true`. However, you can call it at any point should you need to display the\r\n     * debug Graphic from a fixed point.\r\n     *\r\n     * You can control which objects are drawn to the Graphics object, and the colors they use,\r\n     * by setting the debug properties in the physics config.\r\n     *\r\n     * You should not typically use this in a production game. Use it to aid during debugging.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * Sets the position, size and properties of the World boundary.\r\n     *\r\n     * The World boundary is an invisible rectangle that defines the edges of the World.\r\n     * If a Body is set to collide with the world bounds then it will automatically stop\r\n     * when it reaches any of the edges. You can optionally set which edges of the boundary\r\n     * should be checked against.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The top-left x coordinate of the boundary.\r\n     * @param {number} y - The top-left y coordinate of the boundary.\r\n     * @param {number} width - The width of the boundary.\r\n     * @param {number} height - The height of the boundary.\r\n     * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBounds: function (x, y, width, height, checkLeft, checkRight, checkUp, checkDown)\r\n    {\r\n        this.bounds.setTo(x, y, width, height);\r\n\r\n        if (checkLeft !== undefined)\r\n        {\r\n            this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables collisions on each edge of the World boundary.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setBoundsCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\r\n     * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\r\n     * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\r\n     * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    setBoundsCollision: function (left, right, up, down)\r\n    {\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (up === undefined) { up = true; }\r\n        if (down === undefined) { down = true; }\r\n\r\n        this.checkCollision.left = left;\r\n        this.checkCollision.right = right;\r\n        this.checkCollision.up = up;\r\n        this.checkCollision.down = down;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pauses the simulation.\r\n     *\r\n     * A paused simulation does not update any existing bodies, or run any Colliders.\r\n     *\r\n     * However, you can still enable and disable bodies within it, or manually run collide or overlap\r\n     * checks.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#pause\r\n     * @fires Phaser.Physics.Arcade.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.isPaused = true;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the simulation, if paused.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#resume\r\n     * @fires Phaser.Physics.Arcade.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.isPaused = false;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform collision checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.collide` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addCollider\r\n     * @since 3.0.0\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addCollider: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, false, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Overlap Collider object and adds it to the simulation.\r\n     *\r\n     * A Collider is a way to automatically perform overlap checks between two objects,\r\n     * calling the collide and process callbacks if they occur.\r\n     *\r\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\r\n     *\r\n     * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\r\n     * as it will be handled for you automatically.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#addOverlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for overlap.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object to check for overlap.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\r\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\r\n     */\r\n    addOverlap: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        var collider = new Collider(this, true, object1, object2, collideCallback, processCallback, callbackContext);\r\n\r\n        this.colliders.add(collider);\r\n\r\n        return collider;\r\n    },\r\n\r\n    /**\r\n     * Removes a Collider from the simulation so it is no longer processed.\r\n     *\r\n     * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\r\n     * `World.colliders.add(Collider)`.\r\n     *\r\n     * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\r\n     * automatically clear all of its references and then remove it from the World. If you call destroy on\r\n     * a Collider you _don't_ need to pass it to this method too.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#removeCollider\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\r\n     *\r\n     * @return {Phaser.Physics.Arcade.World} This World object.\r\n     */\r\n    removeCollider: function (collider)\r\n    {\r\n        this.colliders.remove(collider);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the frame rate to run the simulation at.\r\n     *\r\n     * The frame rate value is used to simulate a fixed update time step. This fixed\r\n     * time step allows for a straightforward implementation of a deterministic game state.\r\n     *\r\n     * This frame rate is independent of the frequency at which the game is rendering. The\r\n     * higher you set the fps, the more physics simulation steps will occur per game step.\r\n     * Conversely, the lower you set it, the less will take place.\r\n     *\r\n     * You can optionally advance the simulation directly yourself by calling the `step` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#setFPS\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} framerate - The frame rate to advance the simulation at.\r\n     *\r\n     * @return {this} This World object.\r\n     */\r\n    setFPS: function (framerate)\r\n    {\r\n        this.fps = framerate;\r\n        this._frameTime = 1 / this.fps;\r\n        this._frameTimeMS = 1000 * this._frameTime;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation based on the elapsed time and fps rate.\r\n     *\r\n     * This is called automatically by your Scene and does not need to be invoked directly.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#update\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (this.isPaused || this.bodies.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var fixedDelta = this._frameTime;\r\n        var msPerFrame = this._frameTimeMS * this.timeScale;\r\n\r\n        this._elapsed += delta;\r\n\r\n        //  Update all active bodies\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n\r\n        //  Will a step happen this frame?\r\n        var willStep = (this._elapsed >= msPerFrame);\r\n\r\n        if (!this.fixedStep)\r\n        {\r\n            fixedDelta = delta * 0.001;\r\n            willStep = true;\r\n            this._elapsed = 0;\r\n        }\r\n\r\n        for (i = 0; i < bodies.length; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.preUpdate(willStep, fixedDelta);\r\n            }\r\n        }\r\n\r\n        //  We know that a step will happen this frame, so let's bundle it all together to save branching and iteration costs\r\n        if (willStep)\r\n        {\r\n            this._elapsed -= msPerFrame;\r\n            this.stepsLastFrame = 1;\r\n\r\n            //  Optionally populate our dynamic collision tree\r\n            if (this.useTree)\r\n            {\r\n                this.tree.clear();\r\n                this.tree.load(bodies);\r\n            }\r\n\r\n            //  Process any colliders\r\n            var colliders = this.colliders.update();\r\n\r\n            for (i = 0; i < colliders.length; i++)\r\n            {\r\n                var collider = colliders[i];\r\n\r\n                if (collider.active)\r\n                {\r\n                    collider.update();\r\n                }\r\n            }\r\n\r\n            this.emit(Events.WORLD_STEP, fixedDelta);\r\n        }\r\n\r\n        //  Process any additional steps this frame\r\n        while (this._elapsed >= msPerFrame)\r\n        {\r\n            this._elapsed -= msPerFrame;\r\n\r\n            this.step(fixedDelta);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Advances the simulation by a time increment.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#step\r\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.\r\n     */\r\n    step: function (delta)\r\n    {\r\n        //  Update all active bodies\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enable)\r\n            {\r\n                body.update(delta);\r\n            }\r\n        }\r\n\r\n        //  Optionally populate our dynamic collision tree\r\n        if (this.useTree)\r\n        {\r\n            this.tree.clear();\r\n            this.tree.load(bodies);\r\n        }\r\n\r\n        //  Process any colliders\r\n        var colliders = this.colliders.update();\r\n\r\n        for (i = 0; i < colliders.length; i++)\r\n        {\r\n            var collider = colliders[i];\r\n\r\n            if (collider.active)\r\n            {\r\n                collider.update();\r\n            }\r\n        }\r\n\r\n        this.emit(Events.WORLD_STEP, delta);\r\n\r\n        this.stepsLastFrame++;\r\n    },\r\n\r\n    /**\r\n     * Updates bodies, draws the debug display, and handles pending queue operations.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#postUpdate\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n\r\n        var dynamic = this.bodies;\r\n        var staticBodies = this.staticBodies;\r\n\r\n        //  We don't need to postUpdate if there wasn't a step this frame\r\n        if (this.stepsLastFrame)\r\n        {\r\n            this.stepsLastFrame = 0;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.enable)\r\n                {\r\n                    body.postUpdate();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            var graphics = this.debugGraphic;\r\n\r\n            graphics.clear();\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n\r\n            bodies = staticBodies.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n        }\r\n\r\n        var pending = this.pendingDestroy;\r\n\r\n        if (pending.size > 0)\r\n        {\r\n            var dynamicTree = this.tree;\r\n            var staticTree = this.staticTree;\r\n\r\n            bodies = pending.entries;\r\n            len = bodies.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body.physicsType === CONST.DYNAMIC_BODY)\r\n                {\r\n                    dynamicTree.remove(body);\r\n                    dynamic.delete(body);\r\n                }\r\n                else if (body.physicsType === CONST.STATIC_BODY)\r\n                {\r\n                    staticTree.remove(body);\r\n                    staticBodies.delete(body);\r\n                }\r\n\r\n                body.world = undefined;\r\n                body.gameObject = undefined;\r\n            }\r\n\r\n            pending.clear();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's velocity and updates its position.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#updateMotion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\r\n     * @param {number} delta - The delta value to be used in the motion calculations, in seconds.\r\n     */\r\n    updateMotion: function (body, delta)\r\n    {\r\n        if (body.allowRotation)\r\n        {\r\n            this.computeAngularVelocity(body, delta);\r\n        }\r\n\r\n        this.computeVelocity(body, delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's angular velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeAngularVelocity\r\n     * @since 3.10.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n     */\r\n    computeAngularVelocity: function (body, delta)\r\n    {\r\n        var velocity = body.angularVelocity;\r\n        var acceleration = body.angularAcceleration;\r\n        var drag = body.angularDrag;\r\n        var max = body.maxAngular;\r\n\r\n        if (acceleration)\r\n        {\r\n            velocity += acceleration * delta;\r\n        }\r\n        else if (body.allowDrag && drag)\r\n        {\r\n            drag *= delta;\r\n\r\n            if (FuzzyGreaterThan(velocity - drag, 0, 0.1))\r\n            {\r\n                velocity -= drag;\r\n            }\r\n            else if (FuzzyLessThan(velocity + drag, 0, 0.1))\r\n            {\r\n                velocity += drag;\r\n            }\r\n            else\r\n            {\r\n                velocity = 0;\r\n            }\r\n        }\r\n\r\n        velocity = Clamp(velocity, -max, max);\r\n\r\n        var velocityDelta = velocity - body.angularVelocity;\r\n\r\n        body.angularVelocity += velocityDelta;\r\n        body.rotation += (body.angularVelocity * delta);\r\n    },\r\n\r\n    /**\r\n     * Calculates a Body's per-axis velocity.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\r\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\r\n     */\r\n    computeVelocity: function (body, delta)\r\n    {\r\n        var velocityX = body.velocity.x;\r\n        var accelerationX = body.acceleration.x;\r\n        var dragX = body.drag.x;\r\n        var maxX = body.maxVelocity.x;\r\n\r\n        var velocityY = body.velocity.y;\r\n        var accelerationY = body.acceleration.y;\r\n        var dragY = body.drag.y;\r\n        var maxY = body.maxVelocity.y;\r\n\r\n        var speed = body.speed;\r\n        var maxSpeed = body.maxSpeed;\r\n        var allowDrag = body.allowDrag;\r\n        var useDamping = body.useDamping;\r\n\r\n        if (body.allowGravity)\r\n        {\r\n            velocityX += (this.gravity.x + body.gravity.x) * delta;\r\n            velocityY += (this.gravity.y + body.gravity.y) * delta;\r\n        }\r\n\r\n        if (accelerationX)\r\n        {\r\n            velocityX += accelerationX * delta;\r\n        }\r\n        else if (allowDrag && dragX)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n                dragX = Math.pow(dragX, delta);\r\n\r\n                velocityX *= dragX;\r\n\r\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragX *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityX - dragX, 0, 0.01))\r\n                {\r\n                    velocityX -= dragX;\r\n                }\r\n                else if (FuzzyLessThan(velocityX + dragX, 0, 0.01))\r\n                {\r\n                    velocityX += dragX;\r\n                }\r\n                else\r\n                {\r\n                    velocityX = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (accelerationY)\r\n        {\r\n            velocityY += accelerationY * delta;\r\n        }\r\n        else if (allowDrag && dragY)\r\n        {\r\n            if (useDamping)\r\n            {\r\n                //  Damping based deceleration\r\n                dragY = Math.pow(dragY, delta);\r\n\r\n                velocityY *= dragY;\r\n\r\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\r\n\r\n                if (FuzzyEqual(speed, 0, 0.001))\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Linear deceleration\r\n                dragY *= delta;\r\n\r\n                if (FuzzyGreaterThan(velocityY - dragY, 0, 0.01))\r\n                {\r\n                    velocityY -= dragY;\r\n                }\r\n                else if (FuzzyLessThan(velocityY + dragY, 0, 0.01))\r\n                {\r\n                    velocityY += dragY;\r\n                }\r\n                else\r\n                {\r\n                    velocityY = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        velocityX = Clamp(velocityX, -maxX, maxX);\r\n        velocityY = Clamp(velocityY, -maxY, maxY);\r\n\r\n        body.velocity.set(velocityX, velocityY);\r\n\r\n        if (maxSpeed > -1 && speed > maxSpeed)\r\n        {\r\n            body.velocity.normalize().scale(maxSpeed);\r\n            speed = maxSpeed;\r\n        }\r\n\r\n        body.speed = speed;\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separate\r\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\r\n     * @param {*} [callbackContext] - The context in which to invoke the callback.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     * @param {boolean} [intersects] - Assert that the bodies intersect and should not be tested before separation.\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separate: function (body1, body2, processCallback, callbackContext, overlapOnly, intersects)\r\n    {\r\n        if (\r\n            !intersects &&\r\n            !body1.enable ||\r\n            !body2.enable ||\r\n            body1.checkCollision.none ||\r\n            body2.checkCollision.none ||\r\n            !this.intersects(body1, body2))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\r\n        if (processCallback && processCallback.call(callbackContext, body1.gameObject, body2.gameObject) === false)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  Circle vs. Circle quick bail out\r\n        if (body1.isCircle && body2.isCircle)\r\n        {\r\n            return this.separateCircle(body1, body2, overlapOnly);\r\n        }\r\n\r\n        // We define the behavior of bodies in a collision circle and rectangle\r\n        // If a collision occurs in the corner points of the rectangle, the body behave like circles\r\n\r\n        //  Either body1 or body2 is a circle\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var bodyRect = (body1.isCircle) ? body2 : body1;\r\n            var bodyCircle = (body1.isCircle) ? body1 : body2;\r\n\r\n            var rect = {\r\n                x: bodyRect.x,\r\n                y: bodyRect.y,\r\n                right: bodyRect.right,\r\n                bottom: bodyRect.bottom\r\n            };\r\n\r\n            var circle = bodyCircle.center;\r\n\r\n            if (circle.y < rect.y || circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x || circle.x > rect.right)\r\n                {\r\n                    return this.separateCircle(body1, body2, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        var resultX = false;\r\n        var resultY = false;\r\n\r\n        //  Do we separate on x first or y first or both?\r\n        if (overlapOnly)\r\n        {\r\n            //  No separation but we need to calculate overlapX, overlapY, etc.\r\n            resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n        }\r\n        else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x))\r\n        {\r\n            resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            resultY = SeparateY(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n\r\n            //  Are they still intersecting? Let's do the other axis then\r\n            if (this.intersects(body1, body2))\r\n            {\r\n                resultX = SeparateX(body1, body2, overlapOnly, this.OVERLAP_BIAS);\r\n            }\r\n        }\r\n\r\n        var result = (resultX || resultY);\r\n\r\n        if (result)\r\n        {\r\n            if (overlapOnly)\r\n            {\r\n                if (body1.onOverlap || body2.onOverlap)\r\n                {\r\n                    this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\r\n                }\r\n            }\r\n            else if (body1.onCollide || body2.onCollide)\r\n            {\r\n                this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Separates two Bodies, when both are circular.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#separateCircle\r\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\r\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\r\n     * @param {number} [bias] - A small value added to the calculations.\r\n     *\r\n     * @return {boolean} True if separation occurred, otherwise false.\r\n     */\r\n    separateCircle: function (body1, body2, overlapOnly, bias)\r\n    {\r\n        //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\r\n        GetOverlapX(body1, body2, false, bias);\r\n        GetOverlapY(body1, body2, false, bias);\r\n\r\n        var overlap = 0;\r\n\r\n        if (body1.isCircle !== body2.isCircle)\r\n        {\r\n            var rect = {\r\n                x: (body2.isCircle) ? body1.position.x : body2.position.x,\r\n                y: (body2.isCircle) ? body1.position.y : body2.position.y,\r\n                right: (body2.isCircle) ? body1.right : body2.right,\r\n                bottom: (body2.isCircle) ? body1.bottom : body2.bottom\r\n            };\r\n\r\n            var circle = {\r\n                x: (body1.isCircle) ? body1.center.x : body2.center.x,\r\n                y: (body1.isCircle) ? body1.center.y : body2.center.y,\r\n                radius: (body1.isCircle) ? body1.halfWidth : body2.halfWidth\r\n            };\r\n\r\n            if (circle.y < rect.y)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.y) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.y) - circle.radius;\r\n                }\r\n            }\r\n            else if (circle.y > rect.bottom)\r\n            {\r\n                if (circle.x < rect.x)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\r\n                }\r\n                else if (circle.x > rect.right)\r\n                {\r\n                    overlap = DistanceBetween(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\r\n                }\r\n            }\r\n\r\n            overlap *= -1;\r\n        }\r\n        else\r\n        {\r\n            overlap = (body1.halfWidth + body2.halfWidth) - DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\r\n        }\r\n\r\n        body1.overlapR = overlap;\r\n        body2.overlapR = overlap;\r\n\r\n        //  Can't separate two immovable bodies, or a body with its own custom separation logic\r\n        if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateX || body2.customSeparateX)\r\n        {\r\n            if (overlap !== 0 && (body1.onOverlap || body2.onOverlap))\r\n            {\r\n                this.emit(Events.OVERLAP, body1.gameObject, body2.gameObject, body1, body2);\r\n            }\r\n\r\n            //  return true if there was some overlap, otherwise false\r\n            return (overlap !== 0);\r\n        }\r\n\r\n        var dx = body1.center.x - body2.center.x;\r\n        var dy = body1.center.y - body2.center.y;\r\n        var d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n        var nx = ((body2.center.x - body1.center.x) / d) || 0;\r\n        var ny = ((body2.center.y - body1.center.y) / d) || 0;\r\n        var p = 2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny) / (body1.mass + body2.mass);\r\n\r\n        if (body1.immovable || body2.immovable)\r\n        {\r\n            p *= 2;\r\n        }\r\n\r\n        if (!body1.immovable)\r\n        {\r\n            body1.velocity.x = (body1.velocity.x - p / body1.mass * nx);\r\n            body1.velocity.y = (body1.velocity.y - p / body1.mass * ny);\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.velocity.x = (body2.velocity.x + p / body2.mass * nx);\r\n            body2.velocity.y = (body2.velocity.y + p / body2.mass * ny);\r\n        }\r\n\r\n        if (!body1.immovable && !body2.immovable)\r\n        {\r\n            overlap /= 2;\r\n        }\r\n\r\n        // Note: This is inadequate for circle-rectangle separation\r\n\r\n        var angle = AngleBetweenPoints(body1.center, body2.center);\r\n        var overlapX = (overlap + MATH_CONST.EPSILON) * Math.cos(angle);\r\n        var overlapY = (overlap + MATH_CONST.EPSILON) * Math.sin(angle);\r\n\r\n        if (!body1.immovable)\r\n        {\r\n            body1.x -= overlapX;\r\n            body1.y -= overlapY;\r\n\r\n            body1.updateCenter();\r\n        }\r\n\r\n        if (!body2.immovable)\r\n        {\r\n            body2.x += overlapX;\r\n            body2.y += overlapY;\r\n\r\n            body2.updateCenter();\r\n        }\r\n\r\n        body1.velocity.x *= body1.bounce.x;\r\n        body1.velocity.y *= body1.bounce.y;\r\n        body2.velocity.x *= body2.bounce.x;\r\n        body2.velocity.y *= body2.bounce.y;\r\n\r\n        if (body1.onCollide || body2.onCollide)\r\n        {\r\n            this.emit(Events.COLLIDE, body1.gameObject, body2.gameObject, body1, body2);\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if two Bodies intersect at all.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\r\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    intersects: function (body1, body2)\r\n    {\r\n        if (body1 === body2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (!body1.isCircle && !body2.isCircle)\r\n        {\r\n            //  Rect vs. Rect\r\n            return !(\r\n                body1.right <= body2.position.x ||\r\n                body1.bottom <= body2.position.y ||\r\n                body1.position.x >= body2.right ||\r\n                body1.position.y >= body2.bottom\r\n            );\r\n        }\r\n        else if (body1.isCircle)\r\n        {\r\n            if (body2.isCircle)\r\n            {\r\n                //  Circle vs. Circle\r\n                return DistanceBetween(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= (body1.halfWidth + body2.halfWidth);\r\n            }\r\n            else\r\n            {\r\n                //  Circle vs. Rect\r\n                return this.circleBodyIntersects(body1, body2);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Rect vs. Circle\r\n            return this.circleBodyIntersects(body2, body1);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Tests if a circular Body intersects with another Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#circleBodyIntersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\r\n     * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\r\n     *\r\n     * @return {boolean} True if the two bodies intersect, otherwise false.\r\n     */\r\n    circleBodyIntersects: function (circle, body)\r\n    {\r\n        var x = Clamp(circle.center.x, body.left, body.right);\r\n        var y = Clamp(circle.center.y, body.top, body.bottom);\r\n\r\n        var dx = (circle.center.x - x) * (circle.center.x - x);\r\n        var dy = (circle.center.y - y) * (circle.center.y - y);\r\n\r\n        return (dx + dy) <= (circle.halfWidth * circle.halfWidth);\r\n    },\r\n\r\n    /**\r\n     * Tests if Game Objects overlap.\r\n     *\r\n     * See details in {@link Phaser.Physics.Arcade.World#collide}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if at least one Game Object overlaps another.\r\n     *\r\n     * @see Phaser.Physics.Arcade.World#collide\r\n     */\r\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        return this.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\r\n    },\r\n\r\n    /**\r\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\r\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\r\n     *\r\n     * If you don't require separation then use {@link Phaser.Physics.Arcade.World#overlap} instead.\r\n     *\r\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\r\n     *\r\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\r\n     *\r\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\r\n     *\r\n     * Two callbacks can be provided; they receive the colliding game objects as arguments.\r\n     * If an overlap is detected, the `processCallback` is called first. It can cancel the collision by returning false.\r\n     * Next the objects are separated and `collideCallback` is invoked.\r\n     *\r\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\r\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\r\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\r\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.\r\n     */\r\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (collideCallback === undefined) { collideCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\r\n\r\n        return this.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\r\n    },\r\n\r\n    /**\r\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideObjects\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object to check for collision.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {any} callbackContext - The scope in which to call the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideObjects: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var i;\r\n        var j;\r\n\r\n        if (object1.isParent && object1.physicsType === undefined)\r\n        {\r\n            object1 = object1.children.entries;\r\n        }\r\n\r\n        if (object2 && object2.isParent && object2.physicsType === undefined)\r\n        {\r\n            object2 = object2.children.entries;\r\n        }\r\n\r\n        var object1isArray = Array.isArray(object1);\r\n        var object2isArray = Array.isArray(object2);\r\n\r\n        this._total = 0;\r\n\r\n        if (!object1isArray && !object2isArray)\r\n        {\r\n            //  Neither of them are arrays - do this first as it's the most common use-case\r\n            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n        else if (!object1isArray && object2isArray)\r\n        {\r\n            //  Object 2 is an Array\r\n            for (i = 0; i < object2.length; i++)\r\n            {\r\n                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n        else if (object1isArray && !object2isArray)\r\n        {\r\n            //  Object 1 is an Array\r\n            if (!object2)\r\n            {\r\n                //  Special case for array vs. self\r\n                for (i = 0; i < object1.length; i++)\r\n                {\r\n                    var child = object1[i];\r\n\r\n                    for (j = i + 1; j < object1.length; j++)\r\n                    {\r\n                        if (i === j)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        this.collideHandler(child, object1[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (i = 0; i < object1.length; i++)\r\n                {\r\n                    this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  They're both arrays\r\n            for (i = 0; i < object1.length; i++)\r\n            {\r\n                for (j = 0; j < object2.length; j++)\r\n                {\r\n                    this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, overlapOnly);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (this._total > 0);\r\n    },\r\n\r\n    /**\r\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideHandler\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\r\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object2 - The second object or array of objects to check, or `undefined`.\r\n     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} callbackContext - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        //  Collide Group with Self\r\n        //  Only collide valid objects\r\n        if (object2 === undefined && object1.isParent)\r\n        {\r\n            return this.collideGroupVsGroup(object1, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n\r\n        //  If neither of the objects are set then bail out\r\n        if (!object1 || !object2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  A Body\r\n        if (object1.body)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  GROUPS\r\n        else if (object1.isParent)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isTilemap)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n\r\n        //  TILEMAP LAYERS\r\n        else if (object1.isTilemap)\r\n        {\r\n            if (object2.body)\r\n            {\r\n                return this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n            else if (object2.isParent)\r\n            {\r\n                return this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Sprite collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (!sprite1.body || !sprite2.body)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly))\r\n        {\r\n            if (collideCallback)\r\n            {\r\n                collideCallback.call(callbackContext, sprite1, sprite2);\r\n            }\r\n\r\n            this._total++;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Group collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.Group} group - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\r\n     * @param {any} callbackContext - The scope in which to call the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.\r\n     */\r\n    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var bodyA = sprite.body;\r\n\r\n        if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Does sprite collide with anything?\r\n\r\n        var i;\r\n        var len;\r\n        var bodyB;\r\n\r\n        if (this.useTree || group.physicsType === CONST.STATIC_BODY)\r\n        {\r\n            var minMax = this.treeMinMax;\r\n\r\n            minMax.minX = bodyA.left;\r\n            minMax.minY = bodyA.top;\r\n            minMax.maxX = bodyA.right;\r\n            minMax.maxY = bodyA.bottom;\r\n\r\n            var results = (group.physicsType === CONST.DYNAMIC_BODY) ? this.tree.search(minMax) : this.staticTree.search(minMax);\r\n\r\n            len = results.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = results[i];\r\n\r\n                if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject))\r\n                {\r\n                    //  Skip if comparing against itself, or if bodyB isn't collidable, or if bodyB isn't actually part of the Group\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var children = group.getChildren();\r\n            var skipIndex = group.children.entries.indexOf(sprite);\r\n\r\n            len = children.length;\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                bodyB = children[i].body;\r\n\r\n                if (!bodyB || i === skipIndex || !bodyB.enable)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    if (collideCallback)\r\n                    {\r\n                        collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject);\r\n                    }\r\n\r\n                    this._total++;\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Group vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} callbackContext - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var children = group.getChildren();\r\n\r\n        if (children.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var didCollide = false;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            if (children[i].body)\r\n            {\r\n                if (this.collideSpriteVsTilemapLayer(children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly))\r\n                {\r\n                    didCollide = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return didCollide;\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\r\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\r\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\r\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\r\n     * dynamic maps, this method can prove very useful.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (!sprite.body.enable || tiles.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, false, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\r\n     *\r\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\r\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\r\n     *\r\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\r\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\r\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\r\n     * you should filter them before passing them to this method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#overlapTiles\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\r\n    {\r\n        if (!sprite.body.enable || tiles.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, true, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        var body = sprite.body;\r\n\r\n        if (!body.enable || body.checkCollision.none)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var x = body.position.x;\r\n        var y = body.position.y;\r\n        var w = body.width;\r\n        var h = body.height;\r\n\r\n        var layerData = tilemapLayer.layer;\r\n\r\n        if (layerData.tileWidth > layerData.baseTileWidth)\r\n        {\r\n            // The x origin of a tile is the left side, so x and width need to be adjusted.\r\n            var xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX;\r\n            x -= xDiff;\r\n            w += xDiff;\r\n        }\r\n\r\n        if (layerData.tileHeight > layerData.baseTileHeight)\r\n        {\r\n            // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\r\n            var yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY;\r\n            h += yDiff;\r\n        }\r\n\r\n        var mapData = GetTilesWithinWorldXY(x, y, w, h, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer);\r\n\r\n        if (mapData.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return this.collideSpriteVsTilesHandler(sprite, mapData, collideCallback, processCallback, callbackContext, overlapOnly, true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal handler for Sprite vs. Tilemap collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilesHandler\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\r\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\r\n     * @param {boolean} [isLayer] - Is this check coming from a TilemapLayer or an array of tiles?\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideSpriteVsTilesHandler: function (sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer)\r\n    {\r\n        var body = sprite.body;\r\n\r\n        var tile;\r\n        var tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 };\r\n        var tilemapLayer;\r\n        var collision = false;\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            tile = tiles[i];\r\n\r\n            tilemapLayer = tile.tilemapLayer;\r\n\r\n            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y);\r\n\r\n            tileWorldRect.left = point.x;\r\n            tileWorldRect.top = point.y;\r\n\r\n            //  If the maps base tile size differs from the layer tile size, only the top of the rect\r\n            //  needs to be adjusted since its origin is (0, 1).\r\n            if (tile.baseHeight !== tile.height)\r\n            {\r\n                tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY;\r\n            }\r\n\r\n            tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX;\r\n            tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY;\r\n\r\n            if (TileIntersectsBody(tileWorldRect, body)\r\n                && (!processCallback || processCallback.call(callbackContext, sprite, tile))\r\n                && ProcessTileCallbacks(tile, sprite)\r\n                && (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer)))\r\n            {\r\n                this._total++;\r\n\r\n                collision = true;\r\n\r\n                if (collideCallback)\r\n                {\r\n                    collideCallback.call(callbackContext, sprite, tile);\r\n                }\r\n\r\n                if (overlapOnly && body.onOverlap)\r\n                {\r\n                    this.emit(Events.TILE_OVERLAP, sprite, tile, body);\r\n                }\r\n                else if (body.onCollide)\r\n                {\r\n                    this.emit(Events.TILE_COLLIDE, sprite, tile, body);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collision;\r\n    },\r\n\r\n    /**\r\n     * Internal helper for Group vs. Group collisions.\r\n     * Please use Phaser.Physics.Arcade.World#collide instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.\r\n     * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.\r\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\r\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\r\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\r\n     *\r\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\r\n     */\r\n    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly)\r\n    {\r\n        if (group1.length === 0 || group2.length === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var children = group1.getChildren();\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrap\r\n     * @since 3.3.0\r\n     *\r\n     * @param {any} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\r\n     * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\r\n     */\r\n    wrap: function (object, padding)\r\n    {\r\n        if (object.body)\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n        else if (object.getChildren)\r\n        {\r\n            this.wrapArray(object.getChildren(), padding);\r\n        }\r\n        else if (Array.isArray(object))\r\n        {\r\n            this.wrapArray(object, padding);\r\n        }\r\n        else\r\n        {\r\n            this.wrapObject(object, padding);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapArray\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Array.<*>} objects - An array of objects to be wrapped.\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapArray: function (objects, padding)\r\n    {\r\n        for (var i = 0; i < objects.length; i++)\r\n        {\r\n            this.wrapObject(objects[i], padding);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#wrapObject\r\n     * @since 3.3.0\r\n     *\r\n     * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\r\n     * @param {number} [padding=0] - An amount added to the boundary.\r\n     */\r\n    wrapObject: function (object, padding)\r\n    {\r\n        if (padding === undefined) { padding = 0; }\r\n\r\n        object.x = Wrap(object.x, this.bounds.left - padding, this.bounds.right + padding);\r\n        object.y = Wrap(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation, clearing physics data and removing listeners.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.tree.clear();\r\n        this.staticTree.clear();\r\n        this.bodies.clear();\r\n        this.staticBodies.clear();\r\n        this.colliders.destroy();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Shuts down the simulation and disconnects it from the current scene.\r\n     *\r\n     * @method Phaser.Physics.Arcade.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the acceleration properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Acceleration\r\n * @since 3.0.0\r\n */\r\nvar Acceleration = {\r\n\r\n    /**\r\n     * Sets the body's horizontal and vertical acceleration. If the vertical acceleration value is not provided, the vertical acceleration is set to the same value as the horizontal acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal acceleration\r\n     * @param {number} [y=x] - The vertical acceleration\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAcceleration: function (x, y)\r\n    {\r\n        this.body.acceleration.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the body's horizontal acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The horizontal acceleration\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAccelerationX: function (value)\r\n    {\r\n        this.body.acceleration.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the body's vertical acceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Acceleration#setAccelerationY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The vertical acceleration\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAccelerationY: function (value)\r\n    {\r\n        this.body.acceleration.y = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Acceleration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the angular acceleration properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Angular\r\n * @since 3.0.0\r\n */\r\nvar Angular = {\r\n\r\n    /**\r\n     * Sets the angular velocity of the body.\r\n     * \r\n     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.\r\n     * However, they can have angular motion, which is passed on to the Game Object bound to the body,\r\n     * causing them to visually rotate, even though the body remains axis-aligned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of angular velocity.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngularVelocity: function (value)\r\n    {\r\n        this.body.angularVelocity = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angular acceleration of the body.\r\n     * \r\n     * In Arcade Physics, bodies cannot rotate. They are always axis-aligned.\r\n     * However, they can have angular motion, which is passed on to the Game Object bound to the body,\r\n     * causing them to visually rotate, even though the body remains axis-aligned.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularAcceleration\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of angular acceleration.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngularAcceleration: function (value)\r\n    {\r\n        this.body.angularAcceleration = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angular drag of the body. Drag is applied to the current velocity, providing a form of deceleration.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Angular#setAngularDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of drag.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngularDrag: function (value)\r\n    {\r\n        this.body.angularDrag = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Angular;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the bounce properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Bounce\r\n * @since 3.0.0\r\n */\r\nvar Bounce = {\r\n\r\n    /**\r\n     * Sets the bounce values of this body.\r\n     * \r\n     * Bounce is the amount of restitution, or elasticity, the body has when it collides with another object.\r\n     * A value of 1 means that it will retain its full velocity after the rebound. A value of 0 means it will not rebound at all.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.\r\n     * @param {number} [y=x] - The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setBounce: function (x, y)\r\n    {\r\n        this.body.bounce.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal bounce value for this body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of horizontal bounce to apply on collision. A float, typically between 0 and 1.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setBounceX: function (value)\r\n    {\r\n        this.body.bounce.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical bounce value for this body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setBounceY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of vertical bounce to apply on collision. A float, typically between 0 and 1.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setBounceY: function (value)\r\n    {\r\n        this.body.bounce.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets whether this Body collides with the world boundary.\r\n     * \r\n     * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Phaser.Math.Vector2 first.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Bounce#setCollideWorldBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.\r\n     * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.\r\n     * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setCollideWorldBounds: function (value, bounceX, bounceY)\r\n    {\r\n        this.body.setCollideWorldBounds(value, bounceX, bounceY);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Bounce;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the debug properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Debug\r\n * @since 3.0.0\r\n */\r\nvar Debug = {\r\n\r\n    /**\r\n     * Sets the debug values of this body.\r\n     * \r\n     * Bodies will only draw their debug if debug has been enabled for Arcade Physics as a whole.\r\n     * Note that there is a performance cost in drawing debug displays. It should never be used in production.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Debug#setDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} showBody - Set to `true` to have this body render its outline to the debug display.\r\n     * @param {boolean} showVelocity - Set to `true` to have this body render a velocity marker to the debug display.\r\n     * @param {number} bodyColor - The color of the body outline when rendered to the debug display.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDebug: function (showBody, showVelocity, bodyColor)\r\n    {\r\n        this.debugShowBody = showBody;\r\n        this.debugShowVelocity = showVelocity;\r\n        this.debugBodyColor = bodyColor;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the color of the body outline when it renders to the debug display.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Debug#setDebugBodyColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The color of the body outline when rendered to the debug display.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDebugBodyColor: function (value)\r\n    {\r\n        this.body.debugBodyColor = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set to `true` to have this body render its outline to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugShowBody\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    debugShowBody: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.debugShowBody;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.body.debugShowBody = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Set to `true` to have this body render a velocity marker to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugShowVelocity\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    debugShowVelocity: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.debugShowVelocity;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.body.debugShowVelocity = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The color of the body outline when it renders to the debug display.\r\n     *\r\n     * @name Phaser.Physics.Arcade.Components.Debug#debugBodyColor\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    debugBodyColor: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.debugBodyColor;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.body.debugBodyColor = value;\r\n        }\r\n\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Debug;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the drag properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Drag\r\n * @since 3.0.0\r\n */\r\nvar Drag = {\r\n\r\n    /**\r\n     * Sets the body's horizontal and vertical drag. If the vertical drag value is not provided, the vertical drag is set to the same value as the horizontal drag.\r\n     *\r\n     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.\r\n     * It is the absolute loss of velocity due to movement, in pixels per second squared.\r\n     * The x and y components are applied separately.\r\n     *\r\n     * When `useDamping` is true, this is 1 minus the damping factor.\r\n     * A value of 1 means the Body loses no velocity.\r\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n     *\r\n     * Drag is applied only when `acceleration` is zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDrag\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The amount of horizontal drag to apply.\r\n     * @param {number} [y=x] - The amount of vertical drag to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDrag: function (x, y)\r\n    {\r\n        this.body.drag.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the body's horizontal drag.\r\n     *\r\n     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.\r\n     * It is the absolute loss of velocity due to movement, in pixels per second squared.\r\n     * The x and y components are applied separately.\r\n     *\r\n     * When `useDamping` is true, this is 1 minus the damping factor.\r\n     * A value of 1 means the Body loses no velocity.\r\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n     *\r\n     * Drag is applied only when `acceleration` is zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDragX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of horizontal drag to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDragX: function (value)\r\n    {\r\n        this.body.drag.x = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the body's vertical drag.\r\n     *\r\n     * Drag can be considered as a form of deceleration that will return the velocity of a body back to zero over time.\r\n     * It is the absolute loss of velocity due to movement, in pixels per second squared.\r\n     * The x and y components are applied separately.\r\n     *\r\n     * When `useDamping` is true, this is 1 minus the damping factor.\r\n     * A value of 1 means the Body loses no velocity.\r\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\r\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\r\n     *\r\n     * Drag is applied only when `acceleration` is zero.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDragY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of vertical drag to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDragY: function (value)\r\n    {\r\n        this.body.drag.y = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * If this Body is using `drag` for deceleration this function controls how the drag is applied.\r\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\r\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\r\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\r\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\r\n     *\r\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\r\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\r\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Drag#setDamping\r\n     * @since 3.10.0\r\n     *\r\n     * @param {boolean} value - `true` to use damping for deceleration, or `false` to use linear deceleration.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDamping: function (value)\r\n    {\r\n        this.body.useDamping = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Drag;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the enable properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Enable\r\n * @since 3.0.0\r\n */\r\nvar Enable = {\r\n\r\n    /**\r\n     * Enables this Game Object's Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#enableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} reset - Also reset the Body and place it at (x, y).\r\n     * @param {number} x - The horizontal position to place the Game Object and Body.\r\n     * @param {number} y - The horizontal position to place the Game Object and Body.\r\n     * @param {boolean} enableGameObject - Also activate this Game Object.\r\n     * @param {boolean} showGameObject - Also show this Game Object.\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#enable\r\n     * @see Phaser.Physics.Arcade.StaticBody#enable\r\n     * @see Phaser.Physics.Arcade.Body#reset\r\n     * @see Phaser.Physics.Arcade.StaticBody#reset\r\n     * @see Phaser.GameObjects.GameObject#active\r\n     * @see Phaser.GameObjects.GameObject#visible\r\n     */\r\n    enableBody: function (reset, x, y, enableGameObject, showGameObject)\r\n    {\r\n        if (reset)\r\n        {\r\n            this.body.reset(x, y);\r\n        }\r\n\r\n        if (enableGameObject)\r\n        {\r\n            this.body.gameObject.active = true;\r\n        }\r\n\r\n        if (showGameObject)\r\n        {\r\n            this.body.gameObject.visible = true;\r\n        }\r\n\r\n        this.body.enable = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops and disables this Game Object's Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#disableBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [disableGameObject=false] - Also deactivate this Game Object.\r\n     * @param {boolean} [hideGameObject=false] - Also hide this Game Object.\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#enable\r\n     * @see Phaser.Physics.Arcade.StaticBody#enable\r\n     * @see Phaser.GameObjects.GameObject#active\r\n     * @see Phaser.GameObjects.GameObject#visible\r\n     */\r\n    disableBody: function (disableGameObject, hideGameObject)\r\n    {\r\n        if (disableGameObject === undefined) { disableGameObject = false; }\r\n        if (hideGameObject === undefined) { hideGameObject = false; }\r\n\r\n        this.body.stop();\r\n\r\n        this.body.enable = false;\r\n\r\n        if (disableGameObject)\r\n        {\r\n            this.body.gameObject.active = false;\r\n        }\r\n\r\n        if (hideGameObject)\r\n        {\r\n            this.body.gameObject.visible = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Syncs the Body's position and size with its parent Game Object.\r\n     * You don't need to call this for Dynamic Bodies, as it happens automatically.\r\n     * But for Static bodies it's a useful way of modifying the position of a Static Body\r\n     * in the Physics World, based on its Game Object.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Enable#refreshBody\r\n     * @since 3.1.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject\r\n     */\r\n    refreshBody: function ()\r\n    {\r\n        this.body.updateFromGameObject();\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Enable;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Methods for setting the friction of an Arcade Physics Body.\r\n *\r\n * In Arcade Physics, friction is a special case of motion transfer from an \"immovable\" body to a riding body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Friction\r\n * @since 3.0.0\r\n *\r\n * @see Phaser.Physics.Arcade.Body#friction\r\n */\r\nvar Friction = {\r\n\r\n    /**\r\n     * Sets the friction of this game object's physics body.\r\n     * In Arcade Physics, friction is a special case of motion transfer from an \"immovable\" body to a riding body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The amount of horizontal friction to apply, [0, 1].\r\n     * @param {number} [y=x] - The amount of vertical friction to apply, [0, 1].\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#friction\r\n     */\r\n    setFriction: function (x, y)\r\n    {\r\n        this.body.friction.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal friction of this game object's physics body.\r\n     * This can move a riding body horizontally when it collides with this one on the vertical axis.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The amount of friction to apply, [0, 1].\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#friction\r\n     */\r\n    setFrictionX: function (x)\r\n    {\r\n        this.body.friction.x = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical friction of this game object's physics body.\r\n     * This can move a riding body vertically when it collides with this one on the horizontal axis.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Friction#setFrictionY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - The amount of friction to apply, [0, 1].\r\n     *\r\n     * @return {this} This Game Object.\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#friction\r\n     */\r\n    setFrictionY: function (y)\r\n    {\r\n        this.body.friction.y = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Friction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods for setting the gravity properties of an Arcade Physics Game Object.\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Gravity\r\n * @since 3.0.0\r\n */\r\nvar Gravity = {\r\n\r\n    /**\r\n     * Set the X and Y values of the gravitational pull to act upon this Arcade Physics Game Object. Values can be positive or negative. Larger values result in a stronger effect.\r\n     * \r\n     * If only one value is provided, this value will be used for both the X and Y axis.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The gravitational force to be applied to the X-axis.\r\n     * @param {number} [y=x] - The gravitational force to be applied to the Y-axis. If this is not specified, the X value will be used.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.body.gravity.set(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the gravitational force to be applied to the X axis. Value can be positive or negative. Larger values result in a stronger effect.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The gravitational force to be applied to the X-axis.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setGravityX: function (x)\r\n    {\r\n        this.body.gravity.x = x;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the gravitational force to be applied to the Y axis. Value can be positive or negative. Larger values result in a stronger effect.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Gravity#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - The gravitational force to be applied to the Y-axis.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setGravityY: function (y)\r\n    {\r\n        this.body.gravity.y = y;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Gravity;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the immovable properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Immovable\r\n * @since 3.0.0\r\n */\r\nvar Immovable = {\r\n\r\n    /**\r\n     * Sets if this Body can be separated during collisions with other bodies.\r\n     *\r\n     * When a body is immovable it means it won't move at all, not even to separate it from collision\r\n     * overlap. If you just wish to prevent a body from being knocked around by other bodies, see\r\n     * the `setPushable` method instead.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Immovable#setImmovable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Sets if this body will be separated during collisions with other bodies.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setImmovable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.body.immovable = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Immovable;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the mass properties of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Mass\r\n * @since 3.0.0\r\n */\r\nvar Mass = {\r\n\r\n    /**\r\n     * Sets the mass of the physics body\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Mass#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - New value for the mass of the body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        this.body.mass = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Mass;\r\n","var OverlapRect = require('./OverlapRect');\r\nvar Circle = require('../../../geom/circle/Circle');\r\nvar CircleToCircle = require('../../../geom/intersects/CircleToCircle');\r\nvar CircleToRectangle = require('../../../geom/intersects/CircleToRectangle');\r\n\r\n/**\r\n * This method will search the given circular area and return an array of all physics bodies that\r\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n *\r\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n * contained within it.\r\n *\r\n * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\r\n * otherwise the search is O(N) for Dynamic Bodies.\r\n *\r\n * @function Phaser.Physics.Arcade.Components.OverlapCirc\r\n * @since 3.21.0\r\n *\r\n * @param {number} x - The x coordinate of the center of the area to search within.\r\n * @param {number} y - The y coordinate of the center of the area to search within.\r\n * @param {number} radius - The radius of the area to search within.\r\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n *\r\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n */\r\nvar OverlapCirc = function (world, x, y, radius, includeDynamic, includeStatic)\r\n{\r\n    var bodiesInRect = OverlapRect(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);\r\n\r\n    if (bodiesInRect.length === 0)\r\n    {\r\n        return bodiesInRect;\r\n    }\r\n\r\n    var area = new Circle(x, y, radius);\r\n    var circFromBody = new Circle();\r\n    var bodiesInArea = [];\r\n\r\n    for (var i = 0; i < bodiesInRect.length; i++)\r\n    {\r\n        var body = bodiesInRect[i];\r\n\r\n        if (body.isCircle)\r\n        {\r\n            circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);\r\n\r\n            if (CircleToCircle(area, circFromBody))\r\n            {\r\n                bodiesInArea.push(body);\r\n            }\r\n        }\r\n        else if (CircleToRectangle(area, body))\r\n        {\r\n            bodiesInArea.push(body);\r\n        }\r\n    }\r\n\r\n    return bodiesInArea;\r\n};\r\n\r\nmodule.exports = OverlapCirc;\r\n","/**\r\n * This method will search the given rectangular area and return an array of all physics bodies that\r\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\r\n * \r\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\r\n * contained within it.\r\n * \r\n * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\r\n * otherwise the search is O(N) for Dynamic Bodies.\r\n *\r\n * @function Phaser.Physics.Arcade.Components.OverlapRect\r\n * @since 3.17.0\r\n *\r\n * @param {number} x - The top-left x coordinate of the area to search within.\r\n * @param {number} y - The top-left y coordinate of the area to search within.\r\n * @param {number} width - The width of the area to search within.\r\n * @param {number} height - The height of the area to search within.\r\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\r\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\r\n *\r\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\r\n */\r\nvar OverlapRect = function (world, x, y, width, height, includeDynamic, includeStatic)\r\n{\r\n    if (includeDynamic === undefined) { includeDynamic = true; }\r\n    if (includeStatic === undefined) { includeStatic = false; }\r\n\r\n    var dynamicBodies = [];\r\n    var staticBodies = [];\r\n\r\n    var minMax = world.treeMinMax;\r\n\r\n    minMax.minX = x;\r\n    minMax.minY = y;\r\n    minMax.maxX = x + width;\r\n    minMax.maxY = y + height;\r\n\r\n    if (includeStatic)\r\n    {\r\n        staticBodies = world.staticTree.search(minMax);\r\n    }\r\n\r\n    if (includeDynamic && world.useTree)\r\n    {\r\n        dynamicBodies = world.tree.search(minMax);\r\n    }\r\n    else if (includeDynamic)\r\n    {\r\n        var bodies = world.bodies;\r\n\r\n        var fakeBody =\r\n        {\r\n            position: {\r\n                x: x,\r\n                y: y\r\n            },\r\n            left: x,\r\n            top: y,\r\n            right: x + width,\r\n            bottom: y + height,\r\n            isCircle: false\r\n        };\r\n\r\n        var intersects = world.intersects;\r\n\r\n        bodies.iterate(function (target)\r\n        {\r\n            if (intersects(target, fakeBody))\r\n            {\r\n                dynamicBodies.push(target);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    return staticBodies.concat(dynamicBodies);\r\n};\r\n\r\nmodule.exports = OverlapRect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods used for setting the pushable property of an Arcade Physics Body.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Pushable\r\n * @since 3.50.0\r\n */\r\nvar Pushable = {\r\n\r\n    /**\r\n     * Sets if this Body can be pushed by another Body.\r\n     *\r\n     * A body that cannot be pushed will reflect back all of the velocity it is given to the\r\n     * colliding body. If that body is also not pushable, then the separation will be split\r\n     * between them evenly.\r\n     *\r\n     * If you want your body to never move or seperate at all, see the `setImmovable` method.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Pushable#setPushable\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [value=true] - Sets if this body can be pushed by collisions with another Body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setPushable: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.body.pushable = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Pushable;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods for setting the size of an Arcade Physics Game Object.\n * Should be applied as a mixin and not used directly.\n *\n * @namespace Phaser.Physics.Arcade.Components.Size\n * @since 3.0.0\n */\nvar Size = {\n\n    /**\n     * Sets the body offset. This allows you to adjust the difference between the center of the body\n     * and the x and y coordinates of the parent Game Object.\n     *\n     * @method Phaser.Physics.Arcade.Components.Size#setOffset\n     * @since 3.0.0\n     *\n     * @param {number} x - The amount to offset the body from the parent Game Object along the x-axis.\n     * @param {number} [y=x] - The amount to offset the body from the parent Game Object along the y-axis. Defaults to the value given for the x-axis.\n     *\n     * @return {this} This Game Object.\n     */\n    setOffset: function (x, y)\n    {\n        this.body.setOffset(x, y);\n\n        return this;\n    },\n\n    /**\n     * **DEPRECATED**: Please use `setBodySize` instead.\n     *\n     * Sets the size of this physics body. Setting the size does not adjust the dimensions of the parent Game Object.\n     *\n     * @method Phaser.Physics.Arcade.Components.Size#setSize\n     * @since 3.0.0\n     * @deprecated\n     *\n     * @param {number} width - The new width of the physics body, in pixels.\n     * @param {number} height - The new height of the physics body, in pixels.\n     * @param {boolean} [center=true] - Should the body be re-positioned so its center aligns with the parent Game Object?\n     *\n     * @return {this} This Game Object.\n     */\n    setSize: function (width, height, center)\n    {\n        this.body.setSize(width, height, center);\n\n        return this;\n    },\n\n    /**\n     * Sets the size of this physics body. Setting the size does not adjust the dimensions of the parent Game Object.\n     *\n     * @method Phaser.Physics.Arcade.Components.Size#setBodySize\n     * @since 3.24.0\n     *\n     * @param {number} width - The new width of the physics body, in pixels.\n     * @param {number} height - The new height of the physics body, in pixels.\n     * @param {boolean} [center=true] - Should the body be re-positioned so its center aligns with the parent Game Object?\n     *\n     * @return {this} This Game Object.\n     */\n    setBodySize: function (width, height, center)\n    {\n        this.body.setSize(width, height, center);\n\n        return this;\n    },\n\n    /**\n     * Sets this physics body to use a circle for collision instead of a rectangle.\n     *\n     * @method Phaser.Physics.Arcade.Components.Size#setCircle\n     * @since 3.0.0\n     *\n     * @param {number} radius - The radius of the physics body, in pixels.\n     * @param {number} [offsetX] - The amount to offset the body from the parent Game Object along the x-axis.\n     * @param {number} [offsetY] - The amount to offset the body from the parent Game Object along the y-axis.\n     *\n     * @return {this} This Game Object.\n     */\n    setCircle: function (radius, offsetX, offsetY)\n    {\n        this.body.setCircle(radius, offsetX, offsetY);\n\n        return this;\n    }\n\n};\n\nmodule.exports = Size;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Provides methods for modifying the velocity of an Arcade Physics body.\r\n *\r\n * Should be applied as a mixin and not used directly.\r\n *\r\n * @namespace Phaser.Physics.Arcade.Components.Velocity\r\n * @since 3.0.0\r\n */\r\nvar Velocity = {\r\n\r\n    /**\r\n     * Sets the velocity of the Body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity of the body. Positive values move the body to the right, while negative values move it to the left.\r\n     * @param {number} [y=x] - The vertical velocity of the body. Positive values move the body down, while negative values move it up.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setVelocity: function (x, y)\r\n    {\r\n        this.body.setVelocity(x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal component of the body's velocity.\r\n     *\r\n     * Positive values move the body to the right, while negative values move it to the left.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The new horizontal velocity.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setVelocityX: function (x)\r\n    {\r\n        this.body.setVelocityX(x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical component of the body's velocity.\r\n     *\r\n     * Positive values move the body down, while negative values move it up.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - The new vertical velocity of the body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setVelocityY: function (y)\r\n    {\r\n        this.body.setVelocityY(y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum velocity of the body.\r\n     *\r\n     * @method Phaser.Physics.Arcade.Components.Velocity#setMaxVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The new maximum horizontal velocity.\r\n     * @param {number} [y=x] - The new maximum vertical velocity.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setMaxVelocity: function (x, y)\r\n    {\r\n        this.body.maxVelocity.set(x, y);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Velocity;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade.Components\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Acceleration: require('./Acceleration'),\r\n    Angular: require('./Angular'),\r\n    Bounce: require('./Bounce'),\r\n    Debug: require('./Debug'),\r\n    Drag: require('./Drag'),\r\n    Enable: require('./Enable'),\r\n    Friction: require('./Friction'),\r\n    Gravity: require('./Gravity'),\r\n    Immovable: require('./Immovable'),\r\n    Mass: require('./Mass'),\r\n    OverlapCirc: require('./OverlapCirc'),\r\n    OverlapRect: require('./OverlapRect'),\r\n    Pushable: require('./Pushable'),\r\n    Size: require('./Size'),\r\n    Velocity: require('./Velocity')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Arcade Physics consts.\r\n *\r\n * @ignore\r\n */\r\n\r\nvar CONST = {\r\n\r\n    /**\r\n     * Dynamic Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.DYNAMIC_BODY\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#physicsType\r\n     * @see Phaser.Physics.Arcade.Group#physicsType\r\n     */\r\n    DYNAMIC_BODY: 0,\r\n\r\n    /**\r\n     * Static Body.\r\n     *\r\n     * @name Phaser.Physics.Arcade.STATIC_BODY\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#physicsType\r\n     * @see Phaser.Physics.Arcade.StaticBody#physicsType\r\n     */\r\n    STATIC_BODY: 1,\r\n\r\n    /**\r\n     * Arcade Physics Group containing Dynamic Bodies.\r\n     *\r\n     * @name Phaser.Physics.Arcade.GROUP\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    GROUP: 2,\r\n\r\n    /**\r\n     * A Tilemap Layer.\r\n     *\r\n     * @name Phaser.Physics.Arcade.TILEMAPLAYER\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILEMAPLAYER: 3,\r\n\r\n    /**\r\n     * Facing no direction (initial value).\r\n     *\r\n     * @name Phaser.Physics.Arcade.FACING_NONE\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#facing\r\n     */\r\n    FACING_NONE: 10,\r\n\r\n    /**\r\n     * Facing up.\r\n     *\r\n     * @name Phaser.Physics.Arcade.FACING_UP\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#facing\r\n     */\r\n    FACING_UP: 11,\r\n\r\n    /**\r\n     * Facing down.\r\n     *\r\n     * @name Phaser.Physics.Arcade.FACING_DOWN\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#facing\r\n     */\r\n    FACING_DOWN: 12,\r\n\r\n    /**\r\n     * Facing left.\r\n     *\r\n     * @name Phaser.Physics.Arcade.FACING_LEFT\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#facing\r\n     */\r\n    FACING_LEFT: 13,\r\n\r\n    /**\r\n     * Facing right.\r\n     *\r\n     * @name Phaser.Physics.Arcade.FACING_RIGHT\r\n     * @readonly\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     *\r\n     * @see Phaser.Physics.Arcade.Body#facing\r\n     */\r\n    FACING_RIGHT: 14\r\n\r\n};\r\n\r\nmodule.exports = CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Collide Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least\r\n * one of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\r\n * \r\n * It provides an alternative means to handling collide events rather than using the callback approach.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('collide', listener)`.\r\n * \r\n * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#COLLIDE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the collision. This is the parent of `body1`.\r\n * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the collision. This is the parent of `body2`.\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the collision.\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the collision.\r\n */\r\nmodule.exports = 'collide';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Overlap Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least\r\n * one of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\r\n * \r\n * It provides an alternative means to handling overlap events rather than using the callback approach.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('overlap', listener)`.\r\n * \r\n * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#OVERLAP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the overlap. This is the parent of `body1`.\r\n * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the overlap. This is the parent of `body2`.\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the overlap.\r\n * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the overlap.\r\n */\r\nmodule.exports = 'overlap';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Pause Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance when it is paused.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('pause', listener)`.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#PAUSE\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Resume Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance when it resumes from a paused state.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('resume', listener)`.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#RESUME\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics Tile Collide Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_\r\n * has its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\r\n * \r\n * It provides an alternative means to handling collide events rather than using the callback approach.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.\r\n * \r\n * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#TILE_COLLIDE\r\n * @since 3.16.1\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the collision. This is the parent of `body`.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile the body collided with.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the collision.\r\n */\r\nmodule.exports = 'tilecollide';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics Tile Overlap Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_\r\n * has its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\r\n * \r\n * It provides an alternative means to handling overlap events rather than using the callback approach.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.\r\n * \r\n * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#TILE_OVERLAP\r\n * @since 3.16.1\r\n * \r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the overlap. This is the parent of `body`.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile the body overlapped.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the overlap.\r\n */\r\nmodule.exports = 'tileoverlap';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Bounds Event.\r\n * \r\n * This event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_\r\n * it has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.\r\n * \r\n * It provides an alternative means to handling collide events rather than using the callback approach.\r\n * \r\n * Listen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#WORLD_BOUNDS\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body that hit the world bounds.\r\n * @param {boolean} up - Is the Body blocked up? I.e. collided with the top of the world bounds.\r\n * @param {boolean} down - Is the Body blocked down? I.e. collided with the bottom of the world bounds.\r\n * @param {boolean} left - Is the Body blocked left? I.e. collided with the left of the world bounds.\r\n * @param {boolean} right - Is the Body blocked right? I.e. collided with the right of the world bounds.\r\n */\r\nmodule.exports = 'worldbounds';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Arcade Physics World Step Event.\r\n *\r\n * This event is dispatched by an Arcade Physics World instance whenever a physics step is run.\r\n * It is emitted _after_ the bodies and colliders have been updated.\r\n *\r\n * In high framerate settings this can be multiple times per game frame.\r\n *\r\n * Listen to it from a Scene using: `this.physics.world.on('worldstep', listener)`.\r\n *\r\n * @event Phaser.Physics.Arcade.Events#WORLD_STEP\r\n * @since 3.18.0\r\n *\r\n * @param {number} delta - The delta time amount of this step, in seconds.\r\n */\r\nmodule.exports = 'worldstep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    COLLIDE: require('./COLLIDE_EVENT'),\r\n    OVERLAP: require('./OVERLAP_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    TILE_COLLIDE: require('./TILE_COLLIDE_EVENT'),\r\n    TILE_OVERLAP: require('./TILE_OVERLAP_EVENT'),\r\n    WORLD_BOUNDS: require('./WORLD_BOUNDS_EVENT'),\r\n    WORLD_STEP: require('./WORLD_STEP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade\r\n */\r\n\r\nvar Arcade = {\r\n\r\n    ArcadePhysics: require('./ArcadePhysics'),\r\n    Body: require('./Body'),\r\n    Collider: require('./Collider'),\r\n    Components: require('./components'),\r\n    Events: require('./events'),\r\n    Factory: require('./Factory'),\r\n    GetOverlapX: require('./GetOverlapX'),\r\n    GetOverlapY: require('./GetOverlapY'),\r\n    SeparateX: require('./SeparateX'),\r\n    SeparateY: require('./SeparateY'),\r\n    Group: require('./PhysicsGroup'),\r\n    Image: require('./ArcadeImage'),\r\n    Sprite: require('./ArcadeSprite'),\r\n    StaticBody: require('./StaticBody'),\r\n    StaticGroup: require('./StaticPhysicsGroup'),\r\n    Tilemap: require('./tilemap/'),\r\n    World: require('./World')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nArcade = Extend(false, Arcade, CONST);\r\n\r\nmodule.exports = Arcade;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A function to process the collision callbacks between a single tile and an Arcade Physics enabled Game Object.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileCallbacks\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tile} tile - The Tile to process.\r\n * @param {Phaser.GameObjects.Sprite} sprite - The Game Object to process with the Tile.\r\n *\r\n * @return {boolean} The result of the callback, `true` for further processing, or `false` to skip this pair.\r\n */\r\nvar ProcessTileCallbacks = function (tile, sprite)\r\n{\r\n    //  Tile callbacks take priority over layer level callbacks\r\n    if (tile.collisionCallback)\r\n    {\r\n        return !tile.collisionCallback.call(tile.collisionCallbackContext, sprite, tile);\r\n    }\r\n    else if (tile.layer.callbacks[tile.index])\r\n    {\r\n        return !tile.layer.callbacks[tile.index].callback.call(\r\n            tile.layer.callbacks[tile.index].callbackContext, sprite, tile\r\n        );\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nmodule.exports = ProcessTileCallbacks;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internal function to process the separation of a physics body from a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileSeparationX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {number} x - The x separation amount.\r\n */\r\nvar ProcessTileSeparationX = function (body, x)\r\n{\r\n    if (x < 0)\r\n    {\r\n        body.blocked.none = false;\r\n        body.blocked.left = true;\r\n    }\r\n    else if (x > 0)\r\n    {\r\n        body.blocked.none = false;\r\n        body.blocked.right = true;\r\n    }\r\n\r\n    body.position.x -= x;\r\n\r\n    if (body.bounce.x === 0)\r\n    {\r\n        body.velocity.x = 0;\r\n    }\r\n    else\r\n    {\r\n        body.velocity.x = -body.velocity.x * body.bounce.x;\r\n    }\r\n};\r\n\r\nmodule.exports = ProcessTileSeparationX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internal function to process the separation of a physics body from a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.ProcessTileSeparationY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {number} y - The y separation amount.\r\n */\r\nvar ProcessTileSeparationY = function (body, y)\r\n{\r\n    if (y < 0)\r\n    {\r\n        body.blocked.none = false;\r\n        body.blocked.up = true;\r\n    }\r\n    else if (y > 0)\r\n    {\r\n        body.blocked.none = false;\r\n        body.blocked.down = true;\r\n    }\r\n\r\n    body.position.y -= y;\r\n\r\n    if (body.bounce.y === 0)\r\n    {\r\n        body.velocity.y = 0;\r\n    }\r\n    else\r\n    {\r\n        body.velocity.y = -body.velocity.y * body.bounce.y;\r\n    }\r\n};\r\n\r\nmodule.exports = ProcessTileSeparationY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileCheckX = require('./TileCheckX');\r\nvar TileCheckY = require('./TileCheckY');\r\nvar TileIntersectsBody = require('./TileIntersectsBody');\r\n\r\n/**\r\n * The core separation function to separate a physics body and a tile.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.SeparateTile\r\n * @since 3.0.0\r\n *\r\n * @param {number} i - The index of the tile within the map data.\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to collide against.\r\n * @param {Phaser.Geom.Rectangle} tileWorldRect - A rectangle-like object defining the dimensions of the tile.\r\n * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The tilemapLayer to collide against.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n * @param {boolean} isLayer - Is this check coming from a TilemapLayer or an array of tiles?\r\n *\r\n * @return {boolean} `true` if the body was separated, otherwise `false`.\r\n */\r\nvar SeparateTile = function (i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer)\r\n{\r\n    var tileLeft = tileWorldRect.left;\r\n    var tileTop = tileWorldRect.top;\r\n    var tileRight = tileWorldRect.right;\r\n    var tileBottom = tileWorldRect.bottom;\r\n    var faceHorizontal = tile.faceLeft || tile.faceRight;\r\n    var faceVertical = tile.faceTop || tile.faceBottom;\r\n\r\n    if (!isLayer)\r\n    {\r\n        faceHorizontal = true;\r\n        faceVertical = true;\r\n    }\r\n\r\n    //  We don't need to go any further if this tile doesn't actually have any colliding faces. This\r\n    //  could happen if the tile was meant to be collided with re: a callback, but otherwise isn't\r\n    //  needed for separation.\r\n    if (!faceHorizontal && !faceVertical)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    var ox = 0;\r\n    var oy = 0;\r\n    var minX = 0;\r\n    var minY = 1;\r\n\r\n    if (body.deltaAbsX() > body.deltaAbsY())\r\n    {\r\n        //  Moving faster horizontally, check X axis first\r\n        minX = -1;\r\n    }\r\n    else if (body.deltaAbsX() < body.deltaAbsY())\r\n    {\r\n        //  Moving faster vertically, check Y axis first\r\n        minY = -1;\r\n    }\r\n\r\n    if (body.deltaX() !== 0 && body.deltaY() !== 0 && faceHorizontal && faceVertical)\r\n    {\r\n        //  We only need do this if both axes have colliding faces AND we're moving in both\r\n        //  directions\r\n        minX = Math.min(Math.abs(body.position.x - tileRight), Math.abs(body.right - tileLeft));\r\n        minY = Math.min(Math.abs(body.position.y - tileBottom), Math.abs(body.bottom - tileTop));\r\n    }\r\n\r\n    if (minX < minY)\r\n    {\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);\r\n\r\n            //  That's horizontal done, check if we still intersects? If not then we can return now\r\n            if (ox !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (faceVertical)\r\n        {\r\n            oy = TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer);\r\n\r\n            //  That's vertical done, check if we still intersects? If not then we can return now\r\n            if (oy !== 0 && !TileIntersectsBody(tileWorldRect, body))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (faceHorizontal)\r\n        {\r\n            ox = TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer);\r\n        }\r\n    }\r\n\r\n    return (ox !== 0 || oy !== 0);\r\n};\r\n\r\nmodule.exports = SeparateTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ProcessTileSeparationX = require('./ProcessTileSeparationX');\r\n\r\n/**\r\n * Check the body against the given tile on the X axis.\r\n * Used internally by the SeparateTile function.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileCheckX\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to check.\r\n * @param {number} tileLeft - The left position of the tile within the tile world.\r\n * @param {number} tileRight - The right position of the tile within the tile world.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n * @param {boolean} isLayer - Is this check coming from a TilemapLayer or an array of tiles?\r\n *\r\n * @return {number} The amount of separation that occurred.\r\n */\r\nvar TileCheckX = function (body, tile, tileLeft, tileRight, tileBias, isLayer)\r\n{\r\n    var ox = 0;\r\n\r\n    var faceLeft = tile.faceLeft;\r\n    var faceRight = tile.faceRight;\r\n    var collideLeft = tile.collideLeft;\r\n    var collideRight = tile.collideRight;\r\n\r\n    if (!isLayer)\r\n    {\r\n        faceLeft = true;\r\n        faceRight = true;\r\n        collideLeft = true;\r\n        collideRight = true;\r\n    }\r\n\r\n    if (body.deltaX() < 0 && collideRight && body.checkCollision.left)\r\n    {\r\n        //  Body is moving LEFT\r\n        if (faceRight && body.x < tileRight)\r\n        {\r\n            ox = body.x - tileRight;\r\n\r\n            if (ox < -tileBias)\r\n            {\r\n                ox = 0;\r\n            }\r\n        }\r\n    }\r\n    else if (body.deltaX() > 0 && collideLeft && body.checkCollision.right)\r\n    {\r\n        //  Body is moving RIGHT\r\n        if (faceLeft && body.right > tileLeft)\r\n        {\r\n            ox = body.right - tileLeft;\r\n\r\n            if (ox > tileBias)\r\n            {\r\n                ox = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (ox !== 0)\r\n    {\r\n        if (body.customSeparateX)\r\n        {\r\n            body.overlapX = ox;\r\n        }\r\n        else\r\n        {\r\n            ProcessTileSeparationX(body, ox);\r\n        }\r\n    }\r\n\r\n    return ox;\r\n};\r\n\r\nmodule.exports = TileCheckX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ProcessTileSeparationY = require('./ProcessTileSeparationY');\r\n\r\n/**\r\n * Check the body against the given tile on the Y axis.\r\n * Used internally by the SeparateTile function.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileCheckY\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\r\n * @param {Phaser.Tilemaps.Tile} tile - The tile to check.\r\n * @param {number} tileTop - The top position of the tile within the tile world.\r\n * @param {number} tileBottom - The bottom position of the tile within the tile world.\r\n * @param {number} tileBias - The tile bias value. Populated by the `World.TILE_BIAS` constant.\r\n * @param {boolean} isLayer - Is this check coming from a TilemapLayer or an array of tiles?\r\n *\r\n * @return {number} The amount of separation that occurred.\r\n */\r\nvar TileCheckY = function (body, tile, tileTop, tileBottom, tileBias, isLayer)\r\n{\r\n    var oy = 0;\r\n\r\n    var faceTop = tile.faceTop;\r\n    var faceBottom = tile.faceBottom;\r\n    var collideUp = tile.collideUp;\r\n    var collideDown = tile.collideDown;\r\n\r\n    if (!isLayer)\r\n    {\r\n        faceTop = true;\r\n        faceBottom = true;\r\n        collideUp = true;\r\n        collideDown = true;\r\n    }\r\n\r\n    if (body.deltaY() < 0 && collideDown && body.checkCollision.up)\r\n    {\r\n        //  Body is moving UP\r\n        if (faceBottom && body.y < tileBottom)\r\n        {\r\n            oy = body.y - tileBottom;\r\n\r\n            if (oy < -tileBias)\r\n            {\r\n                oy = 0;\r\n            }\r\n        }\r\n    }\r\n    else if (body.deltaY() > 0 && collideUp && body.checkCollision.down)\r\n    {\r\n        //  Body is moving DOWN\r\n        if (faceTop && body.bottom > tileTop)\r\n        {\r\n            oy = body.bottom - tileTop;\r\n\r\n            if (oy > tileBias)\r\n            {\r\n                oy = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (oy !== 0)\r\n    {\r\n        if (body.customSeparateY)\r\n        {\r\n            body.overlapY = oy;\r\n        }\r\n        else\r\n        {\r\n            ProcessTileSeparationY(body, oy);\r\n        }\r\n    }\r\n\r\n    return oy;\r\n};\r\n\r\nmodule.exports = TileCheckY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks for intersection between the given tile rectangle-like object and an Arcade Physics body.\r\n *\r\n * @function Phaser.Physics.Arcade.Tilemap.TileIntersectsBody\r\n * @since 3.0.0\r\n *\r\n * @param {{ left: number, right: number, top: number, bottom: number }} tileWorldRect - A rectangle object that defines the tile placement in the world.\r\n * @param {Phaser.Physics.Arcade.Body} body - The body to check for intersection against.\r\n *\r\n * @return {boolean} Returns `true` of the tile intersects with the body, otherwise `false`.\r\n */\r\nvar TileIntersectsBody = function (tileWorldRect, body)\r\n{\r\n    // Currently, all bodies are treated as rectangles when colliding with a Tile.\r\n\r\n    return !(\r\n        body.right <= tileWorldRect.left ||\r\n        body.bottom <= tileWorldRect.top ||\r\n        body.position.x >= tileWorldRect.right ||\r\n        body.position.y >= tileWorldRect.bottom\r\n    );\r\n};\r\n\r\nmodule.exports = TileIntersectsBody;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Arcade.Tilemap\r\n */\r\n\r\nvar Tilemap = {\r\n\r\n    ProcessTileCallbacks: require('./ProcessTileCallbacks'),\r\n    ProcessTileSeparationX: require('./ProcessTileSeparationX'),\r\n    ProcessTileSeparationY: require('./ProcessTileSeparationY'),\r\n    SeparateTile: require('./SeparateTile'),\r\n    TileCheckX: require('./TileCheckX'),\r\n    TileCheckY: require('./TileCheckY'),\r\n    TileIntersectsBody: require('./TileIntersectsBody')\r\n\r\n};\r\n\r\nmodule.exports = Tilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Types.Physics\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Arcade: require('./arcade'),\r\n    Matter: require('./matter-js')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * \r\n * The Body Bounds class contains methods to help you extract the world coordinates from various points around\r\n * the bounds of a Matter Body. Because Matter bodies are positioned based on their center of mass, and not a\r\n * dimension based center, you often need to get the bounds coordinates in order to properly align them in the world.\r\n * \r\n * You can access this class via the MatterPhysics class from a Scene, i.e.:\r\n * \r\n * ```javascript\r\n * this.matter.bodyBounds.getTopLeft(body);\r\n * ```\r\n * \r\n * See also the `MatterPhysics.alignBody` method.\r\n *\r\n * @class BodyBounds\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.22.0\r\n */\r\nvar BodyBounds = new Class({\r\n\r\n    initialize:\r\n\r\n    function BodyBounds ()\r\n    {\r\n        /**\r\n         * A Vector2 that stores the temporary bounds center value during calculations by methods in this class.\r\n         *\r\n         * @name Phaser.Physics.Matter.BodyBounds#boundsCenter\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.22.0\r\n         */\r\n        this.boundsCenter = new Vector2();\r\n\r\n        /**\r\n         * A Vector2 that stores the temporary center diff values during calculations by methods in this class.\r\n         *\r\n         * @name Phaser.Physics.Matter.BodyBounds#centerDiff\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.22.0\r\n         */\r\n        this.centerDiff = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Parses the given body to get the bounds diff values from it.\r\n     * \r\n     * They're stored in this class in the temporary properties `boundsCenter` and `centerDiff`.\r\n     * \r\n     * This method is called automatically by all other methods in this class.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#parseBody\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the bounds position from.\r\n     *\r\n     * @return {boolean} `true` if it was able to get the bounds, otherwise `false`.\r\n     */\r\n    parseBody: function (body)\r\n    {\r\n        body = (body.hasOwnProperty('body')) ? body.body : body;\r\n\r\n        if (!body.hasOwnProperty('bounds') || !body.hasOwnProperty('centerOfMass'))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var boundsCenter = this.boundsCenter;\r\n        var centerDiff = this.centerDiff;\r\n\r\n        var boundsWidth = body.bounds.max.x - body.bounds.min.x;\r\n        var boundsHeight = body.bounds.max.y - body.bounds.min.y;\r\n\r\n        var bodyCenterX = boundsWidth * body.centerOfMass.x;\r\n        var bodyCenterY = boundsHeight * body.centerOfMass.y;\r\n\r\n        boundsCenter.set(boundsWidth / 2, boundsHeight / 2);\r\n        centerDiff.set(bodyCenterX - boundsCenter.x, bodyCenterY - boundsCenter.y);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-left of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopLeft\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopLeft: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the top-right of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getTopRight\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getTopRight: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y + center.y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the left-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getLeftCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getLeftCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the right-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getRightCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getRightCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y + diff.y\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-left of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomLeft\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomLeft: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + center.x + diff.x,\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-center of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomCenter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomCenter: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x + diff.x,\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Takes a Body and returns the world coordinates of the bottom-right of its _bounds_.\r\n     * \r\n     * Body bounds are updated by Matter each step and factor in scale and rotation.\r\n     * This will return the world coordinate based on the bodies _current_ position and bounds.\r\n     *\r\n     * @method Phaser.Physics.Matter.BodyBounds#getBottomRight\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to get the position from.\r\n     * @param {number} [x=0] - Optional horizontal offset to add to the returned coordinates.\r\n     * @param {number} [y=0] - Optional vertical offset to add to the returned coordinates.\r\n     *\r\n     * @return {(Phaser.Math.Vector2|false)} A Vector2 containing the coordinates, or `false` if it was unable to parse the body.\r\n     */\r\n    getBottomRight: function (body, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.parseBody(body))\r\n        {\r\n            var center = this.boundsCenter;\r\n            var diff = this.centerDiff;\r\n\r\n            return new Vector2(\r\n                x - (center.x - diff.x),\r\n                y - (center.y - diff.y)\r\n            );\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BodyBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Matter.Matter\r\n */\r\n\r\nvar Matter = require('./lib/core/Matter');\r\n\r\nMatter.Body = require('./lib/body/Body');\r\nMatter.Composite = require('./lib/body/Composite');\r\nMatter.World = require('./lib/body/World');\r\n\r\nMatter.Detector = require('./lib/collision/Detector');\r\nMatter.Grid = require('./lib/collision/Grid');\r\nMatter.Pairs = require('./lib/collision/Pairs');\r\nMatter.Pair = require('./lib/collision/Pair');\r\nMatter.Query = require('./lib/collision/Query');\r\nMatter.Resolver = require('./lib/collision/Resolver');\r\nMatter.SAT = require('./lib/collision/SAT');\r\n\r\nMatter.Constraint = require('./lib/constraint/Constraint');\r\n\r\nMatter.Common = require('./lib/core/Common');\r\nMatter.Engine = require('./lib/core/Engine');\r\nMatter.Events = require('./lib/core/Events');\r\nMatter.Sleeping = require('./lib/core/Sleeping');\r\nMatter.Plugin = require('./lib/core/Plugin');\r\n\r\nMatter.Bodies = require('./lib/factory/Bodies');\r\nMatter.Composites = require('./lib/factory/Composites');\r\n\r\nMatter.Axes = require('./lib/geometry/Axes');\r\nMatter.Bounds = require('./lib/geometry/Bounds');\r\nMatter.Svg = require('./lib/geometry/Svg');\r\nMatter.Vector = require('./lib/geometry/Vector');\r\nMatter.Vertices = require('./lib/geometry/Vertices');\r\n\r\n// aliases\r\n\r\nMatter.World.add = Matter.Composite.add;\r\nMatter.World.remove = Matter.Composite.remove;\r\nMatter.World.addComposite = Matter.Composite.addComposite;\r\nMatter.World.addBody = Matter.Composite.addBody;\r\nMatter.World.addConstraint = Matter.Composite.addConstraint;\r\nMatter.World.clear = Matter.Composite.clear;\r\n\r\nmodule.exports = Matter;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Bodies = require('./lib/factory/Bodies');\nvar Class = require('../../utils/Class');\nvar Composites = require('./lib/factory/Composites');\nvar Constraint = require('./lib/constraint/Constraint');\nvar Svg = require('./lib/geometry/Svg');\nvar MatterGameObject = require('./MatterGameObject');\nvar MatterImage = require('./MatterImage');\nvar MatterSprite = require('./MatterSprite');\nvar MatterTileBody = require('./MatterTileBody');\nvar PhysicsEditorParser = require('./PhysicsEditorParser');\nvar PhysicsJSONParser = require('./PhysicsJSONParser');\nvar PointerConstraint = require('./PointerConstraint');\nvar Vertices = require('./lib/geometry/Vertices');\n\n/**\n * @classdesc\n * The Matter Factory is responsible for quickly creating a variety of different types of\n * bodies, constraints and Game Objects and adding them into the physics world.\n *\n * You access the factory from within a Scene using `add`:\n *\n * ```javascript\n * this.matter.add.rectangle(x, y, width, height);\n * ```\n *\n * Use of the Factory is optional. All of the objects it creates can also be created\n * directly via your own code or constructors. It is provided as a means to keep your\n * code concise.\n *\n * @class Factory\n * @memberof Phaser.Physics.Matter\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Matter.World} world - The Matter World which this Factory adds to.\n */\nvar Factory = new Class({\n\n    initialize:\n\n    function Factory (world)\n    {\n        /**\n         * The Matter World which this Factory adds to.\n         *\n         * @name Phaser.Physics.Matter.Factory#world\n         * @type {Phaser.Physics.Matter.World}\n         * @since 3.0.0\n         */\n        this.world = world;\n\n        /**\n         * The Scene which this Factory's Matter World belongs to.\n         *\n         * @name Phaser.Physics.Matter.Factory#scene\n         * @type {Phaser.Scene}\n         * @since 3.0.0\n         */\n        this.scene = world.scene;\n\n        /**\n         * A reference to the Scene.Systems this Matter Physics instance belongs to.\n         *\n         * @name Phaser.Physics.Matter.Factory#sys\n         * @type {Phaser.Scenes.Systems}\n         * @since 3.0.0\n         */\n        this.sys = world.scene.sys;\n    },\n\n    /**\n     * Creates a new rigid rectangular Body and adds it to the World.\n     *\n     * @method Phaser.Physics.Matter.Factory#rectangle\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the center of the Body.\n     * @param {number} y - The Y coordinate of the center of the Body.\n     * @param {number} width - The width of the Body.\n     * @param {number} height - The height of the Body.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    rectangle: function (x, y, width, height, options)\n    {\n        var body = Bodies.rectangle(x, y, width, height, options);\n\n        this.world.add(body);\n\n        return body;\n    },\n\n    /**\n     * Creates a new rigid trapezoidal Body and adds it to the World.\n     *\n     * @method Phaser.Physics.Matter.Factory#trapezoid\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the center of the Body.\n     * @param {number} y - The Y coordinate of the center of the Body.\n     * @param {number} width - The width of the trapezoid Body.\n     * @param {number} height - The height of the trapezoid Body.\n     * @param {number} slope - The slope of the trapezoid. 0 creates a rectangle, while 1 creates a triangle. Positive values make the top side shorter, while negative values make the bottom side shorter.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    trapezoid: function (x, y, width, height, slope, options)\n    {\n        var body = Bodies.trapezoid(x, y, width, height, slope, options);\n\n        this.world.add(body);\n\n        return body;\n    },\n\n    /**\n     * Creates a new rigid circular Body and adds it to the World.\n     *\n     * @method Phaser.Physics.Matter.Factory#circle\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the center of the Body.\n     * @param {number} y - The Y coordinate of the center of the Body.\n     * @param {number} radius - The radius of the circle.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {number} [maxSides] - The maximum amount of sides to use for the polygon which will approximate this circle.\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    circle: function (x, y, radius, options, maxSides)\n    {\n        var body = Bodies.circle(x, y, radius, options, maxSides);\n\n        this.world.add(body);\n\n        return body;\n    },\n\n    /**\n     * Creates a new rigid polygonal Body and adds it to the World.\n     *\n     * @method Phaser.Physics.Matter.Factory#polygon\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the center of the Body.\n     * @param {number} y - The Y coordinate of the center of the Body.\n     * @param {number} sides - The number of sides the polygon will have.\n     * @param {number} radius - The \"radius\" of the polygon, i.e. the distance from its center to any vertex. This is also the radius of its circumcircle.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    polygon: function (x, y, sides, radius, options)\n    {\n        var body = Bodies.polygon(x, y, sides, radius, options);\n\n        this.world.add(body);\n\n        return body;\n    },\n\n    /**\n     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices) and adds it to the World.\n     * If the vertices are convex, they will pass through as supplied. Otherwise, if the vertices are concave, they will be decomposed. Note that this process is not guaranteed to support complex sets of vertices, e.g. ones with holes.\n     *\n     * @method Phaser.Physics.Matter.Factory#fromVertices\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the center of the Body.\n     * @param {number} y - The Y coordinate of the center of the Body.\n     * @param {(string|array)} vertexSets - The vertices data. Either a path string or an array of vertices.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {boolean} [flagInternal=false] - Flag internal edges (coincident part edges)\n     * @param {number} [removeCollinear=0.01] - Whether Matter.js will discard collinear edges (to improve performance).\n     * @param {number} [minimumArea=10] - During decomposition discard parts that have an area less than this.\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    fromVertices: function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea)\n    {\n        if (typeof vertexSets === 'string')\n        {\n            vertexSets = Vertices.fromPath(vertexSets);\n        }\n\n        var body = Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);\n\n        this.world.add(body);\n\n        return body;\n    },\n\n    /**\n     * Creates a body using data exported from the application PhysicsEditor (https://www.codeandweb.com/physicseditor)\n     *\n     * The PhysicsEditor file should be loaded as JSON:\n     *\n     * ```javascript\n     * preload ()\n     * {\n     *   this.load.json('vehicles', 'assets/vehicles.json);\n     * }\n     *\n     * create ()\n     * {\n     *   const vehicleShapes = this.cache.json.get('vehicles');\n     *   this.matter.add.fromPhysicsEditor(400, 300, vehicleShapes.truck);\n     * }\n     * ```\n     *\n     * Do not pass the entire JSON file to this method, but instead pass one of the shapes contained within it.\n     *\n     * If you pas in an `options` object, any settings in there will override those in the PhysicsEditor config object.\n     *\n     * @method Phaser.Physics.Matter.Factory#fromPhysicsEditor\n     * @since 3.22.0\n     *\n     * @param {number} x - The horizontal world location of the body.\n     * @param {number} y - The vertical world location of the body.\n     * @param {any} config - The JSON data exported from PhysicsEditor.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    fromPhysicsEditor: function (x, y, config, options, addToWorld)\n    {\n        if (addToWorld === undefined) { addToWorld = true; }\n\n        var body = PhysicsEditorParser.parseBody(x, y, config, options);\n\n        if (addToWorld && !this.world.has(body))\n        {\n            this.world.add(body);\n        }\n\n        return body;\n    },\n\n    /**\n     * Creates a body using the path data from an SVG file.\n     *\n     * SVG Parsing requires the pathseg polyfill from https://github.com/progers/pathseg\n     *\n     * The SVG file should be loaded as XML, as this method requires the ability to extract\n     * the path data from it. I.e.:\n     *\n     * ```javascript\n     * preload ()\n     * {\n     *   this.load.xml('face', 'assets/face.svg);\n     * }\n     *\n     * create ()\n     * {\n     *   this.matter.add.fromSVG(400, 300, this.cache.xml.get('face'));\n     * }\n     * ```\n     *\n     * @method Phaser.Physics.Matter.Factory#fromSVG\n     * @since 3.22.0\n     *\n     * @param {number} x - The X coordinate of the body.\n     * @param {number} y - The Y coordinate of the body.\n     * @param {object} xml - The SVG Path data.\n     * @param {number} [scale=1] - Scale the vertices by this amount after creation.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    fromSVG: function (x, y, xml, scale, options, addToWorld)\n    {\n        if (scale === undefined) { scale = 1; }\n        if (options === undefined) { options = {}; }\n        if (addToWorld === undefined) { addToWorld = true; }\n\n        var path = xml.getElementsByTagName('path');\n        var vertexSets = [];\n\n        for (var i = 0; i < path.length; i++)\n        {\n            var points = Svg.pathToVertices(path[i], 30);\n\n            if (scale !== 1)\n            {\n                Vertices.scale(points, scale, scale);\n            }\n\n            vertexSets.push(points);\n        }\n\n        var body = Bodies.fromVertices(x, y, vertexSets, options);\n\n        if (addToWorld)\n        {\n            this.world.add(body);\n        }\n\n        return body;\n    },\n\n    /**\n     * Creates a body using the supplied physics data, as provided by a JSON file.\n     *\n     * The data file should be loaded as JSON:\n     *\n     * ```javascript\n     * preload ()\n     * {\n     *   this.load.json('ninjas', 'assets/ninjas.json);\n     * }\n     *\n     * create ()\n     * {\n     *   const ninjaShapes = this.cache.json.get('ninjas');\n     *\n     *   this.matter.add.fromJSON(400, 300, ninjaShapes.shinobi);\n     * }\n     * ```\n     *\n     * Do not pass the entire JSON file to this method, but instead pass one of the shapes contained within it.\n     *\n     * If you pas in an `options` object, any settings in there will override those in the config object.\n     *\n     * The structure of the JSON file is as follows:\n     *\n     * ```text\n     * {\n     *   'generator_info': // The name of the application that created the JSON data\n     *   'shapeName': {\n     *     'type': // The type of body\n     *     'label': // Optional body label\n     *     'vertices': // An array, or an array of arrays, containing the vertex data in x/y object pairs\n     *   }\n     * }\n     * ```\n     *\n     * At the time of writing, only the Phaser Physics Tracer App exports in this format.\n     *\n     * @method Phaser.Physics.Matter.Factory#fromJSON\n     * @since 3.22.0\n     *\n     * @param {number} x - The X coordinate of the body.\n     * @param {number} y - The Y coordinate of the body.\n     * @param {any} config - The JSON physics data.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?\n     *\n     * @return {MatterJS.BodyType} A Matter JS Body.\n     */\n    fromJSON: function (x, y, config, options, addToWorld)\n    {\n        if (options === undefined) { options = {}; }\n        if (addToWorld === undefined) { addToWorld = true; }\n\n        var body = PhysicsJSONParser.parseBody(x, y, config, options);\n\n        if (body && addToWorld)\n        {\n            this.world.add(body);\n        }\n\n        return body;\n    },\n\n    /**\n     * Create a new composite containing Matter Image objects created in a grid arrangement.\n     * This function uses the body bounds to prevent overlaps.\n     *\n     * @method Phaser.Physics.Matter.Factory#imageStack\n     * @since 3.0.0\n     *\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|number)} frame - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\n     * @param {number} x - The horizontal position of this composite in the world.\n     * @param {number} y - The vertical position of this composite in the world.\n     * @param {number} columns - The number of columns in the grid.\n     * @param {number} rows - The number of rows in the grid.\n     * @param {number} [columnGap=0] - The distance between each column.\n     * @param {number} [rowGap=0] - The distance between each row.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {MatterJS.CompositeType} A Matter JS Composite Stack.\n     */\n    imageStack: function (key, frame, x, y, columns, rows, columnGap, rowGap, options)\n    {\n        if (columnGap === undefined) { columnGap = 0; }\n        if (rowGap === undefined) { rowGap = 0; }\n        if (options === undefined) { options = {}; }\n\n        var world = this.world;\n        var displayList = this.sys.displayList;\n\n        options.addToWorld = false;\n\n        var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, function (x, y)\n        {\n            var image = new MatterImage(world, x, y, key, frame, options);\n\n            displayList.add(image);\n\n            return image.body;\n        });\n\n        world.add(stack);\n\n        return stack;\n    },\n\n    /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     *\n     * This function uses the body bounds to prevent overlaps.\n     *\n     * @method Phaser.Physics.Matter.Factory#stack\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this composite in the world.\n     * @param {number} y - The vertical position of this composite in the world.\n     * @param {number} columns - The number of columns in the grid.\n     * @param {number} rows - The number of rows in the grid.\n     * @param {number} columnGap - The distance between each column.\n     * @param {number} rowGap - The distance between each row.\n     * @param {function} callback - The callback that creates the stack.\n     *\n     * @return {MatterJS.CompositeType} A new composite containing objects created in the callback.\n     */\n    stack: function (x, y, columns, rows, columnGap, rowGap, callback)\n    {\n        var stack = Composites.stack(x, y, columns, rows, columnGap, rowGap, callback);\n\n        this.world.add(stack);\n\n        return stack;\n    },\n\n    /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body bounds to prevent overlaps.\n     *\n     * @method Phaser.Physics.Matter.Factory#pyramid\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this composite in the world.\n     * @param {number} y - The vertical position of this composite in the world.\n     * @param {number} columns - The number of columns in the pyramid.\n     * @param {number} rows - The number of rows in the pyramid.\n     * @param {number} columnGap - The distance between each column.\n     * @param {number} rowGap - The distance between each row.\n     * @param {function} callback - The callback function to be invoked.\n     *\n     * @return {MatterJS.CompositeType} A Matter JS Composite pyramid.\n     */\n    pyramid: function (x, y, columns, rows, columnGap, rowGap, callback)\n    {\n        var stack = Composites.pyramid(x, y, columns, rows, columnGap, rowGap, callback);\n\n        this.world.add(stack);\n\n        return stack;\n    },\n\n    /**\n     * Chains all bodies in the given composite together using constraints.\n     *\n     * @method Phaser.Physics.Matter.Factory#chain\n     * @since 3.0.0\n     *\n     * @param {MatterJS.CompositeType} composite - The composite in which all bodies will be chained together sequentially.\n     * @param {number} xOffsetA - The horizontal offset of the BodyA constraint. This is a percentage based on the body size, not a world position.\n     * @param {number} yOffsetA - The vertical offset of the BodyA constraint. This is a percentage based on the body size, not a world position.\n     * @param {number} xOffsetB - The horizontal offset of the BodyB constraint. This is a percentage based on the body size, not a world position.\n     * @param {number} yOffsetB - The vertical offset of the BodyB constraint. This is a percentage based on the body size, not a world position.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.CompositeType} The original composite that was passed to this method.\n     */\n    chain: function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options)\n    {\n        return Composites.chain(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options);\n    },\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     *\n     * @method Phaser.Physics.Matter.Factory#mesh\n     * @since 3.0.0\n     *\n     * @param {MatterJS.CompositeType} composite - The composite in which all bodies will be chained together.\n     * @param {number} columns - The number of columns in the mesh.\n     * @param {number} rows - The number of rows in the mesh.\n     * @param {boolean} crossBrace - Create cross braces for the mesh as well?\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.CompositeType} The original composite that was passed to this method.\n     */\n    mesh: function (composite, columns, rows, crossBrace, options)\n    {\n        return Composites.mesh(composite, columns, rows, crossBrace, options);\n    },\n\n    /**\n     * Creates a composite with a Newton's Cradle setup of bodies and constraints.\n     *\n     * @method Phaser.Physics.Matter.Factory#newtonsCradle\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of the start of the cradle.\n     * @param {number} y - The vertical position of the start of the cradle.\n     * @param {number} number - The number of balls in the cradle.\n     * @param {number} size - The radius of each ball in the cradle.\n     * @param {number} length - The length of the 'string' the balls hang from.\n     *\n     * @return {MatterJS.CompositeType} A Newton's cradle composite.\n     */\n    newtonsCradle: function (x, y, number, size, length)\n    {\n        var composite = Composites.newtonsCradle(x, y, number, size, length);\n\n        this.world.add(composite);\n\n        return composite;\n    },\n\n    /**\n     * Creates a composite with simple car setup of bodies and constraints.\n     *\n     * @method Phaser.Physics.Matter.Factory#car\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of the car in the world.\n     * @param {number} y - The vertical position of the car in the world.\n     * @param {number} width - The width of the car chasis.\n     * @param {number} height - The height of the car chasis.\n     * @param {number} wheelSize - The radius of the car wheels.\n     *\n     * @return {MatterJS.CompositeType} A new composite car body.\n     */\n    car: function (x, y, width, height, wheelSize)\n    {\n        var composite = Composites.car(x, y, width, height, wheelSize);\n\n        this.world.add(composite);\n\n        return composite;\n    },\n\n    /**\n     * Creates a simple soft body like object.\n     *\n     * @method Phaser.Physics.Matter.Factory#softBody\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this composite in the world.\n     * @param {number} y - The vertical position of this composite in the world.\n     * @param {number} columns - The number of columns in the Composite.\n     * @param {number} rows - The number of rows in the Composite.\n     * @param {number} columnGap - The distance between each column.\n     * @param {number} rowGap - The distance between each row.\n     * @param {boolean} crossBrace - `true` to create cross braces between the bodies, or `false` to create just straight braces.\n     * @param {number} particleRadius - The radius of this circlular composite.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [particleOptions] - An optional Body configuration object that is used to set initial Body properties on creation.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [constraintOptions] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.CompositeType} A new composite simple soft body.\n     */\n    softBody: function (x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions)\n    {\n        var composite = Composites.softBody(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions);\n\n        this.world.add(composite);\n\n        return composite;\n    },\n\n    /**\n     * This method is an alias for `Factory.constraint`.\n     *\n     * Constraints (or joints) are used for specifying that a fixed distance must be maintained\n     * between two bodies, or a body and a fixed world-space position.\n     *\n     * The stiffness of constraints can be modified to create springs or elastic.\n     *\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`\n     * value (e.g. `0.7` or above).\n     *\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing\n     * `constraintIterations` within the Matter Config.\n     *\n     * For compound bodies, constraints must be applied to the parent body and not one of its parts.\n     *\n     * @method Phaser.Physics.Matter.Factory#joint\n     * @since 3.0.0\n     *\n     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.\n     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.\n     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    joint: function (bodyA, bodyB, length, stiffness, options)\n    {\n        return this.constraint(bodyA, bodyB, length, stiffness, options);\n    },\n\n    /**\n     * This method is an alias for `Factory.constraint`.\n     *\n     * Constraints (or joints) are used for specifying that a fixed distance must be maintained\n     * between two bodies, or a body and a fixed world-space position.\n     *\n     * The stiffness of constraints can be modified to create springs or elastic.\n     *\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`\n     * value (e.g. `0.7` or above).\n     *\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing\n     * `constraintIterations` within the Matter Config.\n     *\n     * For compound bodies, constraints must be applied to the parent body and not one of its parts.\n     *\n     * @method Phaser.Physics.Matter.Factory#spring\n     * @since 3.0.0\n     *\n     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.\n     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.\n     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    spring: function (bodyA, bodyB, length, stiffness, options)\n    {\n        return this.constraint(bodyA, bodyB, length, stiffness, options);\n    },\n\n    /**\n     * Constraints (or joints) are used for specifying that a fixed distance must be maintained\n     * between two bodies, or a body and a fixed world-space position.\n     *\n     * The stiffness of constraints can be modified to create springs or elastic.\n     *\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`\n     * value (e.g. `0.7` or above).\n     *\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing\n     * `constraintIterations` within the Matter Config.\n     *\n     * For compound bodies, constraints must be applied to the parent body and not one of its parts.\n     *\n     * @method Phaser.Physics.Matter.Factory#constraint\n     * @since 3.0.0\n     *\n     * @param {MatterJS.BodyType} bodyA - The first possible `Body` that this constraint is attached to.\n     * @param {MatterJS.BodyType} bodyB - The second possible `Body` that this constraint is attached to.\n     * @param {number} [length] - A Number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    constraint: function (bodyA, bodyB, length, stiffness, options)\n    {\n        if (stiffness === undefined) { stiffness = 1; }\n        if (options === undefined) { options = {}; }\n\n        options.bodyA = (bodyA.type === 'body') ? bodyA : bodyA.body;\n        options.bodyB = (bodyB.type === 'body') ? bodyB : bodyB.body;\n\n        if (!isNaN(length))\n        {\n            options.length = length;\n        }\n\n        options.stiffness = stiffness;\n\n        var constraint = Constraint.create(options);\n\n        this.world.add(constraint);\n\n        return constraint;\n    },\n\n    /**\n     * Constraints (or joints) are used for specifying that a fixed distance must be maintained\n     * between two bodies, or a body and a fixed world-space position.\n     *\n     * A world constraint has only one body, you should specify a `pointA` position in\n     * the constraint options parameter to attach the constraint to the world.\n     *\n     * The stiffness of constraints can be modified to create springs or elastic.\n     *\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness`\n     * value (e.g. `0.7` or above).\n     *\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing\n     * `constraintIterations` within the Matter Config.\n     *\n     * For compound bodies, constraints must be applied to the parent body and not one of its parts.\n     *\n     * @method Phaser.Physics.Matter.Factory#worldConstraint\n     * @since 3.0.0\n     *\n     * @param {MatterJS.BodyType} body - The Matter `Body` that this constraint is attached to.\n     * @param {number} [length] - A number that specifies the target resting length of the constraint. If not given it is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     * @param {number} [stiffness=1] - A Number that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`. A value of `1` means the constraint should be very stiff. A value of `0.2` means the constraint acts as a soft spring.\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    worldConstraint: function (body, length, stiffness, options)\n    {\n        if (stiffness === undefined) { stiffness = 1; }\n        if (options === undefined) { options = {}; }\n\n        options.bodyB = (body.type === 'body') ? body : body.body;\n\n        if (!isNaN(length))\n        {\n            options.length = length;\n        }\n\n        options.stiffness = stiffness;\n\n        var constraint = Constraint.create(options);\n\n        this.world.add(constraint);\n\n        return constraint;\n    },\n\n    /**\n     * This method is an alias for `Factory.pointerConstraint`.\n     *\n     * A Pointer Constraint is a special type of constraint that allows you to click\n     * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\n     * and when one is pressed down it checks to see if that hit any part of any active\n     * body in the world. If it did, and the body has input enabled, it will begin to\n     * drag it until either released, or you stop it via the `stopDrag` method.\n     *\n     * You can adjust the stiffness, length and other properties of the constraint via\n     * the `options` object on creation.\n     *\n     * @method Phaser.Physics.Matter.Factory#mouseSpring\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    mouseSpring: function (options)\n    {\n        return this.pointerConstraint(options);\n    },\n\n    /**\n     * A Pointer Constraint is a special type of constraint that allows you to click\n     * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\n     * and when one is pressed down it checks to see if that hit any part of any active\n     * body in the world. If it did, and the body has input enabled, it will begin to\n     * drag it until either released, or you stop it via the `stopDrag` method.\n     *\n     * You can adjust the stiffness, length and other properties of the constraint via\n     * the `options` object on creation.\n     *\n     * @method Phaser.Physics.Matter.Factory#pointerConstraint\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Matter.MatterConstraintConfig} [options] - An optional Constraint configuration object that is used to set initial Constraint properties on creation.\n     *\n     * @return {MatterJS.ConstraintType} A Matter JS Constraint.\n     */\n    pointerConstraint: function (options)\n    {\n        if (options === undefined) { options = {}; }\n\n        if (!options.hasOwnProperty('render'))\n        {\n            options.render = { visible: false };\n        }\n\n        var pointerConstraint = new PointerConstraint(this.scene, this.world, options);\n\n        this.world.add(pointerConstraint.constraint);\n\n        return pointerConstraint;\n    },\n\n    /**\n     * Creates a Matter Physics Image Game Object.\n     *\n     * An Image is a light-weight Game Object useful for the display of static images in your game,\n     * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\n     * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\n     * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\n     *\n     * @method Phaser.Physics.Matter.Factory#image\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {Phaser.Physics.Matter.Image} The Matter Image Game Object.\n     */\n    image: function (x, y, key, frame, options)\n    {\n        var image = new MatterImage(this.world, x, y, key, frame, options);\n\n        this.sys.displayList.add(image);\n\n        return image;\n    },\n\n    /**\n     * Creates a wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\n     * have one Matter body associated with it. You can either pass in an existing Matter body for\n     * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\n     * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\n     * tile's rectangle bounding box will be used.\n     *\n     * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\n     *\n     * Note: not all Tiled collision shapes are supported. See\n     * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\n     *\n     * @method Phaser.Physics.Matter.Factory#tileBody\n     * @since 3.0.0\n     *\n     * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\n     * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.\n     *\n     * @return {Phaser.Physics.Matter.TileBody} The Matter Tile Body Game Object.\n     */\n    tileBody: function (tile, options)\n    {\n        return new MatterTileBody(this.world, tile, options);\n    },\n\n    /**\n     * Creates a Matter Physics Sprite Game Object.\n     *\n     * A Sprite Game Object is used for the display of both static and animated images in your game.\n     * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\n     * and animated.\n     *\n     * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\n     * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\n     * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\n     *\n     * @method Phaser.Physics.Matter.Factory#sprite\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\n     *\n     * @return {Phaser.Physics.Matter.Sprite} The Matter Sprite Game Object.\n     */\n    sprite: function (x, y, key, frame, options)\n    {\n        var sprite = new MatterSprite(this.world, x, y, key, frame, options);\n\n        this.sys.displayList.add(sprite);\n        this.sys.updateList.add(sprite);\n\n        return sprite;\n    },\n\n    /**\n     * Takes an existing Game Object and injects all of the Matter Components into it.\n     *\n     * This enables you to use component methods such as `setVelocity` or `isSensor` directly from\n     * this Game Object.\n     *\n     * You can also pass in either a Matter Body Configuration object, or a Matter Body instance\n     * to link with this Game Object.\n     *\n     * @method Phaser.Physics.Matter.Factory#gameObject\n     * @since 3.3.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to inject the Matter Components in to.\n     * @param {(Phaser.Types.Physics.Matter.MatterBodyConfig|MatterJS.Body)} [options] - A Matter Body configuration object, or an instance of a Matter Body.\n     * @param {boolean} [addToWorld=true] - Add this Matter Body to the World?\n     *\n     * @return {(Phaser.Physics.Matter.Image|Phaser.Physics.Matter.Sprite|Phaser.GameObjects.GameObject)} The Game Object that had the Matter Components injected into it.\n     */\n    gameObject: function (gameObject, options, addToWorld)\n    {\n        return MatterGameObject(this.world, gameObject, options, addToWorld);\n    },\n\n    /**\n     * Destroys this Factory.\n     *\n     * @method Phaser.Physics.Matter.Factory#destroy\n     * @since 3.5.0\n     */\n    destroy: function ()\n    {\n        this.world = null;\n        this.scene = null;\n        this.sys = null;\n    }\n\n});\n\nmodule.exports = Factory;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Components = require('./components');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Internal function to check if the object has a getter or setter.\r\n *\r\n * @function hasGetterOrSetter\r\n * @private\r\n *\r\n * @param {object} def - The object to check.\r\n *\r\n * @return {boolean} True if it has a getter or setter, otherwise false.\r\n */\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\n/**\r\n * A Matter Game Object is a generic object that allows you to combine any Phaser Game Object,\r\n * including those you have extended or created yourself, with all of the Matter Components.\r\n * \r\n * This enables you to use component methods such as `setVelocity` or `isSensor` directly from\r\n * this Game Object.\r\n *\r\n * @function Phaser.Physics.Matter.MatterGameObject\r\n * @since 3.3.0\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - The Matter world to add the body to.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have the Matter body applied to it.\r\n * @param {(Phaser.Types.Physics.Matter.MatterBodyConfig|MatterJS.Body)} [options] - A Matter Body configuration object, or an instance of a Matter Body.\r\n * @param {boolean} [addToWorld=true] - Should the newly created body be immediately added to the World?\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The Game Object that was created with the Matter body.\r\n */\r\nvar MatterGameObject = function (world, gameObject, options, addToWorld)\r\n{\r\n    if (options === undefined) { options = {}; }\r\n    if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n    var x = gameObject.x;\r\n    var y = gameObject.y;\r\n\r\n    //  Temp body pos to avoid body null checks\r\n    gameObject.body = {\r\n        temp: true,\r\n        position: {\r\n            x: x,\r\n            y: y\r\n        }\r\n    };\r\n\r\n    var mixins = [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Force,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.SetBody,\r\n        Components.Sleep,\r\n        Components.Static,\r\n        Components.Transform,\r\n        Components.Velocity\r\n    ];\r\n\r\n    //  First let's inject all of the components into the Game Object\r\n    mixins.forEach(function (mixin)\r\n    {\r\n        for (var key in mixin)\r\n        {\r\n            if (hasGetterOrSetter(mixin[key]))\r\n            {\r\n                Object.defineProperty(gameObject, key, {\r\n                    get: mixin[key].get,\r\n                    set: mixin[key].set\r\n                });\r\n            }\r\n            else\r\n            {\r\n                Object.defineProperty(gameObject, key, {value: mixin[key]});\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    gameObject.world = world;\r\n\r\n    gameObject._tempVec2 = new Vector2(x, y);\r\n\r\n    if (options.hasOwnProperty('type') && options.type === 'body')\r\n    {\r\n        gameObject.setExistingBody(options, addToWorld);\r\n    }\r\n    else\r\n    {\r\n        var shape = GetFastValue(options, 'shape', null);\r\n\r\n        if (!shape)\r\n        {\r\n            shape = 'rectangle';\r\n        }\r\n\r\n        options.addToWorld = addToWorld;\r\n    \r\n        gameObject.setBody(shape, options);\r\n    }\r\n\r\n    return gameObject;\r\n};\r\n\r\nmodule.exports = MatterGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar GameObject = require('../../gameobjects/GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Image = require('../../gameobjects/image/Image');\r\nvar Pipeline = require('../../gameobjects/components/Pipeline');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Matter Physics Image Game Object.\r\n *\r\n * An Image is a light-weight Game Object useful for the display of static images in your game,\r\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\r\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\r\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\r\n *\r\n * @class Image\r\n * @extends Phaser.GameObjects.Image\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Force\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.SetBody\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n * @extends Phaser.Physics.Matter.Components.Transform\r\n * @extends Phaser.Physics.Matter.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter.World instance that this body belongs to.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n */\r\nvar MatterImage = new Class({\r\n\r\n    Extends: Image,\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Force,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.SetBody,\r\n        Components.Sleep,\r\n        Components.Static,\r\n        Components.Transform,\r\n        Components.Velocity,\r\n        Pipeline\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterImage (world, x, y, texture, frame, options)\r\n    {\r\n        GameObject.call(this, world.scene, 'Image');\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.Physics.Matter.Image#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.24.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setSizeToFrame();\r\n        this.setOrigin();\r\n\r\n        /**\r\n         * A reference to the Matter.World instance that this body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Matter.Image#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * An internal temp vector used for velocity and force calculations.\r\n         *\r\n         * @name Phaser.Physics.Matter.Image#_tempVec2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempVec2 = new Vector2(x, y);\r\n\r\n        var shape = GetFastValue(options, 'shape', null);\r\n\r\n        if (shape)\r\n        {\r\n            this.setBody(shape, options);\r\n        }\r\n        else\r\n        {\r\n            this.setRectangle(this.width, this.height, options);\r\n        }\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.initPipeline();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterImage;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ALIGN_CONST = require('../../display/align/const');\r\nvar Axes = require('./lib/geometry/Axes');\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar BodyBounds = require('./BodyBounds');\r\nvar Bounds = require('./lib/geometry/Bounds');\r\nvar Class = require('../../utils/Class');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Composites = require('./lib/factory/Composites');\r\nvar Constraint = require('./lib/constraint/Constraint');\r\nvar Detector = require('./lib/collision/Detector');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar Factory = require('./Factory');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar Grid = require('./lib/collision/Grid');\r\nvar MatterAttractors = require('./lib/plugins/MatterAttractors');\r\nvar MatterCollisionEvents = require('./lib/plugins/MatterCollisionEvents');\r\nvar MatterLib = require('./lib/core/Matter');\r\nvar MatterWrap = require('./lib/plugins/MatterWrap');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar Pair = require('./lib/collision/Pair');\r\nvar Pairs = require('./lib/collision/Pairs');\r\nvar Plugin = require('./lib/core/Plugin');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar Query = require('./lib/collision/Query');\r\nvar Resolver = require('./lib/collision/Resolver');\r\nvar SAT = require('./lib/collision/SAT');\r\nvar SceneEvents = require('../../scene/events');\r\nvar Svg = require('./lib/geometry/Svg');\r\nvar Vector = require('./lib/geometry/Vector');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\nvar World = require('./World');\r\n\r\n/**\r\n * @classdesc\r\n * The Phaser Matter plugin provides the ability to use the Matter JS Physics Engine within your Phaser games.\r\n * \r\n * Unlike Arcade Physics, the other physics system provided with Phaser, Matter JS is a full-body physics system.\r\n * It features:\r\n * \r\n * * Rigid bodies\r\n * * Compound bodies\r\n * * Composite bodies\r\n * * Concave and convex hulls\r\n * * Physical properties (mass, area, density etc.)\r\n * * Restitution (elastic and inelastic collisions)\r\n * * Collisions (broad-phase, mid-phase and narrow-phase)\r\n * * Stable stacking and resting\r\n * * Conservation of momentum\r\n * * Friction and resistance\r\n * * Constraints\r\n * * Gravity\r\n * * Sleeping and static bodies\r\n * * Rounded corners (chamfering)\r\n * * Views (translate, zoom)\r\n * * Collision queries (raycasting, region tests)\r\n * * Time scaling (slow-mo, speed-up)\r\n * \r\n * Configuration of Matter is handled via the Matter World Config object, which can be passed in either the\r\n * Phaser Game Config, or Phaser Scene Config. Here is a basic example:\r\n * \r\n * ```js\r\n * physics: {\r\n *     default: 'matter',\r\n *     matter: {\r\n *         enableSleeping: true,\r\n *         gravity: {\r\n *             y: 0\r\n *         },\r\n *         debug: {\r\n *             showBody: true,\r\n *             showStaticBody: true\r\n *         }\r\n *     }\r\n * }\r\n * ```\r\n * \r\n * This class acts as an interface between a Phaser Scene and a single instance of the Matter Engine.\r\n * \r\n * Use it to access the most common Matter features and helper functions.\r\n * \r\n * You can find details, documentation and examples on the Matter JS website: https://brm.io/matter-js/\r\n *\r\n * @class MatterPhysics\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Phaser Scene that owns this Matter Physics instance.\r\n */\r\nvar MatterPhysics = new Class({\r\n\r\n    initialize:\r\n\r\n    function MatterPhysics (scene)\r\n    {\r\n        /**\r\n         * The Phaser Scene that owns this Matter Physics instance\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems that belong to the Scene owning this Matter Physics instance.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The parsed Matter Configuration object.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#config\r\n         * @type {Phaser.Types.Physics.Matter.MatterWorldConfig}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = this.getConfig();\r\n\r\n        /**\r\n         * An instance of the Matter World class. This class is responsible for the updating of the\r\n         * Matter Physics world, as well as handling debug drawing functions.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world;\r\n\r\n        /**\r\n         * An instance of the Matter Factory. This class provides lots of functions for creating a\r\n         * wide variety of physics objects and adds them automatically to the Matter World.\r\n         * \r\n         * You can use this class to cut-down on the amount of code required in your game, however,\r\n         * use of the Factory is entirely optional and should be seen as a development aid. It's\r\n         * perfectly possible to create and add components to the Matter world without using it.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#add\r\n         * @type {Phaser.Physics.Matter.Factory}\r\n         * @since 3.0.0\r\n         */\r\n        this.add;\r\n\r\n        /**\r\n         * An instance of the Body Bounds class. This class contains functions used for getting the\r\n         * world position from various points around the bounds of a physics body.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#bodyBounds\r\n         * @type {Phaser.Physics.Matter.BodyBounds}\r\n         * @since 3.22.0\r\n         */\r\n        this.bodyBounds;\r\n\r\n        //  Body\r\n\r\n        /**\r\n         * A reference to the `Matter.Body` module.\r\n         * \r\n         * The `Matter.Body` module contains methods for creating and manipulating body models.\r\n         * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n         * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the `Bodies` module.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#body\r\n         * @type {MatterJS.BodyFactory}\r\n         * @since 3.18.0\r\n         */\r\n        this.body = Body;\r\n\r\n        /**\r\n         * A reference to the `Matter.Composite` module.\r\n         * \r\n         * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n         * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n         * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n         * Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#composite\r\n         * @type {MatterJS.CompositeFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.composite = Composite;\r\n\r\n        //  Collision:\r\n\r\n        /**\r\n         * A reference to the `Matter.Detector` module.\r\n         * \r\n         * The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#detector\r\n         * @type {MatterJS.DetectorFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.detector = Detector;\r\n\r\n        /**\r\n         * A reference to the `Matter.Grid` module.\r\n         * \r\n         * The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#grid\r\n         * @type {MatterJS.GridFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.grid = Grid;\r\n\r\n        /**\r\n         * A reference to the `Matter.Pair` module.\r\n         * \r\n         * The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#pair\r\n         * @type {MatterJS.PairFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.pair = Pair;\r\n\r\n        /**\r\n         * A reference to the `Matter.Pairs` module.\r\n         * \r\n         * The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#pairs\r\n         * @type {MatterJS.PairsFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.pairs = Pairs;\r\n\r\n        /**\r\n         * A reference to the `Matter.Query` module.\r\n         * \r\n         * The `Matter.Query` module contains methods for performing collision queries.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#query\r\n         * @type {MatterJS.QueryFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.query = Query;\r\n\r\n        /**\r\n         * A reference to the `Matter.Resolver` module.\r\n         * \r\n         * The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#resolver\r\n         * @type {MatterJS.ResolverFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.resolver = Resolver;\r\n\r\n        /**\r\n         * A reference to the `Matter.SAT` module.\r\n         * \r\n         * The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#sat\r\n         * @type {MatterJS.SATFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.sat = SAT;\r\n\r\n        //  Constraint\r\n\r\n        /**\r\n         * A reference to the `Matter.Constraint` module.\r\n         * \r\n         * The `Matter.Constraint` module contains methods for creating and manipulating constraints.\r\n         * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\r\n         * The stiffness of constraints can be modified to create springs or elastic.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#constraint\r\n         * @type {MatterJS.ConstraintFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.constraint = Constraint;\r\n\r\n        //  Factory\r\n\r\n        /**\r\n         * A reference to the `Matter.Bodies` module.\r\n         * \r\n         * The `Matter.Bodies` module contains factory methods for creating rigid bodies\r\n         * with commonly used body configurations (such as rectangles, circles and other polygons).\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#bodies\r\n         * @type {MatterJS.BodiesFactory}\r\n         * @since 3.18.0\r\n         */\r\n        this.bodies = Bodies;\r\n\r\n        /**\r\n         * A reference to the `Matter.Composites` module.\r\n         * \r\n         * The `Matter.Composites` module contains factory methods for creating composite bodies\r\n         * with commonly used configurations (such as stacks and chains).\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#composites\r\n         * @type {MatterJS.CompositesFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.composites = Composites;\r\n\r\n        //  Geometry\r\n\r\n        /**\r\n         * A reference to the `Matter.Axes` module.\r\n         * \r\n         * The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#axes\r\n         * @type {MatterJS.AxesFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.axes = Axes;\r\n\r\n        /**\r\n         * A reference to the `Matter.Bounds` module.\r\n         * \r\n         * The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#bounds\r\n         * @type {MatterJS.BoundsFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.bounds = Bounds;\r\n\r\n        /**\r\n         * A reference to the `Matter.Svg` module.\r\n         * \r\n         * The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n         *\r\n         * To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#svg\r\n         * @type {MatterJS.SvgFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.svg = Svg;\r\n\r\n        /**\r\n         * A reference to the `Matter.Vector` module.\r\n         * \r\n         * The `Matter.Vector` module contains methods for creating and manipulating vectors.\r\n         * Vectors are the basis of all the geometry related operations in the engine.\r\n         * A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#vector\r\n         * @type {MatterJS.VectorFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.vector = Vector;\r\n\r\n        /**\r\n         * A reference to the `Matter.Vertices` module.\r\n         * \r\n         * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n         * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n         * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#vertices\r\n         * @type {MatterJS.VerticesFactory}\r\n         * @since 3.22.0\r\n         */\r\n        this.vertices = Vertices;\r\n\r\n        /**\r\n         * A reference to the `Matter.Vertices` module.\r\n         * \r\n         * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n         * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n         * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#verts\r\n         * @type {MatterJS.VerticesFactory}\r\n         * @since 3.14.0\r\n         */\r\n        this.verts = Vertices;\r\n\r\n        /**\r\n         * An internal temp vector used for velocity and force calculations.\r\n         *\r\n         * @name Phaser.Physics.Matter.MatterPhysics#_tempVec2\r\n         * @type {MatterJS.Vector}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this._tempVec2 = Vector.create();\r\n\r\n        //  Matter plugins\r\n\r\n        if (GetValue(this.config, 'plugins.collisionevents', true))\r\n        {\r\n            this.enableCollisionEventsPlugin();\r\n        }\r\n\r\n        if (GetValue(this.config, 'plugins.attractors', false))\r\n        {\r\n            this.enableAttractorPlugin();\r\n        }\r\n\r\n        if (GetValue(this.config, 'plugins.wrap', false))\r\n        {\r\n            this.enableWrapPlugin();\r\n        }\r\n\r\n        Resolver._restingThresh = GetValue(this.config, 'restingThresh', 4);\r\n        Resolver._restingThreshTangent = GetValue(this.config, 'restingThreshTangent', 6);\r\n        Resolver._positionDampen = GetValue(this.config, 'positionDampen', 0.9);\r\n        Resolver._positionWarming = GetValue(this.config, 'positionWarming', 0.8);\r\n        Resolver._frictionNormalMultiplier = GetValue(this.config, 'frictionNormalMultiplier', 5);\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.world = new World(this.scene, this.config);\r\n        this.add = new Factory(this.world);\r\n        this.bodyBounds = new BodyBounds();\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.world)\r\n        {\r\n            this.world = new World(this.scene, this.config);\r\n            this.add = new Factory(this.world);\r\n        }\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\r\n        eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called when this class starts and retrieves the final Matter World Config.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#getConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.Physics.Matter.MatterWorldConfig} The Matter World Config.\r\n     */\r\n    getConfig: function ()\r\n    {\r\n        var gameConfig = this.systems.game.config.physics;\r\n        var sceneConfig = this.systems.settings.physics;\r\n\r\n        var config = Merge(\r\n            GetFastValue(sceneConfig, 'matter', {}),\r\n            GetFastValue(gameConfig, 'matter', {})\r\n        );\r\n\r\n        return config;\r\n    },\r\n\r\n    /**\r\n     * Enables the Matter Attractors Plugin.\r\n     * \r\n     * The attractors plugin that makes it easy to apply continual forces on bodies.\r\n     * It's possible to simulate effects such as wind, gravity and magnetism.\r\n     * \r\n     * https://github.com/liabru/matter-attractors\r\n     * \r\n     * This method is called automatically if `plugins.attractors` is set in the Matter World Config.\r\n     * However, you can also call it directly from within your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#enableAttractorPlugin\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    enableAttractorPlugin: function ()\r\n    {\r\n        Plugin.register(MatterAttractors);\r\n        Plugin.use(MatterLib, MatterAttractors);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables the Matter Wrap Plugin.\r\n     * \r\n     * The coordinate wrapping plugin that automatically wraps the position of bodies such that they always stay\r\n     * within the given bounds. Upon crossing a boundary the body will appear on the opposite side of the bounds,\r\n     * while maintaining its velocity.\r\n     * \r\n     * https://github.com/liabru/matter-wrap\r\n     * \r\n     * This method is called automatically if `plugins.wrap` is set in the Matter World Config.\r\n     * However, you can also call it directly from within your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#enableWrapPlugin\r\n     * @since 3.0.0\r\n     * \r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    enableWrapPlugin: function ()\r\n    {\r\n        Plugin.register(MatterWrap);\r\n        Plugin.use(MatterLib, MatterWrap);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables the Matter Collision Events Plugin.\r\n     * \r\n     * Note that this plugin is enabled by default. So you should only ever need to call this\r\n     * method if you have specifically disabled the plugin in your Matter World Config.\r\n     * You can disable it by setting `plugins.collisionevents: false` in your Matter World Config.\r\n     * \r\n     * This plugin triggers three new events on Matter.Body:\r\n     * \r\n     * 1. `onCollide`\r\n     * 2. `onCollideEnd`\r\n     * 3. `onCollideActive`\r\n     * \r\n     * These events correspond to the Matter.js events `collisionStart`, `collisionActive` and `collisionEnd`, respectively.\r\n     * You can listen to these events via Matter.Events or they will also be emitted from the Matter World.\r\n     * \r\n     * This plugin also extends Matter.Body with three convenience functions:\r\n     * \r\n     * `Matter.Body.setOnCollide(callback)`\r\n     * `Matter.Body.setOnCollideEnd(callback)`\r\n     * `Matter.Body.setOnCollideActive(callback)`\r\n     * \r\n     * You can register event callbacks by providing a function of type (pair: Matter.Pair) => void\r\n     * \r\n     * https://github.com/dxu/matter-collision-events\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#enableCollisionEventsPlugin\r\n     * @since 3.22.0\r\n     * \r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    enableCollisionEventsPlugin: function ()\r\n    {\r\n        Plugin.register(MatterCollisionEvents);\r\n        Plugin.use(MatterLib, MatterCollisionEvents);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pauses the Matter World instance and sets `enabled` to `false`.\r\n     * \r\n     * A paused world will not run any simulations for the duration it is paused.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#pause\r\n     * @fires Phaser.Physics.Matter.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} The Matter World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        return this.world.pause();\r\n    },\r\n\r\n    /**\r\n     * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} The Matter World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        return this.world.resume();\r\n    },\r\n\r\n    /**\r\n     * Sets the Matter Engine to run at fixed timestep of 60Hz and enables `autoUpdate`.\r\n     * If you have set a custom `getDelta` function then this will override it.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#set60Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    set60Hz: function ()\r\n    {\r\n        this.world.getDelta = this.world.update60Hz;\r\n        this.world.autoUpdate = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Matter Engine to run at fixed timestep of 30Hz and enables `autoUpdate`.\r\n     * If you have set a custom `getDelta` function then this will override it.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#set30Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    set30Hz: function ()\r\n    {\r\n        this.world.getDelta = this.world.update30Hz;\r\n        this.world.autoUpdate = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Manually advances the physics simulation by one iteration.\r\n     * \r\n     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n     * If undefined they use the Matter defaults of 60Hz and no correction.\r\n     * \r\n     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n     * \r\n     * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n     * value in to this call.\r\n     *\r\n     * You can adjust the number of iterations that Engine.update performs internally.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#step\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [delta=16.666] - The delta value.\r\n     * @param {number} [correction=1] - Optional delta correction value.\r\n     */\r\n    step: function (delta, correction)\r\n    {\r\n        this.world.step(delta, correction);\r\n    },\r\n\r\n    /**\r\n     * Checks if the vertices of the given body, or an array of bodies, contains the given point, or not.\r\n     * \r\n     * You can pass in either a single body, or an array of bodies to be checked. This method will\r\n     * return `true` if _any_ of the bodies in the array contain the point. See the `intersectPoint` method if you need\r\n     * to get a list of intersecting bodies.\r\n     * \r\n     * The point should be transformed into the Matter World coordinate system in advance. This happens by\r\n     * default with Input Pointers, but if you wish to use points from another system you may need to\r\n     * transform them before passing them.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#containsPoint\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} body - The body, or an array of bodies, to check against the point.\r\n     * @param {number} x - The horizontal coordinate of the point.\r\n     * @param {number} y - The vertical coordinate of the point.\r\n     * \r\n     * @return {boolean} `true` if the point is within one of the bodies given, otherwise `false`.\r\n     */\r\n    containsPoint: function (body, x, y)\r\n    {\r\n        body = this.getMatterBodies(body);\r\n\r\n        var position = Vector.create(x, y);\r\n\r\n        var result = Query.point(body, position);\r\n\r\n        return (result.length > 0) ? true : false;\r\n    },\r\n\r\n    /**\r\n     * Checks the given coordinates to see if any vertices of the given bodies contain it.\r\n     * \r\n     * If no bodies are provided it will search all bodies in the Matter World, including within Composites.\r\n     * \r\n     * The coordinates should be transformed into the Matter World coordinate system in advance. This happens by\r\n     * default with Input Pointers, but if you wish to use coordinates from another system you may need to\r\n     * transform them before passing them.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#intersectPoint\r\n     * @since 3.22.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the point.\r\n     * @param {number} y - The vertical coordinate of the point.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.\r\n     * \r\n     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies which contain the given point.\r\n     */\r\n    intersectPoint: function (x, y, bodies)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var position = Vector.create(x, y);\r\n\r\n        var output = [];\r\n\r\n        var result = Query.point(bodies, position);\r\n\r\n        result.forEach(function (body)\r\n        {\r\n            if (output.indexOf(body) === -1)\r\n            {\r\n                output.push(body);\r\n            }\r\n        });\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Checks the given rectangular area to see if any vertices of the given bodies intersect with it.\r\n     * Or, if the `outside` parameter is set to `true`, it checks to see which bodies do not\r\n     * intersect with it.\r\n     * \r\n     * If no bodies are provided it will search all bodies in the Matter World, including within Composites.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#intersectRect\r\n     * @since 3.22.0\r\n     *\r\n     * @param {number} x - The horizontal coordinate of the top-left of the area.\r\n     * @param {number} y - The vertical coordinate of the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {boolean} [outside=false] - If `false` it checks for vertices inside the area, if `true` it checks for vertices outside the area.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.\r\n     * \r\n     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies that intersect with the given area.\r\n     */\r\n    intersectRect: function (x, y, width, height, outside, bodies)\r\n    {\r\n        if (outside === undefined) { outside = false; }\r\n\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var bounds = {\r\n            min: { x: x, y: y },\r\n            max: { x: x + width, y: y + height }\r\n        };\r\n\r\n        var output = [];\r\n\r\n        var result = Query.region(bodies, bounds, outside);\r\n\r\n        result.forEach(function (body)\r\n        {\r\n            if (output.indexOf(body) === -1)\r\n            {\r\n                output.push(body);\r\n            }\r\n        });\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Checks the given ray segment to see if any vertices of the given bodies intersect with it.\r\n     * \r\n     * If no bodies are provided it will search all bodies in the Matter World.\r\n     * \r\n     * The width of the ray can be specified via the `rayWidth` parameter.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#intersectRay\r\n     * @since 3.22.0\r\n     *\r\n     * @param {number} x1 - The horizontal coordinate of the start of the ray segment.\r\n     * @param {number} y1 - The vertical coordinate of the start of the ray segment.\r\n     * @param {number} x2 - The horizontal coordinate of the end of the ray segment.\r\n     * @param {number} y2 - The vertical coordinate of the end of the ray segment.\r\n     * @param {number} [rayWidth=1] - The width of the ray segment.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check. If not provided it will search all bodies in the world.\r\n     * \r\n     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies whos vertices intersect with the ray segment.\r\n     */\r\n    intersectRay: function (x1, y1, x2, y2, rayWidth, bodies)\r\n    {\r\n        if (rayWidth === undefined) { rayWidth = 1; }\r\n        \r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var result = [];\r\n        var collisions = Query.ray(bodies, Vector.create(x1, y1), Vector.create(x2, y2), rayWidth);\r\n\r\n        for (var i = 0; i < collisions.length; i++)\r\n        {\r\n            result.push(collisions[i].body);\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Checks the given Matter Body to see if it intersects with any of the given bodies.\r\n     * \r\n     * If no bodies are provided it will check against all bodies in the Matter World.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#intersectBody\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The target body.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - An array of bodies to check the target body against. If not provided it will search all bodies in the world.\r\n     * \r\n     * @return {Phaser.Types.Physics.Matter.MatterBody[]} An array of bodies whos vertices intersect with target body.\r\n     */\r\n    intersectBody: function (body, bodies)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var result = [];\r\n        var collisions = Query.collides(body, bodies);\r\n\r\n        for (var i = 0; i < collisions.length; i++)\r\n        {\r\n            var pair = collisions[i];\r\n\r\n            if (pair.bodyA === body)\r\n            {\r\n                result.push(pair.bodyB);\r\n            }\r\n            else\r\n            {\r\n                result.push(pair.bodyA);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the target body, or an array of target bodies, intersects with any of the given bodies.\r\n     * \r\n     * If intersection occurs this method will return `true` and, if provided, invoke the callbacks.\r\n     * \r\n     * If no bodies are provided for the second parameter the target will check again all bodies in the Matter World.\r\n     * \r\n     * Note that bodies can only overlap if they are in non-colliding collision groups or categories.\r\n     * \r\n     * If you provide a `processCallback` then the two bodies that overlap are sent to it. This callback\r\n     * must return a boolean and is used to allow you to perform additional processing tests before a final\r\n     * outcome is decided. If it returns `true` then the bodies are finally passed to the `overlapCallback`, if set.\r\n     * \r\n     * If you provide an `overlapCallback` then the matching pairs of overlapping bodies will be sent to it.\r\n     * \r\n     * Both callbacks have the following signature: `function (bodyA, bodyB, collisionInfo)` where `bodyA` is always\r\n     * the target body. The `collisionInfo` object contains additional data, such as the angle and depth of penetration.\r\n     * \r\n     * @method Phaser.Physics.Matter.MatterPhysics#overlap\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} target - The target body, or array of target bodies, to check.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} [bodies] - The second body, or array of bodies, to check. If falsey it will check against all bodies in the world.\r\n     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the bodies overlap.\r\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two bodies if they overlap. If this is set then `overlapCallback` will only be invoked if this callback returns `true`.\r\n     * @param {*} [callbackContext] - The context, or scope, in which to run the callbacks.\r\n     * \r\n     * @return {boolean} `true` if the target body intersects with _any_ of the bodies given, otherwise `false`.\r\n     */\r\n    overlap: function (target, bodies, overlapCallback, processCallback, callbackContext)\r\n    {\r\n        if (overlapCallback === undefined) { overlapCallback = null; }\r\n        if (processCallback === undefined) { processCallback = null; }\r\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\r\n\r\n        if (!Array.isArray(target))\r\n        {\r\n            target = [ target ];\r\n        }\r\n\r\n        target = this.getMatterBodies(target);\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var match = false;\r\n\r\n        for (var i = 0; i < target.length; i++)\r\n        {\r\n            var entry = target[i];\r\n\r\n            var collisions = Query.collides(entry, bodies);\r\n\r\n            for (var c = 0; c < collisions.length; c++)\r\n            {\r\n                var info = collisions[c];\r\n                var bodyB = (info.bodyA.id === entry.id) ? info.bodyB : info.bodyA;\r\n\r\n                if (!processCallback || processCallback.call(callbackContext, entry, bodyB, info))\r\n                {\r\n                    match = true;\r\n\r\n                    if (overlapCallback)\r\n                    {\r\n                        overlapCallback.call(callbackContext, entry, bodyB, info);\r\n                    }\r\n                    else if (!processCallback)\r\n                    {\r\n                        //  If there are no callbacks we don't need to test every body, just exit when the first is found\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return match;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision filter category of all given Matter Bodies to the given value.\r\n     * \r\n     * This number must be a power of two between 2^0 (= 1) and 2^31.\r\n     * \r\n     * Bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n     * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setCollisionCategory\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} value - Unique category bitfield.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setCollisionCategory: function (bodies, value)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            body.collisionFilter.category = value;\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision filter group of all given Matter Bodies to the given value.\r\n     * \r\n     * If the group value is zero, or if two Matter Bodies have different group values,\r\n     * they will collide according to the usual collision filter rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n     * \r\n     * If two Matter Bodies have the same positive group value, they will always collide;\r\n     * if they have the same negative group value they will never collide.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setCollisionGroup\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} value - Unique group index.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setCollisionGroup: function (bodies, value)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            body.collisionFilter.group = value;\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision filter mask of all given Matter Bodies to the given value.\r\n     * \r\n     * Two Matter Bodies with different collision groups will only collide if each one includes the others\r\n     * category in its mask based on a bitwise AND operation: `(categoryA & maskB) !== 0` and \r\n     * `(categoryB & maskA) !== 0` are both true.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setCollidesWith\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody[]} bodies - An array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setCollidesWith: function (bodies, categories)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var flags = 0;\r\n\r\n        if (!Array.isArray(categories))\r\n        {\r\n            flags = categories;\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < categories.length; i++)\r\n            {\r\n                flags |= categories[i];\r\n            }\r\n        }\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            body.collisionFilter.mask = flags;\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes an array and returns a new array made from all of the Matter Bodies found in the original array.\r\n     * \r\n     * For example, passing in Matter Game Objects, such as a bunch of Matter Sprites, to this method, would\r\n     * return an array containing all of their native Matter Body objects.\r\n     * \r\n     * If the `bodies` argument is falsey, it will return all bodies in the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#getMatterBodies\r\n     * @since 3.22.0\r\n     *\r\n     * @param {array} [bodies] - An array of objects to extract the bodies from. If falsey, it will return all bodies in the world.\r\n     *\r\n     * @return {MatterJS.BodyType[]} An array of native Matter Body objects.\r\n     */\r\n    getMatterBodies: function (bodies)\r\n    {\r\n        if (!bodies)\r\n        {\r\n            return this.world.getAllBodies();\r\n        }\r\n\r\n        if (!Array.isArray(bodies))\r\n        {\r\n            bodies = [ bodies ];\r\n        }\r\n\r\n        var output = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = (bodies[i].hasOwnProperty('body')) ? bodies[i].body : bodies[i];\r\n\r\n            output.push(body);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Sets both the horizontal and vertical linear velocity of the physics bodies.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setVelocity\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} x - The horizontal linear velocity value.\r\n     * @param {number} y - The vertical linear velocity value.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setVelocity: function (bodies, x, y)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        vec2.x = x;\r\n        vec2.y = y;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            Body.setVelocity(body, vec2);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets just the horizontal linear velocity of the physics bodies.\r\n     * The vertical velocity of the body is unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setVelocityX\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} x - The horizontal linear velocity value.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setVelocityX: function (bodies, x)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        vec2.x = x;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            vec2.y = body.velocity.y;\r\n            Body.setVelocity(body, vec2);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets just the vertical linear velocity of the physics bodies.\r\n     * The horizontal velocity of the body is unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setVelocityY\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} y - The vertical linear velocity value.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setVelocityY: function (bodies, y)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        vec2.y = y;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            vec2.x = body.velocity.x;\r\n            Body.setVelocity(body, vec2);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angular velocity of the bodies instantly.\r\n     * Position, angle, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#setAngularVelocity\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} value - The angular velocity.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    setAngularVelocity: function (bodies, value)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            Body.setAngularVelocity(body, value);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Applies a force to a body, at the bodies current position, including resulting torque.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#applyForce\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {Phaser.Types.Math.Vector2Like} force - A Vector that specifies the force to apply.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    applyForce: function (bodies, force)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            vec2.x = body.position.x;\r\n            vec2.y = body.position.y;\r\n\r\n            Body.applyForce(body, vec2, force);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Applies a force to a body, from the given world position, including resulting torque.\r\n     * If no angle is given, the current body angle is used.\r\n     * \r\n     * Use very small speed values, such as 0.1, depending on the mass and required velocity.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#applyForceFromPosition\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {Phaser.Types.Math.Vector2Like} position - A Vector that specifies the world-space position to apply the force at.\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     * @param {number} [angle] - The angle, in radians, to apply the force from. Leave undefined to use the current body angle.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    applyForceFromPosition: function (bodies, position, speed, angle)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            if (angle === undefined)\r\n            {\r\n                angle = body.angle;\r\n            }\r\n\r\n            vec2.x = speed * Math.cos(angle);\r\n            vec2.y = speed * Math.sin(angle);\r\n\r\n            Body.applyForce(body, position, vec2);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply a force to a body based on the given angle and speed.\r\n     * If no angle is given, the current body angle is used.\r\n     * \r\n     * Use very small speed values, such as 0.1, depending on the mass and required velocity.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#applyForceFromAngle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.Physics.Matter.MatterBody|Phaser.Types.Physics.Matter.MatterBody[])} bodies - Either a single Body, or an array of bodies to update. If falsey it will use all bodies in the world.\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     * @param {number} [angle] - The angle, in radians, to apply the force from. Leave undefined to use the current body angle.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    applyForceFromAngle: function (bodies, speed, angle)\r\n    {\r\n        bodies = this.getMatterBodies(bodies);\r\n\r\n        var vec2 = this._tempVec2;\r\n\r\n        bodies.forEach(function (body)\r\n        {\r\n            if (angle === undefined)\r\n            {\r\n                angle = body.angle;\r\n            }\r\n\r\n            vec2.x = speed * Math.cos(angle);\r\n            vec2.y = speed * Math.sin(angle);\r\n\r\n            Body.applyForce(body, { x: body.position.x, y: body.position.y }, vec2);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the length of the given constraint, which is the distance between the two points.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#getConstraintLength\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.ConstraintType} constraint - The constraint to get the length from.\r\n     *\r\n     * @return {number} The length of the constraint.\r\n     */\r\n    getConstraintLength: function (constraint)\r\n    {\r\n        var aX = constraint.pointA.x;\r\n        var aY = constraint.pointA.y;\r\n        var bX = constraint.pointB.x;\r\n        var bY = constraint.pointB.y;\r\n\r\n        if (constraint.bodyA)\r\n        {\r\n            aX += constraint.bodyA.position.x;\r\n            aY += constraint.bodyA.position.y;\r\n        }\r\n\r\n        if (constraint.bodyB)\r\n        {\r\n            bX += constraint.bodyB.position.x;\r\n            bY += constraint.bodyB.position.y;\r\n        }\r\n\r\n        return DistanceBetween(aX, aY, bX, bY);\r\n    },\r\n\r\n    /**\r\n     * Aligns a Body, or Matter Game Object, against the given coordinates.\r\n     * \r\n     * The alignment takes place using the body bounds, which take into consideration things\r\n     * like body scale and rotation.\r\n     * \r\n     * Although a Body has a `position` property, it is based on the center of mass for the body,\r\n     * not a dimension based center. This makes aligning bodies difficult, especially if they have\r\n     * rotated or scaled. This method will derive the correct position based on the body bounds and\r\n     * its center of mass offset, in order to align the body with the given coordinate.\r\n     * \r\n     * For example, if you wanted to align a body so it sat in the bottom-center of the\r\n     * Scene, and the world was 800 x 600 in size:\r\n     * \r\n     * ```javascript\r\n     * this.matter.alignBody(body, 400, 600, Phaser.Display.Align.BOTTOM_CENTER);\r\n     * ```\r\n     * \r\n     * You pass in 400 for the x coordinate, because that is the center of the world, and 600 for\r\n     * the y coordinate, as that is the base of the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#alignBody\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBody} body - The Body to align.\r\n     * @param {number} x - The horizontal position to align the body to.\r\n     * @param {number} y - The vertical position to align the body to.\r\n     * @param {number} align - One of the `Phaser.Display.Align` constants, such as `Phaser.Display.Align.TOP_LEFT`.\r\n     *\r\n     * @return {this} This Matter Physics instance.\r\n     */\r\n    alignBody: function (body, x, y, align)\r\n    {\r\n        body = (body.hasOwnProperty('body')) ? body.body : body;\r\n\r\n        var pos;\r\n\r\n        switch (align)\r\n        {\r\n            case ALIGN_CONST.TOP_LEFT:\r\n            case ALIGN_CONST.LEFT_TOP:\r\n                pos = this.bodyBounds.getTopLeft(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.TOP_CENTER:\r\n                pos = this.bodyBounds.getTopCenter(body, x, y);\r\n                break;\r\n    \r\n            case ALIGN_CONST.TOP_RIGHT:\r\n            case ALIGN_CONST.RIGHT_TOP:\r\n                pos = this.bodyBounds.getTopRight(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.LEFT_CENTER:\r\n                pos = this.bodyBounds.getLeftCenter(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.CENTER:\r\n                pos = this.bodyBounds.getCenter(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.RIGHT_CENTER:\r\n                pos = this.bodyBounds.getRightCenter(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.LEFT_BOTTOM:\r\n            case ALIGN_CONST.BOTTOM_LEFT:\r\n                pos = this.bodyBounds.getBottomLeft(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.BOTTOM_CENTER:\r\n                pos = this.bodyBounds.getBottomCenter(body, x, y);\r\n                break;\r\n\r\n            case ALIGN_CONST.BOTTOM_RIGHT:\r\n            case ALIGN_CONST.RIGHT_BOTTOM:\r\n                pos = this.bodyBounds.getBottomRight(body, x, y);\r\n                break;\r\n        }\r\n\r\n        if (pos)\r\n        {\r\n            Body.setPosition(body, pos);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        if (this.world)\r\n        {\r\n            eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\r\n            eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\r\n        }\r\n\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        if (this.add)\r\n        {\r\n            this.add.destroy();\r\n        }\r\n\r\n        if (this.world)\r\n        {\r\n            this.world.destroy();\r\n        }\r\n\r\n        this.add = null;\r\n        this.world = null;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Physics.Matter.MatterPhysics#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('MatterPhysics', MatterPhysics, 'matterPhysics');\r\n\r\nmodule.exports = MatterPhysics;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AnimationState = require('../../animations/AnimationState');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar GameObject = require('../../gameobjects/GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Pipeline = require('../../gameobjects/components/Pipeline');\r\nvar Sprite = require('../../gameobjects/sprite/Sprite');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Matter Physics Sprite Game Object.\r\n *\r\n * A Sprite Game Object is used for the display of both static and animated images in your game.\r\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\r\n * and animated.\r\n *\r\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\r\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\r\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\r\n *\r\n * @class Sprite\r\n * @extends Phaser.GameObjects.Sprite\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Force\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.SetBody\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n * @extends Phaser.Physics.Matter.Components.Transform\r\n * @extends Phaser.Physics.Matter.Components.Velocity\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter.World instance that this body belongs to.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n */\r\nvar MatterSprite = new Class({\r\n\r\n    Extends: Sprite,\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Force,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.SetBody,\r\n        Components.Sleep,\r\n        Components.Static,\r\n        Components.Transform,\r\n        Components.Velocity,\r\n        Pipeline\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterSprite (world, x, y, texture, frame, options)\r\n    {\r\n        GameObject.call(this, world.scene, 'Sprite');\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.Physics.Matter.Sprite#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.24.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        this.anims = new AnimationState(this);\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setSizeToFrame();\r\n        this.setOrigin();\r\n\r\n        /**\r\n         * A reference to the Matter.World instance that this body belongs to.\r\n         *\r\n         * @name Phaser.Physics.Matter.Sprite#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * An internal temp vector used for velocity and force calculations.\r\n         *\r\n         * @name Phaser.Physics.Matter.Sprite#_tempVec2\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempVec2 = new Vector2(x, y);\r\n\r\n        var shape = GetFastValue(options, 'shape', null);\r\n\r\n        if (shape)\r\n        {\r\n            this.setBody(shape, options);\r\n        }\r\n        else\r\n        {\r\n            this.setRectangle(this.width, this.height, options);\r\n        }\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.initPipeline();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterSprite;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberof Phaser.Physics.Matter\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - The Matter world instance this body belongs to.\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.\r\n */\r\nvar MatterTileBody = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.Sleep,\r\n        Components.Static\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterTileBody (world, tile, options)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The tile object the body is associated with.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#tile\r\n         * @type {Phaser.Tilemaps.Tile}\r\n         * @since 3.0.0\r\n         */\r\n        this.tile = tile;\r\n\r\n        /**\r\n         * The Matter world the body exists within.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        // Install a reference to 'this' on the tile and ensure there can only be one matter body\r\n        // associated with the tile\r\n        if (tile.physics.matterBody)\r\n        {\r\n            tile.physics.matterBody.destroy();\r\n        }\r\n\r\n        tile.physics.matterBody = this;\r\n\r\n        // Set the body either from an existing body (if provided), the shapes in the tileset\r\n        // collision layer (if it exists) or a rectangle matching the tile.\r\n        var body = GetFastValue(options, 'body', null);\r\n\r\n        var addToWorld = GetFastValue(options, 'addToWorld', true);\r\n\r\n        if (!body)\r\n        {\r\n            var collisionGroup = tile.getCollisionGroup();\r\n            var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n            if (collisionObjects.length > 0)\r\n            {\r\n                this.setFromTileCollision(options);\r\n            }\r\n            else\r\n            {\r\n                this.setFromTileRectangle(options);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.setBody(body, addToWorld);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to a rectangle that matches the bounds of the tile.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileRectangle: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var bounds = this.tile.getBounds();\r\n        var cx = bounds.x + (bounds.width / 2);\r\n        var cy = bounds.y + (bounds.height / 2);\r\n        var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\r\n\r\n        this.setBody(body, options.addToWorld);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body from the collision group associated with the Tile. This is typically\r\n     * set up in Tiled's collision editor.\r\n     *\r\n     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n     * polygon into multiple convex polygons yourself.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileCollision: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var sx = this.tile.tilemapLayer.scaleX;\r\n        var sy = this.tile.tilemapLayer.scaleY;\r\n        var tileX = this.tile.getLeft();\r\n        var tileY = this.tile.getTop();\r\n        var collisionGroup = this.tile.getCollisionGroup();\r\n        var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n        var parts = [];\r\n\r\n        for (var i = 0; i < collisionObjects.length; i++)\r\n        {\r\n            var object = collisionObjects[i];\r\n            var ox = tileX + (object.x * sx);\r\n            var oy = tileY + (object.y * sy);\r\n            var ow = object.width * sx;\r\n            var oh = object.height * sy;\r\n            var body = null;\r\n\r\n            if (object.rectangle)\r\n            {\r\n                body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\r\n            }\r\n            else if (object.ellipse)\r\n            {\r\n                body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\r\n            }\r\n            else if (object.polygon || object.polyline)\r\n            {\r\n                // Polygons and polylines are both treated as closed polygons\r\n                var originalPoints = object.polygon ? object.polygon : object.polyline;\r\n\r\n                var points = originalPoints.map(function (p)\r\n                {\r\n                    return { x: p.x * sx, y: p.y * sy };\r\n                });\r\n\r\n                var vertices = Vertices.create(points);\r\n\r\n                // Points are relative to the object's origin (first point placed in Tiled), but\r\n                // matter expects points to be relative to the center of mass. This only applies to\r\n                // convex shapes. When a concave shape is decomposed, multiple parts are created and\r\n                // the individual parts are positioned relative to (ox, oy).\r\n                //\r\n                //  Update: 8th January 2019 - the latest version of Matter needs the Vertices adjusted,\r\n                //  regardless if convex or concave.\r\n\r\n                var center = Vertices.centre(vertices);\r\n\r\n                ox += center.x;\r\n                oy += center.y;\r\n\r\n                body = Bodies.fromVertices(ox, oy, vertices, options);\r\n            }\r\n\r\n            if (body)\r\n            {\r\n                parts.push(body);\r\n            }\r\n        }\r\n\r\n        if (parts.length === 1)\r\n        {\r\n            this.setBody(parts[0], options.addToWorld);\r\n        }\r\n        else if (parts.length > 1)\r\n        {\r\n            options.parts = parts;\r\n            this.setBody(Body.create(options), options.addToWorld);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to the given body. This will remove the previous body, if one already\r\n     * exists.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.BodyType} body - The new Matter body to use.\r\n     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setBody: function (body, addToWorld)\r\n    {\r\n        if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n        if (this.body)\r\n        {\r\n            this.removeBody();\r\n        }\r\n\r\n        this.body = body;\r\n        this.body.gameObject = this;\r\n\r\n        if (addToWorld)\r\n        {\r\n            this.world.add(this.body);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the TileBody and from the Matter world\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#removeBody\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    removeBody: function ()\r\n    {\r\n        if (this.body)\r\n        {\r\n            this.world.remove(this.body);\r\n            this.body.gameObject = undefined;\r\n            this.body = undefined;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the tile and the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeBody();\r\n        this.tile.physics.matterBody = undefined;\r\n        this.removeAllListeners();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterTileBody;\r\n","/**\r\n * @author       Joachim Grill <joachim@codeandweb.com>\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 CodeAndWeb GmbH\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Common = require('./lib/core/Common');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * Use PhysicsEditorParser.parseBody() to build a Matter body object, based on a physics data file\r\n * created and exported with PhysicsEditor (https://www.codeandweb.com/physicseditor).\r\n *\r\n * @namespace Phaser.Physics.Matter.PhysicsEditorParser\r\n * @since 3.10.0\r\n */\r\nvar PhysicsEditorParser = {\r\n\r\n    /**\r\n     * Parses a body element exported by PhysicsEditor.\r\n     *\r\n     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseBody\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} x - The horizontal world location of the body.\r\n     * @param {number} y - The vertical world location of the body.\r\n     * @param {object} config - The body configuration and fixture (child body) definitions, as exported by PhysicsEditor.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     * \r\n     * @return {MatterJS.BodyType} A compound Matter JS Body.\r\n     */\r\n    parseBody: function (x, y, config, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        var fixtureConfigs = GetFastValue(config, 'fixtures', []);\r\n        var fixtures = [];\r\n\r\n        for (var fc = 0; fc < fixtureConfigs.length; fc++)\r\n        {\r\n            var fixtureParts = this.parseFixture(fixtureConfigs[fc]);\r\n\r\n            for (var i = 0; i < fixtureParts.length; i++)\r\n            {\r\n                fixtures.push(fixtureParts[i]);\r\n            }\r\n        }\r\n\r\n        var matterConfig = Common.clone(config, true);\r\n\r\n        Common.extend(matterConfig, options, true);\r\n\r\n        delete matterConfig.fixtures;\r\n        delete matterConfig.type;\r\n\r\n        var body = Body.create(matterConfig);\r\n\r\n        Body.setParts(body, fixtures);\r\n        \r\n        Body.setPosition(body, { x: x, y: y });\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Parses an element of the \"fixtures\" list exported by PhysicsEditor\r\n     *\r\n     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseFixture\r\n     * @since 3.10.0\r\n     *\r\n     * @param {object} fixtureConfig - The fixture object to parse.\r\n     * \r\n     * @return {MatterJS.BodyType[]} - An array of Matter JS Bodies.\r\n     */\r\n    parseFixture: function (fixtureConfig)\r\n    {\r\n        var matterConfig = Common.extend({}, false, fixtureConfig);\r\n\r\n        delete matterConfig.circle;\r\n        delete matterConfig.vertices;\r\n\r\n        var fixtures;\r\n\r\n        if (fixtureConfig.circle)\r\n        {\r\n            var x = GetFastValue(fixtureConfig.circle, 'x');\r\n            var y = GetFastValue(fixtureConfig.circle, 'y');\r\n            var r = GetFastValue(fixtureConfig.circle, 'radius');\r\n            fixtures = [ Bodies.circle(x, y, r, matterConfig) ];\r\n        }\r\n        else if (fixtureConfig.vertices)\r\n        {\r\n            fixtures = this.parseVertices(fixtureConfig.vertices, matterConfig);\r\n        }\r\n\r\n        return fixtures;\r\n    },\r\n\r\n    /**\r\n     * Parses the \"vertices\" lists exported by PhysicsEditor.\r\n     *\r\n     * @function Phaser.Physics.Matter.PhysicsEditorParser.parseVertices\r\n     * @since 3.10.0\r\n     *\r\n     * @param {array} vertexSets - The vertex lists to parse.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     * \r\n     * @return {MatterJS.BodyType[]} - An array of Matter JS Bodies.\r\n     */\r\n    parseVertices: function (vertexSets, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        var parts = [];\r\n\r\n        for (var v = 0; v < vertexSets.length; v++)\r\n        {\r\n            Vertices.clockwiseSort(vertexSets[v]);\r\n\r\n            parts.push(Body.create(Common.extend({\r\n                position: Vertices.centre(vertexSets[v]),\r\n                vertices: vertexSets[v]\r\n            }, options)));\r\n        }\r\n\r\n        // flag coincident part edges\r\n        return Bodies.flagCoincidentParts(parts);\r\n    }\r\n};\r\n\r\nmodule.exports = PhysicsEditorParser;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\n\r\n/**\r\n * Creates a body using the supplied physics data, as provided by a JSON file.\r\n * \r\n * The data file should be loaded as JSON:\r\n * \r\n * ```javascript\r\n * preload ()\r\n * {\r\n *   this.load.json('ninjas', 'assets/ninjas.json);\r\n * }\r\n * \r\n * create ()\r\n * {\r\n *   const ninjaShapes = this.cache.json.get('ninjas');\r\n * \r\n *   this.matter.add.fromJSON(400, 300, ninjaShapes.shinobi);\r\n * }\r\n * ```\r\n * \r\n * Do not pass the entire JSON file to this method, but instead pass one of the shapes contained within it.\r\n * \r\n * If you pas in an `options` object, any settings in there will override those in the config object.\r\n * \r\n * The structure of the JSON file is as follows:\r\n * \r\n * ```text\r\n * {\r\n *   'generator_info': // The name of the application that created the JSON data\r\n *   'shapeName': {\r\n *     'type': // The type of body\r\n *     'label': // Optional body label\r\n *     'vertices': // An array, or an array of arrays, containing the vertex data in x/y object pairs\r\n *   }\r\n * }\r\n * ```\r\n * \r\n * At the time of writing, only the Phaser Physics Tracer App exports in this format.\r\n *\r\n * @namespace Phaser.Physics.Matter.PhysicsJSONParser\r\n * @since 3.22.0\r\n */\r\nvar PhysicsJSONParser = {\r\n\r\n    /**\r\n     * Parses a body element from the given JSON data.\r\n     *\r\n     * @function Phaser.Physics.Matter.PhysicsJSONParser.parseBody\r\n     * @since 3.22.0\r\n     *\r\n     * @param {number} x - The horizontal world location of the body.\r\n     * @param {number} y - The vertical world location of the body.\r\n     * @param {object} config - The body configuration data.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     * \r\n     * @return {MatterJS.BodyType} A Matter JS Body.\r\n     */\r\n    parseBody: function (x, y, config, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        var body;\r\n        var vertexSets = config.vertices;\r\n\r\n        if (vertexSets.length === 1)\r\n        {\r\n            //  Just a single Body\r\n            options.vertices = vertexSets[0];\r\n\r\n            body = Body.create(options);\r\n\r\n            Bodies.flagCoincidentParts(body.parts);\r\n        }\r\n        else\r\n        {\r\n            var parts = [];\r\n\r\n            for (var i = 0; i < vertexSets.length; i++)\r\n            {\r\n                var part = Body.create({\r\n                    vertices: vertexSets[i]\r\n                });\r\n\r\n                parts.push(part);\r\n            }\r\n\r\n            Bodies.flagCoincidentParts(parts);\r\n\r\n            options.parts = parts;\r\n\r\n            body = Body.create(options);\r\n        }\r\n\r\n        body.label = config.label;\r\n\r\n        Body.setPosition(body, { x: x, y: y });\r\n\r\n        return body;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = PhysicsJSONParser;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bounds = require('./lib/geometry/Bounds');\r\nvar Class = require('../../utils/Class');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Constraint = require('./lib/constraint/Constraint');\r\nvar Detector = require('./lib/collision/Detector');\r\nvar Events = require('./events');\r\nvar InputEvents = require('../../input/events');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar Sleeping = require('./lib/core/Sleeping');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A Pointer Constraint is a special type of constraint that allows you to click\r\n * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\r\n * and when one is pressed down it checks to see if that hit any part of any active\r\n * body in the world. If it did, and the body has input enabled, it will begin to\r\n * drag it until either released, or you stop it via the `stopDrag` method.\r\n * \r\n * You can adjust the stiffness, length and other properties of the constraint via\r\n * the `options` object on creation.\r\n *\r\n * @class PointerConstraint\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene to which this Pointer Constraint belongs.\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter World instance to which this Constraint belongs.\r\n * @param {object} [options] - A Constraint configuration object.\r\n */\r\nvar PointerConstraint = new Class({\r\n\r\n    initialize:\r\n\r\n    function PointerConstraint (scene, world, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        //  Defaults\r\n        var defaults = {\r\n            label: 'Pointer Constraint',\r\n            pointA: { x: 0, y: 0 },\r\n            pointB: { x: 0, y: 0 },\r\n            length: 0.01,\r\n            stiffness: 0.1,\r\n            angularStiffness: 1,\r\n            collisionFilter: {\r\n                category: 0x0001,\r\n                mask: 0xFFFFFFFF,\r\n                group: 0\r\n            }\r\n        };\r\n\r\n        /**\r\n         * A reference to the Scene to which this Pointer Constraint belongs.\r\n         * This is the same Scene as the Matter World instance.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Matter World instance to which this Constraint belongs.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Camera the Pointer was interacting with when the input\r\n         * down event was processed.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */\r\n        this.camera = null;\r\n\r\n        /**\r\n         * A reference to the Input Pointer that activated this Constraint.\r\n         * This is set in the `onDown` handler.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * Is this Constraint active or not?\r\n         * \r\n         * An active constraint will be processed each update. An inactive one will be skipped.\r\n         * Use this to toggle a Pointer Constraint on and off.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The internal transformed position.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2();\r\n\r\n        /**\r\n         * The body that is currently being dragged, if any.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#body\r\n         * @type {?MatterJS.BodyType}\r\n         * @since 3.16.2\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * The part of the body that was clicked on to start the drag.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#part\r\n         * @type {?MatterJS.BodyType}\r\n         * @since 3.16.2\r\n         */\r\n        this.part = null;\r\n\r\n        /**\r\n         * The native Matter Constraint that is used to attach to bodies.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n         * @type {MatterJS.ConstraintType}\r\n         * @since 3.0.0\r\n         */\r\n        this.constraint = Constraint.create(Merge(options, defaults));\r\n\r\n        this.world.on(Events.BEFORE_UPDATE, this.update, this);\r\n\r\n        scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);\r\n        scene.sys.input.on(InputEvents.POINTER_UP, this.onUp, this);\r\n    },\r\n\r\n    /**\r\n     * A Pointer has been pressed down onto the Scene.\r\n     * \r\n     * If this Constraint doesn't have an active Pointer then a hit test is set to\r\n     * run against all active bodies in the world during the _next_ call to `update`.\r\n     * If a body is found, it is bound to this constraint and the drag begins.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n     */\r\n    onDown: function (pointer)\r\n    {\r\n        if (!this.pointer)\r\n        {\r\n            this.pointer = pointer;\r\n            this.camera = pointer.camera;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A Pointer has been released from the Scene. If it was the one this constraint was using, it's cleared.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onUp\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n     */\r\n    onUp: function (pointer)\r\n    {\r\n        if (pointer === this.pointer)\r\n        {\r\n            this.pointer = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans all active bodies in the current Matter World to see if any of them\r\n     * are hit by the Pointer. The _first one_ found to hit is set as the active contraint\r\n     * body.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#getBody\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_START\r\n     * @since 3.16.2\r\n     * \r\n     * @return {boolean} `true` if a body was found and set, otherwise `false`.\r\n     */\r\n    getBody: function (pointer)\r\n    {\r\n        var pos = this.position;\r\n        var constraint = this.constraint;\r\n\r\n        this.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n\r\n        var bodies = Composite.allBodies(this.world.localWorld);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            if (!body.ignorePointer &&\r\n                Bounds.contains(body.bounds, pos) &&\r\n                Detector.canCollide(body.collisionFilter, constraint.collisionFilter))\r\n            {\r\n                if (this.hitTestBody(body, pos))\r\n                {\r\n                    this.world.emit(Events.DRAG_START, body, this.part, this);\r\n\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Scans the current body to determine if a part of it was clicked on.\r\n     * If a part is found the body is set as the `constraint.bodyB` property,\r\n     * as well as the `body` property of this class. The part is also set.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody\r\n     * @since 3.16.2\r\n     *\r\n     * @param {MatterJS.BodyType} body - The Matter Body to check.\r\n     * @param {Phaser.Math.Vector2} position - A translated hit test position.\r\n     *\r\n     * @return {boolean} `true` if a part of the body was hit, otherwise `false`.\r\n     */\r\n    hitTestBody: function (body, position)\r\n    {\r\n        var constraint = this.constraint;\r\n        var partsLength = body.parts.length;\r\n\r\n        var start = (partsLength > 1) ? 1 : 0;\r\n\r\n        for (var i = start; i < partsLength; i++)\r\n        {\r\n            var part = body.parts[i];\r\n\r\n            if (Vertices.contains(part.vertices, position))\r\n            {\r\n                constraint.pointA = position;\r\n                constraint.pointB = { x: position.x - body.position.x, y: position.y - body.position.y };\r\n\r\n                constraint.bodyB = body;\r\n                constraint.angleB = body.angle;\r\n\r\n                Sleeping.set(body, false);\r\n\r\n                this.part = part;\r\n                this.body = body;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler. Called in the Matter BEFORE_UPDATE step.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#update\r\n     * @fires Phaser.Physics.Matter.Events#DRAG\r\n     * @since 3.0.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var pointer = this.pointer;\r\n        var body = this.body;\r\n\r\n        if (!this.active || !pointer)\r\n        {\r\n            if (body)\r\n            {\r\n                this.stopDrag();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (!pointer.isDown && body)\r\n        {\r\n            this.stopDrag();\r\n\r\n            return;\r\n        }\r\n        else if (pointer.isDown)\r\n        {\r\n            if (!body && !this.getBody(pointer))\r\n            {\r\n                return;\r\n            }\r\n\r\n            body = this.body;\r\n\r\n            var pos = this.position;\r\n            var constraint = this.constraint;\r\n    \r\n            this.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n   \r\n            //  Drag update\r\n            constraint.pointA.x = pos.x;\r\n            constraint.pointA.y = pos.y;\r\n\r\n            Sleeping.set(body, false);\r\n\r\n            this.world.emit(Events.DRAG, body, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops the Pointer Constraint from dragging the body any further.\r\n     * \r\n     * This is called automatically if the Pointer is released while actively\r\n     * dragging a body. Or, you can call it manually to release a body from a\r\n     * constraint without having to first release the pointer.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#stopDrag\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_END\r\n     * @since 3.16.2\r\n     */\r\n    stopDrag: function ()\r\n    {\r\n        var body = this.body;\r\n        var constraint = this.constraint;\r\n\r\n        constraint.bodyB = null;\r\n        constraint.pointB = null;\r\n\r\n        this.pointer = null;\r\n        this.body = null;\r\n        this.part = null;\r\n\r\n        if (body)\r\n        {\r\n            this.world.emit(Events.DRAG_END, body, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Pointer Constraint instance and all of its references.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.world.removeConstraint(this.constraint);\r\n\r\n        this.pointer = null;\r\n        this.constraint = null;\r\n        this.body = null;\r\n        this.part = null;\r\n\r\n        this.world.off(Events.BEFORE_UPDATE, this.update);\r\n\r\n        this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);\r\n        this.scene.sys.input.off(InputEvents.POINTER_UP, this.onUp, this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointerConstraint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Common = require('./lib/core/Common');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Engine = require('./lib/core/Engine');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar MatterBody = require('./lib/body/Body');\r\nvar MatterEvents = require('./lib/core/Events');\r\nvar MatterTileBody = require('./MatterTileBody');\r\nvar MatterWorld = require('./lib/body/World');\r\nvar Vector = require('./lib/geometry/Vector');\r\n\r\n/**\r\n * @classdesc\r\n * The Matter World class is responsible for managing one single instance of a Matter Physics World for Phaser.\r\n * \r\n * Access this via `this.matter.world` from within a Scene.\r\n * \r\n * This class creates a Matter JS World Composite along with the Matter JS Engine during instantiation. It also\r\n * handles delta timing, bounds, body and constraint creation and debug drawing.\r\n * \r\n * If you wish to access the Matter JS World object directly, see the `localWorld` property.\r\n * If you wish to access the Matter Engine directly, see the `engine` property.\r\n * \r\n * This class is an Event Emitter and will proxy _all_ Matter JS events, as they are received.\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Matter World instance belongs.\r\n * @param {Phaser.Types.Physics.Matter.MatterWorldConfig} config - The Matter World configuration object.\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Scene to which this Matter World instance belongs.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * An instance of the MatterJS Engine.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#engine\r\n         * @type {MatterJS.Engine}\r\n         * @since 3.0.0\r\n         */\r\n        this.engine = Engine.create(config);\r\n\r\n        /**\r\n         * A `World` composite object that will contain all simulated bodies and constraints.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#localWorld\r\n         * @type {MatterJS.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.localWorld = this.engine.world;\r\n\r\n        var gravity = GetValue(config, 'gravity', null);\r\n\r\n        if (gravity)\r\n        {\r\n            this.setGravity(gravity.x, gravity.y, gravity.scale);\r\n        }\r\n        else if (gravity === false)\r\n        {\r\n            this.setGravity(0, 0, 0);\r\n        }\r\n\r\n        /**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#walls\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.walls = { left: null, right: null, top: null, bottom: null };\r\n\r\n        /**\r\n         * A flag that toggles if the world is enabled or not.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = GetValue(config, 'enabled', true);\r\n\r\n        /**\r\n         * The correction argument is an optional Number that specifies the time correction factor to apply to the update.\r\n         * This can help improve the accuracy of the simulation in cases where delta is changing between updates.\r\n         * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.\r\n         * Therefore the value is always 1 (no correction) when delta is constant (or when no correction is desired, which is the default).\r\n         * See the paper on Time Corrected Verlet for more information.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#correction\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.correction = GetValue(config, 'correction', 1);\r\n\r\n        /**\r\n         * This function is called every time the core game loop steps, which is bound to the\r\n         * Request Animation Frame frequency unless otherwise modified.\r\n         * \r\n         * The function is passed two values: `time` and `delta`, both of which come from the game step values.\r\n         * \r\n         * It must return a number. This number is used as the delta value passed to Matter.Engine.update.\r\n         * \r\n         * You can override this function with your own to define your own timestep.\r\n         * \r\n         * If you need to update the Engine multiple times in a single game step then call\r\n         * `World.update` as many times as required. Each call will trigger the `getDelta` function.\r\n         * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.\r\n         *\r\n         * You can also adjust the number of iterations that Engine.update performs.\r\n         * Use the Scene Matter Physics config object to set the following properties:\r\n         *\r\n         * positionIterations (defaults to 6)\r\n         * velocityIterations (defaults to 4)\r\n         * constraintIterations (defaults to 2)\r\n         *\r\n         * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n         * of your game.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#getDelta\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */\r\n        this.getDelta = GetValue(config, 'getDelta', this.update60Hz);\r\n\r\n        var runnerConfig = GetFastValue(config, 'runner', {});\r\n\r\n        var hasFPS = GetFastValue(runnerConfig, 'fps', false);\r\n\r\n        var fps = GetFastValue(runnerConfig, 'fps', 60);\r\n\r\n        var delta = GetFastValue(runnerConfig, 'delta', 1000 / fps);\r\n        var deltaMin = GetFastValue(runnerConfig, 'deltaMin', 1000 / fps);\r\n        var deltaMax = GetFastValue(runnerConfig, 'deltaMax', 1000 / (fps * 0.5));\r\n\r\n        if (!hasFPS)\r\n        {\r\n            fps = 1000 / delta;\r\n        }\r\n\r\n        /**\r\n         * The Matter JS Runner Configuration object.\r\n         * \r\n         * This object is populated via the Matter Configuration object's `runner` property and is\r\n         * updated constantly during the game step.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#runner\r\n         * @type {Phaser.Types.Physics.Matter.MatterRunnerConfig}\r\n         * @since 3.22.0\r\n         */\r\n        this.runner = {\r\n            fps: fps,\r\n            correction: GetFastValue(runnerConfig, 'correction', 1),\r\n            deltaSampleSize: GetFastValue(runnerConfig, 'deltaSampleSize', 60),\r\n            counterTimestamp: 0,\r\n            frameCounter: 0,\r\n            deltaHistory: [],\r\n            timePrev: null,\r\n            timeScalePrev: 1,\r\n            frameRequestId: null,\r\n            isFixed: GetFastValue(runnerConfig, 'isFixed', false),\r\n            delta: delta,\r\n            deltaMin: deltaMin,\r\n            deltaMax: deltaMax\r\n        };\r\n\r\n        /**\r\n         * Automatically call Engine.update every time the game steps.\r\n         * If you disable this then you are responsible for calling `World.step` directly from your game.\r\n         * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#autoUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */\r\n        this.autoUpdate = GetValue(config, 'autoUpdate', true);\r\n\r\n        var debugConfig = GetValue(config, 'debug', false);\r\n\r\n        /**\r\n         * A flag that controls if the debug graphics will be drawn to or not.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#drawDebug\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = (typeof(debugConfig) === 'object') ? true : debugConfig;\r\n\r\n        /**\r\n         * An instance of the Graphics object the debug bodies are drawn to, if enabled.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        /**\r\n         * The debug configuration object.\r\n         * \r\n         * The values stored in this object are read from the Matter World Config `debug` property.\r\n         * \r\n         * When a new Body or Constraint is _added to the World_, they are given the values stored in this object,\r\n         * unless they have their own `render` object set that will override them.\r\n         * \r\n         * Note that while you can modify the values of properties in this object at run-time, it will not change\r\n         * any of the Matter objects _already added_. It will only impact objects newly added to the world, or one\r\n         * that is removed and then re-added at a later time.\r\n         *\r\n         * @name Phaser.Physics.Matter.World#debugConfig\r\n         * @type {Phaser.Types.Physics.Matter.MatterDebugConfig}\r\n         * @since 3.22.0\r\n         */\r\n        this.debugConfig = {\r\n            showAxes: GetFastValue(debugConfig, 'showAxes', false),\r\n            showAngleIndicator: GetFastValue(debugConfig, 'showAngleIndicator', false),\r\n            angleColor: GetFastValue(debugConfig, 'angleColor', 0xe81153),\r\n\r\n            showBroadphase: GetFastValue(debugConfig, 'showBroadphase', false),\r\n            broadphaseColor: GetFastValue(debugConfig, 'broadphaseColor', 0xffb400),\r\n\r\n            showBounds: GetFastValue(debugConfig, 'showBounds', false),\r\n            boundsColor: GetFastValue(debugConfig, 'boundsColor', 0xffffff),\r\n\r\n            showVelocity: GetFastValue(debugConfig, 'showVelocity', false),\r\n            velocityColor: GetFastValue(debugConfig, 'velocityColor', 0x00aeef),\r\n\r\n            showCollisions: GetFastValue(debugConfig, 'showCollisions', false),\r\n            collisionColor: GetFastValue(debugConfig, 'collisionColor', 0xf5950c),\r\n\r\n            showSeparations: GetFastValue(debugConfig, 'showSeparations', false),\r\n            separationColor: GetFastValue(debugConfig, 'separationColor', 0xffa500),\r\n\r\n            showBody: GetFastValue(debugConfig, 'showBody', true),\r\n            showStaticBody: GetFastValue(debugConfig, 'showStaticBody', true),\r\n            showInternalEdges: GetFastValue(debugConfig, 'showInternalEdges', false),\r\n\r\n            renderFill: GetFastValue(debugConfig, 'renderFill', false),\r\n            renderLine: GetFastValue(debugConfig, 'renderLine', true),\r\n\r\n            fillColor: GetFastValue(debugConfig, 'fillColor', 0x106909),\r\n            fillOpacity: GetFastValue(debugConfig, 'fillOpacity', 1),\r\n            lineColor: GetFastValue(debugConfig, 'lineColor', 0x28de19),\r\n            lineOpacity: GetFastValue(debugConfig, 'lineOpacity', 1),\r\n            lineThickness: GetFastValue(debugConfig, 'lineThickness', 1),\r\n\r\n            staticFillColor: GetFastValue(debugConfig, 'staticFillColor', 0x0d177b),\r\n            staticLineColor: GetFastValue(debugConfig, 'staticLineColor', 0x1327e4),\r\n\r\n            showSleeping: GetFastValue(debugConfig, 'showSleeping', false),\r\n            staticBodySleepOpacity: GetFastValue(debugConfig, 'staticBodySleepOpacity', 0.7),\r\n            sleepFillColor: GetFastValue(debugConfig, 'sleepFillColor', 0x464646),\r\n            sleepLineColor: GetFastValue(debugConfig, 'sleepLineColor', 0x999a99),\r\n\r\n            showSensors: GetFastValue(debugConfig, 'showSensors', true),\r\n            sensorFillColor: GetFastValue(debugConfig, 'sensorFillColor', 0x0d177b),\r\n            sensorLineColor: GetFastValue(debugConfig, 'sensorLineColor', 0x1327e4),\r\n\r\n            showPositions: GetFastValue(debugConfig, 'showPositions', true),\r\n            positionSize: GetFastValue(debugConfig, 'positionSize', 4),\r\n            positionColor: GetFastValue(debugConfig, 'positionColor', 0xe042da),\r\n\r\n            showJoint: GetFastValue(debugConfig, 'showJoint', true),\r\n            jointColor: GetFastValue(debugConfig, 'jointColor', 0xe0e042),\r\n            jointLineOpacity: GetFastValue(debugConfig, 'jointLineOpacity', 1),\r\n            jointLineThickness: GetFastValue(debugConfig, 'jointLineThickness', 2),\r\n\r\n            pinSize: GetFastValue(debugConfig, 'pinSize', 4),\r\n            pinColor: GetFastValue(debugConfig, 'pinColor', 0x42e0e0),\r\n\r\n            springColor: GetFastValue(debugConfig, 'springColor', 0xe042e0),\r\n\r\n            anchorColor: GetFastValue(debugConfig, 'anchorColor', 0xefefef),\r\n            anchorSize: GetFastValue(debugConfig, 'anchorSize', 4),\r\n\r\n            showConvexHulls: GetFastValue(debugConfig, 'showConvexHulls', false),\r\n            hullColor: GetFastValue(debugConfig, 'hullColor', 0xd703d0)\r\n        };\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n\r\n        this.setEventsProxy();\r\n\r\n        //  Create the walls\r\n\r\n        if (GetFastValue(config, 'setBounds', false))\r\n        {\r\n            var boundsConfig = config['setBounds'];\r\n\r\n            if (typeof boundsConfig === 'boolean')\r\n            {\r\n                this.setBounds();\r\n            }\r\n            else\r\n            {\r\n                var x = GetFastValue(boundsConfig, 'x', 0);\r\n                var y = GetFastValue(boundsConfig, 'y', 0);\r\n                var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\r\n                var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\r\n                var thickness = GetFastValue(boundsConfig, 'thickness', 64);\r\n                var left = GetFastValue(boundsConfig, 'left', true);\r\n                var right = GetFastValue(boundsConfig, 'right', true);\r\n                var top = GetFastValue(boundsConfig, 'top', true);\r\n                var bottom = GetFastValue(boundsConfig, 'bottom', true);\r\n\r\n                this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the children of the given Matter Composite.\r\n     * \r\n     * Composites themselves do not render, but they can contain bodies, constraints and other composites that may do.\r\n     * So the children of this composite are passed to the `setBodyRenderStyle`, `setCompositeRenderStyle` and\r\n     * `setConstraintRenderStyle` methods accordingly.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setCompositeRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.CompositeType} composite - The Matter Composite to set the render style on.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setCompositeRenderStyle: function (composite)\r\n    {\r\n        var bodies = composite.bodies;\r\n        var constraints = composite.constraints;\r\n        var composites = composite.composites;\r\n\r\n        var i;\r\n        var obj;\r\n        var render;\r\n\r\n        for (i = 0; i < bodies.length; i++)\r\n        {\r\n            obj = bodies[i];\r\n            render = obj.render;\r\n\r\n            this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\r\n        }\r\n\r\n        for (i = 0; i < constraints.length; i++)\r\n        {\r\n            obj = constraints[i];\r\n            render = obj.render;\r\n\r\n            this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\r\n        }\r\n\r\n        for (i = 0; i < composites.length; i++)\r\n        {\r\n            obj = composites[i];\r\n\r\n            this.setCompositeRenderStyle(obj);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the given Matter Body.\r\n     * \r\n     * If you are using this on a Phaser Game Object, such as a Matter Sprite, then pass in the body property\r\n     * to this method, not the Game Object itself.\r\n     * \r\n     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n     * \r\n     * If you wish to reset the Body render colors to the defaults found in the World Debug Config, then call\r\n     * this method with just the `body` parameter provided and no others.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setBodyRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.BodyType} body - The Matter Body to set the render style on.\r\n     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n     * @param {number} [fillColor] - The fill color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setBodyRenderStyle: function (body, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity)\r\n    {\r\n        var render = body.render;\r\n        var config = this.debugConfig;\r\n\r\n        if (!render)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (lineColor === undefined || lineColor === null)\r\n        {\r\n            lineColor = (body.isStatic) ? config.staticLineColor : config.lineColor;\r\n        }\r\n\r\n        if (lineOpacity === undefined || lineOpacity === null)\r\n        {\r\n            lineOpacity = config.lineOpacity;\r\n        }\r\n\r\n        if (lineThickness === undefined || lineThickness === null)\r\n        {\r\n            lineThickness = config.lineThickness;\r\n        }\r\n\r\n        if (fillColor === undefined || fillColor === null)\r\n        {\r\n            fillColor = (body.isStatic) ? config.staticFillColor : config.fillColor;\r\n        }\r\n\r\n        if (fillOpacity === undefined || fillOpacity === null)\r\n        {\r\n            fillOpacity = config.fillOpacity;\r\n        }\r\n\r\n        if (lineColor !== false)\r\n        {\r\n            render.lineColor = lineColor;\r\n        }\r\n\r\n        if (lineOpacity !== false)\r\n        {\r\n            render.lineOpacity = lineOpacity;\r\n        }\r\n\r\n        if (lineThickness !== false)\r\n        {\r\n            render.lineThickness = lineThickness;\r\n        }\r\n\r\n        if (fillColor !== false)\r\n        {\r\n            render.fillColor = fillColor;\r\n        }\r\n\r\n        if (fillOpacity !== false)\r\n        {\r\n            render.fillOpacity = fillOpacity;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the debug render style for the given Matter Constraint.\r\n     * \r\n     * If you are using this on a Phaser Game Object, then pass in the body property\r\n     * to this method, not the Game Object itself.\r\n     * \r\n     * If you wish to skip a parameter, so it retains its current value, pass `false` for it.\r\n     * \r\n     * If you wish to reset the Constraint render colors to the defaults found in the World Debug Config, then call\r\n     * this method with just the `constraint` parameter provided and no others.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#setConstraintRenderStyle\r\n     * @since 3.22.0\r\n     *\r\n     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to set the render style on.\r\n     * @param {number} [lineColor] - The line color. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1. If `null` it will use the World Debug Config value.\r\n     * @param {number} [lineThickness] - The line thickness. If `null` it will use the World Debug Config value.\r\n     * @param {number} [pinSize] - If this constraint is a pin, this sets the size of the pin circle. If `null` it will use the World Debug Config value.\r\n     * @param {number} [anchorColor] - The color used when rendering this constraints anchors.  If `null` it will use the World Debug Config value.\r\n     * @param {number} [anchorSize] - The size of the anchor circle, if this constraint has anchors. If `null` it will use the World Debug Config value.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    setConstraintRenderStyle: function (constraint, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize)\r\n    {\r\n        var render = constraint.render;\r\n        var config = this.debugConfig;\r\n\r\n        if (!render)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        //  Reset them\r\n        if (lineColor === undefined || lineColor === null)\r\n        {\r\n            var type = render.type;\r\n\r\n            if (type === 'line')\r\n            {\r\n                lineColor = config.jointColor;\r\n            }\r\n            else if (type === 'pin')\r\n            {\r\n                lineColor = config.pinColor;\r\n            }\r\n            else if (type === 'spring')\r\n            {\r\n                lineColor = config.springColor;\r\n            }\r\n        }\r\n\r\n        if (lineOpacity === undefined || lineOpacity === null)\r\n        {\r\n            lineOpacity = config.jointLineOpacity;\r\n        }\r\n\r\n        if (lineThickness === undefined || lineThickness === null)\r\n        {\r\n            lineThickness = config.jointLineThickness;\r\n        }\r\n\r\n        if (pinSize === undefined || pinSize === null)\r\n        {\r\n            pinSize = config.pinSize;\r\n        }\r\n\r\n        if (anchorColor === undefined || anchorColor === null)\r\n        {\r\n            anchorColor = config.anchorColor;\r\n        }\r\n\r\n        if (anchorSize === undefined || anchorSize === null)\r\n        {\r\n            anchorSize = config.anchorSize;\r\n        }\r\n\r\n        if (lineColor !== false)\r\n        {\r\n            render.lineColor = lineColor;\r\n        }\r\n\r\n        if (lineOpacity !== false)\r\n        {\r\n            render.lineOpacity = lineOpacity;\r\n        }\r\n\r\n        if (lineThickness !== false)\r\n        {\r\n            render.lineThickness = lineThickness;\r\n        }\r\n\r\n        if (pinSize !== false)\r\n        {\r\n            render.pinSize = pinSize;\r\n        }\r\n\r\n        if (anchorColor !== false)\r\n        {\r\n            render.anchorColor = anchorColor;\r\n        }\r\n\r\n        if (anchorSize !== false)\r\n        {\r\n            render.anchorSize = anchorSize;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This internal method acts as a proxy between all of the Matter JS events and then re-emits them\r\n     * via this class.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setEventsProxy\r\n     * @since 3.0.0\r\n     */\r\n    setEventsProxy: function ()\r\n    {\r\n        var _this = this;\r\n        var engine = this.engine;\r\n        var world = this.localWorld;\r\n\r\n        //  Inject debug styles\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            MatterEvents.on(world, 'compositeModified', function (composite)\r\n            {\r\n                _this.setCompositeRenderStyle(composite);\r\n            });\r\n\r\n            MatterEvents.on(world, 'beforeAdd', function (event)\r\n            {\r\n                var objects = [].concat(event.object);\r\n    \r\n                for (var i = 0; i < objects.length; i++)\r\n                {\r\n                    var obj = objects[i];\r\n                    var render = obj.render;\r\n    \r\n                    if (obj.type === 'body')\r\n                    {\r\n                        _this.setBodyRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.fillColor, render.fillOpacity);\r\n                    }\r\n                    else if (obj.type === 'composite')\r\n                    {\r\n                        _this.setCompositeRenderStyle(obj);\r\n                    }\r\n                    else if (obj.type === 'constraint')\r\n                    {\r\n                        _this.setConstraintRenderStyle(obj, render.lineColor, render.lineOpacity, render.lineThickness, render.pinSize, render.anchorColor, render.anchorSize);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        MatterEvents.on(world, 'beforeAdd', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_ADD, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'afterAdd', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_ADD, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'beforeRemove', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_REMOVE, event);\r\n        });\r\n\r\n        MatterEvents.on(world, 'afterRemove', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_REMOVE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'beforeUpdate', function (event)\r\n        {\r\n            _this.emit(Events.BEFORE_UPDATE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'afterUpdate', function (event)\r\n        {\r\n            _this.emit(Events.AFTER_UPDATE, event);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionStart', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_START, event, bodyA, bodyB);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionActive', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_ACTIVE, event, bodyA, bodyB);\r\n        });\r\n\r\n        MatterEvents.on(engine, 'collisionEnd', function (event)\r\n        {\r\n            var pairs = event.pairs;\r\n            var bodyA;\r\n            var bodyB;\r\n\r\n            if (pairs.length > 0)\r\n            {\r\n                bodyA = pairs[0].bodyA;\r\n                bodyB = pairs[0].bodyB;\r\n            }\r\n\r\n            _this.emit(Events.COLLISION_END, event, bodyA, bodyB);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y=0] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=64] - The thickness of each wall, in pixels.\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Matter.World} This Matter World object.\r\n     */\r\n    setBounds: function (x, y, width, height, thickness, left, right, top, bottom)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n        if (thickness === undefined) { thickness = 64; }\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (top === undefined) { top = true; }\r\n        if (bottom === undefined) { bottom = true; }\r\n\r\n        this.updateWall(left, 'left', x - thickness, y - thickness, thickness, height + (thickness * 2));\r\n        this.updateWall(right, 'right', x + width, y - thickness, thickness, height + (thickness * 2));\r\n        this.updateWall(top, 'top', x, y - thickness, width, thickness);\r\n        this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the 4 rectangle bodies that were created, if `setBounds` was set in the Matter config, to use\r\n     * the new positions and sizes. This method is usually only called internally via the `setBounds` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - `true` if the walls are being added or updated, `false` to remove them from the world.\r\n     * @param {string} [position] - Either `left`, `right`, `top` or `bottom`. Only optional if `add` is `false`.\r\n     * @param {number} [x] - The horizontal position to place the walls at. Only optional if `add` is `false`.\r\n     * @param {number} [y] - The vertical position to place the walls at. Only optional if `add` is `false`.\r\n     * @param {number} [width] - The width of the walls, in pixels. Only optional if `add` is `false`.\r\n     * @param {number} [height] - The height of the walls, in pixels. Only optional if `add` is `false`.\r\n     */\r\n    updateWall: function (add, position, x, y, width, height)\r\n    {\r\n        var wall = this.walls[position];\r\n\r\n        if (add)\r\n        {\r\n            if (wall)\r\n            {\r\n                MatterWorld.remove(this.localWorld, wall);\r\n            }\r\n\r\n            //  adjust center\r\n            x += (width / 2);\r\n            y += (height / 2);\r\n\r\n            this.walls[position] = this.create(x, y, width, height, { isStatic: true, friction: 0, frictionStatic: 0 });\r\n        }\r\n        else\r\n        {\r\n            if (wall)\r\n            {\r\n                MatterWorld.remove(this.localWorld, wall);\r\n            }\r\n\r\n            this.walls[position] = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Phaser.GameObjects.Graphics object that is used to render all of the debug bodies and joints to.\r\n     * \r\n     * This method is called automatically by the constructor, if debugging has been enabled.\r\n     * \r\n     * The created Graphics object is automatically added to the Scene at 0x0 and given a depth of `Number.MAX_VALUE`,\r\n     * so it renders above all else in the Scene.\r\n     * \r\n     * The Graphics object is assigned to the `debugGraphic` property of this class and `drawDebug` is enabled.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The newly created Graphics object.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * Sets the world gravity and gravity scale to 0.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#disableGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    disableGravity: function ()\r\n    {\r\n        this.localWorld.gravity.x = 0;\r\n        this.localWorld.gravity.y = 0;\r\n        this.localWorld.gravity.scale = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the worlds gravity to the values given.\r\n     * \r\n     * Gravity effects all bodies in the world, unless they have the `ignoreGravity` flag set.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The world gravity x component.\r\n     * @param {number} [y=1] - The world gravity y component.\r\n     * @param {number} [scale=0.001] - The gravity scale factor.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    setGravity: function (x, y, scale)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 1; }\r\n\r\n        this.localWorld.gravity.x = x;\r\n        this.localWorld.gravity.y = y;\r\n\r\n        if (scale !== undefined)\r\n        {\r\n            this.localWorld.gravity.scale = scale;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a rectangle Matter body and adds it to the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal position of the body in the world.\r\n     * @param {number} y - The vertical position of the body in the world.\r\n     * @param {number} width - The width of the body.\r\n     * @param {number} height - The height of the body.\r\n     * @param {object} options - Optional Matter configuration object.\r\n     *\r\n     * @return {MatterJS.BodyType} The Matter.js body that was created.\r\n     */\r\n    create: function (x, y, width, height, options)\r\n    {\r\n        var body = Bodies.rectangle(x, y, width, height, options);\r\n\r\n        MatterWorld.add(this.localWorld, body);\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * Adds a Matter JS object, or array of objects, to the world.\r\n     * \r\n     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n     * \r\n     * Triggers `beforeAdd` and `afterAdd` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    add: function (object)\r\n    {\r\n        MatterWorld.add(this.localWorld, object);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Matter JS object, or array of objects, from the world.\r\n     * \r\n     * The objects should be valid Matter JS entities, such as a Body, Composite or Constraint.\r\n     * \r\n     * Triggers `beforeRemove` and `afterRemove` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(object|object[])} object - Can be single object, or an array, and can be a body, composite or constraint.\r\n     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    remove: function (object, deep)\r\n    {\r\n        if (!Array.isArray(object))\r\n        {\r\n            object = [ object ];\r\n        }\r\n\r\n        for (var i = 0; i < object.length; i++)\r\n        {\r\n            var entity = object[i];\r\n\r\n            var body = (entity.body) ? entity.body : entity;\r\n\r\n            Composite.remove(this.localWorld, body, deep);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Matter JS constraint, or array of constraints, from the world.\r\n     * \r\n     * Triggers `beforeRemove` and `afterRemove` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#removeConstraint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(MatterJS.ConstraintType|MatterJS.ConstraintType[])} constraint - A Matter JS Constraint, or an array of constraints, to be removed.\r\n     * @param {boolean} [deep=false] - Optionally search the objects children and recursively remove those as well.\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    removeConstraint: function (constraint, deep)\r\n    {\r\n        Composite.remove(this.localWorld, constraint, deep);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds `MatterTileBody` instances for all the colliding tiles within the given tilemap layer.\r\n     * \r\n     * Set the appropriate tiles in your layer to collide before calling this method!\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    convertTilemapLayer: function (tilemapLayer, options)\r\n    {\r\n        var layerData = tilemapLayer.layer;\r\n        var tiles = tilemapLayer.getTilesWithin(0, 0, layerData.width, layerData.height, { isColliding: true });\r\n\r\n        this.convertTiles(tiles, options);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds `MatterTileBody` instances for the given tiles. This adds bodies regardless of whether the\r\n     * tiles are set to collide or not.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#convertTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of tiles.\r\n     * @param {object} [options] - Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    convertTiles: function (tiles, options)\r\n    {\r\n        if (tiles.length === 0)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            new MatterTileBody(this, tiles[i], options);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the next unique group index for which bodies will collide.\r\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will not collide.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [isNonColliding=false] - If `true`, returns the next unique group index for which bodies will _not_ collide.\r\n     *\r\n     * @return {number} Unique category bitfield\r\n     */\r\n    nextGroup: function (isNonColliding)\r\n    {\r\n        return MatterBody.nextGroup(isNonColliding);\r\n    },\r\n\r\n    /**\r\n     * Returns the next unique category bitfield (starting after the initial default category 0x0001).\r\n     * There are 32 available.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#nextCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} Unique category bitfield\r\n     */\r\n    nextCategory: function ()\r\n    {\r\n        return MatterBody.nextCategory();\r\n    },\r\n\r\n    /**\r\n     * Pauses this Matter World instance and sets `enabled` to `false`.\r\n     * \r\n     * A paused world will not run any simulations for the duration it is paused.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#pause\r\n     * @fires Phaser.Physics.Matter.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.enabled = false;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes this Matter World instance from a paused state and sets `enabled` to `true`.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#resume\r\n     * @fires Phaser.Physics.Matter.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Matter World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.enabled = true;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The internal update method. This is called automatically by the parent Scene.\r\n     * \r\n     * Moves the simulation forward in time by delta ms. Uses `World.correction` value as an optional number that\r\n     * specifies the time correction factor to apply to the update. This can help improve the accuracy of the\r\n     * simulation in cases where delta is changing between updates. The value of correction is defined as `delta / lastDelta`,\r\n     * i.e. the percentage change of delta over the last step. Therefore the value is always 1 (no correction) when\r\n     * delta is constant (or when no correction is desired, which is the default).\r\n     * See the paper on Time Corrected Verlet for more information.\r\n     * \r\n     * Triggers `beforeUpdate` and `afterUpdate` events. Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n     * \r\n     * If the World is paused, `update` is still run, but exits early and does not update the Matter Engine.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.enabled || !this.autoUpdate)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var engine = this.engine;\r\n        var runner = this.runner;\r\n\r\n        var timing = engine.timing;\r\n        var correction = this.correction;\r\n\r\n        if (runner.isFixed)\r\n        {\r\n            //  fixed timestep\r\n            delta = this.getDelta(time, delta);\r\n        }\r\n        else\r\n        {\r\n            //  dynamic timestep based on wall clock between calls\r\n            delta = (time - runner.timePrev) || runner.delta;\r\n            runner.timePrev = time;\r\n\r\n            // optimistically filter delta over a few frames, to improve stability\r\n            runner.deltaHistory.push(delta);\r\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\r\n            delta = Math.min.apply(null, runner.deltaHistory);\r\n            \r\n            // limit delta\r\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\r\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\r\n\r\n            // correction for delta\r\n            correction = delta / runner.delta;\r\n\r\n            // update engine timing object\r\n            runner.delta = delta;\r\n        }\r\n\r\n        // time correction for time scaling\r\n        if (runner.timeScalePrev !== 0)\r\n        {\r\n            correction *= timing.timeScale / runner.timeScalePrev;\r\n        }\r\n\r\n        if (timing.timeScale === 0)\r\n        {\r\n            correction = 0;\r\n        }\r\n\r\n        runner.timeScalePrev = timing.timeScale;\r\n        runner.correction = correction;\r\n\r\n        // fps counter\r\n        runner.frameCounter += 1;\r\n\r\n        if (time - runner.counterTimestamp >= 1000)\r\n        {\r\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\r\n            runner.counterTimestamp = time;\r\n            runner.frameCounter = 0;\r\n        }\r\n\r\n        Engine.update(engine, delta, correction);\r\n    },\r\n\r\n    /**\r\n     * Manually advances the physics simulation by one iteration.\r\n     * \r\n     * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.\r\n     * If undefined they use the Matter defaults of 60Hz and no correction.\r\n     * \r\n     * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.\r\n     * \r\n     * It also ignores any custom `getDelta` functions, as you should be passing the delta\r\n     * value in to this call.\r\n     *\r\n     * You can adjust the number of iterations that Engine.update performs internally.\r\n     * Use the Scene Matter Physics config object to set the following properties:\r\n     *\r\n     * positionIterations (defaults to 6)\r\n     * velocityIterations (defaults to 4)\r\n     * constraintIterations (defaults to 2)\r\n     *\r\n     * Adjusting these values can help performance in certain situations, depending on the physics requirements\r\n     * of your game.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#step\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [delta=16.666] - The delta value.\r\n     * @param {number} [correction=1] - Optional delta correction value.\r\n     */\r\n    step: function (delta, correction)\r\n    {\r\n        Engine.update(this.engine, delta, correction);\r\n    },\r\n\r\n    /**\r\n     * Runs the Matter Engine.update at a fixed timestep of 60Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update60Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */\r\n    update60Hz: function ()\r\n    {\r\n        return 1000 / 60;\r\n    },\r\n\r\n    /**\r\n     * Runs the Matter Engine.update at a fixed timestep of 30Hz.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#update30Hz\r\n     * @since 3.4.0\r\n     *\r\n     * @return {number} The delta value to be passed to Engine.update.\r\n     */\r\n    update30Hz: function ()\r\n    {\r\n        return 1000 / 30;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the given body can be found within the World.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#has\r\n     * @since 3.22.0\r\n     * \r\n     * @param {(MatterJS.Body|Phaser.GameObjects.GameObject)} body - The Matter Body, or Game Object, to search for within the world.\r\n     * \r\n     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n     */\r\n    has: function (body)\r\n    {\r\n        var src = (body.hasOwnProperty('body')) ? body.body : body;\r\n\r\n        return (Composite.get(this.localWorld, src.id, src.type) !== null);\r\n    },\r\n\r\n    /**\r\n     * Returns all the bodies in the Matter World, including all bodies in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllBodies\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.BodyType[]} An array of all the Matter JS Bodies in this World.\r\n     */\r\n    getAllBodies: function ()\r\n    {\r\n        return Composite.allBodies(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Returns all the constraints in the Matter World, including all constraints in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllConstraints\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.ConstraintType[]} An array of all the Matter JS Constraints in this World.\r\n     */\r\n    getAllConstraints: function ()\r\n    {\r\n        return Composite.allConstraints(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Returns all the composites in the Matter World, including all composites in children, recursively.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#getAllComposites\r\n     * @since 3.22.0\r\n     * \r\n     * @return {MatterJS.CompositeType[]} An array of all the Matter JS Composites in this World.\r\n     */\r\n    getAllComposites: function ()\r\n    {\r\n        return Composite.allComposites(this.localWorld);\r\n    },\r\n\r\n    /**\r\n     * Handles the rendering of bodies and debug information to the debug Graphics object, if enabled.\r\n     * \r\n     * This method is called automatically by the Scene after all processing has taken place.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#postUpdate\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    postUpdate: function ()\r\n    {\r\n        if (!this.drawDebug)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var config = this.debugConfig;\r\n        var engine = this.engine;\r\n        var graphics = this.debugGraphic;\r\n\r\n        var bodies = Composite.allBodies(this.localWorld);\r\n\r\n        this.debugGraphic.clear();\r\n\r\n        if (config.showBroadphase && engine.broadphase.controller)\r\n        {\r\n            this.renderGrid(engine.broadphase, graphics, config.broadphaseColor, 0.5);\r\n        }\r\n\r\n        if (config.showBounds)\r\n        {\r\n            this.renderBodyBounds(bodies, graphics, config.boundsColor, 0.5);\r\n        }\r\n\r\n        if (config.showBody || config.showStaticBody)\r\n        {\r\n            this.renderBodies(bodies);\r\n        }\r\n\r\n        if (config.showJoint)\r\n        {\r\n            this.renderJoints();\r\n        }\r\n\r\n        if (config.showAxes || config.showAngleIndicator)\r\n        {\r\n            this.renderBodyAxes(bodies, graphics, config.showAxes, config.angleColor, 0.5);\r\n        }\r\n\r\n        if (config.showVelocity)\r\n        {\r\n            this.renderBodyVelocity(bodies, graphics, config.velocityColor, 1, 2);\r\n        }\r\n\r\n        if (config.showSeparations)\r\n        {\r\n            this.renderSeparations(engine.pairs.list, graphics, config.separationColor);\r\n        }\r\n\r\n        if (config.showCollisions)\r\n        {\r\n            this.renderCollisions(engine.pairs.list, graphics, config.collisionColor);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Engine Broadphase Controller Grid to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showBroadphase` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderGrid\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Grid} grid - The Matter Grid to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderGrid: function (grid, graphics, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        var bucketKeys = Common.keys(grid.buckets);\r\n\r\n        for (var i = 0; i < bucketKeys.length; i++)\r\n        {\r\n            var bucketId = bucketKeys[i];\r\n\r\n            if (grid.buckets[bucketId].length < 2)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var region = bucketId.split(/C|R/);\r\n\r\n            graphics.strokeRect(\r\n                parseInt(region[1], 10) * grid.bucketWidth,\r\n                parseInt(region[2], 10) * grid.bucketHeight,\r\n                grid.bucketWidth,\r\n                grid.bucketHeight\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the list of Pair separations to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showSeparations` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderSeparations\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderSeparations: function (pairs, graphics, lineColor)\r\n    {\r\n        graphics.lineStyle(1, lineColor, 1);\r\n\r\n        for (var i = 0; i < pairs.length; i++)\r\n        {\r\n            var pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var collision = pair.collision;\r\n            var bodyA = collision.bodyA;\r\n            var bodyB = collision.bodyB;\r\n            var posA = bodyA.position;\r\n            var posB = bodyB.position;\r\n            var penetration = collision.penetration;\r\n\r\n            var k = (!bodyA.isStatic && !bodyB.isStatic) ? 4 : 1;\r\n            \r\n            if (bodyB.isStatic)\r\n            {\r\n                k = 0;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                posB.x,\r\n                posB.y,\r\n                posB.x - (penetration.x * k),\r\n                posB.y - (penetration.y * k)\r\n            );\r\n\r\n            k = (!bodyA.isStatic && !bodyB.isStatic) ? 4 : 1;\r\n\r\n            if (bodyA.isStatic)\r\n            {\r\n                k = 0;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                posA.x,\r\n                posA.y,\r\n                posA.x - (penetration.x * k),\r\n                posA.y - (penetration.y * k)\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the list of collision points and normals to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showCollisions` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render the Grid to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderCollisions\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.Pair[]} pairs - An array of Matter Pairs to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderCollisions: function (pairs, graphics, lineColor)\r\n    {\r\n        graphics.lineStyle(1, lineColor, 0.5);\r\n        graphics.fillStyle(lineColor, 1);\r\n\r\n        var i;\r\n        var pair;\r\n\r\n        //  Collision Positions\r\n\r\n        for (i = 0; i < pairs.length; i++)\r\n        {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            for (var j = 0; j < pair.activeContacts.length; j++)\r\n            {\r\n                var contact = pair.activeContacts[j];\r\n                var vertex = contact.vertex;\r\n\r\n                graphics.fillRect(vertex.x - 2, vertex.y - 2, 5, 5);\r\n            }\r\n        }\r\n\r\n        //  Collision Normals\r\n\r\n        for (i = 0; i < pairs.length; i++)\r\n        {\r\n            pair = pairs[i];\r\n\r\n            if (!pair.isActive)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var collision = pair.collision;\r\n            var contacts = pair.activeContacts;\r\n\r\n            if (contacts.length > 0)\r\n            {\r\n                var normalPosX = contacts[0].vertex.x;\r\n                var normalPosY = contacts[0].vertex.y;\r\n\r\n                if (contacts.length === 2)\r\n                {\r\n                    normalPosX = (contacts[0].vertex.x + contacts[1].vertex.x) / 2;\r\n                    normalPosY = (contacts[0].vertex.y + contacts[1].vertex.y) / 2;\r\n                }\r\n\r\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic)\r\n                {\r\n                    graphics.lineBetween(\r\n                        normalPosX - collision.normal.x * 8,\r\n                        normalPosY - collision.normal.y * 8,\r\n                        normalPosX,\r\n                        normalPosY\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    graphics.lineBetween(\r\n                        normalPosX + collision.normal.x * 8,\r\n                        normalPosY + collision.normal.y * 8,\r\n                        normalPosX,\r\n                        normalPosY\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the bounds of an array of Bodies to the given Graphics instance.\r\n     * \r\n     * If the body is a compound body, it will render the bounds for the parent compound.\r\n     * \r\n     * The debug renderer calls this method if the `showBounds` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyBounds\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     */\r\n    renderBodyBounds: function (bodies, graphics, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var bounds = body.bounds;\r\n\r\n            if (bounds)\r\n            {\r\n                graphics.strokeRect(\r\n                    bounds.min.x,\r\n                    bounds.min.y,\r\n                    bounds.max.x - bounds.min.x,\r\n                    bounds.max.y - bounds.min.y\r\n                );\r\n            }\r\n            else\r\n            {\r\n                var parts = body.parts;\r\n\r\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    var part = parts[j];\r\n    \r\n                    graphics.strokeRect(\r\n                        part.bounds.min.x,\r\n                        part.bounds.min.y,\r\n                        part.bounds.max.x - part.bounds.min.x,\r\n                        part.bounds.max.y - part.bounds.min.y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders either all axes, or a single axis indicator, for an array of Bodies, to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showAxes` or `showAngleIndicator` config values are set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyAxes\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {boolean} showAxes - If `true` it will render all body axes. If `false` it will render a single axis indicator.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     */\r\n    renderBodyAxes: function (bodies, graphics, showAxes, lineColor, lineOpacity)\r\n    {\r\n        graphics.lineStyle(1, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n            var parts = body.parts;\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var part;\r\n            var j;\r\n            var k;\r\n\r\n            if (showAxes)\r\n            {\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    part = parts[j];\r\n    \r\n                    for (k = 0; k < part.axes.length; k++)\r\n                    {\r\n                        var axis = part.axes[k];\r\n\r\n                        graphics.lineBetween(\r\n                            part.position.x,\r\n                            part.position.y,\r\n                            part.position.x + axis.x * 20,\r\n                            part.position.y + axis.y * 20\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++)\r\n                {\r\n                    part = parts[j];\r\n    \r\n                    for (k = 0; k < part.axes.length; k++)\r\n                    {\r\n                        graphics.lineBetween(\r\n                            part.position.x,\r\n                            part.position.y,\r\n                            (part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2,\r\n                            (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders a velocity indicator for an array of Bodies, to the given Graphics instance.\r\n     * \r\n     * The debug renderer calls this method if the `showVelocity` config value is set.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render bounds to your own Graphics instance.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodyVelocity\r\n     * @since 3.22.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * @param {number} lineThickness - The line thickness.\r\n     */\r\n    renderBodyVelocity: function (bodies, graphics, lineColor, lineOpacity, lineThickness)\r\n    {\r\n        graphics.lineStyle(lineThickness, lineColor, lineOpacity);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            graphics.lineBetween(\r\n                body.position.x,\r\n                body.position.y,\r\n                body.position.x + (body.position.x - body.positionPrev.x) * 2,\r\n                body.position.y + (body.position.y - body.positionPrev.y) * 2\r\n            );\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the given array of Bodies to the debug graphics instance.\r\n     * \r\n     * Called automatically by the `postUpdate` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderBodies\r\n     * @private\r\n     * @since 3.14.0\r\n     * \r\n     * @param {array} bodies - An array of bodies from the localWorld.\r\n     */\r\n    renderBodies: function (bodies)\r\n    {\r\n        var graphics = this.debugGraphic;\r\n\r\n        var config = this.debugConfig;\r\n\r\n        var showBody = config.showBody;\r\n        var showStaticBody = config.showStaticBody;\r\n        var showSleeping = config.showSleeping;\r\n        var showInternalEdges = config.showInternalEdges;\r\n        var showConvexHulls = config.showConvexHulls;\r\n\r\n        var renderFill = config.renderFill;\r\n        var renderLine = config.renderLine;\r\n\r\n        var staticBodySleepOpacity = config.staticBodySleepOpacity;\r\n        var sleepFillColor = config.sleepFillColor;\r\n        var sleepLineColor = config.sleepLineColor;\r\n\r\n        var hullColor = config.hullColor;\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            //  1) Don't show invisible bodies\r\n            if (!body.render.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  2) Don't show static bodies, OR\r\n            //  3) Don't show dynamic bodies\r\n            if ((!showStaticBody && body.isStatic) || (!showBody && !body.isStatic))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var lineColor = body.render.lineColor;\r\n            var lineOpacity = body.render.lineOpacity;\r\n            var lineThickness = body.render.lineThickness;\r\n            var fillColor = body.render.fillColor;\r\n            var fillOpacity = body.render.fillOpacity;\r\n\r\n            if (showSleeping && body.isSleeping)\r\n            {\r\n                if (body.isStatic)\r\n                {\r\n                    lineOpacity *= staticBodySleepOpacity;\r\n                    fillOpacity *= staticBodySleepOpacity;\r\n                }\r\n                else\r\n                {\r\n                    lineColor = sleepLineColor;\r\n                    fillColor = sleepFillColor;\r\n                }\r\n            }\r\n\r\n            if (!renderFill)\r\n            {\r\n                fillColor = null;\r\n            }\r\n\r\n            if (!renderLine)\r\n            {\r\n                lineColor = null;\r\n            }\r\n\r\n            this.renderBody(body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity);\r\n\r\n            var partsLength = body.parts.length;\r\n\r\n            if (showConvexHulls && partsLength > 1)\r\n            {\r\n                this.renderConvexHull(body, graphics, hullColor, lineThickness);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders a single Matter Body to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Body to your own Graphics instance.\r\n     * \r\n     * If you don't wish to render a line around the body, set the `lineColor` parameter to `null`.\r\n     * Equally, if you don't wish to render a fill, set the `fillColor` parameter to `null`.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderBody\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {boolean} showInternalEdges - Render internal edges of the polygon?\r\n     * @param {number} [lineColor] - The line color.\r\n     * @param {number} [lineOpacity] - The line opacity, between 0 and 1.\r\n     * @param {number} [lineThickness=1] - The line thickness.\r\n     * @param {number} [fillColor] - The fill color.\r\n     * @param {number} [fillOpacity] - The fill opacity, between 0 and 1.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderBody: function (body, graphics, showInternalEdges, lineColor, lineOpacity, lineThickness, fillColor, fillOpacity)\r\n    {\r\n        if (lineColor === undefined) { lineColor = null; }\r\n        if (lineOpacity === undefined) { lineOpacity = null; }\r\n        if (lineThickness === undefined) { lineThickness = 1; }\r\n        if (fillColor === undefined) { fillColor = null; }\r\n        if (fillOpacity === undefined) { fillOpacity = null; }\r\n\r\n        var config = this.debugConfig;\r\n\r\n        var sensorFillColor = config.sensorFillColor;\r\n        var sensorLineColor = config.sensorLineColor;\r\n\r\n        //  Handle compound parts\r\n        var parts = body.parts;\r\n        var partsLength = parts.length;\r\n\r\n        for (var k = (partsLength > 1) ? 1 : 0; k < partsLength; k++)\r\n        {\r\n            var part = parts[k];\r\n            var render = part.render;\r\n            var opacity = render.opacity;\r\n\r\n            if (!render.visible || opacity === 0 || (part.isSensor && !config.showSensors))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //  Part polygon\r\n            var circleRadius = part.circleRadius;\r\n\r\n            graphics.beginPath();\r\n\r\n            if (part.isSensor)\r\n            {\r\n                if (fillColor !== null)\r\n                {\r\n                    graphics.fillStyle(sensorFillColor, fillOpacity * opacity);\r\n                }\r\n    \r\n                if (lineColor !== null)\r\n                {\r\n                    graphics.lineStyle(lineThickness, sensorLineColor, lineOpacity * opacity);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (fillColor !== null)\r\n                {\r\n                    graphics.fillStyle(fillColor, fillOpacity * opacity);\r\n                }\r\n    \r\n                if (lineColor !== null)\r\n                {\r\n                    graphics.lineStyle(lineThickness, lineColor, lineOpacity * opacity);\r\n                }\r\n            }\r\n\r\n            if (circleRadius)\r\n            {\r\n                graphics.arc(part.position.x, part.position.y, circleRadius, 0, 2 * Math.PI);\r\n            }\r\n            else\r\n            {\r\n                var vertices = part.vertices;\r\n                var vertLength = vertices.length;\r\n\r\n                graphics.moveTo(vertices[0].x, vertices[0].y);\r\n\r\n                for (var j = 1; j < vertLength; j++)\r\n                {\r\n                    var vert = vertices[j];\r\n\r\n                    if (!vertices[j - 1].isInternal || showInternalEdges)\r\n                    {\r\n                        graphics.lineTo(vert.x, vert.y);\r\n                    }\r\n                    else\r\n                    {\r\n                        graphics.moveTo(vert.x, vert.y);\r\n                    }\r\n\r\n                    if (j < vertLength && vert.isInternal && !showInternalEdges)\r\n                    {\r\n                        var nextIndex = (j + 1) % vertLength;\r\n\r\n                        graphics.moveTo(vertices[nextIndex].x, vertices[nextIndex].y);\r\n                    }\r\n                }\r\n                \r\n                graphics.closePath();\r\n            }\r\n\r\n            if (fillColor !== null)\r\n            {\r\n                graphics.fillPath();\r\n            }\r\n\r\n            if (lineColor !== null)\r\n            {\r\n                graphics.strokePath();\r\n            }\r\n        }\r\n\r\n        if (config.showPositions && !body.isStatic)\r\n        {\r\n            var px = body.position.x;\r\n            var py = body.position.y;\r\n            var hs = Math.ceil(config.positionSize / 2);\r\n\r\n            graphics.fillStyle(config.positionColor, 1);\r\n            graphics.fillRect(px - hs, py - hs, config.positionSize, config.positionSize);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders the Convex Hull for a single Matter Body to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Body hull to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderConvexHull\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.BodyType} body - The Matter Body to be rendered.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} hullColor - The color used to render the hull.\r\n     * @param {number} [lineThickness=1] - The hull line thickness.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderConvexHull: function (body, graphics, hullColor, lineThickness)\r\n    {\r\n        if (lineThickness === undefined) { lineThickness = 1; }\r\n\r\n        var parts = body.parts;\r\n        var partsLength = parts.length;\r\n\r\n        //  Render Convex Hulls\r\n        if (partsLength > 1)\r\n        {\r\n            var verts = body.vertices;\r\n\r\n            graphics.lineStyle(lineThickness, hullColor);\r\n\r\n            graphics.beginPath();\r\n\r\n            graphics.moveTo(verts[0].x, verts[0].y);\r\n\r\n            for (var v = 1; v < verts.length; v++)\r\n            {\r\n                graphics.lineTo(verts[v].x, verts[v].y);\r\n            }\r\n            \r\n            graphics.lineTo(verts[0].x, verts[0].y);\r\n\r\n            graphics.strokePath();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Renders all of the constraints in the world (unless they are specifically set to invisible).\r\n     * \r\n     * Called automatically by the `postUpdate` method.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#renderJoints\r\n     * @private\r\n     * @since 3.14.0\r\n     */\r\n    renderJoints: function ()\r\n    {\r\n        var graphics = this.debugGraphic;\r\n\r\n        // Render constraints \r\n        var constraints = Composite.allConstraints(this.localWorld);\r\n\r\n        for (var i = 0; i < constraints.length; i++)\r\n        {\r\n            var config = constraints[i].render;\r\n\r\n            var lineColor = config.lineColor;\r\n            var lineOpacity = config.lineOpacity;\r\n            var lineThickness = config.lineThickness;\r\n            var pinSize = config.pinSize;\r\n            var anchorColor = config.anchorColor;\r\n            var anchorSize = config.anchorSize;\r\n\r\n            this.renderConstraint(constraints[i], graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders a single Matter Constraint, such as a Pin or a Spring, to the given Phaser Graphics Game Object.\r\n     * \r\n     * This method is used internally by the Matter Debug Renderer, but is also exposed publically should\r\n     * you wish to render a Constraint to your own Graphics instance.\r\n     * \r\n     * @method Phaser.Physics.Matter.World#renderConstraint\r\n     * @since 3.22.0\r\n     * \r\n     * @param {MatterJS.ConstraintType} constraint - The Matter Constraint to render.\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics object to render to.\r\n     * @param {number} lineColor - The line color.\r\n     * @param {number} lineOpacity - The line opacity, between 0 and 1.\r\n     * @param {number} lineThickness - The line thickness.\r\n     * @param {number} pinSize - If this constraint is a pin, this sets the size of the pin circle.\r\n     * @param {number} anchorColor - The color used when rendering this constraints anchors. Set to `null` to not render anchors.\r\n     * @param {number} anchorSize - The size of the anchor circle, if this constraint has anchors and is rendering them.\r\n     * \r\n     * @return {this} This Matter World instance for method chaining.\r\n     */\r\n    renderConstraint: function (constraint, graphics, lineColor, lineOpacity, lineThickness, pinSize, anchorColor, anchorSize)\r\n    {\r\n        var render = constraint.render;\r\n\r\n        if (!render.visible || !constraint.pointA || !constraint.pointB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        graphics.lineStyle(lineThickness, lineColor, lineOpacity);\r\n\r\n        var bodyA = constraint.bodyA;\r\n        var bodyB = constraint.bodyB;\r\n        var start;\r\n        var end;\r\n\r\n        if (bodyA)\r\n        {\r\n            start = Vector.add(bodyA.position, constraint.pointA);\r\n        }\r\n        else\r\n        {\r\n            start = constraint.pointA;\r\n        }\r\n\r\n        if (render.type === 'pin')\r\n        {\r\n            graphics.strokeCircle(start.x, start.y, pinSize);\r\n        }\r\n        else\r\n        {\r\n            if (bodyB)\r\n            {\r\n                end = Vector.add(bodyB.position, constraint.pointB);\r\n            }\r\n            else\r\n            {\r\n                end = constraint.pointB;\r\n            }\r\n\r\n            graphics.beginPath();\r\n            graphics.moveTo(start.x, start.y);\r\n\r\n            if (render.type === 'spring')\r\n            {\r\n                var delta = Vector.sub(end, start);\r\n                var normal = Vector.perp(Vector.normalise(delta));\r\n                var coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20));\r\n                var offset;\r\n\r\n                for (var j = 1; j < coils; j += 1)\r\n                {\r\n                    offset = (j % 2 === 0) ? 1 : -1;\r\n\r\n                    graphics.lineTo(\r\n                        start.x + delta.x * (j / coils) + normal.x * offset * 4,\r\n                        start.y + delta.y * (j / coils) + normal.y * offset * 4\r\n                    );\r\n                }\r\n            }\r\n\r\n            graphics.lineTo(end.x, end.y);\r\n        }\r\n\r\n        graphics.strokePath();\r\n\r\n        if (render.anchors && anchorSize > 0)\r\n        {\r\n            graphics.fillStyle(anchorColor);\r\n            graphics.fillCircle(start.x, start.y, anchorSize);\r\n            graphics.fillCircle(end.x, end.y, anchorSize);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the internal collision IDs that Matter.JS uses for Body collision groups.\r\n     * \r\n     * You should call this before destroying your game if you need to restart the game\r\n     * again on the same page, without first reloading the page. Or, if you wish to\r\n     * consistently destroy a Scene that contains Matter.js and then run it again\r\n     * later in the same game.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#resetCollisionIDs\r\n     * @since 3.17.0\r\n     */\r\n    resetCollisionIDs: function ()\r\n    {\r\n        Body._nextCollidingGroupId = 1;\r\n        Body._nextNonCollidingGroupId = -1;\r\n        Body._nextCategory = 0x0001;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Will remove all Matter physics event listeners and clear the matter physics world,\r\n     * engine and any debug graphics, if any.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        MatterEvents.off(this.engine);\r\n\r\n        this.removeAllListeners();\r\n\r\n        MatterWorld.clear(this.localWorld, false);\r\n\r\n        Engine.clear(this.engine);\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.debugGraphic.destroy();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Will remove all Matter physics event listeners and clear the matter physics world,\r\n     * engine and any debug graphics, if any.\r\n     *\r\n     * After destroying the world it cannot be re-used again.\r\n     *\r\n     * @method Phaser.Physics.Matter.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A component to set restitution on objects.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Bounce\r\n * @since 3.0.0\r\n */\r\nvar Bounce = {\r\n\r\n    /**\r\n     * Sets the restitution on the physics object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Bounce#setBounce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - A Number that defines the restitution (elasticity) of the body. The value is always positive and is in the range (0, 1). A value of 0 means collisions may be perfectly inelastic and no bouncing may occur. A value of 0.8 means the body may bounce back with approximately 80% of its kinetic energy. Note that collision response is based on pairs of bodies, and that restitution values are combined with the following formula: `Math.max(bodyA.restitution, bodyB.restitution)`\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setBounce: function (value)\r\n    {\r\n        this.body.restitution = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Bounce;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Contains methods for changing the collision filter of a Matter Body. Should be used as a mixin and not called directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Collision\r\n * @since 3.0.0\r\n */\r\nvar Collision = {\r\n\r\n    /**\r\n     * Sets the collision category of this Game Object's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n     * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n     * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionCategory\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique category bitfield.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollisionCategory: function (value)\r\n    {\r\n        this.body.collisionFilter.category = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision group of this Game Object's Matter Body. If this is zero or two Matter Bodies have different values,\r\n     * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n     * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n     * they will never collide.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Unique group index.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollisionGroup: function (value)\r\n    {\r\n        this.body.collisionFilter.group = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision mask for this Game Object's Matter Body. Two Matter Bodies with different collision groups will only\r\n     * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n     * and `(categoryB & maskA) !== 0` are both true.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setCollidesWith\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCollidesWith: function (categories)\r\n    {\r\n        var flags = 0;\r\n\r\n        if (!Array.isArray(categories))\r\n        {\r\n            flags = categories;\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < categories.length; i++)\r\n            {\r\n                flags |= categories[i];\r\n            }\r\n        }\r\n\r\n        this.body.collisionFilter.mask = flags;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollide\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollide: function (callback)\r\n    {\r\n        this.body.onCollideCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideEnd\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideEnd: function (callback)\r\n    {\r\n        this.body.onCollideEndCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideActive\r\n     * @since 3.22.0\r\n     *\r\n     * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideActive: function (callback)\r\n    {\r\n        this.body.onCollideActiveCallback = callback;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n     * \r\n     * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n     * to the callback.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Collision#setOnCollideWith\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n     * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setOnCollideWith: function (body, callback)\r\n    {\r\n        if (!Array.isArray(body))\r\n        {\r\n            body = [ body ];\r\n        }\r\n\r\n        for (var i = 0; i < body.length; i++)\r\n        {\r\n            var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n            this.body.setOnCollideWith(src, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Collision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\n\r\n/**\r\n * A component to apply force to Matter.js bodies.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Force\r\n * @since 3.0.0\r\n */\r\nvar Force = {\r\n\r\n    //  force = vec2 / point\r\n\r\n    /**\r\n     * Applies a force to a body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#applyForce\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} force - A Vector that specifies the force to apply.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    applyForce: function (force)\r\n    {\r\n        this._tempVec2.set(this.body.position.x, this.body.position.y);\r\n\r\n        Body.applyForce(this.body, this._tempVec2, force);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Applies a force to a body from a given position.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#applyForceFrom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} position - The position in which the force comes from.\r\n     * @param {Phaser.Math.Vector2} force - A Vector that specifies the force to apply.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    applyForceFrom: function (position, force)\r\n    {\r\n        Body.applyForce(this.body, position, force);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply thrust to the forward position of the body.\r\n     * \r\n     * Use very small values, such as 0.1, depending on the mass and required speed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrust\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    thrust: function (speed)\r\n    {\r\n        var angle = this.body.angle;\r\n\r\n        this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));\r\n\r\n        Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply thrust to the left position of the body.\r\n     * \r\n     * Use very small values, such as 0.1, depending on the mass and required speed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    thrustLeft: function (speed)\r\n    {\r\n        var angle = this.body.angle - Math.PI / 2;\r\n\r\n        this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));\r\n\r\n        Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply thrust to the right position of the body.\r\n     * \r\n     * Use very small values, such as 0.1, depending on the mass and required speed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    thrustRight: function (speed)\r\n    {\r\n        var angle = this.body.angle + Math.PI / 2;\r\n\r\n        this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));\r\n\r\n        Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Apply thrust to the back position of the body.\r\n     * \r\n     * Use very small values, such as 0.1, depending on the mass and required speed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Force#thrustBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} speed - A speed value to be applied to a directional force.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    thrustBack: function (speed)\r\n    {\r\n        var angle = this.body.angle - Math.PI;\r\n\r\n        this._tempVec2.set(speed * Math.cos(angle), speed * Math.sin(angle));\r\n\r\n        Body.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Force;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Contains methods for changing the friction of a Game Object's Matter Body. Should be used a mixin, not called directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Friction\r\n * @since 3.0.0\r\n */\r\nvar Friction = {\r\n\r\n    /**\r\n     * Sets new friction values for this Game Object's Matter Body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFriction\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The new friction of the body, between 0 and 1, where 0 allows the Body to slide indefinitely, while 1 allows it to stop almost immediately after a force is applied.\r\n     * @param {number} [air] - If provided, the new air resistance of the Body. The higher the value, the faster the Body will slow as it moves through space. 0 means the body has no air resistance.\r\n     * @param {number} [fstatic] - If provided, the new static friction of the Body. The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary. 0 means the body will never \"stick\" when it is nearly stationary.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setFriction: function (value, air, fstatic)\r\n    {\r\n        this.body.friction = value;\r\n\r\n        if (air !== undefined)\r\n        {\r\n            this.body.frictionAir = air;\r\n        }\r\n\r\n        if (fstatic !== undefined)\r\n        {\r\n            this.body.frictionStatic = fstatic;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a new air resistance for this Game Object's Matter Body.\r\n     * A value of 0 means the Body will never slow as it moves through space.\r\n     * The higher the value, the faster a Body slows when moving through space.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFrictionAir\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The new air resistance for the Body.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setFrictionAir: function (value)\r\n    {\r\n        this.body.frictionAir = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a new static friction for this Game Object's Matter Body.\r\n     * A value of 0 means the Body will never \"stick\" when it is nearly stationary.\r\n     * The higher the value (e.g. 10), the more force it will take to initially get the Body moving when it is nearly stationary.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Friction#setFrictionStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The new static friction for the Body.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setFrictionStatic: function (value)\r\n    {\r\n        this.body.frictionStatic = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Friction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A component to manipulate world gravity for Matter.js bodies.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Gravity\r\n * @since 3.0.0\r\n */\r\nvar Gravity = {\r\n\r\n    /**\r\n     * A togglable function for ignoring world gravity in real-time on the current body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Gravity#setIgnoreGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Set to true to ignore the effect of world gravity, or false to not ignore it.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setIgnoreGravity: function (value)\r\n    {\r\n        this.body.ignoreGravity = value;\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Gravity;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\nvar Vector2 = require('../../../math/Vector2');\r\n\r\n/**\r\n * Allows accessing the mass, density, and center of mass of a Matter-enabled Game Object. Should be used as a mixin and not directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Mass\r\n * @since 3.0.0\r\n */\r\nvar Mass = {\r\n\r\n    /**\r\n     * Sets the mass of the Game Object's Matter Body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Mass#setMass\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The new mass of the body.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setMass: function (value)\r\n    {\r\n        Body.setMass(this.body, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets density of the body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Mass#setDensity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The new density of the body.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setDensity: function (value)\r\n    {\r\n        Body.setDensity(this.body, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The body's center of mass.\r\n     * \r\n     * Calling this creates a new `Vector2 each time to avoid mutation.\r\n     * \r\n     * If you only need to read the value and won't change it, you can get it from `GameObject.body.centerOfMass`.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Mass#centerOfMass\r\n     * @type {Phaser.Math.Vector2}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Math.Vector2} The center of mass.\r\n     */\r\n    centerOfMass: {\r\n\r\n        get: function ()\r\n        {\r\n            return new Vector2(this.body.centerOfMass.x, this.body.centerOfMass.y);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Mass;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Enables a Matter-enabled Game Object to be a sensor. Should be used as a mixin and not directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Sensor\r\n * @since 3.0.0\r\n */\r\nvar Sensor = {\r\n\r\n    /**\r\n     * Set the body belonging to this Game Object to be a sensor.\r\n     * Sensors trigger collision events, but don't react with colliding body physically.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sensor#setSensor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to set the body as a sensor, or `false` to disable it.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setSensor: function (value)\r\n    {\r\n        this.body.isSensor = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Is the body belonging to this Game Object a sensor or not?\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sensor#isSensor\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the body is a sensor, otherwise `false`.\r\n     */\r\n    isSensor: function ()\r\n    {\r\n        return this.body.isSensor;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Sensor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('../lib/factory/Bodies');\r\nvar Body = require('../lib/body/Body');\r\nvar FuzzyEquals = require('../../../math/fuzzy/Equal');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar PhysicsEditorParser = require('../PhysicsEditorParser');\r\nvar PhysicsJSONParser = require('../PhysicsJSONParser');\r\nvar Vertices = require('../lib/geometry/Vertices');\r\n\r\n/**\r\n * Enables a Matter-enabled Game Object to set its Body. Should be used as a mixin and not directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.SetBody\r\n * @since 3.0.0\r\n */\r\nvar SetBody = {\r\n\r\n    /**\r\n     * Set the body on a Game Object to a rectangle.\r\n     * \r\n     * Calling this methods resets previous properties you may have set on the body, including\r\n     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - Width of the rectangle.\r\n     * @param {number} height - Height of the rectangle.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setRectangle: function (width, height, options)\r\n    {\r\n        return this.setBody({ type: 'rectangle', width: width, height: height }, options);\r\n    },\r\n\r\n    /**\r\n     * Set the body on a Game Object to a circle.\r\n     * \r\n     * Calling this methods resets previous properties you may have set on the body, including\r\n     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setCircle: function (radius, options)\r\n    {\r\n        return this.setBody({ type: 'circle', radius: radius }, options);\r\n    },\r\n\r\n    /**\r\n     * Set the body on the Game Object to a polygon shape.\r\n     * \r\n     * Calling this methods resets previous properties you may have set on the body, including\r\n     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setPolygon\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radius - The \"radius\" of the polygon, i.e. the distance from its center to any vertex. This is also the radius of its circumcircle.\r\n     * @param {number} sides - The number of sides the polygon will have.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setPolygon: function (radius, sides, options)\r\n    {\r\n        return this.setBody({ type: 'polygon', sides: sides, radius: radius }, options);\r\n    },\r\n\r\n    /**\r\n     * Set the body on the Game Object to a trapezoid shape.\r\n     * \r\n     * Calling this methods resets previous properties you may have set on the body, including\r\n     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setTrapezoid\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of the trapezoid Body.\r\n     * @param {number} height - The height of the trapezoid Body.\r\n     * @param {number} slope - The slope of the trapezoid. 0 creates a rectangle, while 1 creates a triangle. Positive values make the top side shorter, while negative values make the bottom side shorter.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setTrapezoid: function (width, height, slope, options)\r\n    {\r\n        return this.setBody({ type: 'trapezoid', width: width, height: height, slope: slope }, options);\r\n    },\r\n\r\n    /**\r\n     * Set this Game Object to use the given existing Matter Body.\r\n     * \r\n     * The body is first removed from the world before being added to this Game Object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setExistingBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.BodyType} body - The Body this Game Object should use.\r\n     * @param {boolean} [addToWorld=true] - Should the body be immediately added to the World?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setExistingBody: function (body, addToWorld)\r\n    {\r\n        if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n        if (this.body)\r\n        {\r\n            this.world.remove(this.body, true);\r\n        }\r\n\r\n        this.body = body;\r\n\r\n        for (var i = 0; i < body.parts.length; i++)\r\n        {\r\n            body.parts[i].gameObject = this;\r\n        }\r\n\r\n        var _this = this;\r\n\r\n        body.destroy = function destroy ()\r\n        {\r\n            _this.world.remove(_this.body, true);\r\n            _this.body.gameObject = null;\r\n        };\r\n\r\n        if (addToWorld)\r\n        {\r\n            if (this.world.has(body))\r\n            {\r\n                //  Because it could be part of another Composite\r\n                this.world.remove(body, true);\r\n            }\r\n\r\n            this.world.add(body);\r\n        }\r\n\r\n        if (this._originComponent)\r\n        {\r\n            var rx = body.render.sprite.xOffset;\r\n            var ry = body.render.sprite.yOffset;\r\n\r\n            var comx = body.centerOfMass.x;\r\n            var comy = body.centerOfMass.y;\r\n\r\n            if (FuzzyEquals(comx, 0.5) && FuzzyEquals(comy, 0.5))\r\n            {\r\n                this.setOrigin(rx + 0.5, ry + 0.5);\r\n            }\r\n            else\r\n            {\r\n                var cx = body.centerOffset.x;\r\n                var cy = body.centerOffset.y;\r\n\r\n                this.setOrigin(rx + (cx / this.displayWidth), ry + (cy / this.displayHeight));\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set this Game Object to create and use a new Body based on the configuration object given.\r\n     * \r\n     * Calling this method resets previous properties you may have set on the body, including\r\n     * plugins, mass, friction, etc. So be sure to re-apply these in the options object if needed.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.SetBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Types.Physics.Matter.MatterSetBodyConfig)} config - Either a string, such as `circle`, or a Matter Set Body Configuration object.\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyConfig} [options] - An optional Body configuration object that is used to set initial Body properties on creation.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setBody: function (config, options)\r\n    {\r\n        if (!config)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var body;\r\n\r\n        //  Allow them to do: shape: 'circle' instead of shape: { type: 'circle' }\r\n        if (typeof config === 'string')\r\n        {\r\n            //  Using defaults\r\n            config = { type: config };\r\n        }\r\n\r\n        var shapeType = GetFastValue(config, 'type', 'rectangle');\r\n        var bodyX = GetFastValue(config, 'x', this._tempVec2.x);\r\n        var bodyY = GetFastValue(config, 'y', this._tempVec2.y);\r\n        var bodyWidth = GetFastValue(config, 'width', this.width);\r\n        var bodyHeight = GetFastValue(config, 'height', this.height);\r\n\r\n        switch (shapeType)\r\n        {\r\n            case 'rectangle':\r\n                body = Bodies.rectangle(bodyX, bodyY, bodyWidth, bodyHeight, options);\r\n                break;\r\n\r\n            case 'circle':\r\n                var radius = GetFastValue(config, 'radius', Math.max(bodyWidth, bodyHeight) / 2);\r\n                var maxSides = GetFastValue(config, 'maxSides', 25);\r\n                body = Bodies.circle(bodyX, bodyY, radius, options, maxSides);\r\n                break;\r\n\r\n            case 'trapezoid':\r\n                var slope = GetFastValue(config, 'slope', 0.5);\r\n                body = Bodies.trapezoid(bodyX, bodyY, bodyWidth, bodyHeight, slope, options);\r\n                break;\r\n\r\n            case 'polygon':\r\n                var sides = GetFastValue(config, 'sides', 5);\r\n                var pRadius = GetFastValue(config, 'radius', Math.max(bodyWidth, bodyHeight) / 2);\r\n                body = Bodies.polygon(bodyX, bodyY, sides, pRadius, options);\r\n                break;\r\n\r\n            case 'fromVertices':\r\n            case 'fromVerts':\r\n\r\n                var verts = GetFastValue(config, 'verts', null);\r\n\r\n                if (verts)\r\n                {\r\n                    //  Has the verts array come from Vertices.fromPath, or is it raw?\r\n                    if (typeof verts === 'string')\r\n                    {\r\n                        verts = Vertices.fromPath(verts);\r\n                    }\r\n\r\n                    if (this.body && !this.body.hasOwnProperty('temp'))\r\n                    {\r\n                        Body.setVertices(this.body, verts);\r\n\r\n                        body = this.body;\r\n                    }\r\n                    else\r\n                    {\r\n                        var flagInternal = GetFastValue(config, 'flagInternal', false);\r\n                        var removeCollinear = GetFastValue(config, 'removeCollinear', 0.01);\r\n                        var minimumArea = GetFastValue(config, 'minimumArea', 10);\r\n    \r\n                        body = Bodies.fromVertices(bodyX, bodyY, verts, options, flagInternal, removeCollinear, minimumArea);\r\n                    }\r\n                }\r\n\r\n                break;\r\n\r\n            case 'fromPhysicsEditor':\r\n                body = PhysicsEditorParser.parseBody(bodyX, bodyY, config, options);\r\n                break;\r\n\r\n            case 'fromPhysicsTracer':\r\n                body = PhysicsJSONParser.parseBody(bodyX, bodyY, config, options);\r\n                break;\r\n        }\r\n\r\n        if (body)\r\n        {\r\n            this.setExistingBody(body, config.addToWorld);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = SetBody;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Events = require('../events');\r\nvar Sleeping = require('../lib/core/Sleeping');\r\nvar MatterEvents = require('../lib/core/Events');\r\n\r\n/**\r\n * Enables a Matter-enabled Game Object to be able to go to sleep. Should be used as a mixin and not directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Sleep\r\n * @since 3.0.0\r\n */\r\nvar Sleep = {\r\n\r\n    /**\r\n     * Sets this Body to sleep.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setToSleep\r\n     * @since 3.22.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setToSleep: function ()\r\n    {\r\n        Sleeping.set(this.body, true);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Wakes this Body if asleep.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setAwake\r\n     * @since 3.22.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAwake: function ()\r\n    {\r\n        Sleeping.set(this.body, false);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of updates in which this body must have near-zero velocity before it is set as sleeping (if sleeping is enabled by the engine).\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepThreshold\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [value=60] - A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSleepThreshold: function (value)\r\n    {\r\n        if (value === undefined) { value = 60; }\r\n\r\n        this.body.sleepThreshold = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enable sleep and wake events for this body.\r\n     *\r\n     * By default when a body goes to sleep, or wakes up, it will not emit any events.\r\n     *\r\n     * The events are emitted by the Matter World instance and can be listened to via\r\n     * the `SLEEP_START` and `SLEEP_END` events.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEvents\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} start - `true` if you want the sleep start event to be emitted for this body.\r\n     * @param {boolean} end - `true` if you want the sleep end event to be emitted for this body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSleepEvents: function (start, end)\r\n    {\r\n        this.setSleepStartEvent(start);\r\n        this.setSleepEndEvent(end);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables the Sleep Start event for this body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepStartEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to enable the sleep event, or `false` to disable it.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSleepStartEvent: function (value)\r\n    {\r\n        if (value)\r\n        {\r\n            var world = this.world;\r\n\r\n            MatterEvents.on(this.body, 'sleepStart', function (event)\r\n            {\r\n                world.emit(Events.SLEEP_START, event, this);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            MatterEvents.off(this.body, 'sleepStart');\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Enables or disables the Sleep End event for this body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Sleep#setSleepEndEvent\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to enable the sleep event, or `false` to disable it.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setSleepEndEvent: function (value)\r\n    {\r\n        if (value)\r\n        {\r\n            var world = this.world;\r\n\r\n            MatterEvents.on(this.body, 'sleepEnd', function (event)\r\n            {\r\n                world.emit(Events.SLEEP_END, event, this);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            MatterEvents.off(this.body, 'sleepEnd');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Sleep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\n\r\n/**\r\n * Provides methods used for getting and setting the static state of a physics body.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Static\r\n * @since 3.0.0\r\n */\r\nvar Static = {\r\n\r\n    /**\r\n     * Changes the physics body to be either static `true` or dynamic `false`.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Static#setStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to set the body as being static, or `false` to make it dynamic.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setStatic: function (value)\r\n    {\r\n        Body.setStatic(this.body, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the body is static, otherwise `false` for a dynamic body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Static#isStatic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the body is static, otherwise `false`.\r\n     */\r\n    isStatic: function ()\r\n    {\r\n        return this.body.isStatic;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Static;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar WrapAngle = require('../../../math/angle/Wrap');\r\nvar WrapAngleDegrees = require('../../../math/angle/WrapDegrees');\r\n\r\n//  global bitmask flag for GameObject.renderMask (used by Scale)\r\nvar _FLAG = 4; // 0100\r\n\r\n//  Transform Component\r\n\r\n/**\r\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Transform\r\n * @since 3.0.0\r\n */\r\nvar Transform = {\r\n\r\n    /**\r\n     * The x position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#x\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(value, this.y);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y position of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#y\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.position.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tempVec2.set(this.x, value);\r\n\r\n            Body.setPosition(this.body, this._tempVec2);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleX\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factorX = 1 / this._scaleX;\r\n            var factorY = 1 / this._scaleY;\r\n    \r\n            this._scaleX = value;\r\n\r\n            if (this._scaleX === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            //  Reset Matter scale back to 1 (sigh)\r\n            Body.scale(this.body, factorX, factorY);\r\n\r\n            Body.scale(this.body, value, this._scaleY);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of this Game Object.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#scaleY\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    scaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._scaleY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var factorX = 1 / this._scaleX;\r\n            var factorY = 1 / this._scaleY;\r\n\r\n            this._scaleY = value;\r\n\r\n            if (this._scaleY === 0)\r\n            {\r\n                this.renderFlags &= ~_FLAG;\r\n            }\r\n            else\r\n            {\r\n                this.renderFlags |= _FLAG;\r\n            }\r\n\r\n            Body.scale(this.body, factorX, factorY);\r\n\r\n            Body.scale(this.body, this._scaleX, value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Use `angle` to set or get rotation of the physics body associated to this GameObject.\r\n     * Unlike rotation, when using set the value can be in degrees, which will be converted to radians internally.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#angle\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    angle: {\r\n\r\n        get: function ()\r\n        {\r\n            return WrapAngleDegrees(this.body.angle * MATH_CONST.RAD_TO_DEG);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in degrees\r\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Use `rotation` to set or get the rotation of the physics body associated with this GameObject.\r\n     * The value when set must be in radians.\r\n     *\r\n     * @name Phaser.Physics.Matter.Components.Transform#rotation\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    rotation: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.body.angle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            //  value is in radians\r\n            this._rotation = WrapAngle(value);\r\n\r\n            Body.setAngle(this.body, this._rotation);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the position of the physics body along x and y axes.\r\n     * Both the parameters to this function are optional and if not passed any they default to 0.\r\n     * Velocity, angle, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the body.\r\n     * @param {number} [y=x] - The vertical position of the body.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this._tempVec2.set(x, y);\r\n\r\n        Body.setPosition(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Immediately sets the angle of the Body.\r\n     * Angular velocity, position, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [radians=0] - The angle of the body, in radians.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setRotation: function (radians)\r\n    {\r\n        if (radians === undefined) { radians = 0; }\r\n\r\n        this._rotation = WrapAngle(radians);\r\n\r\n        Body.setAngle(this.body, radians);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Setting fixed rotation sets the Body inertia to Infinity, which stops it\r\n     * from being able to rotate when forces are applied to it.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setFixedRotation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setFixedRotation: function ()\r\n    {\r\n        Body.setInertia(this.body, Infinity);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Immediately sets the angle of the Body.\r\n     * Angular velocity, position, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [degrees=0] - The angle to set, in degrees.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setAngle: function (degrees)\r\n    {\r\n        if (degrees === undefined) { degrees = 0; }\r\n\r\n        this.angle = degrees;\r\n\r\n        Body.setAngle(this.body, this.rotation);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of this Game Object.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Transform#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=1] - The horizontal scale of this Game Object.\r\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the x value.\r\n     * @param {Phaser.Math.Vector2} [point] - The point (Vector2) from which scaling will occur.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setScale: function (x, y, point)\r\n    {\r\n        if (x === undefined) { x = 1; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        var factorX = 1 / this._scaleX;\r\n        var factorY = 1 / this._scaleY;\r\n\r\n        this._scaleX = x;\r\n        this._scaleY = y;\r\n\r\n        Body.scale(this.body, factorX, factorY, point);\r\n\r\n        Body.scale(this.body, x, y, point);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Transform;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('../lib/body/Body');\r\n\r\n/**\r\n * Contains methods for changing the velocity of a Matter Body. Should be used as a mixin and not called directly.\r\n *\r\n * @namespace Phaser.Physics.Matter.Components.Velocity\r\n * @since 3.0.0\r\n */\r\nvar Velocity = {\r\n\r\n    /**\r\n     * Sets the angular velocity of the body instantly.\r\n     * Position, angle, force etc. are unchanged.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setAngularVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The angular velocity.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setAngularVelocity: function (value)\r\n    {\r\n        Body.setAngularVelocity(this.body, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal velocity of the physics body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity value.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setVelocityX: function (x)\r\n    {\r\n        this._tempVec2.set(x, this.body.velocity.y);\r\n\r\n        Body.setVelocity(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets vertical velocity of the physics body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} y - The vertical velocity value.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setVelocityY: function (y)\r\n    {\r\n        this._tempVec2.set(this.body.velocity.x, y);\r\n\r\n        Body.setVelocity(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets both the horizontal and vertical velocity of the physics body.\r\n     *\r\n     * @method Phaser.Physics.Matter.Components.Velocity#setVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal velocity value.\r\n     * @param {number} [y=x] - The vertical velocity value, it can be either positive or negative. If not given, it will be the same as the `x` value.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} This Game Object.\r\n     */\r\n    setVelocity: function (x, y)\r\n    {\r\n        this._tempVec2.set(x, y);\r\n\r\n        Body.setVelocity(this.body, this._tempVec2);\r\n\r\n        return this;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Velocity;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Matter.Components\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Bounce: require('./Bounce'),\r\n    Collision: require('./Collision'),\r\n    Force: require('./Force'),\r\n    Friction: require('./Friction'),\r\n    Gravity: require('./Gravity'),\r\n    Mass: require('./Mass'),\r\n    Sensor: require('./Sensor'),\r\n    SetBody: require('./SetBody'),\r\n    Sleep: require('./Sleep'),\r\n    Static: require('./Static'),\r\n    Transform: require('./Transform'),\r\n    Velocity: require('./Velocity')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.AfterAddEvent\r\n *\r\n * @property {any[]} object - An array of the object(s) that have been added. May be a single body, constraint, composite or a mixture of these.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics After Add Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance at the end of the process when a new Body\r\n * or Constraint has just been added to the world.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('afteradd', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#AFTER_ADD\r\n * @since 3.22.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.AfterAddEvent} event - The Add Event object.\r\n */\r\nmodule.exports = 'afteradd';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.AfterRemoveEvent\r\n *\r\n * @property {any[]} object - An array of the object(s) that were removed. May be a single body, constraint, composite or a mixture of these.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics After Remove Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance at the end of the process when a \r\n * Body or Constraint was removed from the world.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('afterremove', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#AFTER_REMOVE\r\n * @since 3.22.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.AfterRemoveEvent} event - The Remove Event object.\r\n */\r\nmodule.exports = 'afterremove';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.AfterUpdateEvent\r\n *\r\n * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics After Update Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance after the engine has updated and all collision events have resolved.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('afterupdate', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#AFTER_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.AfterUpdateEvent} event - The Update Event object.\r\n */\r\nmodule.exports = 'afterupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.BeforeAddEvent\r\n *\r\n * @property {any[]} object - An array of the object(s) to be added. May be a single body, constraint, composite or a mixture of these.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Before Add Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance at the start of the process when a new Body\r\n * or Constraint is being added to the world.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('beforeadd', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#BEFORE_ADD\r\n * @since 3.22.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.BeforeAddEvent} event - The Add Event object.\r\n */\r\nmodule.exports = 'beforeadd';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.BeforeRemoveEvent\r\n *\r\n * @property {any[]} object - An array of the object(s) to be removed. May be a single body, constraint, composite or a mixture of these.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Before Remove Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance at the start of the process when a \r\n * Body or Constraint is being removed from the world.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('beforeremove', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#BEFORE_REMOVE\r\n * @since 3.22.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.BeforeRemoveEvent} event - The Remove Event object.\r\n */\r\nmodule.exports = 'beforeremove';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.BeforeUpdateEvent\r\n *\r\n * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Before Update Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance right before all the collision processing takes place.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('beforeupdate', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#BEFORE_UPDATE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.BeforeUpdateEvent} event - The Update Event object.\r\n */\r\nmodule.exports = 'beforeupdate';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.CollisionActiveEvent\r\n *\r\n * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.\r\n * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Collision Active Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance after the engine has updated.\r\n * It provides a list of all pairs that are colliding in the current tick (if any).\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('collisionactive', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#COLLISION_ACTIVE\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.CollisionActiveEvent} event - The Collision Event object.\r\n * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n */\r\nmodule.exports = 'collisionactive';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.CollisionEndEvent\r\n *\r\n * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.\r\n * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Collision End Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance after the engine has updated.\r\n * It provides a list of all pairs that have finished colliding in the current tick (if any).\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('collisionend', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#COLLISION_END\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.CollisionEndEvent} event - The Collision Event object.\r\n * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n */\r\nmodule.exports = 'collisionend';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.CollisionStartEvent\r\n *\r\n * @property {Phaser.Types.Physics.Matter.MatterCollisionData[]} pairs - A list of all affected pairs in the collision.\r\n * @property {number} timestamp - The Matter Engine `timing.timestamp` value for the event.\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Collision Start Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance after the engine has updated.\r\n * It provides a list of all pairs that have started to collide in the current tick (if any).\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('collisionstart', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#COLLISION_START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.CollisionStartEvent} event - The Collision Event object.\r\n * @param {MatterJS.BodyType} bodyA - The first body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n * @param {MatterJS.BodyType} bodyB - The second body of the first colliding pair. The `event.pairs` array may contain more colliding bodies.\r\n */\r\nmodule.exports = 'collisionstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Matter Physics Drag End Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance when a Pointer Constraint\r\n * stops dragging a body.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('dragend', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#DRAG_END\r\n * @since 3.16.2\r\n * \r\n * @param {MatterJS.BodyType} body - The Body that has stopped being dragged. This is a Matter Body, not a Phaser Game Object.\r\n * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that was dragging the body.\r\n */\r\nmodule.exports = 'dragend';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Matter Physics Drag Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance when a Pointer Constraint\r\n * is actively dragging a body. It is emitted each time the pointer moves.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('drag', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#DRAG\r\n * @since 3.16.2\r\n * \r\n * @param {MatterJS.BodyType} body - The Body that is being dragged. This is a Matter Body, not a Phaser Game Object.\r\n * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that is dragging the body.\r\n */\r\nmodule.exports = 'drag';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Matter Physics Drag Start Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance when a Pointer Constraint\r\n * starts dragging a body.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('dragstart', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#DRAG_START\r\n * @since 3.16.2\r\n * \r\n * @param {MatterJS.BodyType} body - The Body that has started being dragged. This is a Matter Body, not a Phaser Game Object.\r\n * @param {MatterJS.BodyType} part - The part of the body that was clicked on.\r\n * @param {Phaser.Physics.Matter.PointerConstraint} constraint - The Pointer Constraint that is dragging the body.\r\n */\r\nmodule.exports = 'dragstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Matter Physics World Pause Event.\r\n * \r\n * This event is dispatched by an Matter Physics World instance when it is paused.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('pause', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#PAUSE\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Matter Physics World Resume Event.\r\n * \r\n * This event is dispatched by an Matter Physics World instance when it resumes from a paused state.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('resume', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#RESUME\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.SleepEndEvent\r\n *\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Sleep End Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance when a Body stop sleeping.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('sleepend', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#SLEEP_END\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.SleepEndEvent} event - The Sleep Event object.\r\n * @param {MatterJS.BodyType} body - The body that has stopped sleeping.\r\n */\r\nmodule.exports = 'sleepend';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @typedef {object} Phaser.Physics.Matter.Events.SleepStartEvent\r\n *\r\n * @property {any} source - The source object of the event.\r\n * @property {string} name - The name of the event.\r\n */\r\n\r\n/**\r\n * The Matter Physics Sleep Start Event.\r\n * \r\n * This event is dispatched by a Matter Physics World instance when a Body goes to sleep.\r\n * \r\n * Listen to it from a Scene using: `this.matter.world.on('sleepstart', listener)`.\r\n *\r\n * @event Phaser.Physics.Matter.Events#SLEEP_START\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Physics.Matter.Events.SleepStartEvent} event - The Sleep Event object.\r\n * @param {MatterJS.BodyType} body - The body that has gone to sleep.\r\n */\r\nmodule.exports = 'sleepstart';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Matter.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AFTER_ADD: require('./AFTER_ADD_EVENT'),\r\n    AFTER_REMOVE: require('./AFTER_REMOVE_EVENT'),\r\n    AFTER_UPDATE: require('./AFTER_UPDATE_EVENT'),\r\n    BEFORE_ADD: require('./BEFORE_ADD_EVENT'),\r\n    BEFORE_REMOVE: require('./BEFORE_REMOVE_EVENT'),\r\n    BEFORE_UPDATE: require('./BEFORE_UPDATE_EVENT'),\r\n    COLLISION_ACTIVE: require('./COLLISION_ACTIVE_EVENT'),\r\n    COLLISION_END: require('./COLLISION_END_EVENT'),\r\n    COLLISION_START: require('./COLLISION_START_EVENT'),\r\n    DRAG_END: require('./DRAG_END_EVENT'),\r\n    DRAG: require('./DRAG_EVENT'),\r\n    DRAG_START: require('./DRAG_START_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    SLEEP_END: require('./SLEEP_END_EVENT'),\r\n    SLEEP_START: require('./SLEEP_START_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Physics.Matter\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BodyBounds: require('./BodyBounds'),\r\n    Components: require('./components'),\r\n    Events: require('./events'),\r\n    Factory: require('./Factory'),\r\n    MatterGameObject: require('./MatterGameObject'),\r\n    Image: require('./MatterImage'),\r\n    Matter: require('./CustomMain'),\r\n    MatterPhysics: require('./MatterPhysics'),\r\n    PolyDecomp: require('./poly-decomp'),\r\n    Sprite: require('./MatterSprite'),\r\n    TileBody: require('./MatterTileBody'),\r\n    PhysicsEditorParser: require('./PhysicsEditorParser'),\r\n    PhysicsJSONParser: require('./PhysicsJSONParser'),\r\n    PointerConstraint: require('./PointerConstraint'),\r\n    World: require('./World')\r\n\r\n};\r\n","/**\r\n * The `Matter.Body` module contains methods for creating and manipulating body models.\r\n * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\r\n * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\r\n *\r\n * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n * @class Body\r\n */\r\n\r\nvar Body = {};\r\n\r\nmodule.exports = Body;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Sleeping = require('../core/Sleeping');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Axes = require('../geometry/Axes');\r\n\r\n(function() {\r\n\r\n    Body._inertiaScale = 4;\r\n    Body._nextCollidingGroupId = 1;\r\n    Body._nextNonCollidingGroupId = -1;\r\n    Body._nextCategory = 0x0001;\r\n\r\n    /**\r\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * Vertices must be specified in clockwise order.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {body} body\r\n     */\r\n    Body.create = function(options) {\r\n        var defaults = {\r\n            id: Common.nextId(),\r\n            type: 'body',\r\n            label: 'Body',\r\n            parts: [],\r\n            plugin: {},\r\n            angle: 0,\r\n            vertices: null, // Phaser change: no point calling fromPath if they pass in vertices anyway\r\n            position: { x: 0, y: 0 },\r\n            force: { x: 0, y: 0 },\r\n            torque: 0,\r\n            positionImpulse: { x: 0, y: 0 },\r\n            previousPositionImpulse: { x: 0, y: 0 },\r\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\r\n            totalContacts: 0,\r\n            speed: 0,\r\n            angularSpeed: 0,\r\n            velocity: { x: 0, y: 0 },\r\n            angularVelocity: 0,\r\n            isSensor: false,\r\n            isStatic: false,\r\n            isSleeping: false,\r\n            motion: 0,\r\n            sleepThreshold: 60,\r\n            density: 0.001,\r\n            restitution: 0,\r\n            friction: 0.1,\r\n            frictionStatic: 0.5,\r\n            frictionAir: 0.01,\r\n            collisionFilter: {\r\n                category: 0x0001,\r\n                mask: 0xFFFFFFFF,\r\n                group: 0\r\n            },\r\n            slop: 0.05,\r\n            timeScale: 1,\r\n            events: null,\r\n            bounds: null,\r\n            chamfer: null,\r\n            circleRadius: 0,\r\n            positionPrev: null,\r\n            anglePrev: 0,\r\n            parent: null,\r\n            axes: null,\r\n            area: 0,\r\n            mass: 0,\r\n            inverseMass: 0,\r\n            inertia: 0,\r\n            inverseInertia: 0,\r\n            _original: null,\r\n            render: {\r\n                visible: true,\r\n                opacity: 1,\r\n                sprite: {\r\n                    xOffset: 0,\r\n                    yOffset: 0\r\n                },\r\n                fillColor: null,            // custom Phaser property\r\n                fillOpacity: null,          // custom Phaser property\r\n                lineColor: null,            // custom Phaser property\r\n                lineOpacity: null,          // custom Phaser property\r\n                lineThickness: null         // custom Phaser property\r\n            },\r\n            gameObject: null,               // custom Phaser property\r\n            scale: { x: 1, y: 1 },          // custom Phaser property\r\n            centerOfMass: { x: 0, y: 0 },   // custom Phaser property (float, 0 - 1)\r\n            centerOffset: { x: 0, y: 0 },   // custom Phaser property (pixel values)\r\n            gravityScale: { x: 1, y: 1 },   // custom Phaser property\r\n            ignoreGravity: false,           // custom Phaser property\r\n            ignorePointer: false,           // custom Phaser property\r\n            onCollideCallback: null,        // custom Phaser property\r\n            onCollideEndCallback: null,     // custom Phaser property\r\n            onCollideActiveCallback: null,  // custom Phaser property\r\n            onCollideWith: {}               // custom Phaser property\r\n        };\r\n\r\n        if (!options.hasOwnProperty('position') && options.hasOwnProperty('vertices'))\r\n        {\r\n            options.position = Vertices.centre(options.vertices);\r\n        }\r\n        else if (!options.hasOwnProperty('vertices'))\r\n        {\r\n            defaults.vertices = Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40');\r\n        }\r\n\r\n        var body = Common.extend(defaults, options);\r\n\r\n        _initProperties(body, options);\r\n\r\n        //  Helper function\r\n        body.setOnCollideWith = function (body, callback)\r\n        {\r\n            if (callback)\r\n            {\r\n                this.onCollideWith[body.id] = callback;\r\n            }\r\n            else\r\n            {\r\n                delete this.onCollideWith[body.id];\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        return body;\r\n    };\r\n\r\n    /**\r\n     * Returns the next unique group index for which bodies will collide.\r\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method nextGroup\r\n     * @param {bool} [isNonColliding=false]\r\n     * @return {Number} Unique group index\r\n     */\r\n    Body.nextGroup = function(isNonColliding) {\r\n        if (isNonColliding)\r\n            return Body._nextNonCollidingGroupId--;\r\n\r\n        return Body._nextCollidingGroupId++;\r\n    };\r\n\r\n    /**\r\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\r\n     * There are 32 available. See `body.collisionFilter` for more information.\r\n     * @method nextCategory\r\n     * @return {Number} Unique category bitfield\r\n     */\r\n    Body.nextCategory = function() {\r\n        Body._nextCategory = Body._nextCategory << 1;\r\n        return Body._nextCategory;\r\n    };\r\n\r\n    /**\r\n     * Initialises body properties.\r\n     * @method _initProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @param {} [options]\r\n     */\r\n    var _initProperties = function(body, options) {\r\n        options = options || {};\r\n\r\n        // init required properties (order is important)\r\n        Body.set(body, {\r\n            bounds: body.bounds || Bounds.create(body.vertices),\r\n            positionPrev: body.positionPrev || Vector.clone(body.position),\r\n            anglePrev: body.anglePrev || body.angle,\r\n            vertices: body.vertices,\r\n            parts: body.parts || [body],\r\n            isStatic: body.isStatic,\r\n            isSleeping: body.isSleeping,\r\n            parent: body.parent || body\r\n        });\r\n\r\n        var bounds = body.bounds;\r\n\r\n        Vertices.rotate(body.vertices, body.angle, body.position);\r\n        Axes.rotate(body.axes, body.angle);\r\n        Bounds.update(bounds, body.vertices, body.velocity);\r\n\r\n        // allow options to override the automatically calculated properties\r\n        Body.set(body, {\r\n            axes: options.axes || body.axes,\r\n            area: options.area || body.area,\r\n            mass: options.mass || body.mass,\r\n            inertia: options.inertia || body.inertia\r\n        });\r\n\r\n        if (body.parts.length === 1)\r\n        {\r\n            var centerOfMass = body.centerOfMass;\r\n            var centerOffset = body.centerOffset;\r\n    \r\n            var bodyWidth = bounds.max.x - bounds.min.x;\r\n            var bodyHeight = bounds.max.y - bounds.min.y;\r\n    \r\n            centerOfMass.x = -(bounds.min.x - body.position.x) / bodyWidth;\r\n            centerOfMass.y = -(bounds.min.y - body.position.y) / bodyHeight;\r\n    \r\n            centerOffset.x = bodyWidth * centerOfMass.x;\r\n            centerOffset.y = bodyHeight * centerOfMass.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\r\n     * Prefer to use the actual setter functions in performance critical situations.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {} settings A property name (or map of properties and values) to set on the body.\r\n     * @param {} value The value to set if `settings` is a single property name.\r\n     */\r\n    Body.set = function(body, settings, value) {\r\n        var property;\r\n\r\n        if (typeof settings === 'string') {\r\n            property = settings;\r\n            settings = {};\r\n            settings[property] = value;\r\n        }\r\n\r\n        for (property in settings) {\r\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\r\n                continue;\r\n\r\n            value = settings[property];\r\n            switch (property) {\r\n\r\n            case 'isStatic':\r\n                Body.setStatic(body, value);\r\n                break;\r\n            case 'isSleeping':\r\n                Sleeping.set(body, value);\r\n                break;\r\n            case 'mass':\r\n                Body.setMass(body, value);\r\n                break;\r\n            case 'density':\r\n                Body.setDensity(body, value);\r\n                break;\r\n            case 'inertia':\r\n                Body.setInertia(body, value);\r\n                break;\r\n            case 'vertices':\r\n                Body.setVertices(body, value);\r\n                break;\r\n            case 'position':\r\n                Body.setPosition(body, value);\r\n                break;\r\n            case 'angle':\r\n                Body.setAngle(body, value);\r\n                break;\r\n            case 'velocity':\r\n                Body.setVelocity(body, value);\r\n                break;\r\n            case 'angularVelocity':\r\n                Body.setAngularVelocity(body, value);\r\n                break;\r\n            case 'parts':\r\n                Body.setParts(body, value);\r\n                break;\r\n            case 'centre':\r\n                Body.setCentre(body, value);\r\n                break;\r\n            default:\r\n                body[property] = value;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\r\n     * @method setStatic\r\n     * @param {body} body\r\n     * @param {bool} isStatic\r\n     */\r\n    Body.setStatic = function(body, isStatic) {\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.isStatic = isStatic;\r\n\r\n            if (isStatic) {\r\n                part._original = {\r\n                    restitution: part.restitution,\r\n                    friction: part.friction,\r\n                    mass: part.mass,\r\n                    inertia: part.inertia,\r\n                    density: part.density,\r\n                    inverseMass: part.inverseMass,\r\n                    inverseInertia: part.inverseInertia\r\n                };\r\n\r\n                part.restitution = 0;\r\n                part.friction = 1;\r\n                part.mass = part.inertia = part.density = Infinity;\r\n                part.inverseMass = part.inverseInertia = 0;\r\n\r\n                part.positionPrev.x = part.position.x;\r\n                part.positionPrev.y = part.position.y;\r\n                part.anglePrev = part.angle;\r\n                part.angularVelocity = 0;\r\n                part.speed = 0;\r\n                part.angularSpeed = 0;\r\n                part.motion = 0;\r\n            } else if (part._original) {\r\n                part.restitution = part._original.restitution;\r\n                part.friction = part._original.friction;\r\n                part.mass = part._original.mass;\r\n                part.inertia = part._original.inertia;\r\n                part.density = part._original.density;\r\n                part.inverseMass = part._original.inverseMass;\r\n                part.inverseInertia = part._original.inverseInertia;\r\n\r\n                part._original = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\r\n     * @method setMass\r\n     * @param {body} body\r\n     * @param {number} mass\r\n     */\r\n    Body.setMass = function(body, mass) {\r\n        var moment = body.inertia / (body.mass / 6);\r\n        body.inertia = moment * (mass / 6);\r\n        body.inverseInertia = 1 / body.inertia;\r\n\r\n        body.mass = mass;\r\n        body.inverseMass = 1 / body.mass;\r\n        body.density = body.mass / body.area;\r\n    };\r\n\r\n    /**\r\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\r\n     * @method setDensity\r\n     * @param {body} body\r\n     * @param {number} density\r\n     */\r\n    Body.setDensity = function(body, density) {\r\n        Body.setMass(body, density * body.area);\r\n        body.density = density;\r\n    };\r\n\r\n    /**\r\n     * Sets the moment of inertia (i.e. second moment of area) of the body. \r\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\r\n     * @method setInertia\r\n     * @param {body} body\r\n     * @param {number} inertia\r\n     */\r\n    Body.setInertia = function(body, inertia) {\r\n        body.inertia = inertia;\r\n        body.inverseInertia = 1 / body.inertia;\r\n    };\r\n\r\n    /**\r\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\r\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\r\n     * They are then automatically translated to world space based on `body.position`.\r\n     *\r\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\r\n     * Vertices must form a convex hull, concave hulls are not supported.\r\n     *\r\n     * @method setVertices\r\n     * @param {body} body\r\n     * @param {vector[]} vertices\r\n     */\r\n    Body.setVertices = function(body, vertices) {\r\n        // change vertices\r\n        if (vertices[0].body === body) {\r\n            body.vertices = vertices;\r\n        } else {\r\n            body.vertices = Vertices.create(vertices, body);\r\n        }\r\n\r\n        // update properties\r\n        body.axes = Axes.fromVertices(body.vertices);\r\n        body.area = Vertices.area(body.vertices);\r\n        Body.setMass(body, body.density * body.area);\r\n\r\n        // orient vertices around the centre of mass at origin (0, 0)\r\n        var centre = Vertices.centre(body.vertices);\r\n        Vertices.translate(body.vertices, centre, -1);\r\n\r\n        // update inertia while vertices are at origin (0, 0)\r\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\r\n\r\n        // update geometry\r\n        Vertices.translate(body.vertices, body.position);\r\n\r\n        Bounds.update(body.bounds, body.vertices, body.velocity);\r\n    };\r\n\r\n    /**\r\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\r\n     * Each part will have its parent set to `body`.\r\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\r\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\r\n     * @method setParts\r\n     * @param {body} body\r\n     * @param [body] parts\r\n     * @param {bool} [autoHull=true]\r\n     */\r\n    Body.setParts = function(body, parts, autoHull) {\r\n        var i;\r\n\r\n        // add all the parts, ensuring that the first part is always the parent body\r\n        parts = parts.slice(0);\r\n        body.parts.length = 0;\r\n        body.parts.push(body);\r\n        body.parent = body;\r\n\r\n        for (i = 0; i < parts.length; i++) {\r\n            var part = parts[i];\r\n            if (part !== body) {\r\n                part.parent = body;\r\n                body.parts.push(part);\r\n            }\r\n        }\r\n\r\n        if (body.parts.length === 1)\r\n            return;\r\n\r\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\r\n\r\n        // find the convex hull of all parts to set on the parent body\r\n        if (autoHull) {\r\n            var vertices = [];\r\n            for (i = 0; i < parts.length; i++) {\r\n                vertices = vertices.concat(parts[i].vertices);\r\n            }\r\n\r\n            Vertices.clockwiseSort(vertices);\r\n\r\n            var hull = Vertices.hull(vertices),\r\n                hullCentre = Vertices.centre(hull);\r\n\r\n            Body.setVertices(body, hull);\r\n            Vertices.translate(body.vertices, hullCentre);\r\n        }\r\n\r\n        // sum the properties of all compound parts of the parent body\r\n        var total = Body._totalProperties(body);\r\n\r\n        //  Phaser addition\r\n        var cx = total.centre.x;\r\n        var cy = total.centre.y;\r\n\r\n        var bounds = body.bounds;\r\n        var centerOfMass = body.centerOfMass;\r\n        var centerOffset = body.centerOffset;\r\n\r\n        Bounds.update(bounds, body.vertices, body.velocity);\r\n\r\n        centerOfMass.x = -(bounds.min.x - cx) / (bounds.max.x - bounds.min.x);\r\n        centerOfMass.y = -(bounds.min.y - cy) / (bounds.max.y - bounds.min.y);\r\n\r\n        centerOffset.x = cx;\r\n        centerOffset.y = cy;\r\n\r\n        body.area = total.area;\r\n        body.parent = body;\r\n        body.position.x = cx;\r\n        body.position.y = cy;\r\n        body.positionPrev.x = cx;\r\n        body.positionPrev.y = cy;\r\n\r\n        Body.setMass(body, total.mass);\r\n        Body.setInertia(body, total.inertia);\r\n        Body.setPosition(body, total.centre);\r\n    };\r\n\r\n    /**\r\n     * Set the centre of mass of the body. \r\n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\r\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\r\n     * This is equal to moving `body.position` but not the `body.vertices`.\r\n     * Invalid if the `centre` falls outside the body's convex hull.\r\n     * @method setCentre\r\n     * @param {body} body\r\n     * @param {vector} centre\r\n     * @param {bool} relative\r\n     */\r\n    Body.setCentre = function(body, centre, relative) {\r\n        if (!relative) {\r\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\r\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\r\n            body.position.x = centre.x;\r\n            body.position.y = centre.y;\r\n        } else {\r\n            body.positionPrev.x += centre.x;\r\n            body.positionPrev.y += centre.y;\r\n            body.position.x += centre.x;\r\n            body.position.y += centre.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\r\n     * @method setPosition\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     */\r\n    Body.setPosition = function(body, position) {\r\n        var delta = Vector.sub(position, body.position);\r\n        body.positionPrev.x += delta.x;\r\n        body.positionPrev.y += delta.y;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.position.x += delta.x;\r\n            part.position.y += delta.y;\r\n            Vertices.translate(part.vertices, delta);\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\r\n     * @method setAngle\r\n     * @param {body} body\r\n     * @param {number} angle\r\n     */\r\n    Body.setAngle = function(body, angle) {\r\n        var delta = angle - body.angle;\r\n        body.anglePrev += delta;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n            part.angle += delta;\r\n            Vertices.rotate(part.vertices, delta, body.position);\r\n            Axes.rotate(part.axes, delta);\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n            if (i > 0) {\r\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setVelocity\r\n     * @param {body} body\r\n     * @param {vector} velocity\r\n     */\r\n    Body.setVelocity = function(body, velocity) {\r\n        body.positionPrev.x = body.position.x - velocity.x;\r\n        body.positionPrev.y = body.position.y - velocity.y;\r\n        body.velocity.x = velocity.x;\r\n        body.velocity.y = velocity.y;\r\n        body.speed = Vector.magnitude(body.velocity);\r\n    };\r\n\r\n    /**\r\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\r\n     * @method setAngularVelocity\r\n     * @param {body} body\r\n     * @param {number} velocity\r\n     */\r\n    Body.setAngularVelocity = function(body, velocity) {\r\n        body.anglePrev = body.angle - velocity;\r\n        body.angularVelocity = velocity;\r\n        body.angularSpeed = Math.abs(body.angularVelocity);\r\n    };\r\n\r\n    /**\r\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\r\n     * @method translate\r\n     * @param {body} body\r\n     * @param {vector} translation\r\n     */\r\n    Body.translate = function(body, translation) {\r\n        Body.setPosition(body, Vector.add(body.position, translation));\r\n    };\r\n\r\n    /**\r\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {body} body\r\n     * @param {number} rotation\r\n     * @param {vector} [point]\r\n     */\r\n    Body.rotate = function(body, rotation, point) {\r\n        if (!point) {\r\n            Body.setAngle(body, body.angle + rotation);\r\n        } else {\r\n            var cos = Math.cos(rotation),\r\n                sin = Math.sin(rotation),\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + (dx * cos - dy * sin),\r\n                y: point.y + (dx * sin + dy * cos)\r\n            });\r\n\r\n            Body.setAngle(body, body.angle + rotation);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\r\n     * @method scale\r\n     * @param {body} body\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} [point]\r\n     */\r\n    Body.scale = function(body, scaleX, scaleY, point) {\r\n        var totalArea = 0,\r\n            totalInertia = 0;\r\n\r\n        point = point || body.position;\r\n\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n\r\n            part.scale.x = scaleX;\r\n            part.scale.y = scaleY;\r\n\r\n            // scale vertices\r\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\r\n\r\n            // update properties\r\n            part.axes = Axes.fromVertices(part.vertices);\r\n            part.area = Vertices.area(part.vertices);\r\n            Body.setMass(part, body.density * part.area);\r\n\r\n            // update inertia (requires vertices to be at origin)\r\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\r\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\r\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\r\n\r\n            if (i > 0) {\r\n                totalArea += part.area;\r\n                totalInertia += part.inertia;\r\n            }\r\n\r\n            // scale position\r\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\r\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\r\n\r\n            // update bounds\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n\r\n        // handle parent body\r\n        if (body.parts.length > 1) {\r\n            body.area = totalArea;\r\n\r\n            if (!body.isStatic) {\r\n                Body.setMass(body, body.density * totalArea);\r\n                Body.setInertia(body, totalInertia);\r\n            }\r\n        }\r\n\r\n        // handle circles\r\n        if (body.circleRadius) { \r\n            if (scaleX === scaleY) {\r\n                body.circleRadius *= scaleX;\r\n            } else {\r\n                // body is no longer a circle\r\n                body.circleRadius = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\r\n     * @method update\r\n     * @param {body} body\r\n     * @param {number} deltaTime\r\n     * @param {number} timeScale\r\n     * @param {number} correction\r\n     */\r\n    Body.update = function(body, deltaTime, timeScale, correction) {\r\n        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);\r\n\r\n        // from the previous step\r\n        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\r\n            velocityPrevX = body.position.x - body.positionPrev.x,\r\n            velocityPrevY = body.position.y - body.positionPrev.y;\r\n\r\n        // update velocity with Verlet integration\r\n        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;\r\n        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;\r\n\r\n        body.positionPrev.x = body.position.x;\r\n        body.positionPrev.y = body.position.y;\r\n        body.position.x += body.velocity.x;\r\n        body.position.y += body.velocity.y;\r\n\r\n        // update angular velocity with Verlet integration\r\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\r\n        body.anglePrev = body.angle;\r\n        body.angle += body.angularVelocity;\r\n\r\n        // track speed and acceleration\r\n        body.speed = Vector.magnitude(body.velocity);\r\n        body.angularSpeed = Math.abs(body.angularVelocity);\r\n\r\n        // transform the body geometry\r\n        for (var i = 0; i < body.parts.length; i++) {\r\n            var part = body.parts[i];\r\n\r\n            Vertices.translate(part.vertices, body.velocity);\r\n            \r\n            if (i > 0) {\r\n                part.position.x += body.velocity.x;\r\n                part.position.y += body.velocity.y;\r\n            }\r\n\r\n            if (body.angularVelocity !== 0) {\r\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\r\n                Axes.rotate(part.axes, body.angularVelocity);\r\n                if (i > 0) {\r\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\r\n                }\r\n            }\r\n\r\n            Bounds.update(part.bounds, part.vertices, body.velocity);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applies a force to a body from a given world-space position, including resulting torque.\r\n     * @method applyForce\r\n     * @param {body} body\r\n     * @param {vector} position\r\n     * @param {vector} force\r\n     */\r\n    Body.applyForce = function(body, position, force) {\r\n        body.force.x += force.x;\r\n        body.force.y += force.y;\r\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\r\n        body.torque += offset.x * force.y - offset.y * force.x;\r\n    };\r\n\r\n    /**\r\n     * Returns the sums of the properties of all compound parts of the parent body.\r\n     * @method _totalProperties\r\n     * @private\r\n     * @param {body} body\r\n     * @return {}\r\n     */\r\n    Body._totalProperties = function(body) {\r\n        // from equations at:\r\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\r\n        // http://output.to/sideway/default.asp?qno=121100087\r\n\r\n        var properties = {\r\n            mass: 0,\r\n            area: 0,\r\n            inertia: 0,\r\n            centre: { x: 0, y: 0 }\r\n        };\r\n\r\n        // sum the properties of all compound parts of the parent body\r\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\r\n            var part = body.parts[i],\r\n                mass = part.mass !== Infinity ? part.mass : 1;\r\n\r\n            properties.mass += mass;\r\n            properties.area += part.area;\r\n            properties.inertia += part.inertia;\r\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\r\n        }\r\n\r\n        properties.centre = Vector.div(properties.centre, properties.mass);\r\n\r\n        return properties;\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n    * Fired when a body starts sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepStart\r\n    * @this {body} The body that has started sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a body ends sleeping (where `this` is the body).\r\n    *\r\n    * @event sleepEnd\r\n    * @this {body} The body that has ended sleeping\r\n    * @param {} event An event object\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"body\"\r\n     * @readOnly\r\n     */\r\n\r\n    /**\r\n     * An arbitrary `String` name to help the user identify and manage bodies.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Body\"\r\n     */\r\n\r\n    /**\r\n     * An array of bodies that make up this body. \r\n     * The first body in the array must always be a self reference to the current body instance.\r\n     * All bodies in the `parts` array together form a single rigid compound body.\r\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\r\n     * Parts themselves should never be added to a `World`, only the parent body should be.\r\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\r\n     *\r\n     * @property parts\r\n     * @type body[]\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n    /**\r\n     * A self reference if the body is _not_ a part of another body.\r\n     * Otherwise this is a reference to the body that this is a part of.\r\n     * See `body.parts`.\r\n     *\r\n     * @property parent\r\n     * @type body\r\n     */\r\n\r\n    /**\r\n     * A `Number` specifying the angle of the body, in radians.\r\n     *\r\n     * @property angle\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\r\n     * These should be provided about the origin `(0, 0)`. E.g.\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\r\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \r\n     *\r\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\r\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\r\n     *\r\n     * @property vertices\r\n     * @type vector[]\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the current world-space position of the body.\r\n     *\r\n     * @property position\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that holds the current scale values as set by `Body.setScale`.\r\n     *\r\n     * @property scale\r\n     * @type vector\r\n     * @default { x: 1, y: 1 }\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\r\n     *\r\n     * @property force\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\r\n     *\r\n     * @property torque\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\r\n     *\r\n     * @readOnly\r\n     * @property speed\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\r\n     *\r\n     * @readOnly\r\n     * @property angularSpeed\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property velocity\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \r\n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\r\n     *\r\n     * @readOnly\r\n     * @property angularVelocity\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\r\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\r\n     *\r\n     * @property isStatic\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\r\n     *\r\n     * @property isSensor\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\r\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\r\n     *\r\n     * @property isSleeping\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\r\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\r\n     *\r\n     * @readOnly\r\n     * @property motion\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\r\n     *\r\n     * @property sleepThreshold\r\n     * @type number\r\n     * @default 60\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the density of the body, that is its mass per unit area.\r\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\r\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\r\n     *\r\n     * @property density\r\n     * @type number\r\n     * @default 0.001\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\r\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\r\n     *\r\n     * @property mass\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\r\n     * If you modify this value, you must also modify the `body.mass` property.\r\n     *\r\n     * @property inverseMass\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\r\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\r\n     *\r\n     * @property inertia\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\r\n     * If you modify this value, you must also modify the `body.inertia` property.\r\n     *\r\n     * @property inverseInertia\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \r\n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.max(bodyA.restitution, bodyB.restitution)\r\n     *\r\n     * @property restitution\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\r\n     * A value of `0` means that the body may slide indefinitely.\r\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\r\n     *\r\n     * The effects of the value may be non-linear. \r\n     * High values may be unstable depending on the body.\r\n     * The engine uses a Coulomb friction model including static and kinetic friction.\r\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\r\n     *\r\n     *     Math.min(bodyA.friction, bodyB.friction)\r\n     *\r\n     * @property friction\r\n     * @type number\r\n     * @default 0.1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \r\n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\r\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\r\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\r\n     *\r\n     * @property frictionStatic\r\n     * @type number\r\n     * @default 0.5\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the air friction of the body (air resistance). \r\n     * A value of `0` means the body will never slow as it moves through space.\r\n     * The higher the value, the faster a body slows when moving through space.\r\n     * The effects of the value are non-linear. \r\n     *\r\n     * @property frictionAir\r\n     * @type number\r\n     * @default 0.01\r\n     */\r\n\r\n    /**\r\n     * An `Object` that specifies the collision filtering properties of this body.\r\n     *\r\n     * Collisions between two bodies will obey the following rules:\r\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\r\n     *   they will always collide if the value is positive, and they will never collide\r\n     *   if the value is negative.\r\n     * - If the two bodies have different values of `collisionFilter.group` or if one\r\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\r\n     *\r\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\r\n     * value is used as a bit field and the category should have only one bit set, meaning that\r\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\r\n     * different collision categories available.\r\n     *\r\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\r\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\r\n     *\r\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\r\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\r\n     * are both true.\r\n     *\r\n     * @property collisionFilter\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * An Integer `Number`, that specifies the collision group this body belongs to.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.group\r\n     * @type object\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A bit field that specifies the collision category this body belongs to.\r\n     * The category value should have only one bit set, for example `0x0001`.\r\n     * This means there are up to 32 unique collision categories available.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.category\r\n     * @type object\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * A bit mask that specifies the collision categories this body may collide with.\r\n     * See `body.collisionFilter` for more information.\r\n     *\r\n     * @property collisionFilter.mask\r\n     * @type object\r\n     * @default -1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\r\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\r\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\r\n     *\r\n     * @property slop\r\n     * @type number\r\n     * @default 0.05\r\n     */\r\n\r\n    /**\r\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\r\n     *\r\n     * @property timeScale\r\n     * @type number\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n     *\r\n     * @property render\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates if the body should be rendered.\r\n     *\r\n     * @property render.visible\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n\r\n    /**\r\n     * Sets the opacity to use when rendering.\r\n     *\r\n     * @property render.opacity\r\n     * @type number\r\n     * @default 1\r\n    */\r\n\r\n    /**\r\n     * An `Object` that defines the sprite properties to use when rendering, if any.\r\n     *\r\n     * @property render.sprite\r\n     * @type object\r\n     */\r\n\r\n     /**\r\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\r\n      *\r\n      * @property render.sprite.xOffset\r\n      * @type number\r\n      * @default 0\r\n      */\r\n\r\n     /**\r\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\r\n      *\r\n      * @property render.sprite.yOffset\r\n      * @type number\r\n      * @default 0\r\n      */\r\n\r\n    /**\r\n     * A hex color value that defines the fill color to use when rendering the body.\r\n     *\r\n     * @property render.fillColor\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A value that defines the fill opacity to use when rendering the body.\r\n     *\r\n     * @property render.fillOpacity\r\n     * @type number\r\n     */\r\n\r\n     /**\r\n     * A hex color value that defines the line color to use when rendering the body.\r\n     *\r\n     * @property render.lineColor\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A value that defines the line opacity to use when rendering the body.\r\n     *\r\n     * @property render.lineOpacity\r\n     * @type number\r\n     */\r\n\r\n     /**\r\n     * A `Number` that defines the line width to use when rendering the body outline.\r\n     *\r\n     * @property render.lineThickness\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * An array of unique axis vectors (edge normals) used for collision detection.\r\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\r\n     * They are constantly updated by `Body.update` during the simulation.\r\n     *\r\n     * @property axes\r\n     * @type vector[]\r\n     */\r\n     \r\n    /**\r\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\r\n     *\r\n     * @property area\r\n     * @type string\r\n     * @default \r\n     */\r\n\r\n    /**\r\n     * A `Bounds` object that defines the AABB region for the body.\r\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\r\n     *\r\n     * @property bounds\r\n     * @type bounds\r\n     */\r\n\r\n    /**\r\n     * A reference to the Phaser Game Object this body belongs to, if any.\r\n     *\r\n     * @property gameObject\r\n     * @type Phaser.GameObjects.GameObject\r\n     */\r\n\r\n    /**\r\n     * The center of mass of the Body.\r\n     *\r\n     * @property centerOfMass\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * The center of the body in pixel values.\r\n     * Used by Phaser for texture aligment.\r\n     *\r\n     * @property centerOffset\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * Will this Body ignore World gravity during the Engine update?\r\n     *\r\n     * @property ignoreGravity\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * Scale the influence of World gravity when applied to this body.\r\n     *\r\n     * @property gravityScale\r\n     * @type vector\r\n     * @default { x: 1, y: 1 }\r\n     */\r\n\r\n     /**\r\n     * Will this Body ignore Phaser Pointer input events?\r\n     *\r\n     * @property ignorePointer\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked when this Body starts colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked when this Body stops colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideEndCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A callback that is invoked for the duration that this Body is colliding with any other Body.\r\n     * \r\n     * You can register callbacks by providing a function of type `( pair: Matter.Pair) => void`.\r\n     *\r\n     * @property onCollideActiveCallback\r\n     * @type function\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A collision callback dictionary used by the `Body.setOnCollideWith` function.\r\n     *\r\n     * @property onCollideWith\r\n     * @type object\r\n     * @default null\r\n     */\r\n\r\n})();\r\n","/**\r\n* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.\r\n* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.\r\n* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.\r\n* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composite\r\n*/\r\n\r\nvar Composite = {};\r\n\r\nmodule.exports = Composite;\r\n\r\nvar Events = require('../core/Events');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Body = require('./Body');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properites section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} [options]\r\n     * @return {composite} A new composite\r\n     */\r\n    Composite.create = function(options) {\r\n        return Common.extend({ \r\n            id: Common.nextId(),\r\n            type: 'composite',\r\n            parent: null,\r\n            isModified: false,\r\n            bodies: [], \r\n            constraints: [], \r\n            composites: [],\r\n            label: 'Composite',\r\n            plugin: {}\r\n        }, options);\r\n    };\r\n\r\n    /**\r\n     * Sets the composite's `isModified` flag. \r\n     * If `updateParents` is true, all parents will be set (default: false).\r\n     * If `updateChildren` is true, all children will be set (default: false).\r\n     * @method setModified\r\n     * @param {composite} composite\r\n     * @param {boolean} isModified\r\n     * @param {boolean} [updateParents=false]\r\n     * @param {boolean} [updateChildren=false]\r\n     */\r\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\r\n\r\n        Events.trigger(composite, 'compositeModified', composite);\r\n\r\n        composite.isModified = isModified;\r\n\r\n        if (updateParents && composite.parent) {\r\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\r\n        }\r\n\r\n        if (updateChildren) {\r\n            for(var i = 0; i < composite.composites.length; i++) {\r\n                var childComposite = composite.composites[i];\r\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\r\n     * @method add\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @return {composite} The original composite with the objects added\r\n     */\r\n    Composite.add = function(composite, object) {\r\n        var objects = [].concat(object);\r\n\r\n        Events.trigger(composite, 'beforeAdd', { object: object });\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            var obj = objects[i];\r\n\r\n            switch (obj.type) {\r\n\r\n            case 'body':\r\n                // skip adding compound parts\r\n                if (obj.parent !== obj) {\r\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\r\n                    break;\r\n                }\r\n\r\n                Composite.addBody(composite, obj);\r\n                break;\r\n            case 'constraint':\r\n                Composite.addConstraint(composite, obj);\r\n                break;\r\n            case 'composite':\r\n                Composite.addComposite(composite, obj);\r\n                break;\r\n            case 'mouseConstraint':\r\n                Composite.addConstraint(composite, obj.constraint);\r\n                break;\r\n\r\n            }\r\n        }\r\n\r\n        Events.trigger(composite, 'afterAdd', { object: object });\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\r\n     * Optionally searching its children recursively.\r\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\r\n     * @method remove\r\n     * @param {composite} composite\r\n     * @param {} object\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the objects removed\r\n     */\r\n    Composite.remove = function(composite, object, deep) {\r\n        var objects = [].concat(object);\r\n\r\n        Events.trigger(composite, 'beforeRemove', { object: object });\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            var obj = objects[i];\r\n\r\n            switch (obj.type) {\r\n\r\n            case 'body':\r\n                Composite.removeBody(composite, obj, deep);\r\n                break;\r\n            case 'constraint':\r\n                Composite.removeConstraint(composite, obj, deep);\r\n                break;\r\n            case 'composite':\r\n                Composite.removeComposite(composite, obj, deep);\r\n                break;\r\n            case 'mouseConstraint':\r\n                Composite.removeConstraint(composite, obj.constraint);\r\n                break;\r\n\r\n            }\r\n        }\r\n\r\n        Events.trigger(composite, 'afterRemove', { object: object });\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a composite to the given composite.\r\n     * @private\r\n     * @method addComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @return {composite} The original compositeA with the objects from compositeB added\r\n     */\r\n    Composite.addComposite = function(compositeA, compositeB) {\r\n        compositeA.composites.push(compositeB);\r\n        compositeB.parent = compositeA;\r\n        Composite.setModified(compositeA, true, true, false);\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Removes a composite from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeComposite\r\n     * @param {composite} compositeA\r\n     * @param {composite} compositeB\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original compositeA with the composite removed\r\n     */\r\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\r\n        var position = compositeA.composites.indexOf(compositeB);\r\n        if (position !== -1) {\r\n            Composite.removeCompositeAt(compositeA, position);\r\n            Composite.setModified(compositeA, true, true, false);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < compositeA.composites.length; i++){\r\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\r\n            }\r\n        }\r\n\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Removes a composite from the given composite.\r\n     * @private\r\n     * @method removeCompositeAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the composite removed\r\n     */\r\n    Composite.removeCompositeAt = function(composite, position) {\r\n        composite.composites.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a body to the given composite.\r\n     * @private\r\n     * @method addBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @return {composite} The original composite with the body added\r\n     */\r\n    Composite.addBody = function(composite, body) {\r\n        composite.bodies.push(body);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeBody\r\n     * @param {composite} composite\r\n     * @param {body} body\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the body removed\r\n     */\r\n    Composite.removeBody = function(composite, body, deep) {\r\n        var position = composite.bodies.indexOf(body);\r\n        if (position !== -1) {\r\n            Composite.removeBodyAt(composite, position);\r\n            Composite.setModified(composite, true, true, false);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.removeBody(composite.composites[i], body, true);\r\n            }\r\n        }\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeBodyAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the body removed\r\n     */\r\n    Composite.removeBodyAt = function(composite, position) {\r\n        composite.bodies.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Adds a constraint to the given composite.\r\n     * @private\r\n     * @method addConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @return {composite} The original composite with the constraint added\r\n     */\r\n    Composite.addConstraint = function(composite, constraint) {\r\n        composite.constraints.push(constraint);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\r\n     * @private\r\n     * @method removeConstraint\r\n     * @param {composite} composite\r\n     * @param {constraint} constraint\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original composite with the constraint removed\r\n     */\r\n    Composite.removeConstraint = function(composite, constraint, deep) {\r\n        var position = composite.constraints.indexOf(constraint);\r\n        if (position !== -1) {\r\n            Composite.removeConstraintAt(composite, position);\r\n        }\r\n\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.removeConstraint(composite.composites[i], constraint, true);\r\n            }\r\n        }\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes a body from the given composite.\r\n     * @private\r\n     * @method removeConstraintAt\r\n     * @param {composite} composite\r\n     * @param {number} position\r\n     * @return {composite} The original composite with the constraint removed\r\n     */\r\n    Composite.removeConstraintAt = function(composite, position) {\r\n        composite.constraints.splice(position, 1);\r\n        Composite.setModified(composite, true, true, false);\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Removes all bodies, constraints and composites from the given composite.\r\n     * Optionally clearing its children recursively.\r\n     * @method clear\r\n     * @param {composite} composite\r\n     * @param {boolean} keepStatic\r\n     * @param {boolean} [deep=false]\r\n     */\r\n    Composite.clear = function(composite, keepStatic, deep) {\r\n        if (deep) {\r\n            for (var i = 0; i < composite.composites.length; i++){\r\n                Composite.clear(composite.composites[i], keepStatic, true);\r\n            }\r\n        }\r\n        \r\n        if (keepStatic) {\r\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\r\n        } else {\r\n            composite.bodies.length = 0;\r\n        }\r\n\r\n        composite.constraints.length = 0;\r\n        composite.composites.length = 0;\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\r\n     * @method allBodies\r\n     * @param {composite} composite\r\n     * @return {body[]} All the bodies\r\n     */\r\n    Composite.allBodies = function(composite) {\r\n        var bodies = [].concat(composite.bodies);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\r\n\r\n        return bodies;\r\n    };\r\n\r\n    /**\r\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\r\n     * @method allConstraints\r\n     * @param {composite} composite\r\n     * @return {constraint[]} All the constraints\r\n     */\r\n    Composite.allConstraints = function(composite) {\r\n        var constraints = [].concat(composite.constraints);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\r\n\r\n        return constraints;\r\n    };\r\n\r\n    /**\r\n     * Returns all composites in the given composite, including all composites in its children, recursively.\r\n     * @method allComposites\r\n     * @param {composite} composite\r\n     * @return {composite[]} All the composites\r\n     */\r\n    Composite.allComposites = function(composite) {\r\n        var composites = [].concat(composite.composites);\r\n\r\n        for (var i = 0; i < composite.composites.length; i++)\r\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\r\n\r\n        return composites;\r\n    };\r\n\r\n    /**\r\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\r\n     * @method get\r\n     * @param {composite} composite\r\n     * @param {number} id\r\n     * @param {string} type\r\n     * @return {object} The requested object, if found\r\n     */\r\n    Composite.get = function(composite, id, type) {\r\n        var objects,\r\n            object;\r\n\r\n        switch (type) {\r\n        case 'body':\r\n            objects = Composite.allBodies(composite);\r\n            break;\r\n        case 'constraint':\r\n            objects = Composite.allConstraints(composite);\r\n            break;\r\n        case 'composite':\r\n            objects = Composite.allComposites(composite).concat(composite);\r\n            break;\r\n        }\r\n\r\n        if (!objects)\r\n            return null;\r\n\r\n        object = objects.filter(function(object) { \r\n            return object.id.toString() === id.toString(); \r\n        });\r\n\r\n        return object.length === 0 ? null : object[0];\r\n    };\r\n\r\n    /**\r\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\r\n     * @method move\r\n     * @param {compositeA} compositeA\r\n     * @param {object[]} objects\r\n     * @param {compositeB} compositeB\r\n     * @return {composite} Returns compositeA\r\n     */\r\n    Composite.move = function(compositeA, objects, compositeB) {\r\n        Composite.remove(compositeA, objects);\r\n        Composite.add(compositeB, objects);\r\n        return compositeA;\r\n    };\r\n\r\n    /**\r\n     * Assigns new ids for all objects in the composite, recursively.\r\n     * @method rebase\r\n     * @param {composite} composite\r\n     * @return {composite} Returns composite\r\n     */\r\n    Composite.rebase = function(composite) {\r\n        var objects = Composite.allBodies(composite)\r\n            .concat(Composite.allConstraints(composite))\r\n            .concat(Composite.allComposites(composite));\r\n\r\n        for (var i = 0; i < objects.length; i++) {\r\n            objects[i].id = Common.nextId();\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Translates all children in the composite by a given vector relative to their current positions, \r\n     * without imparting any velocity.\r\n     * @method translate\r\n     * @param {composite} composite\r\n     * @param {vector} translation\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.translate = function(composite, translation, recursive) {\r\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            Body.translate(bodies[i], translation);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\r\n     * @method rotate\r\n     * @param {composite} composite\r\n     * @param {number} rotation\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.rotate = function(composite, rotation, point, recursive) {\r\n        var cos = Math.cos(rotation),\r\n            sin = Math.sin(rotation),\r\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + (dx * cos - dy * sin),\r\n                y: point.y + (dx * sin + dy * cos)\r\n            });\r\n\r\n            Body.rotate(body, rotation);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\r\n     * @method scale\r\n     * @param {composite} composite\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     * @param {bool} [recursive=true]\r\n     */\r\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\r\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                dx = body.position.x - point.x,\r\n                dy = body.position.y - point.y;\r\n                \r\n            Body.setPosition(body, {\r\n                x: point.x + dx * scaleX,\r\n                y: point.y + dy * scaleY\r\n            });\r\n\r\n            Body.scale(body, scaleX, scaleY);\r\n        }\r\n\r\n        Composite.setModified(composite, true, true, false);\r\n\r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Returns the union of the bounds of all of the composite's bodies.\r\n     * @method bounds\r\n     * @param {composite} composite The composite.\r\n     * @returns {bounds} The composite bounds.\r\n     */\r\n    Composite.bounds = function(composite) {\r\n        var bodies = Composite.allBodies(composite),\r\n            vertices = [];\r\n\r\n        for (var i = 0; i < bodies.length; i += 1) {\r\n            var body = bodies[i];\r\n            vertices.push(body.bounds.min, body.bounds.max);\r\n        }\r\n\r\n        return Bounds.create(vertices);\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Events Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.add` is made, before objects have been added.\r\n    *\r\n    * @event beforeAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.add` is made, after objects have been added.\r\n    *\r\n    * @event afterAdd\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\r\n    *\r\n    * @event beforeRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\r\n    *\r\n    * @event afterRemove\r\n    * @param {} event An event object\r\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"composite\"\r\n     * @readOnly\r\n     */\r\n\r\n    /**\r\n     * An arbitrary `String` name to help the user identify and manage composites.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Composite\"\r\n     */\r\n\r\n    /**\r\n     * A flag that specifies whether the composite has been modified during the current step.\r\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\r\n     * If you need to change it manually, you should use the `Composite.setModified` method.\r\n     *\r\n     * @property isModified\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\r\n     *\r\n     * @property parent\r\n     * @type composite\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * An array of `Body` that are _direct_ children of this composite.\r\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\r\n     *\r\n     * @property bodies\r\n     * @type body[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An array of `Constraint` that are _direct_ children of this composite.\r\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\r\n     *\r\n     * @property constraints\r\n     * @type constraint[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An array of `Composite` that are _direct_ children of this composite.\r\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\r\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\r\n     *\r\n     * @property composites\r\n     * @type composite[]\r\n     * @default []\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n})();\r\n","/**\r\n* The `Matter.World` module contains methods for creating and manipulating the world composite.\r\n* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.\r\n* A `Matter.World` has a few additional properties including `gravity` and `bounds`.\r\n* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.\r\n* There are also a few methods here that alias those in `Matter.Composite` for easier readability.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class World\r\n* @extends Composite\r\n*/\r\n\r\nvar World = {};\r\n\r\nmodule.exports = World;\r\n\r\nvar Composite = require('./Composite');\r\nvar Constraint = require('../constraint/Constraint');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @constructor\r\n     * @param {} options\r\n     * @return {world} A new world\r\n     */\r\n    World.create = function(options) {\r\n        var composite = Composite.create();\r\n\r\n        var defaults = {\r\n            label: 'World',\r\n            gravity: {\r\n                x: 0,\r\n                y: 1,\r\n                scale: 0.001\r\n            },\r\n            bounds: { \r\n                min: { x: -Infinity, y: -Infinity }, \r\n                max: { x: Infinity, y: Infinity } \r\n            }\r\n        };\r\n        \r\n        return Common.extend(composite, defaults, options);\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * The gravity to apply on the world.\r\n     *\r\n     * @property gravity\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * The gravity x component.\r\n     *\r\n     * @property gravity.x\r\n     * @type object\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * The gravity y component.\r\n     *\r\n     * @property gravity.y\r\n     * @type object\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * The gravity scale factor.\r\n     *\r\n     * @property gravity.scale\r\n     * @type object\r\n     * @default 0.001\r\n     */\r\n\r\n    /**\r\n     * A `Bounds` object that defines the world bounds for collision detection.\r\n     *\r\n     * @property bounds\r\n     * @type bounds\r\n     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }\r\n     */\r\n\r\n    // World is a Composite body\r\n    // see src/module/Outro.js for these aliases:\r\n    \r\n    /**\r\n     * An alias for Composite.add\r\n     * @method add\r\n     * @param {world} world\r\n     * @param {} object\r\n     * @return {composite} The original world with the objects added\r\n     */\r\n\r\n    /**\r\n     * An alias for Composite.remove\r\n     * @method remove\r\n     * @param {world} world\r\n     * @param {} object\r\n     * @param {boolean} [deep=false]\r\n     * @return {composite} The original world with the objects removed\r\n     */\r\n\r\n    /**\r\n     * An alias for Composite.clear\r\n     * @method clear\r\n     * @param {world} world\r\n     * @param {boolean} keepStatic\r\n     */\r\n\r\n    /**\r\n     * An alias for Composite.addComposite\r\n     * @method addComposite\r\n     * @param {world} world\r\n     * @param {composite} composite\r\n     * @return {world} The original world with the objects from composite added\r\n     */\r\n    \r\n     /**\r\n      * An alias for Composite.addBody\r\n      * @method addBody\r\n      * @param {world} world\r\n      * @param {body} body\r\n      * @return {world} The original world with the body added\r\n      */\r\n\r\n     /**\r\n      * An alias for Composite.addConstraint\r\n      * @method addConstraint\r\n      * @param {world} world\r\n      * @param {constraint} constraint\r\n      * @return {world} The original world with the constraint added\r\n      */\r\n\r\n})();\r\n","/**\r\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\r\n*\r\n* @class Detector\r\n*/\r\n\r\n// TODO: speculative contacts\r\n\r\nvar Detector = {};\r\n\r\nmodule.exports = Detector;\r\n\r\nvar SAT = require('./SAT');\r\nvar Pair = require('./Pair');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Finds all collisions given a list of pairs.\r\n     * @method collisions\r\n     * @param {pair[]} broadphasePairs\r\n     * @param {engine} engine\r\n     * @return {array} collisions\r\n     */\r\n    Detector.collisions = function(broadphasePairs, engine) {\r\n        var collisions = [],\r\n            pairsTable = engine.pairs.table;\r\n\r\n        // @if DEBUG\r\n        var metrics = engine.metrics;\r\n        // @endif\r\n        \r\n        for (var i = 0; i < broadphasePairs.length; i++) {\r\n            var bodyA = broadphasePairs[i][0], \r\n                bodyB = broadphasePairs[i][1];\r\n\r\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\r\n                continue;\r\n            \r\n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\r\n                continue;\r\n\r\n            // @if DEBUG\r\n            metrics.midphaseTests += 1;\r\n            // @endif\r\n\r\n            // mid phase\r\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\r\n                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\r\n                    var partA = bodyA.parts[j];\r\n\r\n                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\r\n                        var partB = bodyB.parts[k];\r\n\r\n                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {\r\n                            // find a previous collision we could reuse\r\n                            var pairId = Pair.id(partA, partB),\r\n                                pair = pairsTable[pairId],\r\n                                previousCollision;\r\n\r\n                            if (pair && pair.isActive) {\r\n                                previousCollision = pair.collision;\r\n                            } else {\r\n                                previousCollision = null;\r\n                            }\r\n\r\n                            // narrow phase\r\n                            var collision = SAT.collides(partA, partB, previousCollision);\r\n\r\n                            // @if DEBUG\r\n                            metrics.narrowphaseTests += 1;\r\n                            if (collision.reused)\r\n                                metrics.narrowReuseCount += 1;\r\n                            // @endif\r\n\r\n                            if (collision.collided) {\r\n                                collisions.push(collision);\r\n                                // @if DEBUG\r\n                                metrics.narrowDetections += 1;\r\n                                // @endif\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\r\n     * See `body.collisionFilter` for more information.\r\n     * @method canCollide\r\n     * @param {} filterA\r\n     * @param {} filterB\r\n     * @return {bool} `true` if collision can occur\r\n     */\r\n    Detector.canCollide = function(filterA, filterB) {\r\n        if (filterA.group === filterB.group && filterA.group !== 0)\r\n            return filterA.group > 0;\r\n\r\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\r\n*\r\n* @class Grid\r\n*/\r\n\r\nvar Grid = {};\r\n\r\nmodule.exports = Grid;\r\n\r\nvar Pair = require('./Pair');\r\nvar Detector = require('./Detector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new grid.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {grid} A new grid\r\n     */\r\n    Grid.create = function(options) {\r\n        var defaults = {\r\n            controller: Grid,\r\n            detector: Detector.collisions,\r\n            buckets: {},\r\n            pairs: {},\r\n            pairsList: [],\r\n            bucketWidth: 48,\r\n            bucketHeight: 48\r\n        };\r\n\r\n        return Common.extend(defaults, options);\r\n    };\r\n\r\n    /**\r\n     * The width of a single grid bucket.\r\n     *\r\n     * @property bucketWidth\r\n     * @type number\r\n     * @default 48\r\n     */\r\n\r\n    /**\r\n     * The height of a single grid bucket.\r\n     *\r\n     * @property bucketHeight\r\n     * @type number\r\n     * @default 48\r\n     */\r\n\r\n    /**\r\n     * Updates the grid.\r\n     * @method update\r\n     * @param {grid} grid\r\n     * @param {body[]} bodies\r\n     * @param {engine} engine\r\n     * @param {boolean} forceUpdate\r\n     */\r\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\r\n        var i, col, row,\r\n            world = engine.world,\r\n            buckets = grid.buckets,\r\n            bucket,\r\n            bucketId,\r\n            gridChanged = false;\r\n\r\n        // @if DEBUG\r\n        var metrics = engine.metrics;\r\n        metrics.broadphaseTests = 0;\r\n        // @endif\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.isSleeping && !forceUpdate)\r\n                continue;\r\n\r\n            // don't update out of world bodies\r\n            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\r\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)\r\n                continue;\r\n\r\n            var newRegion = Grid._getRegion(grid, body);\r\n\r\n            // if the body has changed grid region\r\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\r\n\r\n                // @if DEBUG\r\n                metrics.broadphaseTests += 1;\r\n                // @endif\r\n\r\n                if (!body.region || forceUpdate)\r\n                    body.region = newRegion;\r\n\r\n                var union = Grid._regionUnion(newRegion, body.region);\r\n\r\n                // update grid buckets affected by region change\r\n                // iterate over the union of both regions\r\n                for (col = union.startCol; col <= union.endCol; col++) {\r\n                    for (row = union.startRow; row <= union.endRow; row++) {\r\n                        bucketId = Grid._getBucketId(col, row);\r\n                        bucket = buckets[bucketId];\r\n\r\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\r\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\r\n\r\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\r\n                                                && row >= body.region.startRow && row <= body.region.endRow);\r\n\r\n                        // remove from old region buckets\r\n                        if (!isInsideNewRegion && isInsideOldRegion) {\r\n                            if (isInsideOldRegion) {\r\n                                if (bucket)\r\n                                    Grid._bucketRemoveBody(grid, bucket, body);\r\n                            }\r\n                        }\r\n\r\n                        // add to new region buckets\r\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\r\n                            if (!bucket)\r\n                                bucket = Grid._createBucket(buckets, bucketId);\r\n                            Grid._bucketAddBody(grid, bucket, body);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // set the new region\r\n                body.region = newRegion;\r\n\r\n                // flag changes so we can update pairs\r\n                gridChanged = true;\r\n            }\r\n        }\r\n\r\n        // update pairs list only if pairs changed (i.e. a body changed region)\r\n        if (gridChanged)\r\n            grid.pairsList = Grid._createActivePairsList(grid);\r\n    };\r\n\r\n    /**\r\n     * Clears the grid.\r\n     * @method clear\r\n     * @param {grid} grid\r\n     */\r\n    Grid.clear = function(grid) {\r\n        grid.buckets = {};\r\n        grid.pairs = {};\r\n        grid.pairsList = [];\r\n    };\r\n\r\n    /**\r\n     * Finds the union of two regions.\r\n     * @method _regionUnion\r\n     * @private\r\n     * @param {} regionA\r\n     * @param {} regionB\r\n     * @return {} region\r\n     */\r\n    Grid._regionUnion = function(regionA, regionB) {\r\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\r\n            endCol = Math.max(regionA.endCol, regionB.endCol),\r\n            startRow = Math.min(regionA.startRow, regionB.startRow),\r\n            endRow = Math.max(regionA.endRow, regionB.endRow);\r\n\r\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\r\n    };\r\n\r\n    /**\r\n     * Gets the region a given body falls in for a given grid.\r\n     * @method _getRegion\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} body\r\n     * @return {} region\r\n     */\r\n    Grid._getRegion = function(grid, body) {\r\n        var bounds = body.bounds,\r\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\r\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\r\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\r\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\r\n\r\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\r\n    };\r\n\r\n    /**\r\n     * Creates a region.\r\n     * @method _createRegion\r\n     * @private\r\n     * @param {} startCol\r\n     * @param {} endCol\r\n     * @param {} startRow\r\n     * @param {} endRow\r\n     * @return {} region\r\n     */\r\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\r\n        return { \r\n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\r\n            startCol: startCol, \r\n            endCol: endCol, \r\n            startRow: startRow, \r\n            endRow: endRow \r\n        };\r\n    };\r\n\r\n    /**\r\n     * Gets the bucket id at the given position.\r\n     * @method _getBucketId\r\n     * @private\r\n     * @param {} column\r\n     * @param {} row\r\n     * @return {string} bucket id\r\n     */\r\n    Grid._getBucketId = function(column, row) {\r\n        return 'C' + column + 'R' + row;\r\n    };\r\n\r\n    /**\r\n     * Creates a bucket.\r\n     * @method _createBucket\r\n     * @private\r\n     * @param {} buckets\r\n     * @param {} bucketId\r\n     * @return {} bucket\r\n     */\r\n    Grid._createBucket = function(buckets, bucketId) {\r\n        var bucket = buckets[bucketId] = [];\r\n        return bucket;\r\n    };\r\n\r\n    /**\r\n     * Adds a body to a bucket.\r\n     * @method _bucketAddBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */\r\n    Grid._bucketAddBody = function(grid, bucket, body) {\r\n        // add new pairs\r\n        for (var i = 0; i < bucket.length; i++) {\r\n            var bodyB = bucket[i];\r\n\r\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\r\n                continue;\r\n\r\n            // keep track of the number of buckets the pair exists in\r\n            // important for Grid.update to work\r\n            var pairId = Pair.id(body, bodyB),\r\n                pair = grid.pairs[pairId];\r\n\r\n            if (pair) {\r\n                pair[2] += 1;\r\n            } else {\r\n                grid.pairs[pairId] = [body, bodyB, 1];\r\n            }\r\n        }\r\n\r\n        // add to bodies (after pairs, otherwise pairs with self)\r\n        bucket.push(body);\r\n    };\r\n\r\n    /**\r\n     * Removes a body from a bucket.\r\n     * @method _bucketRemoveBody\r\n     * @private\r\n     * @param {} grid\r\n     * @param {} bucket\r\n     * @param {} body\r\n     */\r\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\r\n        // remove from bucket\r\n        bucket.splice(bucket.indexOf(body), 1);\r\n\r\n        // update pair counts\r\n        for (var i = 0; i < bucket.length; i++) {\r\n            // keep track of the number of buckets the pair exists in\r\n            // important for _createActivePairsList to work\r\n            var bodyB = bucket[i],\r\n                pairId = Pair.id(body, bodyB),\r\n                pair = grid.pairs[pairId];\r\n\r\n            if (pair)\r\n                pair[2] -= 1;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Generates a list of the active pairs in the grid.\r\n     * @method _createActivePairsList\r\n     * @private\r\n     * @param {} grid\r\n     * @return [] pairs\r\n     */\r\n    Grid._createActivePairsList = function(grid) {\r\n        var pairKeys,\r\n            pair,\r\n            pairs = [];\r\n\r\n        // grid.pairs is used as a hashmap\r\n        pairKeys = Common.keys(grid.pairs);\r\n\r\n        // iterate over grid.pairs\r\n        for (var k = 0; k < pairKeys.length; k++) {\r\n            pair = grid.pairs[pairKeys[k]];\r\n\r\n            // if pair exists in at least one bucket\r\n            // it is a pair that needs further collision testing so push it\r\n            if (pair[2] > 0) {\r\n                pairs.push(pair);\r\n            } else {\r\n                delete grid.pairs[pairKeys[k]];\r\n            }\r\n        }\r\n\r\n        return pairs;\r\n    };\r\n    \r\n})();\r\n","/**\r\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\r\n*\r\n* @class Pair\r\n*/\r\n\r\nvar Pair = {};\r\n\r\nmodule.exports = Pair;\r\n\r\n(function() {\r\n    \r\n    /**\r\n     * Creates a pair.\r\n     * @method create\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     * @return {pair} A new pair\r\n     */\r\n    Pair.create = function(collision, timestamp) {\r\n        var bodyA = collision.bodyA,\r\n            bodyB = collision.bodyB;\r\n\r\n        var pair = {\r\n            id: Pair.id(bodyA, bodyB),\r\n            bodyA: bodyA,\r\n            bodyB: bodyB,\r\n            activeContacts: [],\r\n            separation: 0,\r\n            isActive: true,\r\n            confirmedActive: true,\r\n            isSensor: bodyA.isSensor || bodyB.isSensor,\r\n            timeCreated: timestamp,\r\n            timeUpdated: timestamp,\r\n            collision: null,\r\n            inverseMass: 0,\r\n            friction: 0,\r\n            frictionStatic: 0,\r\n            restitution: 0,\r\n            slop: 0\r\n        };\r\n\r\n        Pair.update(pair, collision, timestamp);\r\n\r\n        return pair;\r\n    };\r\n\r\n    /**\r\n     * Updates a pair given a collision.\r\n     * @method update\r\n     * @param {pair} pair\r\n     * @param {collision} collision\r\n     * @param {number} timestamp\r\n     */\r\n    Pair.update = function(pair, collision, timestamp) {\r\n        pair.collision = collision;\r\n\r\n        if (collision.collided) {\r\n            var supports = collision.supports,\r\n                activeContacts = pair.activeContacts,\r\n                parentA = collision.parentA,\r\n                parentB = collision.parentB;\r\n\r\n            pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\r\n            pair.friction = Math.min(parentA.friction, parentB.friction);\r\n            pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\r\n            pair.restitution = Math.max(parentA.restitution, parentB.restitution);\r\n            pair.slop = Math.max(parentA.slop, parentB.slop);\r\n\r\n            for (var i = 0; i < supports.length; i++) {\r\n                activeContacts[i] = supports[i].contact;\r\n            }\r\n\r\n            // optimise array size\r\n            var supportCount = supports.length;\r\n            if (supportCount < activeContacts.length) {\r\n                activeContacts.length = supportCount;\r\n            }\r\n\r\n            pair.separation = collision.depth;\r\n            Pair.setActive(pair, true, timestamp);\r\n        } else {\r\n            if (pair.isActive === true)\r\n                Pair.setActive(pair, false, timestamp);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Set a pair as active or inactive.\r\n     * @method setActive\r\n     * @param {pair} pair\r\n     * @param {bool} isActive\r\n     * @param {number} timestamp\r\n     */\r\n    Pair.setActive = function(pair, isActive, timestamp) {\r\n        if (isActive) {\r\n            pair.isActive = true;\r\n            pair.timeUpdated = timestamp;\r\n        } else {\r\n            pair.isActive = false;\r\n            pair.activeContacts.length = 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the id for the given pair.\r\n     * @method id\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @return {string} Unique pairId\r\n     */\r\n    Pair.id = function(bodyA, bodyB) {\r\n        if (bodyA.id < bodyB.id) {\r\n            return 'A' + bodyA.id + 'B' + bodyB.id;\r\n        } else {\r\n            return 'A' + bodyB.id + 'B' + bodyA.id;\r\n        }\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\r\n*\r\n* @class Pairs\r\n*/\r\n\r\nvar Pairs = {};\r\n\r\nmodule.exports = Pairs;\r\n\r\nvar Pair = require('./Pair');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n    \r\n    Pairs._pairMaxIdleLife = 1000;\r\n\r\n    /**\r\n     * Creates a new pairs structure.\r\n     * @method create\r\n     * @param {object} options\r\n     * @return {pairs} A new pairs structure\r\n     */\r\n    Pairs.create = function(options) {\r\n        return Common.extend({ \r\n            table: {},\r\n            list: [],\r\n            collisionStart: [],\r\n            collisionActive: [],\r\n            collisionEnd: []\r\n        }, options);\r\n    };\r\n\r\n    /**\r\n     * Updates pairs given a list of collisions.\r\n     * @method update\r\n     * @param {object} pairs\r\n     * @param {collision[]} collisions\r\n     * @param {number} timestamp\r\n     */\r\n    Pairs.update = function(pairs, collisions, timestamp) {\r\n        var pairsList = pairs.list,\r\n            pairsTable = pairs.table,\r\n            collisionStart = pairs.collisionStart,\r\n            collisionEnd = pairs.collisionEnd,\r\n            collisionActive = pairs.collisionActive,\r\n            collision,\r\n            pairId,\r\n            pair,\r\n            i;\r\n\r\n        // clear collision state arrays, but maintain old reference\r\n        collisionStart.length = 0;\r\n        collisionEnd.length = 0;\r\n        collisionActive.length = 0;\r\n\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pairsList[i].confirmedActive = false;\r\n        }\r\n\r\n        for (i = 0; i < collisions.length; i++) {\r\n            collision = collisions[i];\r\n\r\n            if (collision.collided) {\r\n                pairId = Pair.id(collision.bodyA, collision.bodyB);\r\n\r\n                pair = pairsTable[pairId];\r\n                \r\n                if (pair) {\r\n                    // pair already exists (but may or may not be active)\r\n                    if (pair.isActive) {\r\n                        // pair exists and is active\r\n                        collisionActive.push(pair);\r\n                    } else {\r\n                        // pair exists but was inactive, so a collision has just started again\r\n                        collisionStart.push(pair);\r\n                    }\r\n\r\n                    // update the pair\r\n                    Pair.update(pair, collision, timestamp);\r\n                    pair.confirmedActive = true;\r\n                } else {\r\n                    // pair did not exist, create a new pair\r\n                    pair = Pair.create(collision, timestamp);\r\n                    pairsTable[pairId] = pair;\r\n\r\n                    // push the new pair\r\n                    collisionStart.push(pair);\r\n                    pairsList.push(pair);\r\n                }\r\n            }\r\n        }\r\n\r\n        // deactivate previously active pairs that are now inactive\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pair = pairsList[i];\r\n            if (pair.isActive && !pair.confirmedActive) {\r\n                Pair.setActive(pair, false, timestamp);\r\n                collisionEnd.push(pair);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Finds and removes pairs that have been inactive for a set amount of time.\r\n     * @method removeOld\r\n     * @param {object} pairs\r\n     * @param {number} timestamp\r\n     */\r\n    Pairs.removeOld = function(pairs, timestamp) {\r\n        var pairsList = pairs.list,\r\n            pairsTable = pairs.table,\r\n            indexesToRemove = [],\r\n            pair,\r\n            collision,\r\n            pairIndex,\r\n            i;\r\n\r\n        for (i = 0; i < pairsList.length; i++) {\r\n            pair = pairsList[i];\r\n            collision = pair.collision;\r\n            \r\n            // never remove sleeping pairs\r\n            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\r\n                pair.timeUpdated = timestamp;\r\n                continue;\r\n            }\r\n\r\n            // if pair is inactive for too long, mark it to be removed\r\n            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {\r\n                indexesToRemove.push(i);\r\n            }\r\n        }\r\n\r\n        // remove marked pairs\r\n        for (i = 0; i < indexesToRemove.length; i++) {\r\n            pairIndex = indexesToRemove[i] - i;\r\n            pair = pairsList[pairIndex];\r\n            delete pairsTable[pair.id];\r\n            pairsList.splice(pairIndex, 1);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Clears the given pairs structure.\r\n     * @method clear\r\n     * @param {pairs} pairs\r\n     * @return {pairs} pairs\r\n     */\r\n    Pairs.clear = function(pairs) {\r\n        pairs.table = {};\r\n        pairs.list.length = 0;\r\n        pairs.collisionStart.length = 0;\r\n        pairs.collisionActive.length = 0;\r\n        pairs.collisionEnd.length = 0;\r\n        return pairs;\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Query` module contains methods for performing collision queries.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Query\r\n*/\r\n\r\nvar Query = {};\r\n\r\nmodule.exports = Query;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar SAT = require('./SAT');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Bodies = require('../factory/Bodies');\r\nvar Vertices = require('../geometry/Vertices');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Returns a list of collisions between `body` and `bodies`.\r\n     * @method collides\r\n     * @param {body} body\r\n     * @param {body[]} bodies\r\n     * @return {object[]} Collisions\r\n     */\r\n    Query.collides = function(body, bodies) {\r\n        var collisions = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var bodyA = bodies[i];\r\n\r\n            //  Phaser addition - skip same body checks\r\n            if (body === bodyA)\r\n            {\r\n                continue;\r\n            }\r\n            \r\n            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\r\n                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\r\n                    var part = bodyA.parts[j];\r\n\r\n                    if (Bounds.overlaps(part.bounds, body.bounds)) {\r\n                        var collision = SAT.collides(part, body);\r\n\r\n                        if (collision.collided) {\r\n                            collisions.push(collision);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\r\n     * @method ray\r\n     * @param {body[]} bodies\r\n     * @param {vector} startPoint\r\n     * @param {vector} endPoint\r\n     * @param {number} [rayWidth]\r\n     * @return {object[]} Collisions\r\n     */\r\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\r\n        rayWidth = rayWidth || 1e-100;\r\n\r\n        var rayAngle = Vector.angle(startPoint, endPoint),\r\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\r\n            rayX = (endPoint.x + startPoint.x) * 0.5,\r\n            rayY = (endPoint.y + startPoint.y) * 0.5,\r\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\r\n            collisions = Query.collides(ray, bodies);\r\n\r\n        for (var i = 0; i < collisions.length; i += 1) {\r\n            var collision = collisions[i];\r\n            collision.body = collision.bodyB = collision.bodyA;            \r\n        }\r\n\r\n        return collisions;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\r\n     * @method region\r\n     * @param {body[]} bodies\r\n     * @param {bounds} bounds\r\n     * @param {bool} [outside=false]\r\n     * @return {body[]} The bodies matching the query\r\n     */\r\n    Query.region = function(bodies, bounds, outside) {\r\n        var result = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                overlaps = Bounds.overlaps(body.bounds, bounds);\r\n            if ((overlaps && !outside) || (!overlaps && outside))\r\n                result.push(body);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\r\n     * @method point\r\n     * @param {body[]} bodies\r\n     * @param {vector} point\r\n     * @return {body[]} The bodies matching the query\r\n     */\r\n    Query.point = function(bodies, point) {\r\n        var result = [];\r\n\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n            \r\n            if (Bounds.contains(body.bounds, point)) {\r\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\r\n                    var part = body.parts[j];\r\n\r\n                    if (Bounds.contains(part.bounds, point)\r\n                        && Vertices.contains(part.vertices, point)) {\r\n                        result.push(body);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\r\n*\r\n* @class Resolver\r\n*/\r\n\r\nvar Resolver = {};\r\n\r\nmodule.exports = Resolver;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\nvar Bounds = require('../geometry/Bounds');\r\n\r\n(function() {\r\n\r\n    Resolver._restingThresh = 4;\r\n    Resolver._restingThreshTangent = 6;\r\n    Resolver._positionDampen = 0.9;\r\n    Resolver._positionWarming = 0.8;\r\n    Resolver._frictionNormalMultiplier = 5;\r\n\r\n    /**\r\n     * Prepare pairs for position solving.\r\n     * @method preSolvePosition\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolvePosition = function(pairs) {\r\n        var i,\r\n            pair,\r\n            activeCount;\r\n\r\n        // find total contacts on each body\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive)\r\n                continue;\r\n            \r\n            activeCount = pair.activeContacts.length;\r\n            pair.collision.parentA.totalContacts += activeCount;\r\n            pair.collision.parentB.totalContacts += activeCount;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair positions.\r\n     * @method solvePosition\r\n     * @param {pair[]} pairs\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solvePosition = function(pairs, bodies, timeScale) {\r\n        var i,\r\n            normalX,\r\n            normalY,\r\n            pair,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            separation,\r\n            penetration,\r\n            positionImpulseA,\r\n            positionImpulseB,\r\n            contactShare,\r\n            bodyBtoAX,\r\n            bodyBtoAY,\r\n            positionImpulse,\r\n            impulseCoefficient = timeScale * Resolver._positionDampen;\r\n\r\n        for (i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n            body.previousPositionImpulse.x = body.positionImpulse.x;\r\n            body.previousPositionImpulse.y = body.positionImpulse.y;\r\n        }\r\n\r\n        // find impulses required to resolve penetration\r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n\r\n            positionImpulseA = bodyA.previousPositionImpulse;\r\n            positionImpulseB = bodyB.previousPositionImpulse;\r\n\r\n            penetration = collision.penetration;\r\n\r\n            bodyBtoAX = positionImpulseB.x - positionImpulseA.x + penetration.x;\r\n            bodyBtoAY = positionImpulseB.y - positionImpulseA.y + penetration.y;\r\n\r\n            normalX = normal.x;\r\n            normalY = normal.y;\r\n\r\n            separation = normalX * bodyBtoAX + normalY * bodyBtoAY;\r\n            pair.separation = separation;\r\n\r\n            positionImpulse = (separation - pair.slop) * impulseCoefficient;\r\n\r\n            if (bodyA.isStatic || bodyB.isStatic)\r\n                positionImpulse *= 2;\r\n            \r\n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                contactShare = positionImpulse / bodyA.totalContacts;\r\n                bodyA.positionImpulse.x += normalX * contactShare;\r\n                bodyA.positionImpulse.y += normalY * contactShare;\r\n            }\r\n\r\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                contactShare = positionImpulse / bodyB.totalContacts;\r\n                bodyB.positionImpulse.x -= normalX * contactShare;\r\n                bodyB.positionImpulse.y -= normalY * contactShare;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Apply position resolution.\r\n     * @method postSolvePosition\r\n     * @param {body[]} bodies\r\n     */\r\n    Resolver.postSolvePosition = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            // reset contact count\r\n            body.totalContacts = 0;\r\n\r\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\r\n                // update body geometry\r\n                for (var j = 0; j < body.parts.length; j++) {\r\n                    var part = body.parts[j];\r\n                    Vertices.translate(part.vertices, body.positionImpulse);\r\n                    Bounds.update(part.bounds, part.vertices, body.velocity);\r\n                    part.position.x += body.positionImpulse.x;\r\n                    part.position.y += body.positionImpulse.y;\r\n                }\r\n\r\n                // move the body without changing velocity\r\n                body.positionPrev.x += body.positionImpulse.x;\r\n                body.positionPrev.y += body.positionImpulse.y;\r\n\r\n                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\r\n                    // reset cached impulse if the body has velocity along it\r\n                    body.positionImpulse.x = 0;\r\n                    body.positionImpulse.y = 0;\r\n                } else {\r\n                    // warm the next iteration\r\n                    body.positionImpulse.x *= Resolver._positionWarming;\r\n                    body.positionImpulse.y *= Resolver._positionWarming;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Prepare pairs for velocity solving.\r\n     * @method preSolveVelocity\r\n     * @param {pair[]} pairs\r\n     */\r\n    Resolver.preSolveVelocity = function(pairs) {\r\n        var i,\r\n            j,\r\n            pair,\r\n            contacts,\r\n            collision,\r\n            bodyA,\r\n            bodyB,\r\n            normal,\r\n            tangent,\r\n            contact,\r\n            contactVertex,\r\n            normalImpulse,\r\n            tangentImpulse,\r\n            offset,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1];\r\n        \r\n        for (i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            contacts = pair.activeContacts;\r\n            collision = pair.collision;\r\n            bodyA = collision.parentA;\r\n            bodyB = collision.parentB;\r\n            normal = collision.normal;\r\n            tangent = collision.tangent;\r\n\r\n            // resolve each contact\r\n            for (j = 0; j < contacts.length; j++) {\r\n                contact = contacts[j];\r\n                contactVertex = contact.vertex;\r\n                normalImpulse = contact.normalImpulse;\r\n                tangentImpulse = contact.tangentImpulse;\r\n\r\n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\r\n                    // total impulse from contact\r\n                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                    \r\n                    // apply impulse from contact\r\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyA.position, tempA);\r\n                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\r\n                    }\r\n\r\n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                        offset = Vector.sub(contactVertex, bodyB.position, tempA);\r\n                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find a solution for pair velocities.\r\n     * @method solveVelocity\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Resolver.solveVelocity = function(pairs, timeScale) {\r\n        var timeScaleSquared = timeScale * timeScale,\r\n            impulse = Vector._temp[0],\r\n            tempA = Vector._temp[1],\r\n            tempB = Vector._temp[2],\r\n            tempC = Vector._temp[3],\r\n            tempD = Vector._temp[4],\r\n            tempE = Vector._temp[5];\r\n        \r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            if (!pair.isActive || pair.isSensor)\r\n                continue;\r\n            \r\n            var collision = pair.collision,\r\n                bodyA = collision.parentA,\r\n                bodyB = collision.parentB,\r\n                normal = collision.normal,\r\n                tangent = collision.tangent,\r\n                contacts = pair.activeContacts,\r\n                contactShare = 1 / contacts.length;\r\n\r\n            // update body velocities\r\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\r\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\r\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\r\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\r\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\r\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\r\n\r\n            // resolve each contact\r\n            for (var j = 0; j < contacts.length; j++) {\r\n                var contact = contacts[j],\r\n                    contactVertex = contact.vertex,\r\n                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\r\n                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\r\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\r\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), \r\n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\r\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\r\n\r\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\r\n                    tangentSpeed = Math.abs(tangentVelocity),\r\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\r\n\r\n                // raw impulses\r\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\r\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;\r\n\r\n                // coulomb friction\r\n                var tangentImpulse = tangentVelocity,\r\n                    maxFriction = Infinity;\r\n\r\n                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\r\n                    maxFriction = tangentSpeed;\r\n                    tangentImpulse = Common.clamp(\r\n                        pair.friction * tangentVelocityDirection * timeScaleSquared,\r\n                        -maxFriction, maxFriction\r\n                    );\r\n                }\r\n\r\n                // modify impulses accounting for mass, inertia and offset\r\n                var oAcN = Vector.cross(offsetA, normal),\r\n                    oBcN = Vector.cross(offsetB, normal),\r\n                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\r\n\r\n                normalImpulse *= share;\r\n                tangentImpulse *= share;\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\r\n                    // high normal velocity so clear cached contact normal impulse\r\n                    contact.normalImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // impulse constraint tends to 0\r\n                    var contactNormalImpulse = contact.normalImpulse;\r\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\r\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\r\n                }\r\n\r\n                // handle high velocity and resting collisions separately\r\n                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\r\n                    // high tangent velocity so clear cached contact tangent impulse\r\n                    contact.tangentImpulse = 0;\r\n                } else {\r\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\r\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\r\n                    var contactTangentImpulse = contact.tangentImpulse;\r\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\r\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\r\n                }\r\n\r\n                // total impulse from contact\r\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\r\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\r\n                \r\n                // apply impulse from contact\r\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\r\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\r\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\r\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\r\n                }\r\n\r\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\r\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\r\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\r\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\r\n*\r\n* @class SAT\r\n*/\r\n\r\n// TODO: true circles and curves\r\n\r\nvar SAT = {};\r\n\r\nmodule.exports = SAT;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Detect collision between two bodies using the Separating Axis Theorem.\r\n     * @method collides\r\n     * @param {body} bodyA\r\n     * @param {body} bodyB\r\n     * @param {collision} previousCollision\r\n     * @return {collision} collision\r\n     */\r\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\r\n        var overlapAB,\r\n            overlapBA, \r\n            minOverlap,\r\n            collision,\r\n            canReusePrevCol = false;\r\n\r\n        if (previousCollision) {\r\n            // estimate total motion\r\n            var parentA = bodyA.parent,\r\n                parentB = bodyB.parent,\r\n                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed\r\n                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;\r\n\r\n            // we may be able to (partially) reuse collision result \r\n            // but only safe if collision was resting\r\n            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;\r\n\r\n            // reuse collision object\r\n            collision = previousCollision;\r\n        } else {\r\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\r\n        }\r\n\r\n        if (previousCollision && canReusePrevCol) {\r\n            // if we can reuse the collision result\r\n            // we only need to test the previously found axis\r\n            var axisBodyA = collision.axisBody,\r\n                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\r\n                axes = [axisBodyA.axes[previousCollision.axisNumber]];\r\n\r\n            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\r\n            collision.reused = true;\r\n\r\n            if (minOverlap.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n        } else {\r\n            // if we can't reuse a result, perform a full SAT test\r\n\r\n            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\r\n\r\n            if (overlapAB.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\r\n\r\n            if (overlapBA.overlap <= 0) {\r\n                collision.collided = false;\r\n                return collision;\r\n            }\r\n\r\n            if (overlapAB.overlap < overlapBA.overlap) {\r\n                minOverlap = overlapAB;\r\n                collision.axisBody = bodyA;\r\n            } else {\r\n                minOverlap = overlapBA;\r\n                collision.axisBody = bodyB;\r\n            }\r\n\r\n            // important for reuse later\r\n            collision.axisNumber = minOverlap.axisNumber;\r\n        }\r\n\r\n        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\r\n        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\r\n        collision.collided = true;\r\n        collision.depth = minOverlap.overlap;\r\n        collision.parentA = collision.bodyA.parent;\r\n        collision.parentB = collision.bodyB.parent;\r\n        \r\n        bodyA = collision.bodyA;\r\n        bodyB = collision.bodyB;\r\n\r\n        // ensure normal is facing away from bodyA\r\n        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\r\n            collision.normal = {\r\n                x: minOverlap.axis.x,\r\n                y: minOverlap.axis.y\r\n            };\r\n        } else {\r\n            collision.normal = {\r\n                x: -minOverlap.axis.x,\r\n                y: -minOverlap.axis.y\r\n            };\r\n        }\r\n\r\n        collision.tangent = Vector.perp(collision.normal);\r\n\r\n        collision.penetration = collision.penetration || {};\r\n        collision.penetration.x = collision.normal.x * collision.depth;\r\n        collision.penetration.y = collision.normal.y * collision.depth; \r\n\r\n        // find support points, there is always either exactly one or two\r\n        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\r\n            supports = [];\r\n\r\n        // find the supports from bodyB that are inside bodyA\r\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\r\n            supports.push(verticesB[0]);\r\n\r\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\r\n            supports.push(verticesB[1]);\r\n\r\n        // find the supports from bodyA that are inside bodyB\r\n        if (supports.length < 2) {\r\n            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\r\n                \r\n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\r\n                supports.push(verticesA[0]);\r\n\r\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\r\n                supports.push(verticesA[1]);\r\n        }\r\n\r\n        // account for the edge case of overlapping but no vertex containment\r\n        if (supports.length < 1)\r\n            supports = [verticesB[0]];\r\n        \r\n        collision.supports = supports;\r\n\r\n        return collision;\r\n    };\r\n\r\n    /**\r\n     * Find the overlap between two sets of vertices.\r\n     * @method _overlapAxes\r\n     * @private\r\n     * @param {} verticesA\r\n     * @param {} verticesB\r\n     * @param {} axes\r\n     * @return result\r\n     */\r\n    SAT._overlapAxes = function(verticesA, verticesB, axes) {\r\n        var projectionA = Vector._temp[0], \r\n            projectionB = Vector._temp[1],\r\n            result = { overlap: Number.MAX_VALUE },\r\n            overlap,\r\n            axis;\r\n\r\n        for (var i = 0; i < axes.length; i++) {\r\n            axis = axes[i];\r\n\r\n            SAT._projectToAxis(projectionA, verticesA, axis);\r\n            SAT._projectToAxis(projectionB, verticesB, axis);\r\n\r\n            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\r\n\r\n            if (overlap <= 0) {\r\n                result.overlap = overlap;\r\n                return result;\r\n            }\r\n\r\n            if (overlap < result.overlap) {\r\n                result.overlap = overlap;\r\n                result.axis = axis;\r\n                result.axisNumber = i;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Projects vertices on an axis and returns an interval.\r\n     * @method _projectToAxis\r\n     * @private\r\n     * @param {} projection\r\n     * @param {} vertices\r\n     * @param {} axis\r\n     */\r\n    SAT._projectToAxis = function(projection, vertices, axis) {\r\n        var min = Vector.dot(vertices[0], axis),\r\n            max = min;\r\n\r\n        for (var i = 1; i < vertices.length; i += 1) {\r\n            var dot = Vector.dot(vertices[i], axis);\r\n\r\n            if (dot > max) { \r\n                max = dot; \r\n            } else if (dot < min) { \r\n                min = dot; \r\n            }\r\n        }\r\n\r\n        projection.min = min;\r\n        projection.max = max;\r\n    };\r\n    \r\n    /**\r\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\r\n     * @method _findSupports\r\n     * @private\r\n     * @param {} bodyA\r\n     * @param {} bodyB\r\n     * @param {} normal\r\n     * @return [vector]\r\n     */\r\n    SAT._findSupports = function(bodyA, bodyB, normal) {\r\n        var nearestDistance = Number.MAX_VALUE,\r\n            vertexToBody = Vector._temp[0],\r\n            vertices = bodyB.vertices,\r\n            bodyAPosition = bodyA.position,\r\n            distance,\r\n            vertex,\r\n            vertexA,\r\n            vertexB;\r\n\r\n        // find closest vertex on bodyB\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            vertexToBody.x = vertex.x - bodyAPosition.x;\r\n            vertexToBody.y = vertex.y - bodyAPosition.y;\r\n            distance = -Vector.dot(normal, vertexToBody);\r\n\r\n            if (distance < nearestDistance) {\r\n                nearestDistance = distance;\r\n                vertexA = vertex;\r\n            }\r\n        }\r\n\r\n        // find next closest vertex using the two connected to it\r\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\r\n        vertex = vertices[prevIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        nearestDistance = -Vector.dot(normal, vertexToBody);\r\n        vertexB = vertex;\r\n\r\n        var nextIndex = (vertexA.index + 1) % vertices.length;\r\n        vertex = vertices[nextIndex];\r\n        vertexToBody.x = vertex.x - bodyAPosition.x;\r\n        vertexToBody.y = vertex.y - bodyAPosition.y;\r\n        distance = -Vector.dot(normal, vertexToBody);\r\n        if (distance < nearestDistance) {\r\n            vertexB = vertex;\r\n        }\r\n\r\n        return [vertexA, vertexB];\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\r\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\r\n* The stiffness of constraints can be modified to create springs or elastic.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Constraint\r\n*/\r\n\r\nvar Constraint = {};\r\n\r\nmodule.exports = Constraint;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Vector = require('../geometry/Vector');\r\nvar Sleeping = require('../core/Sleeping');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Axes = require('../geometry/Axes');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    Constraint._warming = 0.4;\r\n    Constraint._torqueDampen = 1;\r\n    Constraint._minLength = 0.000001;\r\n\r\n    /**\r\n     * Creates a new constraint.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\r\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\r\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {} options\r\n     * @return {constraint} constraint\r\n     */\r\n    Constraint.create = function(options) {\r\n        var constraint = options;\r\n\r\n        // if bodies defined but no points, use body centre\r\n        if (constraint.bodyA && !constraint.pointA)\r\n            constraint.pointA = { x: 0, y: 0 };\r\n        if (constraint.bodyB && !constraint.pointB)\r\n            constraint.pointB = { x: 0, y: 0 };\r\n\r\n        // calculate static length using initial world space points\r\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\r\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\r\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\r\n    \r\n        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\r\n\r\n        // option defaults\r\n        constraint.id = constraint.id || Common.nextId();\r\n        constraint.label = constraint.label || 'Constraint';\r\n        constraint.type = 'constraint';\r\n        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\r\n        constraint.damping = constraint.damping || 0;\r\n        constraint.angularStiffness = constraint.angularStiffness || 0;\r\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\r\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\r\n        constraint.plugin = {};\r\n\r\n        // render\r\n        var render = {\r\n            visible: true,\r\n            type: 'line',\r\n            anchors: true,\r\n            lineColor: null, // custom Phaser property\r\n            lineOpacity: null, // custom Phaser property\r\n            lineThickness: null, // custom Phaser property\r\n            pinSize: null, // custom Phaser property\r\n            anchorColor: null, // custom Phaser property\r\n            anchorSize: null // custom Phaser property\r\n        };\r\n\r\n        if (constraint.length === 0 && constraint.stiffness > 0.1) {\r\n            render.type = 'pin';\r\n            render.anchors = false;\r\n        } else if (constraint.stiffness < 0.9) {\r\n            render.type = 'spring';\r\n        }\r\n\r\n        constraint.render = Common.extend(render, constraint.render);\r\n\r\n        return constraint;\r\n    };\r\n\r\n    /**\r\n     * Prepares for solving by constraint warming.\r\n     * @private\r\n     * @method preSolveAll\r\n     * @param {body[]} bodies\r\n     */\r\n    Constraint.preSolveAll = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i += 1) {\r\n            var body = bodies[i],\r\n                impulse = body.constraintImpulse;\r\n\r\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\r\n                continue;\r\n            }\r\n\r\n            body.position.x += impulse.x;\r\n            body.position.y += impulse.y;\r\n            body.angle += impulse.angle;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Solves all constraints in a list of collisions.\r\n     * @private\r\n     * @method solveAll\r\n     * @param {constraint[]} constraints\r\n     * @param {number} timeScale\r\n     */\r\n    Constraint.solveAll = function(constraints, timeScale) {\r\n        // Solve fixed constraints first.\r\n        for (var i = 0; i < constraints.length; i += 1) {\r\n            var constraint = constraints[i],\r\n                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),\r\n                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\r\n\r\n            if (fixedA || fixedB) {\r\n                Constraint.solve(constraints[i], timeScale);\r\n            }\r\n        }\r\n\r\n        // Solve free constraints last.\r\n        for (i = 0; i < constraints.length; i += 1) {\r\n            constraint = constraints[i];\r\n            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);\r\n            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\r\n\r\n            if (!fixedA && !fixedB) {\r\n                Constraint.solve(constraints[i], timeScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Solves a distance constraint with Gauss-Siedel method.\r\n     * @private\r\n     * @method solve\r\n     * @param {constraint} constraint\r\n     * @param {number} timeScale\r\n     */\r\n    Constraint.solve = function(constraint, timeScale) {\r\n        var bodyA = constraint.bodyA,\r\n            bodyB = constraint.bodyB,\r\n            pointA = constraint.pointA,\r\n            pointB = constraint.pointB;\r\n\r\n        if (!bodyA && !bodyB)\r\n            return;\r\n\r\n        // update reference angle\r\n        if (bodyA && !bodyA.isStatic) {\r\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\r\n            constraint.angleA = bodyA.angle;\r\n        }\r\n        \r\n        // update reference angle\r\n        if (bodyB && !bodyB.isStatic) {\r\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\r\n            constraint.angleB = bodyB.angle;\r\n        }\r\n\r\n        var pointAWorld = pointA,\r\n            pointBWorld = pointB;\r\n\r\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\r\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\r\n\r\n        if (!pointAWorld || !pointBWorld)\r\n            return;\r\n\r\n        var delta = Vector.sub(pointAWorld, pointBWorld),\r\n            currentLength = Vector.magnitude(delta);\r\n\r\n        // prevent singularity\r\n        if (currentLength < Constraint._minLength) {\r\n            currentLength = Constraint._minLength;\r\n        }\r\n\r\n        // solve distance constraint with Gauss-Siedel method\r\n        var difference = (currentLength - constraint.length) / currentLength,\r\n            stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness,\r\n            force = Vector.mult(delta, difference * stiffness),\r\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\r\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\r\n            resistanceTotal = massTotal + inertiaTotal,\r\n            torque,\r\n            share,\r\n            normal,\r\n            normalVelocity,\r\n            relativeVelocity;\r\n\r\n        if (constraint.damping) {\r\n            var zero = Vector.create();\r\n            normal = Vector.div(delta, currentLength);\r\n\r\n            relativeVelocity = Vector.sub(\r\n                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,\r\n                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero\r\n            );\r\n\r\n            normalVelocity = Vector.dot(normal, relativeVelocity);\r\n        }\r\n\r\n        if (bodyA && !bodyA.isStatic) {\r\n            share = bodyA.inverseMass / massTotal;\r\n\r\n            // keep track of applied impulses for post solving\r\n            bodyA.constraintImpulse.x -= force.x * share;\r\n            bodyA.constraintImpulse.y -= force.y * share;\r\n\r\n            // apply forces\r\n            bodyA.position.x -= force.x * share;\r\n            bodyA.position.y -= force.y * share;\r\n\r\n            // apply damping\r\n            if (constraint.damping) {\r\n                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;\r\n                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;\r\n            }\r\n\r\n            // apply torque\r\n            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\r\n            bodyA.constraintImpulse.angle -= torque;\r\n            bodyA.angle -= torque;\r\n        }\r\n\r\n        if (bodyB && !bodyB.isStatic) {\r\n            share = bodyB.inverseMass / massTotal;\r\n\r\n            // keep track of applied impulses for post solving\r\n            bodyB.constraintImpulse.x += force.x * share;\r\n            bodyB.constraintImpulse.y += force.y * share;\r\n            \r\n            // apply forces\r\n            bodyB.position.x += force.x * share;\r\n            bodyB.position.y += force.y * share;\r\n\r\n            // apply damping\r\n            if (constraint.damping) {\r\n                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;\r\n                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;\r\n            }\r\n\r\n            // apply torque\r\n            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\r\n            bodyB.constraintImpulse.angle += torque;\r\n            bodyB.angle += torque;\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Performs body updates required after solving constraints.\r\n     * @private\r\n     * @method postSolveAll\r\n     * @param {body[]} bodies\r\n     */\r\n    Constraint.postSolveAll = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                impulse = body.constraintImpulse;\r\n\r\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\r\n                continue;\r\n            }\r\n\r\n            Sleeping.set(body, false);\r\n\r\n            // update geometry and reset\r\n            for (var j = 0; j < body.parts.length; j++) {\r\n                var part = body.parts[j];\r\n                \r\n                Vertices.translate(part.vertices, impulse);\r\n\r\n                if (j > 0) {\r\n                    part.position.x += impulse.x;\r\n                    part.position.y += impulse.y;\r\n                }\r\n\r\n                if (impulse.angle !== 0) {\r\n                    Vertices.rotate(part.vertices, impulse.angle, body.position);\r\n                    Axes.rotate(part.axes, impulse.angle);\r\n                    if (j > 0) {\r\n                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\r\n                    }\r\n                }\r\n\r\n                Bounds.update(part.bounds, part.vertices, body.velocity);\r\n            }\r\n\r\n            // dampen the cached impulse for warming next step\r\n            impulse.angle *= Constraint._warming;\r\n            impulse.x *= Constraint._warming;\r\n            impulse.y *= Constraint._warming;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\r\n     * @method pointAWorld\r\n     * @param {constraint} constraint\r\n     * @returns {vector} the world-space position\r\n     */\r\n    Constraint.pointAWorld = function(constraint) {\r\n        return {\r\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,\r\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\r\n     * @method pointBWorld\r\n     * @param {constraint} constraint\r\n     * @returns {vector} the world-space position\r\n     */\r\n    Constraint.pointBWorld = function(constraint) {\r\n        return {\r\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,\r\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y\r\n        };\r\n    };\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\r\n     *\r\n     * @property id\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * A `String` denoting the type of object.\r\n     *\r\n     * @property type\r\n     * @type string\r\n     * @default \"constraint\"\r\n     * @readOnly\r\n     */\r\n\r\n    /**\r\n     * An arbitrary `String` name to help the user identify and manage bodies.\r\n     *\r\n     * @property label\r\n     * @type string\r\n     * @default \"Constraint\"\r\n     */\r\n\r\n    /**\r\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\r\n     *\r\n     * @property render\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * A flag that indicates if the constraint should be rendered.\r\n     *\r\n     * @property render.visible\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n\r\n    /**\r\n     * A `Number` that defines the line width to use when rendering the constraint outline.\r\n     * A value of `0` means no outline will be rendered.\r\n     *\r\n     * @property render.lineWidth\r\n     * @type number\r\n     * @default 2\r\n     */\r\n\r\n    /**\r\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\r\n     * It is the same as when using a canvas, so it accepts CSS style property values.\r\n     *\r\n     * @property render.strokeStyle\r\n     * @type string\r\n     * @default a random colour\r\n     */\r\n\r\n    /**\r\n     * A `String` that defines the constraint rendering type. \r\n     * The possible values are 'line', 'pin', 'spring'.\r\n     * An appropriate render type will be automatically chosen unless one is given in options.\r\n     *\r\n     * @property render.type\r\n     * @type string\r\n     * @default 'line'\r\n     */\r\n\r\n    /**\r\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\r\n     *\r\n     * @property render.anchors\r\n     * @type boolean\r\n     * @default true\r\n     */\r\n\r\n    /**\r\n     * The first possible `Body` that this constraint is attached to.\r\n     *\r\n     * @property bodyA\r\n     * @type body\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * The second possible `Body` that this constraint is attached to.\r\n     *\r\n     * @property bodyB\r\n     * @type body\r\n     * @default null\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\r\n     *\r\n     * @property pointA\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\r\n     *\r\n     * @property pointB\r\n     * @type vector\r\n     * @default { x: 0, y: 0 }\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\r\n     * A value of `1` means the constraint should be very stiff.\r\n     * A value of `0.2` means the constraint acts like a soft spring.\r\n     *\r\n     * @property stiffness\r\n     * @type number\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the damping of the constraint, \r\n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\r\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\r\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\r\n     * A value of `0` means the constraint will apply no damping.\r\n     *\r\n     * @property damping\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the target resting length of the constraint. \r\n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\r\n     *\r\n     * @property length\r\n     * @type number\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n})();\r\n","/**\r\n* The `Matter.Common` module contains utility functions that are common to all modules.\r\n*\r\n* @class Common\r\n*/\r\n\r\nvar Common = {};\r\n\r\nmodule.exports = Common;\r\n\r\n(function() {\r\n\r\n    Common._nextId = 0;\r\n    Common._seed = 0;\r\n    Common._nowStartTime = +(new Date());\r\n\r\n    /**\r\n     * Extends the object in the first argument using the object in the second argument.\r\n     * @method extend\r\n     * @param {} obj\r\n     * @param {boolean} deep\r\n     * @return {} obj extended\r\n     */\r\n    Common.extend = function(obj, deep) {\r\n        var argsStart,\r\n            args,\r\n            deepClone;\r\n\r\n        if (typeof deep === 'boolean') {\r\n            argsStart = 2;\r\n            deepClone = deep;\r\n        } else {\r\n            argsStart = 1;\r\n            deepClone = true;\r\n        }\r\n\r\n        for (var i = argsStart; i < arguments.length; i++) {\r\n            var source = arguments[i];\r\n\r\n            if (source) {\r\n                for (var prop in source) {\r\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\r\n                        if (!obj[prop] || obj[prop].constructor === Object) {\r\n                            obj[prop] = obj[prop] || {};\r\n                            Common.extend(obj[prop], deepClone, source[prop]);\r\n                        } else {\r\n                            obj[prop] = source[prop];\r\n                        }\r\n                    } else {\r\n                        obj[prop] = source[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return obj;\r\n    };\r\n\r\n    /**\r\n     * Creates a new clone of the object, if deep is true references will also be cloned.\r\n     * @method clone\r\n     * @param {} obj\r\n     * @param {bool} deep\r\n     * @return {} obj cloned\r\n     */\r\n    Common.clone = function(obj, deep) {\r\n        return Common.extend({}, deep, obj);\r\n    };\r\n\r\n    /**\r\n     * Returns the list of keys for the given object.\r\n     * @method keys\r\n     * @param {} obj\r\n     * @return {string[]} keys\r\n     */\r\n    Common.keys = function(obj) {\r\n        if (Object.keys)\r\n            return Object.keys(obj);\r\n\r\n        // avoid hasOwnProperty for performance\r\n        var keys = [];\r\n        for (var key in obj)\r\n            keys.push(key);\r\n        return keys;\r\n    };\r\n\r\n    /**\r\n     * Returns the list of values for the given object.\r\n     * @method values\r\n     * @param {} obj\r\n     * @return {array} Array of the objects property values\r\n     */\r\n    Common.values = function(obj) {\r\n        var values = [];\r\n        \r\n        if (Object.keys) {\r\n            var keys = Object.keys(obj);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                values.push(obj[keys[i]]);\r\n            }\r\n            return values;\r\n        }\r\n        \r\n        // avoid hasOwnProperty for performance\r\n        for (var key in obj)\r\n            values.push(obj[key]);\r\n        return values;\r\n    };\r\n\r\n    /**\r\n     * Gets a value from `base` relative to the `path` string.\r\n     * @method get\r\n     * @param {} obj The base object\r\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n     * @param {number} [begin] Path slice begin\r\n     * @param {number} [end] Path slice end\r\n     * @return {} The object at the given path\r\n     */\r\n    Common.get = function(obj, path, begin, end) {\r\n        path = path.split('.').slice(begin, end);\r\n\r\n        for (var i = 0; i < path.length; i += 1) {\r\n            obj = obj[path[i]];\r\n        }\r\n\r\n        return obj;\r\n    };\r\n\r\n    /**\r\n     * Sets a value on `base` relative to the given `path` string.\r\n     * @method set\r\n     * @param {} obj The base object\r\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\r\n     * @param {} val The value to set\r\n     * @param {number} [begin] Path slice begin\r\n     * @param {number} [end] Path slice end\r\n     * @return {} Pass through `val` for chaining\r\n     */\r\n    Common.set = function(obj, path, val, begin, end) {\r\n        var parts = path.split('.').slice(begin, end);\r\n        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\r\n        return val;\r\n    };\r\n\r\n    /**\r\n     * Shuffles the given array in-place.\r\n     * The function uses a seeded random generator.\r\n     * @method shuffle\r\n     * @param {array} array\r\n     * @return {array} array shuffled randomly\r\n     */\r\n    Common.shuffle = function(array) {\r\n        for (var i = array.length - 1; i > 0; i--) {\r\n            var j = Math.floor(Common.random() * (i + 1));\r\n            var temp = array[i];\r\n            array[i] = array[j];\r\n            array[j] = temp;\r\n        }\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Randomly chooses a value from a list with equal probability.\r\n     * The function uses a seeded random generator.\r\n     * @method choose\r\n     * @param {array} choices\r\n     * @return {object} A random choice object from the array\r\n     */\r\n    Common.choose = function(choices) {\r\n        return choices[Math.floor(Common.random() * choices.length)];\r\n    };\r\n\r\n    /**\r\n     * Returns true if the object is a HTMLElement, otherwise false.\r\n     * @method isElement\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\r\n     */\r\n    Common.isElement = function(obj) {\r\n        if (typeof HTMLElement !== 'undefined') {\r\n            return obj instanceof HTMLElement;\r\n        }\r\n\r\n        return !!(obj && obj.nodeType && obj.nodeName);\r\n    };\r\n\r\n    /**\r\n     * Returns true if the object is an array.\r\n     * @method isArray\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is an array, otherwise false\r\n     */\r\n    Common.isArray = function(obj) {\r\n        return Object.prototype.toString.call(obj) === '[object Array]';\r\n    };\r\n\r\n    /**\r\n     * Returns true if the object is a function.\r\n     * @method isFunction\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a function, otherwise false\r\n     */\r\n    Common.isFunction = function(obj) {\r\n        return typeof obj === \"function\";\r\n    };\r\n\r\n    /**\r\n     * Returns true if the object is a plain object.\r\n     * @method isPlainObject\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a plain object, otherwise false\r\n     */\r\n    Common.isPlainObject = function(obj) {\r\n        return typeof obj === 'object' && obj.constructor === Object;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the object is a string.\r\n     * @method isString\r\n     * @param {object} obj\r\n     * @return {boolean} True if the object is a string, otherwise false\r\n     */\r\n    Common.isString = function(obj) {\r\n        return Object.prototype.toString.call(obj) === '[object String]';\r\n    };\r\n    \r\n    /**\r\n     * Returns the given value clamped between a minimum and maximum value.\r\n     * @method clamp\r\n     * @param {number} value\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @return {number} The value clamped between min and max inclusive\r\n     */\r\n    Common.clamp = function(value, min, max) {\r\n        if (value < min)\r\n            return min;\r\n        if (value > max)\r\n            return max;\r\n        return value;\r\n    };\r\n    \r\n    /**\r\n     * Returns the sign of the given value.\r\n     * @method sign\r\n     * @param {number} value\r\n     * @return {number} -1 if negative, +1 if 0 or positive\r\n     */\r\n    Common.sign = function(value) {\r\n        return value < 0 ? -1 : 1;\r\n    };\r\n    \r\n    /**\r\n     * Returns the current timestamp since the time origin (e.g. from page load).\r\n     * The result will be high-resolution including decimal places if available.\r\n     * @method now\r\n     * @return {number} the current timestamp\r\n     */\r\n    Common.now = function() {\r\n        if (typeof window !== 'undefined' && window.performance) {\r\n            if (window.performance.now) {\r\n                return window.performance.now();\r\n            } else if (window.performance.webkitNow) {\r\n                return window.performance.webkitNow();\r\n            }\r\n        }\r\n\r\n        return (new Date()) - Common._nowStartTime;\r\n    };\r\n    \r\n    /**\r\n     * Returns a random value between a minimum and a maximum value inclusive.\r\n     * The function uses a seeded random generator.\r\n     * @method random\r\n     * @param {number} min\r\n     * @param {number} max\r\n     * @return {number} A random number between min and max inclusive\r\n     */\r\n    Common.random = function(min, max) {\r\n        min = (typeof min !== \"undefined\") ? min : 0;\r\n        max = (typeof max !== \"undefined\") ? max : 1;\r\n        return min + _seededRandom() * (max - min);\r\n    };\r\n\r\n    var _seededRandom = function() {\r\n        // https://en.wikipedia.org/wiki/Linear_congruential_generator\r\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\r\n        return Common._seed / 233280;\r\n    };\r\n\r\n    /**\r\n     * Converts a CSS hex colour string into an integer.\r\n     * @method colorToNumber\r\n     * @param {string} colorString\r\n     * @return {number} An integer representing the CSS hex string\r\n     */\r\n    Common.colorToNumber = function(colorString) {\r\n        colorString = colorString.replace('#','');\r\n\r\n        if (colorString.length == 3) {\r\n            colorString = colorString.charAt(0) + colorString.charAt(0)\r\n                        + colorString.charAt(1) + colorString.charAt(1)\r\n                        + colorString.charAt(2) + colorString.charAt(2);\r\n        }\r\n\r\n        return parseInt(colorString, 16);\r\n    };\r\n\r\n    /**\r\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\r\n     * The default level is 'debug' which shows all console messages.  \r\n     *\r\n     * Possible level values are:\r\n     * - 0 = None\r\n     * - 1 = Debug\r\n     * - 2 = Info\r\n     * - 3 = Warn\r\n     * - 4 = Error\r\n     * @property Common.logLevel\r\n     * @type {Number}\r\n     * @default 1\r\n     */\r\n    Common.logLevel = 1;\r\n\r\n    /**\r\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method log\r\n     * @param ...objs {} The objects to log.\r\n     */\r\n    Common.log = function() {\r\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\r\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method info\r\n     * @param ...objs {} The objects to log.\r\n     */\r\n    Common.info = function() {\r\n        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\r\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\r\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\r\n     * @method warn\r\n     * @param ...objs {} The objects to log.\r\n     */\r\n    Common.warn = function() {\r\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\r\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the next unique sequential ID.\r\n     * @method nextId\r\n     * @return {Number} Unique sequential ID\r\n     */\r\n    Common.nextId = function() {\r\n        return Common._nextId++;\r\n    };\r\n\r\n    /**\r\n     * A cross browser compatible indexOf implementation.\r\n     * @method indexOf\r\n     * @param {array} haystack\r\n     * @param {object} needle\r\n     * @return {number} The position of needle in haystack, otherwise -1.\r\n     */\r\n    Common.indexOf = function(haystack, needle) {\r\n        if (haystack.indexOf)\r\n            return haystack.indexOf(needle);\r\n\r\n        for (var i = 0; i < haystack.length; i++) {\r\n            if (haystack[i] === needle)\r\n                return i;\r\n        }\r\n\r\n        return -1;\r\n    };\r\n\r\n    /**\r\n     * A cross browser compatible array map implementation.\r\n     * @method map\r\n     * @param {array} list\r\n     * @param {function} func\r\n     * @return {array} Values from list transformed by func.\r\n     */\r\n    Common.map = function(list, func) {\r\n        if (list.map) {\r\n            return list.map(func);\r\n        }\r\n\r\n        var mapped = [];\r\n\r\n        for (var i = 0; i < list.length; i += 1) {\r\n            mapped.push(func(list[i]));\r\n        }\r\n\r\n        return mapped;\r\n    };\r\n\r\n    /**\r\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\r\n     * Circular dependencies are allowed.\r\n     * @method topologicalSort\r\n     * @param {object} graph\r\n     * @return {array} Partially ordered set of vertices in topological order.\r\n     */\r\n    Common.topologicalSort = function(graph) {\r\n        // https://github.com/mgechev/javascript-algorithms\r\n        // Copyright (c) Minko Gechev (MIT license)\r\n        // Modifications: tidy formatting and naming\r\n        var result = [],\r\n            visited = [],\r\n            temp = [];\r\n\r\n        for (var node in graph) {\r\n            if (!visited[node] && !temp[node]) {\r\n                Common._topologicalSort(node, visited, temp, graph, result);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    Common._topologicalSort = function(node, visited, temp, graph, result) {\r\n        var neighbors = graph[node] || [];\r\n        temp[node] = true;\r\n\r\n        for (var i = 0; i < neighbors.length; i += 1) {\r\n            var neighbor = neighbors[i];\r\n\r\n            if (temp[neighbor]) {\r\n                // skip circular dependencies\r\n                continue;\r\n            }\r\n\r\n            if (!visited[neighbor]) {\r\n                Common._topologicalSort(neighbor, visited, temp, graph, result);\r\n            }\r\n        }\r\n\r\n        temp[node] = false;\r\n        visited[node] = true;\r\n\r\n        result.push(node);\r\n    };\r\n\r\n    /**\r\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\r\n     * The arguments applied when calling the new function will also be applied to every function passed.\r\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\r\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\r\n     * After all passed functions have been called the new function returns the last returned value (if any).\r\n     * If any of the passed functions are a chain, then the chain will be flattened.\r\n     * @method chain\r\n     * @param ...funcs {function} The functions to chain.\r\n     * @return {function} A new function that calls the passed functions in order.\r\n     */\r\n    Common.chain = function() {\r\n        var funcs = [];\r\n\r\n        for (var i = 0; i < arguments.length; i += 1) {\r\n            var func = arguments[i];\r\n\r\n            if (func._chained) {\r\n                // flatten already chained functions\r\n                funcs.push.apply(funcs, func._chained);\r\n            } else {\r\n                funcs.push(func);\r\n            }\r\n        }\r\n\r\n        var chain = function() {\r\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\r\n            var lastResult,\r\n                args = new Array(arguments.length);\r\n\r\n            for (var i = 0, l = arguments.length; i < l; i++) {\r\n                args[i] = arguments[i];\r\n            }\r\n\r\n            for (i = 0; i < funcs.length; i += 1) {\r\n                var result = funcs[i].apply(lastResult, args);\r\n\r\n                if (typeof result !== 'undefined') {\r\n                    lastResult = result;\r\n                }\r\n            }\r\n\r\n            return lastResult;\r\n        };\r\n\r\n        chain._chained = funcs;\r\n\r\n        return chain;\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\r\n     * See also docs for `Common.chain`.\r\n     * @method chainPathBefore\r\n     * @param {} base The base object\r\n     * @param {string} path The path relative to `base`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Common.chainPathBefore = function(base, path, func) {\r\n        return Common.set(base, path, Common.chain(\r\n            func,\r\n            Common.get(base, path)\r\n        ));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\r\n     * See also docs for `Common.chain`.\r\n     * @method chainPathAfter\r\n     * @param {} base The base object\r\n     * @param {string} path The path relative to `base`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Common.chainPathAfter = function(base, path, func) {\r\n        return Common.set(base, path, Common.chain(\r\n            Common.get(base, path),\r\n            func\r\n        ));\r\n    };\r\n})();\r\n","/**\r\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\r\n* An engine is a controller that manages updating the simulation of the world.\r\n* See `Matter.Runner` for an optional game loop utility.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Engine\r\n*/\r\n\r\nvar Engine = {};\r\n\r\nmodule.exports = Engine;\r\n\r\nvar World = require('../body/World');\r\nvar Sleeping = require('./Sleeping');\r\nvar Resolver = require('../collision/Resolver');\r\nvar Pairs = require('../collision/Pairs');\r\nvar Metrics = require('./Metrics');\r\nvar Grid = require('../collision/Grid');\r\nvar Events = require('./Events');\r\nvar Composite = require('../body/Composite');\r\nvar Constraint = require('../constraint/Constraint');\r\nvar Common = require('./Common');\r\nvar Body = require('../body/Body');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\r\n     * See the properties section below for detailed information on what you can pass via the `options` object.\r\n     * @method create\r\n     * @param {object} [options]\r\n     * @return {engine} engine\r\n     */\r\n    Engine.create = function(element, options) {\r\n        // options may be passed as the first (and only) argument\r\n        options = Common.isElement(element) ? options : element;\r\n        element = Common.isElement(element) ? element : null;\r\n        options = options || {};\r\n\r\n        if (element || options.render) {\r\n            Common.warn('Engine.create: engine.render is deprecated (see docs)');\r\n        }\r\n\r\n        var defaults = {\r\n            positionIterations: 6,\r\n            velocityIterations: 4,\r\n            constraintIterations: 2,\r\n            enableSleeping: false,\r\n            events: [],\r\n            plugin: {},\r\n            timing: {\r\n                timestamp: 0,\r\n                timeScale: 1\r\n            },\r\n            broadphase: {\r\n                controller: Grid\r\n            }\r\n        };\r\n\r\n        var engine = Common.extend(defaults, options);\r\n\r\n        engine.world = options.world || World.create(engine.world);\r\n        engine.pairs = Pairs.create();\r\n        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);\r\n        engine.metrics = engine.metrics || { extended: false };\r\n\r\n        // @if DEBUG\r\n        engine.metrics = Metrics.create(engine.metrics);\r\n        // @endif\r\n\r\n        return engine;\r\n    };\r\n\r\n    /**\r\n     * Moves the simulation forward in time by `delta` ms.\r\n     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\r\n     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\r\n     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\r\n     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\r\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\r\n     *\r\n     * Triggers `beforeUpdate` and `afterUpdate` events.\r\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\r\n     * @method update\r\n     * @param {engine} engine\r\n     * @param {number} [delta=16.666]\r\n     * @param {number} [correction=1]\r\n     */\r\n    Engine.update = function(engine, delta, correction) {\r\n        delta = delta || 1000 / 60;\r\n        correction = correction || 1;\r\n\r\n        var world = engine.world,\r\n            timing = engine.timing,\r\n            broadphase = engine.broadphase,\r\n            broadphasePairs = [],\r\n            i;\r\n\r\n        // increment timestamp\r\n        timing.timestamp += delta * timing.timeScale;\r\n\r\n        // create an event object\r\n        var event = {\r\n            timestamp: timing.timestamp\r\n        };\r\n\r\n        Events.trigger(engine, 'beforeUpdate', event);\r\n\r\n        // get lists of all bodies and constraints, no matter what composites they are in\r\n        var allBodies = Composite.allBodies(world),\r\n            allConstraints = Composite.allConstraints(world);\r\n\r\n        // @if DEBUG\r\n        // reset metrics logging\r\n        Metrics.reset(engine.metrics);\r\n        // @endif\r\n\r\n        // if sleeping enabled, call the sleeping controller\r\n        if (engine.enableSleeping)\r\n            Sleeping.update(allBodies, timing.timeScale);\r\n\r\n        // applies gravity to all bodies\r\n        Engine._bodiesApplyGravity(allBodies, world.gravity);\r\n\r\n        // update all body position and rotation by integration\r\n        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);\r\n\r\n        // update all constraints (first pass)\r\n        Constraint.preSolveAll(allBodies);\r\n        for (i = 0; i < engine.constraintIterations; i++) {\r\n            Constraint.solveAll(allConstraints, timing.timeScale);\r\n        }\r\n        Constraint.postSolveAll(allBodies);\r\n\r\n        // broadphase pass: find potential collision pairs\r\n        if (broadphase.controller) {\r\n            // if world is dirty, we must flush the whole grid\r\n            if (world.isModified)\r\n                broadphase.controller.clear(broadphase);\r\n\r\n            // update the grid buckets based on current bodies\r\n            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);\r\n            broadphasePairs = broadphase.pairsList;\r\n        } else {\r\n            // if no broadphase set, we just pass all bodies\r\n            broadphasePairs = allBodies;\r\n        }\r\n\r\n        // clear all composite modified flags\r\n        if (world.isModified) {\r\n            Composite.setModified(world, false, false, true);\r\n        }\r\n\r\n        // narrowphase pass: find actual collisions, then create or update collision pairs\r\n        var collisions = broadphase.detector(broadphasePairs, engine);\r\n\r\n        // update collision pairs\r\n        var pairs = engine.pairs,\r\n            timestamp = timing.timestamp;\r\n        Pairs.update(pairs, collisions, timestamp);\r\n        Pairs.removeOld(pairs, timestamp);\r\n\r\n        // wake up bodies involved in collisions\r\n        if (engine.enableSleeping)\r\n            Sleeping.afterCollisions(pairs.list, timing.timeScale);\r\n\r\n        // trigger collision events\r\n        if (pairs.collisionStart.length > 0)\r\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\r\n\r\n        // iteratively resolve position between collisions\r\n        Resolver.preSolvePosition(pairs.list);\r\n        for (i = 0; i < engine.positionIterations; i++) {\r\n            Resolver.solvePosition(pairs.list, allBodies, timing.timeScale);\r\n        }\r\n        Resolver.postSolvePosition(allBodies);\r\n\r\n        // update all constraints (second pass)\r\n        Constraint.preSolveAll(allBodies);\r\n        for (i = 0; i < engine.constraintIterations; i++) {\r\n            Constraint.solveAll(allConstraints, timing.timeScale);\r\n        }\r\n        Constraint.postSolveAll(allBodies);\r\n\r\n        // iteratively resolve velocity between collisions\r\n        Resolver.preSolveVelocity(pairs.list);\r\n        for (i = 0; i < engine.velocityIterations; i++) {\r\n            Resolver.solveVelocity(pairs.list, timing.timeScale);\r\n        }\r\n\r\n        // trigger collision events\r\n        if (pairs.collisionActive.length > 0)\r\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\r\n\r\n        if (pairs.collisionEnd.length > 0)\r\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\r\n\r\n        // @if DEBUG\r\n        // update metrics log\r\n        Metrics.update(engine.metrics, engine);\r\n        // @endif\r\n\r\n        // clear force buffers\r\n        Engine._bodiesClearForces(allBodies);\r\n\r\n        Events.trigger(engine, 'afterUpdate', event);\r\n\r\n        return engine;\r\n    };\r\n    \r\n    /**\r\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\r\n     * @method merge\r\n     * @param {engine} engineA\r\n     * @param {engine} engineB\r\n     */\r\n    Engine.merge = function(engineA, engineB) {\r\n        Common.extend(engineA, engineB);\r\n        \r\n        if (engineB.world) {\r\n            engineA.world = engineB.world;\r\n\r\n            Engine.clear(engineA);\r\n\r\n            var bodies = Composite.allBodies(engineA.world);\r\n\r\n            for (var i = 0; i < bodies.length; i++) {\r\n                var body = bodies[i];\r\n                Sleeping.set(body, false);\r\n                body.id = Common.nextId();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Clears the engine including the world, pairs and broadphase.\r\n     * @method clear\r\n     * @param {engine} engine\r\n     */\r\n    Engine.clear = function(engine) {\r\n        var world = engine.world;\r\n        \r\n        Pairs.clear(engine.pairs);\r\n\r\n        var broadphase = engine.broadphase;\r\n        if (broadphase.controller) {\r\n            var bodies = Composite.allBodies(world);\r\n            broadphase.controller.clear(broadphase);\r\n            broadphase.controller.update(broadphase, bodies, engine, true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Zeroes the `body.force` and `body.torque` force buffers.\r\n     * @method _bodiesClearForces\r\n     * @private\r\n     * @param {body[]} bodies\r\n     */\r\n    Engine._bodiesClearForces = function(bodies) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            // reset force buffers\r\n            body.force.x = 0;\r\n            body.force.y = 0;\r\n            body.torque = 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applys a mass dependant force to all given bodies.\r\n     * @method _bodiesApplyGravity\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {vector} gravity\r\n     */\r\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\r\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\r\n\r\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\r\n            return;\r\n        }\r\n        \r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.ignoreGravity || body.isStatic || body.isSleeping)\r\n                continue;\r\n\r\n            // apply gravity\r\n            body.force.x += (body.mass * gravity.x * gravityScale) * body.gravityScale.x;\r\n            body.force.y += (body.mass * gravity.y * gravityScale) * body.gravityScale.y;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Applys `Body.update` to all given `bodies`.\r\n     * @method _bodiesUpdate\r\n     * @private\r\n     * @param {body[]} bodies\r\n     * @param {number} deltaTime \r\n     * The amount of time elapsed between updates\r\n     * @param {number} timeScale\r\n     * @param {number} correction \r\n     * The Verlet correction factor (deltaTime / lastDeltaTime)\r\n     * @param {bounds} worldBounds\r\n     */\r\n    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i];\r\n\r\n            if (body.isStatic || body.isSleeping)\r\n                continue;\r\n\r\n            Body.update(body, deltaTime, timeScale, correction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * An alias for `Runner.run`, see `Matter.Runner` for more information.\r\n     * @method run\r\n     * @param {engine} engine\r\n     */\r\n\r\n    /**\r\n    * Fired just before an update\r\n    *\r\n    * @event beforeUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update and all collision events\r\n    *\r\n    * @event afterUpdate\r\n    * @param {} event An event object\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\r\n    *\r\n    * @event collisionStart\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\r\n    *\r\n    * @event collisionActive\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /**\r\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\r\n    *\r\n    * @event collisionEnd\r\n    * @param {} event An event object\r\n    * @param {} event.pairs List of affected pairs\r\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\r\n    * @param {} event.source The source object of the event\r\n    * @param {} event.name The name of the event\r\n    */\r\n\r\n    /*\r\n    *\r\n    *  Properties Documentation\r\n    *\r\n    */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of position iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property positionIterations\r\n     * @type number\r\n     * @default 6\r\n     */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     *\r\n     * @property velocityIterations\r\n     * @type number\r\n     * @default 4\r\n     */\r\n\r\n    /**\r\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\r\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\r\n     * The default value of `2` is usually very adequate.\r\n     *\r\n     * @property constraintIterations\r\n     * @type number\r\n     * @default 2\r\n     */\r\n\r\n    /**\r\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\r\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\r\n     *\r\n     * @property enableSleeping\r\n     * @type boolean\r\n     * @default false\r\n     */\r\n\r\n    /**\r\n     * An `Object` containing properties regarding the timing systems of the engine. \r\n     *\r\n     * @property timing\r\n     * @type object\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the global scaling factor of time for all bodies.\r\n     * A value of `0` freezes the simulation.\r\n     * A value of `0.1` gives a slow-motion effect.\r\n     * A value of `1.2` gives a speed-up effect.\r\n     *\r\n     * @property timing.timeScale\r\n     * @type number\r\n     * @default 1\r\n     */\r\n\r\n    /**\r\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \r\n     * It is incremented on every `Engine.update` by the given `delta` argument. \r\n     *\r\n     * @property timing.timestamp\r\n     * @type number\r\n     * @default 0\r\n     */\r\n\r\n    /**\r\n     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.\r\n     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.\r\n     *\r\n     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).\r\n     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.\r\n     *\r\n     * @property render\r\n     * @type render\r\n     * @deprecated see Demo.js for an example of creating a renderer\r\n     * @default a Matter.Render instance\r\n     */\r\n\r\n    /**\r\n     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.\r\n     *\r\n     * @property broadphase\r\n     * @type grid\r\n     * @default a Matter.Grid instance\r\n     */\r\n\r\n    /**\r\n     * A `World` composite object that will contain all simulated bodies and constraints.\r\n     *\r\n     * @property world\r\n     * @type world\r\n     * @default a Matter.World instance\r\n     */\r\n\r\n    /**\r\n     * An object reserved for storing plugin-specific properties.\r\n     *\r\n     * @property plugin\r\n     * @type {}\r\n     */\r\n\r\n})();\r\n","/**\r\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Events\r\n*/\r\n\r\nvar Events = {};\r\n\r\nmodule.exports = Events;\r\n\r\nvar Common = require('./Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Subscribes a callback function to the given object's `eventName`.\r\n     * @method on\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {function} callback\r\n     */\r\n    Events.on = function(object, eventNames, callback) {\r\n        var names = eventNames.split(' '),\r\n            name;\r\n\r\n        for (var i = 0; i < names.length; i++) {\r\n            name = names[i];\r\n            object.events = object.events || {};\r\n            object.events[name] = object.events[name] || [];\r\n            object.events[name].push(callback);\r\n        }\r\n\r\n        return callback;\r\n    };\r\n\r\n    /**\r\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\r\n     * @method off\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {function} callback\r\n     */\r\n    Events.off = function(object, eventNames, callback) {\r\n        if (!eventNames) {\r\n            object.events = {};\r\n            return;\r\n        }\r\n\r\n        // handle Events.off(object, callback)\r\n        if (typeof eventNames === 'function') {\r\n            callback = eventNames;\r\n            eventNames = Common.keys(object.events).join(' ');\r\n        }\r\n\r\n        var names = eventNames.split(' ');\r\n\r\n        for (var i = 0; i < names.length; i++) {\r\n            var callbacks = object.events[names[i]],\r\n                newCallbacks = [];\r\n\r\n            if (callback && callbacks) {\r\n                for (var j = 0; j < callbacks.length; j++) {\r\n                    if (callbacks[j] !== callback)\r\n                        newCallbacks.push(callbacks[j]);\r\n                }\r\n            }\r\n\r\n            object.events[names[i]] = newCallbacks;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\r\n     * @method trigger\r\n     * @param {} object\r\n     * @param {string} eventNames\r\n     * @param {} event\r\n     */\r\n    Events.trigger = function(object, eventNames, event) {\r\n        var names,\r\n            name,\r\n            callbacks,\r\n            eventClone;\r\n\r\n        var events = object.events;\r\n        \r\n        if (events && Common.keys(events).length > 0) {\r\n            if (!event)\r\n                event = {};\r\n\r\n            names = eventNames.split(' ');\r\n\r\n            for (var i = 0; i < names.length; i++) {\r\n                name = names[i];\r\n                callbacks = events[name];\r\n\r\n                if (callbacks) {\r\n                    eventClone = Common.clone(event, false);\r\n                    eventClone.name = name;\r\n                    eventClone.source = object;\r\n\r\n                    for (var j = 0; j < callbacks.length; j++) {\r\n                        callbacks[j].apply(object, [eventClone]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/\r\n\r\nvar Matter = {};\r\n\r\nmodule.exports = Matter;\r\n\r\nvar Plugin = require('./Plugin');\r\nvar Common = require('./Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.name = 'matter-js';\r\n\r\n    /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.version = '0.14.2';\r\n\r\n    /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */\r\n    Matter.uses = [];\r\n\r\n    /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */\r\n    Matter.used = [];\r\n\r\n    /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */\r\n    Matter.use = function() {\r\n        Plugin.use(Matter, Array.prototype.slice.call(arguments));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.before = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathBefore(Matter, path, func);\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.after = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathAfter(Matter, path, func);\r\n    };\r\n\r\n})();\r\n","// @if DEBUG\r\n/**\r\n* _Internal Class_, not generally used outside of the engine's internals.\r\n*\r\n*/\r\n\r\nvar Metrics = {};\r\n\r\nmodule.exports = Metrics;\r\n\r\nvar Composite = require('../body/Composite');\r\nvar Common = require('./Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new metrics.\r\n     * @method create\r\n     * @private\r\n     * @return {metrics} A new metrics\r\n     */\r\n    Metrics.create = function(options) {\r\n        var defaults = {\r\n            extended: false,\r\n            narrowDetections: 0,\r\n            narrowphaseTests: 0,\r\n            narrowReuse: 0,\r\n            narrowReuseCount: 0,\r\n            midphaseTests: 0,\r\n            broadphaseTests: 0,\r\n            narrowEff: 0.0001,\r\n            midEff: 0.0001,\r\n            broadEff: 0.0001,\r\n            collisions: 0,\r\n            buckets: 0,\r\n            bodies: 0,\r\n            pairs: 0\r\n        };\r\n\r\n        return Common.extend(defaults, false, options);\r\n    };\r\n\r\n    /**\r\n     * Resets metrics.\r\n     * @method reset\r\n     * @private\r\n     * @param {metrics} metrics\r\n     */\r\n    Metrics.reset = function(metrics) {\r\n        if (metrics.extended) {\r\n            metrics.narrowDetections = 0;\r\n            metrics.narrowphaseTests = 0;\r\n            metrics.narrowReuse = 0;\r\n            metrics.narrowReuseCount = 0;\r\n            metrics.midphaseTests = 0;\r\n            metrics.broadphaseTests = 0;\r\n            metrics.narrowEff = 0;\r\n            metrics.midEff = 0;\r\n            metrics.broadEff = 0;\r\n            metrics.collisions = 0;\r\n            metrics.buckets = 0;\r\n            metrics.pairs = 0;\r\n            metrics.bodies = 0;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Updates metrics.\r\n     * @method update\r\n     * @private\r\n     * @param {metrics} metrics\r\n     * @param {engine} engine\r\n     */\r\n    Metrics.update = function(metrics, engine) {\r\n        if (metrics.extended) {\r\n            var world = engine.world,\r\n                bodies = Composite.allBodies(world);\r\n\r\n            metrics.collisions = metrics.narrowDetections;\r\n            metrics.pairs = engine.pairs.list.length;\r\n            metrics.bodies = bodies.length;\r\n            metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);\r\n            metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);\r\n            metrics.broadEff = (1 - (metrics.broadphaseTests / (bodies.length || 1))).toFixed(2);\r\n            metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);\r\n            //var broadphase = engine.broadphase[engine.broadphase.current];\r\n            //if (broadphase.instance)\r\n            //    metrics.buckets = Common.keys(broadphase.instance.buckets).length;\r\n        }\r\n    };\r\n\r\n})();\r\n// @endif\r\n","/**\r\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\r\n*\r\n* @class Plugin\r\n*/\r\n\r\nvar Plugin = {};\r\n\r\nmodule.exports = Plugin;\r\n\r\nvar Common = require('./Common');\r\n\r\n(function() {\r\n\r\n    Plugin._registry = {};\r\n\r\n    /**\r\n     * Registers a plugin object so it can be resolved later by name.\r\n     * @method register\r\n     * @param plugin {} The plugin to register.\r\n     * @return {object} The plugin.\r\n     */\r\n    Plugin.register = function(plugin) {\r\n        if (!Plugin.isPlugin(plugin)) {\r\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\r\n        }\r\n\r\n        if (plugin.name in Plugin._registry) {\r\n            var registered = Plugin._registry[plugin.name],\r\n                pluginVersion = Plugin.versionParse(plugin.version).number,\r\n                registeredVersion = Plugin.versionParse(registered.version).number;\r\n\r\n            if (pluginVersion > registeredVersion) {\r\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\r\n                Plugin._registry[plugin.name] = plugin;\r\n            } else if (pluginVersion < registeredVersion) {\r\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\r\n            } else if (plugin !== registered) {\r\n                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\r\n            }\r\n        } else {\r\n            Plugin._registry[plugin.name] = plugin;\r\n        }\r\n\r\n        return plugin;\r\n    };\r\n\r\n    /**\r\n     * Resolves a dependency to a plugin object from the registry if it exists. \r\n     * The `dependency` may contain a version, but only the name matters when resolving.\r\n     * @method resolve\r\n     * @param dependency {string} The dependency.\r\n     * @return {object} The plugin if resolved, otherwise `undefined`.\r\n     */\r\n    Plugin.resolve = function(dependency) {\r\n        return Plugin._registry[Plugin.dependencyParse(dependency).name];\r\n    };\r\n\r\n    /**\r\n     * Returns a pretty printed plugin name and version.\r\n     * @method toString\r\n     * @param plugin {} The plugin.\r\n     * @return {string} Pretty printed plugin name and version.\r\n     */\r\n    Plugin.toString = function(plugin) {\r\n        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\r\n     * This means it must define the following properties:\r\n     * - `name`\r\n     * - `version`\r\n     * - `install`\r\n     * @method isPlugin\r\n     * @param obj {} The obj to test.\r\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\r\n     */\r\n    Plugin.isPlugin = function(obj) {\r\n        return obj && obj.name && obj.version && obj.install;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\r\n     * @method isUsed\r\n     * @param module {} The module.\r\n     * @param name {string} The plugin name.\r\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\r\n     */\r\n    Plugin.isUsed = function(module, name) {\r\n        return module.used.indexOf(name) > -1;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\r\n     * If `plugin.for` is not specified then it is assumed to be applicable.\r\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\r\n     * @method isFor\r\n     * @param plugin {} The plugin.\r\n     * @param module {} The module.\r\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\r\n     */\r\n    Plugin.isFor = function(plugin, module) {\r\n        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\r\n        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));\r\n    };\r\n\r\n    /**\r\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\r\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\r\n     * Plugins may be specified either by their name or a reference to the plugin object.\r\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\r\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\r\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\r\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\r\n     * - A green tick  indicates a dependency was resolved and installed.\r\n     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\r\n     * - A red cross  indicates a dependency could not be resolved.\r\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param module {} The module install plugins on.\r\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\r\n     */\r\n    Plugin.use = function(module, plugins) {\r\n        module.uses = (module.uses || []).concat(plugins || []);\r\n\r\n        if (module.uses.length === 0) {\r\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\r\n            return;\r\n        }\r\n\r\n        var dependencies = Plugin.dependencies(module),\r\n            sortedDependencies = Common.topologicalSort(dependencies),\r\n            status = [];\r\n\r\n        for (var i = 0; i < sortedDependencies.length; i += 1) {\r\n            if (sortedDependencies[i] === module.name) {\r\n                continue;\r\n            }\r\n\r\n            var plugin = Plugin.resolve(sortedDependencies[i]);\r\n\r\n            if (!plugin) {\r\n                status.push(' ' + sortedDependencies[i]);\r\n                continue;\r\n            }\r\n\r\n            if (Plugin.isUsed(module, plugin.name)) {\r\n                continue;\r\n            }\r\n\r\n            if (!Plugin.isFor(plugin, module)) {\r\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\r\n                plugin._warned = true;\r\n            }\r\n\r\n            if (plugin.install) {\r\n                plugin.install(module);\r\n            } else {\r\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\r\n                plugin._warned = true;\r\n            }\r\n\r\n            if (plugin._warned) {\r\n                status.push(' ' + Plugin.toString(plugin));\r\n                delete plugin._warned;\r\n            } else {\r\n                status.push(' ' + Plugin.toString(plugin));\r\n            }\r\n\r\n            module.used.push(plugin.name);\r\n        }\r\n\r\n        if (status.length > 0 && !plugin.silent) {\r\n            Common.info(status.join('  '));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\r\n     * @method dependencies\r\n     * @param module {} The module.\r\n     * @return {object} A dependency graph.\r\n     */\r\n    Plugin.dependencies = function(module, tracked) {\r\n        var parsedBase = Plugin.dependencyParse(module),\r\n            name = parsedBase.name;\r\n\r\n        tracked = tracked || {};\r\n\r\n        if (name in tracked) {\r\n            return;\r\n        }\r\n\r\n        module = Plugin.resolve(module) || module;\r\n\r\n        tracked[name] = Common.map(module.uses || [], function(dependency) {\r\n            if (Plugin.isPlugin(dependency)) {\r\n                Plugin.register(dependency);\r\n            }\r\n\r\n            var parsed = Plugin.dependencyParse(dependency),\r\n                resolved = Plugin.resolve(dependency);\r\n\r\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\r\n                Common.warn(\r\n                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',\r\n                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'\r\n                );\r\n\r\n                resolved._warned = true;\r\n                module._warned = true;\r\n            } else if (!resolved) {\r\n                Common.warn(\r\n                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',\r\n                    Plugin.toString(parsedBase), 'could not be resolved.'\r\n                );\r\n\r\n                module._warned = true;\r\n            }\r\n\r\n            return parsed.name;\r\n        });\r\n\r\n        for (var i = 0; i < tracked[name].length; i += 1) {\r\n            Plugin.dependencies(tracked[name][i], tracked);\r\n        }\r\n\r\n        return tracked;\r\n    };\r\n\r\n    /**\r\n     * Parses a dependency string into its components.\r\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\r\n     * See documentation for `Plugin.versionParse` for a description of the format.\r\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\r\n     * @method dependencyParse\r\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\r\n     * @return {object} The dependency parsed into its components.\r\n     */\r\n    Plugin.dependencyParse = function(dependency) {\r\n        if (Common.isString(dependency)) {\r\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/;\r\n\r\n            if (!pattern.test(dependency)) {\r\n                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\r\n            }\r\n\r\n            return {\r\n                name: dependency.split('@')[0],\r\n                range: dependency.split('@')[1] || '*'\r\n            };\r\n        }\r\n\r\n        return {\r\n            name: dependency.name,\r\n            range: dependency.range || dependency.version\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Parses a version string into its components.  \r\n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\r\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\r\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\r\n     * Only the following range types are supported:\r\n     * - Tilde ranges e.g. `~1.2.3`\r\n     * - Caret ranges e.g. `^1.2.3`\r\n     * - Exact version e.g. `1.2.3`\r\n     * - Any version `*`\r\n     * @method versionParse\r\n     * @param range {string} The version string.\r\n     * @return {object} The version range parsed into its components.\r\n     */\r\n    Plugin.versionParse = function(range) {\r\n        var pattern = /^\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?$/;\r\n\r\n        if (!pattern.test(range)) {\r\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\r\n        }\r\n\r\n        var identifiers = range.split('-');\r\n        range = identifiers[0];\r\n\r\n        var isRange = isNaN(Number(range[0])),\r\n            version = isRange ? range.substr(1) : range,\r\n            parts = Common.map(version.split('.'), function(part) {\r\n                return Number(part);\r\n            });\r\n\r\n        return {\r\n            isRange: isRange,\r\n            version: version,\r\n            range: range,\r\n            operator: isRange ? range[0] : '',\r\n            parts: parts,\r\n            prerelease: identifiers[1],\r\n            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if `version` satisfies the given `range`.\r\n     * See documentation for `Plugin.versionParse` for a description of the format.\r\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\r\n     * @method versionSatisfies\r\n     * @param version {string} The version string.\r\n     * @param range {string} The range string.\r\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\r\n     */\r\n    Plugin.versionSatisfies = function(version, range) {\r\n        range = range || '*';\r\n\r\n        var rangeParsed = Plugin.versionParse(range),\r\n            rangeParts = rangeParsed.parts,\r\n            versionParsed = Plugin.versionParse(version),\r\n            versionParts = versionParsed.parts;\r\n\r\n        if (rangeParsed.isRange) {\r\n            if (rangeParsed.operator === '*' || version === '*') {\r\n                return true;\r\n            }\r\n\r\n            if (rangeParsed.operator === '~') {\r\n                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];\r\n            }\r\n\r\n            if (rangeParsed.operator === '^') {\r\n                if (rangeParts[0] > 0) {\r\n                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;\r\n                }\r\n\r\n                if (rangeParts[1] > 0) {\r\n                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];\r\n                }\r\n\r\n                return versionParts[2] === rangeParts[2];\r\n            }\r\n        }\r\n\r\n        return version === range || version === '*';\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\r\n*\r\n* @class Sleeping\r\n*/\r\n\r\nvar Sleeping = {};\r\n\r\nmodule.exports = Sleeping;\r\n\r\nvar Events = require('./Events');\r\n\r\n(function() {\r\n\r\n    Sleeping._motionWakeThreshold = 0.18;\r\n    Sleeping._motionSleepThreshold = 0.08;\r\n    Sleeping._minBias = 0.9;\r\n\r\n    /**\r\n     * Puts bodies to sleep or wakes them up depending on their motion.\r\n     * @method update\r\n     * @param {body[]} bodies\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.update = function(bodies, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // update bodies sleeping status\r\n        for (var i = 0; i < bodies.length; i++) {\r\n            var body = bodies[i],\r\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\r\n\r\n            // wake up bodies if they have a force applied\r\n            if (body.force.x !== 0 || body.force.y !== 0) {\r\n                Sleeping.set(body, false);\r\n                continue;\r\n            }\r\n\r\n            var minMotion = Math.min(body.motion, motion),\r\n                maxMotion = Math.max(body.motion, motion);\r\n        \r\n            // biased average motion estimation between frames\r\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\r\n            \r\n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\r\n                body.sleepCounter += 1;\r\n                \r\n                if (body.sleepCounter >= body.sleepThreshold)\r\n                    Sleeping.set(body, true);\r\n            } else if (body.sleepCounter > 0) {\r\n                body.sleepCounter -= 1;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\r\n     * @method afterCollisions\r\n     * @param {pair[]} pairs\r\n     * @param {number} timeScale\r\n     */\r\n    Sleeping.afterCollisions = function(pairs, timeScale) {\r\n        var timeFactor = timeScale * timeScale * timeScale;\r\n\r\n        // wake up bodies involved in collisions\r\n        for (var i = 0; i < pairs.length; i++) {\r\n            var pair = pairs[i];\r\n            \r\n            // don't wake inactive pairs\r\n            if (!pair.isActive)\r\n                continue;\r\n\r\n            var collision = pair.collision,\r\n                bodyA = collision.bodyA.parent, \r\n                bodyB = collision.bodyB.parent;\r\n        \r\n            // don't wake if at least one body is static\r\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\r\n                continue;\r\n        \r\n            if (bodyA.isSleeping || bodyB.isSleeping) {\r\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\r\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\r\n\r\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\r\n                    Sleeping.set(sleepingBody, false);\r\n                }\r\n            }\r\n        }\r\n    };\r\n  \r\n    /**\r\n     * Set a body as sleeping or awake.\r\n     * @method set\r\n     * @param {body} body\r\n     * @param {boolean} isSleeping\r\n     */\r\n    Sleeping.set = function(body, isSleeping) {\r\n        var wasSleeping = body.isSleeping;\r\n\r\n        if (isSleeping) {\r\n            body.isSleeping = true;\r\n            body.sleepCounter = body.sleepThreshold;\r\n\r\n            body.positionImpulse.x = 0;\r\n            body.positionImpulse.y = 0;\r\n\r\n            body.positionPrev.x = body.position.x;\r\n            body.positionPrev.y = body.position.y;\r\n\r\n            body.anglePrev = body.angle;\r\n            body.speed = 0;\r\n            body.angularSpeed = 0;\r\n            body.motion = 0;\r\n\r\n            if (!wasSleeping) {\r\n                Events.trigger(body, 'sleepStart');\r\n            }\r\n        } else {\r\n            body.isSleeping = false;\r\n            body.sleepCounter = 0;\r\n\r\n            if (wasSleeping) {\r\n                Events.trigger(body, 'sleepEnd');\r\n            }\r\n        }\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \r\n* with commonly used body configurations (such as rectangles, circles and other polygons).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Bodies\r\n*/\r\n\r\n// TODO: true circle bodies\r\n\r\nvar Bodies = {};\r\n\r\nmodule.exports = Bodies;\r\n\r\nvar Vertices = require('../geometry/Vertices');\r\nvar Common = require('../core/Common');\r\nvar Body = require('../body/Body');\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Vector = require('../geometry/Vector');\r\nvar decomp = require('../../poly-decomp');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new rigid body model with a rectangle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method rectangle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {object} [options]\r\n     * @return {body} A new rectangle body\r\n     */\r\n    Bodies.rectangle = function(x, y, width, height, options) {\r\n        options = options || {};\r\n\r\n        var rectangle = { \r\n            label: 'Rectangle Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, rectangle, options));\r\n    };\r\n    \r\n    /**\r\n     * Creates a new rigid body model with a trapezoid hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method trapezoid\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} slope\r\n     * @param {object} [options]\r\n     * @return {body} A new trapezoid body\r\n     */\r\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\r\n        options = options || {};\r\n\r\n        slope *= 0.5;\r\n        var roof = (1 - (slope * 2)) * width;\r\n        \r\n        var x1 = width * slope,\r\n            x2 = x1 + roof,\r\n            x3 = x2 + x1,\r\n            verticesPath;\r\n\r\n        if (slope < 0.5) {\r\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        } else {\r\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\r\n        }\r\n\r\n        var trapezoid = { \r\n            label: 'Trapezoid Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(verticesPath)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, trapezoid, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a circle hull. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method circle\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @param {number} [maxSides]\r\n     * @return {body} A new circle body\r\n     */\r\n    Bodies.circle = function(x, y, radius, options, maxSides) {\r\n        options = options || {};\r\n\r\n        var circle = {\r\n            label: 'Circle Body',\r\n            circleRadius: radius\r\n        };\r\n        \r\n        // approximate circles with polygons until true circles implemented in SAT\r\n        maxSides = maxSides || 25;\r\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\r\n\r\n        // optimisation: always use even number of sides (half the number of unique axes)\r\n        if (sides % 2 === 1)\r\n            sides += 1;\r\n\r\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \r\n     * The options parameter is an object that specifies any properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method polygon\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {number} sides\r\n     * @param {number} radius\r\n     * @param {object} [options]\r\n     * @return {body} A new regular polygon body\r\n     */\r\n    Bodies.polygon = function(x, y, sides, radius, options) {\r\n        options = options || {};\r\n\r\n        if (sides < 3)\r\n            return Bodies.circle(x, y, radius, options);\r\n\r\n        var theta = 2 * Math.PI / sides,\r\n            path = '',\r\n            offset = theta * 0.5;\r\n\r\n        for (var i = 0; i < sides; i += 1) {\r\n            var angle = offset + (i * theta),\r\n                xx = Math.cos(angle) * radius,\r\n                yy = Math.sin(angle) * radius;\r\n\r\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\r\n        }\r\n\r\n        var polygon = { \r\n            label: 'Polygon Body',\r\n            position: { x: x, y: y },\r\n            vertices: Vertices.fromPath(path)\r\n        };\r\n\r\n        if (options.chamfer) {\r\n            var chamfer = options.chamfer;\r\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \r\n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\r\n            delete options.chamfer;\r\n        }\r\n\r\n        return Body.create(Common.extend({}, polygon, options));\r\n    };\r\n\r\n    /**\r\n     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).\r\n     * If the vertices are convex, they will pass through as supplied.\r\n     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.\r\n     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).\r\n     * By default the decomposition will discard collinear edges (to improve performance).\r\n     * It can also optionally discard any parts that have an area less than `minimumArea`.\r\n     * If the vertices can not be decomposed, the result will fall back to using the convex hull.\r\n     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.\r\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\r\n     * @method fromVertices\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param [[vector]] vertexSets\r\n     * @param {object} [options]\r\n     * @param {bool} [flagInternal=false]\r\n     * @param {number} [removeCollinear=0.01]\r\n     * @param {number} [minimumArea=10]\r\n     * @return {body}\r\n     */\r\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {\r\n        var body,\r\n            parts,\r\n            isConvex,\r\n            vertices,\r\n            i,\r\n            j,\r\n            k,\r\n            v,\r\n            z;\r\n\r\n        options = options || {};\r\n        parts = [];\r\n\r\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\r\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\r\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\r\n\r\n        if (!decomp) {\r\n            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');\r\n        }\r\n\r\n        // ensure vertexSets is an array of arrays\r\n        if (!Common.isArray(vertexSets[0])) {\r\n            vertexSets = [vertexSets];\r\n        }\r\n\r\n        for (v = 0; v < vertexSets.length; v += 1) {\r\n            vertices = vertexSets[v];\r\n            isConvex = Vertices.isConvex(vertices);\r\n\r\n            if (isConvex || !decomp) {\r\n                if (isConvex) {\r\n                    vertices = Vertices.clockwiseSort(vertices);\r\n                } else {\r\n                    // fallback to convex hull when decomposition is not possible\r\n                    vertices = Vertices.hull(vertices);\r\n                }\r\n\r\n                parts.push({\r\n                    position: { x: x, y: y },\r\n                    vertices: vertices\r\n                });\r\n            } else {\r\n                // initialise a decomposition\r\n                var concave = vertices.map(function(vertex) {\r\n                    return [vertex.x, vertex.y];\r\n                });\r\n\r\n                // vertices are concave and simple, we can decompose into parts\r\n                decomp.makeCCW(concave);\r\n                if (removeCollinear !== false)\r\n                    decomp.removeCollinearPoints(concave, removeCollinear);\r\n\r\n                // use the quick decomposition algorithm (Bayazit)\r\n                var decomposed = decomp.quickDecomp(concave);\r\n\r\n                // for each decomposed chunk\r\n                for (i = 0; i < decomposed.length; i++) {\r\n                    var chunk = decomposed[i];\r\n\r\n                    // convert vertices into the correct structure\r\n                    var chunkVertices = chunk.map(function(vertices) {\r\n                        return {\r\n                            x: vertices[0],\r\n                            y: vertices[1]\r\n                        };\r\n                    });\r\n\r\n                    // skip small chunks\r\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\r\n                        continue;\r\n\r\n                    // create a compound part\r\n                    parts.push({\r\n                        position: Vertices.centre(chunkVertices),\r\n                        vertices: chunkVertices\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // create body parts\r\n        for (i = 0; i < parts.length; i++) {\r\n            parts[i] = Body.create(Common.extend(parts[i], options));\r\n        }\r\n\r\n        if (flagInternal)\r\n        {\r\n            Bodies.flagCoincidentParts(parts, 5);\r\n        }\r\n\r\n        if (parts.length > 1) {\r\n            // create the parent body to be returned, that contains generated compound parts\r\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\r\n            Body.setPosition(body, { x: x, y: y });\r\n\r\n            return body;\r\n        } else {\r\n            return parts[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Takes an array of Body objects and flags all internal edges (coincident parts) based on the maxDistance\r\n     * value. The array is changed in-place and returned, so you can pass this function a `Body.parts` property.\r\n     * \r\n     * @method flagCoincidentParts\r\n     * @param {body[]} parts - The Body parts, or array of bodies, to flag.\r\n     * @param {number} [maxDistance=5]\r\n     * @return {body[]} The modified `parts` parameter.\r\n     */\r\n    Bodies.flagCoincidentParts = function (parts, maxDistance)\r\n    {\r\n        if (maxDistance === undefined) { maxDistance = 5; }\r\n\r\n        for (var i = 0; i < parts.length; i++)\r\n        {\r\n            var partA = parts[i];\r\n\r\n            for (var j = i + 1; j < parts.length; j++)\r\n            {\r\n                var partB = parts[j];\r\n\r\n                if (Bounds.overlaps(partA.bounds, partB.bounds))\r\n                {\r\n                    var pav = partA.vertices;\r\n                    var pbv = partB.vertices;\r\n\r\n                    // iterate vertices of both parts\r\n                    for (var k = 0; k < partA.vertices.length; k++)\r\n                    {\r\n                        for (var z = 0; z < partB.vertices.length; z++)\r\n                        {\r\n                            // find distances between the vertices\r\n                            var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z]));\r\n                            var db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\r\n\r\n                            // if both vertices are very close, consider the edge concident (internal)\r\n                            if (da < maxDistance && db < maxDistance)\r\n                            {\r\n                                pav[k].isInternal = true;\r\n                                pbv[z].isInternal = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return parts;\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Composites` module contains factory methods for creating composite bodies\r\n* with commonly used configurations (such as stacks and chains).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Composites\r\n*/\r\n\r\nvar Composites = {};\r\n\r\nmodule.exports = Composites;\r\n\r\nvar Composite = require('../body/Composite');\r\nvar Constraint = require('../constraint/Constraint');\r\nvar Common = require('../core/Common');\r\nvar Body = require('../body/Body');\r\nvar Bodies = require('./Bodies');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method stack\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */\r\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\r\n        var stack = Composite.create({ label: 'Stack' }),\r\n            x = xx,\r\n            y = yy,\r\n            lastBody,\r\n            i = 0;\r\n\r\n        for (var row = 0; row < rows; row++) {\r\n            var maxHeight = 0;\r\n            \r\n            for (var column = 0; column < columns; column++) {\r\n                var body = callback(x, y, column, row, lastBody, i);\r\n                    \r\n                if (body) {\r\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\r\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \r\n\r\n                    if (bodyHeight > maxHeight)\r\n                        maxHeight = bodyHeight;\r\n                    \r\n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\r\n\r\n                    x = body.bounds.max.x + columnGap;\r\n\r\n                    Composite.addBody(stack, body);\r\n                    \r\n                    lastBody = body;\r\n                    i += 1;\r\n                } else {\r\n                    x += columnGap;\r\n                }\r\n            }\r\n            \r\n            y += maxHeight + rowGap;\r\n            x = xx;\r\n        }\r\n\r\n        return stack;\r\n    };\r\n    \r\n    /**\r\n     * Chains all bodies in the given composite together using constraints.\r\n     * @method chain\r\n     * @param {composite} composite\r\n     * @param {number} xOffsetA\r\n     * @param {number} yOffsetA\r\n     * @param {number} xOffsetB\r\n     * @param {number} yOffsetB\r\n     * @param {object} options\r\n     * @return {composite} A new composite containing objects chained together with constraints\r\n     */\r\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\r\n        var bodies = composite.bodies;\r\n        \r\n        for (var i = 1; i < bodies.length; i++) {\r\n            var bodyA = bodies[i - 1],\r\n                bodyB = bodies[i],\r\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\r\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \r\n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\r\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\r\n        \r\n            var defaults = {\r\n                bodyA: bodyA,\r\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\r\n                bodyB: bodyB,\r\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\r\n            };\r\n            \r\n            var constraint = Common.extend(defaults, options);\r\n        \r\n            Composite.addConstraint(composite, Constraint.create(constraint));\r\n        }\r\n\r\n        composite.label += ' Chain';\r\n        \r\n        return composite;\r\n    };\r\n\r\n    /**\r\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\r\n     * @method mesh\r\n     * @param {composite} composite\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {boolean} crossBrace\r\n     * @param {object} options\r\n     * @return {composite} The composite containing objects meshed together with constraints\r\n     */\r\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\r\n        var bodies = composite.bodies,\r\n            row,\r\n            col,\r\n            bodyA,\r\n            bodyB,\r\n            bodyC;\r\n        \r\n        for (row = 0; row < rows; row++) {\r\n            for (col = 1; col < columns; col++) {\r\n                bodyA = bodies[(col - 1) + (row * columns)];\r\n                bodyB = bodies[col + (row * columns)];\r\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\r\n            }\r\n\r\n            if (row > 0) {\r\n                for (col = 0; col < columns; col++) {\r\n                    bodyA = bodies[col + ((row - 1) * columns)];\r\n                    bodyB = bodies[col + (row * columns)];\r\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\r\n\r\n                    if (crossBrace && col > 0) {\r\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\r\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\r\n                    }\r\n\r\n                    if (crossBrace && col < columns - 1) {\r\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\r\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        composite.label += ' Mesh';\r\n        \r\n        return composite;\r\n    };\r\n    \r\n    /**\r\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\r\n     * This function uses the body's bounds to prevent overlaps.\r\n     * @method pyramid\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {function} callback\r\n     * @return {composite} A new composite containing objects created in the callback\r\n     */\r\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\r\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\r\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\r\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\r\n            \r\n            if (row > actualRows)\r\n                return;\r\n            \r\n            // reverse row order\r\n            row = actualRows - row;\r\n            \r\n            var start = row,\r\n                end = columns - 1 - row;\r\n\r\n            if (column < start || column > end)\r\n                return;\r\n            \r\n            // retroactively fix the first body's position, since width was unknown\r\n            if (i === 1) {\r\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\r\n            }\r\n\r\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\r\n            \r\n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Creates a composite with a Newton's Cradle setup of bodies and constraints.\r\n     * @method newtonsCradle\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} number\r\n     * @param {number} size\r\n     * @param {number} length\r\n     * @return {composite} A new composite newtonsCradle body\r\n     */\r\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\r\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\r\n\r\n        for (var i = 0; i < number; i++) {\r\n            var separation = 1.9,\r\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, \r\n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\r\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\r\n\r\n            Composite.addBody(newtonsCradle, circle);\r\n            Composite.addConstraint(newtonsCradle, constraint);\r\n        }\r\n\r\n        return newtonsCradle;\r\n    };\r\n    \r\n    /**\r\n     * Creates a composite with simple car setup of bodies and constraints.\r\n     * @method car\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @param {number} wheelSize\r\n     * @return {composite} A new composite car body\r\n     */\r\n    Composites.car = function(xx, yy, width, height, wheelSize) {\r\n        var group = Body.nextGroup(true),\r\n            wheelBase = 20,\r\n            wheelAOffset = -width * 0.5 + wheelBase,\r\n            wheelBOffset = width * 0.5 - wheelBase,\r\n            wheelYOffset = 0;\r\n    \r\n        var car = Composite.create({ label: 'Car' }),\r\n            body = Bodies.rectangle(xx, yy, width, height, { \r\n                collisionFilter: {\r\n                    group: group\r\n                },\r\n                chamfer: {\r\n                    radius: height * 0.5\r\n                },\r\n                density: 0.0002\r\n            });\r\n    \r\n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { \r\n            collisionFilter: {\r\n                group: group\r\n            },\r\n            friction: 0.8\r\n        });\r\n                    \r\n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { \r\n            collisionFilter: {\r\n                group: group\r\n            },\r\n            friction: 0.8\r\n        });\r\n                    \r\n        var axelA = Constraint.create({\r\n            bodyB: body,\r\n            pointB: { x: wheelAOffset, y: wheelYOffset },\r\n            bodyA: wheelA,\r\n            stiffness: 1,\r\n            length: 0\r\n        });\r\n                        \r\n        var axelB = Constraint.create({\r\n            bodyB: body,\r\n            pointB: { x: wheelBOffset, y: wheelYOffset },\r\n            bodyA: wheelB,\r\n            stiffness: 1,\r\n            length: 0\r\n        });\r\n        \r\n        Composite.addBody(car, body);\r\n        Composite.addBody(car, wheelA);\r\n        Composite.addBody(car, wheelB);\r\n        Composite.addConstraint(car, axelA);\r\n        Composite.addConstraint(car, axelB);\r\n\r\n        return car;\r\n    };\r\n\r\n    /**\r\n     * Creates a simple soft body like object.\r\n     * @method softBody\r\n     * @param {number} xx\r\n     * @param {number} yy\r\n     * @param {number} columns\r\n     * @param {number} rows\r\n     * @param {number} columnGap\r\n     * @param {number} rowGap\r\n     * @param {boolean} crossBrace\r\n     * @param {number} particleRadius\r\n     * @param {} particleOptions\r\n     * @param {} constraintOptions\r\n     * @return {composite} A new composite softBody\r\n     */\r\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\r\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\r\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\r\n\r\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\r\n            return Bodies.circle(x, y, particleRadius, particleOptions);\r\n        });\r\n\r\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\r\n\r\n        softBody.label = 'Soft Body';\r\n\r\n        return softBody;\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\r\n*\r\n* @class Axes\r\n*/\r\n\r\nvar Axes = {};\r\n\r\nmodule.exports = Axes;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new set of axes from the given vertices.\r\n     * @method fromVertices\r\n     * @param {vertices} vertices\r\n     * @return {axes} A new axes from the given vertices\r\n     */\r\n    Axes.fromVertices = function(vertices) {\r\n        var axes = {};\r\n\r\n        // find the unique axes, using edge normal gradients\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var j = (i + 1) % vertices.length, \r\n                normal = Vector.normalise({ \r\n                    x: vertices[j].y - vertices[i].y, \r\n                    y: vertices[i].x - vertices[j].x\r\n                }),\r\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\r\n            \r\n            // limit precision\r\n            gradient = gradient.toFixed(3).toString();\r\n            axes[gradient] = normal;\r\n        }\r\n\r\n        return Common.values(axes);\r\n    };\r\n\r\n    /**\r\n     * Rotates a set of axes by the given angle.\r\n     * @method rotate\r\n     * @param {axes} axes\r\n     * @param {number} angle\r\n     */\r\n    Axes.rotate = function(axes, angle) {\r\n        if (angle === 0)\r\n            return;\r\n        \r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle);\r\n\r\n        for (var i = 0; i < axes.length; i++) {\r\n            var axis = axes[i],\r\n                xx;\r\n            xx = axis.x * cos - axis.y * sin;\r\n            axis.y = axis.x * sin + axis.y * cos;\r\n            axis.x = xx;\r\n        }\r\n    };\r\n\r\n})();\r\n","/**\r\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\r\n*\r\n* @class Bounds\r\n*/\r\n\r\nvar Bounds = {};\r\n\r\nmodule.exports = Bounds;\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\r\n     * @method create\r\n     * @param {vertices} vertices\r\n     * @return {bounds} A new bounds object\r\n     */\r\n    Bounds.create = function(vertices) {\r\n        var bounds = { \r\n            min: { x: 0, y: 0 }, \r\n            max: { x: 0, y: 0 }\r\n        };\r\n\r\n        if (vertices)\r\n            Bounds.update(bounds, vertices);\r\n        \r\n        return bounds;\r\n    };\r\n\r\n    /**\r\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\r\n     * @method update\r\n     * @param {bounds} bounds\r\n     * @param {vertices} vertices\r\n     * @param {vector} velocity\r\n     */\r\n    Bounds.update = function(bounds, vertices, velocity) {\r\n        bounds.min.x = Infinity;\r\n        bounds.max.x = -Infinity;\r\n        bounds.min.y = Infinity;\r\n        bounds.max.y = -Infinity;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertex = vertices[i];\r\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\r\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\r\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\r\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\r\n        }\r\n        \r\n        if (velocity) {\r\n            if (velocity.x > 0) {\r\n                bounds.max.x += velocity.x;\r\n            } else {\r\n                bounds.min.x += velocity.x;\r\n            }\r\n            \r\n            if (velocity.y > 0) {\r\n                bounds.max.y += velocity.y;\r\n            } else {\r\n                bounds.min.y += velocity.y;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns true if the bounds contains the given point.\r\n     * @method contains\r\n     * @param {bounds} bounds\r\n     * @param {vector} point\r\n     * @return {boolean} True if the bounds contain the point, otherwise false\r\n     */\r\n    Bounds.contains = function(bounds, point) {\r\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \r\n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the two bounds intersect.\r\n     * @method overlaps\r\n     * @param {bounds} boundsA\r\n     * @param {bounds} boundsB\r\n     * @return {boolean} True if the bounds overlap, otherwise false\r\n     */\r\n    Bounds.overlaps = function(boundsA, boundsB) {\r\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\r\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\r\n    };\r\n\r\n    /**\r\n     * Translates the bounds by the given vector.\r\n     * @method translate\r\n     * @param {bounds} bounds\r\n     * @param {vector} vector\r\n     */\r\n    Bounds.translate = function(bounds, vector) {\r\n        bounds.min.x += vector.x;\r\n        bounds.max.x += vector.x;\r\n        bounds.min.y += vector.y;\r\n        bounds.max.y += vector.y;\r\n    };\r\n\r\n    /**\r\n     * Shifts the bounds to the given position.\r\n     * @method shift\r\n     * @param {bounds} bounds\r\n     * @param {vector} position\r\n     */\r\n    Bounds.shift = function(bounds, position) {\r\n        var deltaX = bounds.max.x - bounds.min.x,\r\n            deltaY = bounds.max.y - bounds.min.y;\r\n            \r\n        bounds.min.x = position.x;\r\n        bounds.max.x = position.x + deltaX;\r\n        bounds.min.y = position.y;\r\n        bounds.max.y = position.y + deltaY;\r\n    };\r\n    \r\n})();\r\n","/**\r\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\r\n*\r\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Svg\r\n*/\r\n\r\nvar Svg = {};\r\n\r\nmodule.exports = Svg;\r\n\r\nvar Bounds = require('../geometry/Bounds');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Converts an SVG path into an array of vector points.\r\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\r\n     * See `Bodies.fromVertices` which provides support for this.\r\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\r\n     * You must load the `pathseg.js` polyfill on newer browsers.\r\n     * @method pathToVertices\r\n     * @param {SVGPathElement} path\r\n     * @param {Number} [sampleLength=15]\r\n     * @return {Vector[]} points\r\n     */\r\n    Svg.pathToVertices = function(path, sampleLength) {\r\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\r\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\r\n        }\r\n\r\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\r\n        var i, il, total, point, segment, segments, \r\n            segmentsQueue, lastSegment, \r\n            lastPoint, segmentIndex, points = [],\r\n            lx, ly, length = 0, x = 0, y = 0;\r\n\r\n        sampleLength = sampleLength || 15;\r\n\r\n        var addPoint = function(px, py, pathSegType) {\r\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\r\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\r\n\r\n            // when the last point doesn't equal the current point add the current point\r\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\r\n                if (lastPoint && isRelative) {\r\n                    lx = lastPoint.x;\r\n                    ly = lastPoint.y;\r\n                } else {\r\n                    lx = 0;\r\n                    ly = 0;\r\n                }\r\n\r\n                var point = {\r\n                    x: lx + px,\r\n                    y: ly + py\r\n                };\r\n\r\n                // set last point\r\n                if (isRelative || !lastPoint) {\r\n                    lastPoint = point;\r\n                }\r\n\r\n                points.push(point);\r\n\r\n                x = lx + px;\r\n                y = ly + py;\r\n            }\r\n        };\r\n\r\n        var addSegmentPoint = function(segment) {\r\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\r\n\r\n            // skip path ends\r\n            if (segType === 'Z') \r\n                return;\r\n\r\n            // map segment to x and y\r\n            switch (segType) {\r\n\r\n            case 'M':\r\n            case 'L':\r\n            case 'T':\r\n            case 'C':\r\n            case 'S':\r\n            case 'Q':\r\n                x = segment.x;\r\n                y = segment.y;\r\n                break;\r\n            case 'H':\r\n                x = segment.x;\r\n                break;\r\n            case 'V':\r\n                y = segment.y;\r\n                break;\r\n            }\r\n\r\n            addPoint(x, y, segment.pathSegType);\r\n        };\r\n\r\n        // ensure path is absolute\r\n        Svg._svgPathToAbsolute(path);\r\n\r\n        // get total length\r\n        total = path.getTotalLength();\r\n\r\n        // queue segments\r\n        segments = [];\r\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\r\n            segments.push(path.pathSegList.getItem(i));\r\n\r\n        segmentsQueue = segments.concat();\r\n\r\n        // sample through path\r\n        while (length < total) {\r\n            // get segment at position\r\n            segmentIndex = path.getPathSegAtLength(length);\r\n            segment = segments[segmentIndex];\r\n\r\n            // new segment\r\n            if (segment != lastSegment) {\r\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\r\n                    addSegmentPoint(segmentsQueue.shift());\r\n\r\n                lastSegment = segment;\r\n            }\r\n\r\n            // add points in between when curving\r\n            // TODO: adaptive sampling\r\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\r\n\r\n            case 'C':\r\n            case 'T':\r\n            case 'S':\r\n            case 'Q':\r\n            case 'A':\r\n                point = path.getPointAtLength(length);\r\n                addPoint(point.x, point.y, 0);\r\n                break;\r\n\r\n            }\r\n\r\n            // increment by sample value\r\n            length += sampleLength;\r\n        }\r\n\r\n        // add remaining segments not passed by sampling\r\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\r\n            addSegmentPoint(segmentsQueue[i]);\r\n\r\n        return points;\r\n    };\r\n\r\n    Svg._svgPathToAbsolute = function(path) {\r\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\r\n        // Copyright (c) Gavin Kistner\r\n        // http://phrogz.net/js/_ReuseLicense.txt\r\n        // Modifications: tidy formatting and naming\r\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\r\n            x = 0, y = 0, len = segs.numberOfItems;\r\n\r\n        for (var i = 0; i < len; ++i) {\r\n            var seg = segs.getItem(i),\r\n                segType = seg.pathSegTypeAsLetter;\r\n\r\n            if (/[MLHVCSQTA]/.test(segType)) {\r\n                if ('x' in seg) x = seg.x;\r\n                if ('y' in seg) y = seg.y;\r\n            } else {\r\n                if ('x1' in seg) x1 = x + seg.x1;\r\n                if ('x2' in seg) x2 = x + seg.x2;\r\n                if ('y1' in seg) y1 = y + seg.y1;\r\n                if ('y2' in seg) y2 = y + seg.y2;\r\n                if ('x' in seg) x += seg.x;\r\n                if ('y' in seg) y += seg.y;\r\n\r\n                switch (segType) {\r\n\r\n                case 'm':\r\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\r\n                    break;\r\n                case 'l':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\r\n                    break;\r\n                case 'h':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\r\n                    break;\r\n                case 'v':\r\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\r\n                    break;\r\n                case 'c':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\r\n                    break;\r\n                case 's':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\r\n                    break;\r\n                case 'q':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\r\n                    break;\r\n                case 't':\r\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\r\n                    break;\r\n                case 'a':\r\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\r\n                    break;\r\n                case 'z':\r\n                case 'Z':\r\n                    x = x0;\r\n                    y = y0;\r\n                    break;\r\n\r\n                }\r\n            }\r\n\r\n            if (segType == 'M' || segType == 'm') {\r\n                x0 = x;\r\n                y0 = y;\r\n            }\r\n        }\r\n    };\r\n\r\n})();","/**\r\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\r\n* Vectors are the basis of all the geometry related operations in the engine.\r\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vector\r\n*/\r\n\r\n// TODO: consider params for reusing vector objects\r\n\r\nvar Vector = {};\r\n\r\nmodule.exports = Vector;\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new vector.\r\n     * @method create\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @return {vector} A new vector\r\n     */\r\n    Vector.create = function(x, y) {\r\n        return { x: x || 0, y: y || 0 };\r\n    };\r\n\r\n    /**\r\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\r\n     * @method clone\r\n     * @param {vector} vector\r\n     * @return {vector} A new cloned vector\r\n     */\r\n    Vector.clone = function(vector) {\r\n        return { x: vector.x, y: vector.y };\r\n    };\r\n\r\n    /**\r\n     * Returns the magnitude (length) of a vector.\r\n     * @method magnitude\r\n     * @param {vector} vector\r\n     * @return {number} The magnitude of the vector\r\n     */\r\n    Vector.magnitude = function(vector) {\r\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\r\n    };\r\n\r\n    /**\r\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\r\n     * @method magnitudeSquared\r\n     * @param {vector} vector\r\n     * @return {number} The squared magnitude of the vector\r\n     */\r\n    Vector.magnitudeSquared = function(vector) {\r\n        return (vector.x * vector.x) + (vector.y * vector.y);\r\n    };\r\n\r\n    /**\r\n     * Rotates the vector about (0, 0) by specified angle.\r\n     * @method rotate\r\n     * @param {vector} vector\r\n     * @param {number} angle\r\n     * @param {vector} [output]\r\n     * @return {vector} The vector rotated about (0, 0)\r\n     */\r\n    Vector.rotate = function(vector, angle, output) {\r\n        var cos = Math.cos(angle), sin = Math.sin(angle);\r\n        if (!output) output = {};\r\n        var x = vector.x * cos - vector.y * sin;\r\n        output.y = vector.x * sin + vector.y * cos;\r\n        output.x = x;\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Rotates the vector about a specified point by specified angle.\r\n     * @method rotateAbout\r\n     * @param {vector} vector\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector rotated about the point\r\n     */\r\n    Vector.rotateAbout = function(vector, angle, point, output) {\r\n        var cos = Math.cos(angle), sin = Math.sin(angle);\r\n        if (!output) output = {};\r\n        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\r\n        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\r\n        output.x = x;\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Normalises a vector (such that its magnitude is `1`).\r\n     * @method normalise\r\n     * @param {vector} vector\r\n     * @return {vector} A new vector normalised\r\n     */\r\n    Vector.normalise = function(vector) {\r\n        var magnitude = Vector.magnitude(vector);\r\n        if (magnitude === 0)\r\n            return { x: 0, y: 0 };\r\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\r\n    };\r\n\r\n    /**\r\n     * Returns the dot-product of two vectors.\r\n     * @method dot\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The dot product of the two vectors\r\n     */\r\n    Vector.dot = function(vectorA, vectorB) {\r\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\r\n    };\r\n\r\n    /**\r\n     * Returns the cross-product of two vectors.\r\n     * @method cross\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The cross product of the two vectors\r\n     */\r\n    Vector.cross = function(vectorA, vectorB) {\r\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\r\n    };\r\n\r\n    /**\r\n     * Returns the cross-product of three vectors.\r\n     * @method cross3\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} vectorC\r\n     * @return {number} The cross product of the three vectors\r\n     */\r\n    Vector.cross3 = function(vectorA, vectorB, vectorC) {\r\n        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\r\n    };\r\n\r\n    /**\r\n     * Adds the two vectors.\r\n     * @method add\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector of vectorA and vectorB added\r\n     */\r\n    Vector.add = function(vectorA, vectorB, output) {\r\n        if (!output) output = {};\r\n        output.x = vectorA.x + vectorB.x;\r\n        output.y = vectorA.y + vectorB.y;\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Subtracts the two vectors.\r\n     * @method sub\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @param {vector} [output]\r\n     * @return {vector} A new vector of vectorA and vectorB subtracted\r\n     */\r\n    Vector.sub = function(vectorA, vectorB, output) {\r\n        if (!output) output = {};\r\n        output.x = vectorA.x - vectorB.x;\r\n        output.y = vectorA.y - vectorB.y;\r\n        return output;\r\n    };\r\n\r\n    /**\r\n     * Multiplies a vector and a scalar.\r\n     * @method mult\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     * @return {vector} A new vector multiplied by scalar\r\n     */\r\n    Vector.mult = function(vector, scalar) {\r\n        return { x: vector.x * scalar, y: vector.y * scalar };\r\n    };\r\n\r\n    /**\r\n     * Divides a vector and a scalar.\r\n     * @method div\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     * @return {vector} A new vector divided by scalar\r\n     */\r\n    Vector.div = function(vector, scalar) {\r\n        return { x: vector.x / scalar, y: vector.y / scalar };\r\n    };\r\n\r\n    /**\r\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\r\n     * @method perp\r\n     * @param {vector} vector\r\n     * @param {bool} [negate=false]\r\n     * @return {vector} The perpendicular vector\r\n     */\r\n    Vector.perp = function(vector, negate) {\r\n        negate = negate === true ? -1 : 1;\r\n        return { x: negate * -vector.y, y: negate * vector.x };\r\n    };\r\n\r\n    /**\r\n     * Negates both components of a vector such that it points in the opposite direction.\r\n     * @method neg\r\n     * @param {vector} vector\r\n     * @return {vector} The negated vector\r\n     */\r\n    Vector.neg = function(vector) {\r\n        return { x: -vector.x, y: -vector.y };\r\n    };\r\n\r\n    /**\r\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\r\n     * @method angle\r\n     * @param {vector} vectorA\r\n     * @param {vector} vectorB\r\n     * @return {number} The angle in radians\r\n     */\r\n    Vector.angle = function(vectorA, vectorB) {\r\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\r\n    };\r\n\r\n    /**\r\n     * Temporary vector pool (not thread-safe).\r\n     * @property _temp\r\n     * @type {vector[]}\r\n     * @private\r\n     */\r\n    Vector._temp = [\r\n        Vector.create(), Vector.create(), \r\n        Vector.create(), Vector.create(), \r\n        Vector.create(), Vector.create()\r\n    ];\r\n\r\n})();","/**\r\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\r\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\r\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\r\n*\r\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\r\n*\r\n* @class Vertices\r\n*/\r\n\r\nvar Vertices = {};\r\n\r\nmodule.exports = Vertices;\r\n\r\nvar Vector = require('../geometry/Vector');\r\nvar Common = require('../core/Common');\r\n\r\n(function() {\r\n\r\n    /**\r\n     * Creates a new set of `Matter.Body` compatible vertices.\r\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\r\n     *\r\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\r\n     *\r\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\r\n     * but with some additional references required for efficient collision detection routines.\r\n     *\r\n     * Vertices must be specified in clockwise order.\r\n     *\r\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\r\n     *\r\n     * @method create\r\n     * @param {vector[]} points\r\n     * @param {body} body\r\n     */\r\n    Vertices.create = function(points, body) {\r\n        var vertices = [];\r\n\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i],\r\n                vertex = {\r\n                    x: point.x,\r\n                    y: point.y,\r\n                    index: i,\r\n                    body: body,\r\n                    isInternal: false,\r\n                    contact: null,\r\n                    offset: null\r\n                };\r\n\r\n            vertex.contact = {\r\n                vertex: vertex,\r\n                normalImpulse: 0,\r\n                tangentImpulse: 0\r\n            };\r\n\r\n            vertices.push(vertex);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \r\n     * into a `Matter.Vertices` object for the given `Matter.Body`.\r\n     * For parsing SVG paths, see `Svg.pathToVertices`.\r\n     * @method fromPath\r\n     * @param {string} path\r\n     * @param {body} body\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.fromPath = function(path, body) {\r\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\r\n            points = [];\r\n\r\n        path.replace(pathPattern, function(match, x, y) {\r\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\r\n        });\r\n\r\n        return Vertices.create(points, body);\r\n    };\r\n\r\n    /**\r\n     * Returns the centre (centroid) of the set of vertices.\r\n     * @method centre\r\n     * @param {vertices} vertices\r\n     * @return {vector} The centre point\r\n     */\r\n    Vertices.centre = function(vertices) {\r\n        var area = Vertices.area(vertices, true),\r\n            centre = { x: 0, y: 0 },\r\n            cross,\r\n            temp,\r\n            j;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            j = (i + 1) % vertices.length;\r\n            cross = Vector.cross(vertices[i], vertices[j]);\r\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\r\n            centre = Vector.add(centre, temp);\r\n        }\r\n\r\n        return Vector.div(centre, 6 * area);\r\n    };\r\n\r\n    /**\r\n     * Returns the average (mean) of the set of vertices.\r\n     * @method mean\r\n     * @param {vertices} vertices\r\n     * @return {vector} The average point\r\n     */\r\n    Vertices.mean = function(vertices) {\r\n        var average = { x: 0, y: 0 };\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            average.x += vertices[i].x;\r\n            average.y += vertices[i].y;\r\n        }\r\n\r\n        return Vector.div(average, vertices.length);\r\n    };\r\n\r\n    /**\r\n     * Returns the area of the set of vertices.\r\n     * @method area\r\n     * @param {vertices} vertices\r\n     * @param {bool} signed\r\n     * @return {number} The area\r\n     */\r\n    Vertices.area = function(vertices, signed) {\r\n        var area = 0,\r\n            j = vertices.length - 1;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\r\n            j = i;\r\n        }\r\n\r\n        if (signed)\r\n            return area / 2;\r\n\r\n        return Math.abs(area) / 2;\r\n    };\r\n\r\n    /**\r\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\r\n     * @method inertia\r\n     * @param {vertices} vertices\r\n     * @param {number} mass\r\n     * @return {number} The polygon's moment of inertia\r\n     */\r\n    Vertices.inertia = function(vertices, mass) {\r\n        var numerator = 0,\r\n            denominator = 0,\r\n            v = vertices,\r\n            cross,\r\n            j;\r\n\r\n        // find the polygon's moment of inertia, using second moment of area\r\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\r\n        for (var n = 0; n < v.length; n++) {\r\n            j = (n + 1) % v.length;\r\n            cross = Math.abs(Vector.cross(v[j], v[n]));\r\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\r\n            denominator += cross;\r\n        }\r\n\r\n        return (mass / 6) * (numerator / denominator);\r\n    };\r\n\r\n    /**\r\n     * Translates the set of vertices in-place.\r\n     * @method translate\r\n     * @param {vertices} vertices\r\n     * @param {vector} vector\r\n     * @param {number} scalar\r\n     */\r\n    Vertices.translate = function(vertices, vector, scalar) {\r\n        var i;\r\n        if (scalar) {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x * scalar;\r\n                vertices[i].y += vector.y * scalar;\r\n            }\r\n        } else {\r\n            for (i = 0; i < vertices.length; i++) {\r\n                vertices[i].x += vector.x;\r\n                vertices[i].y += vector.y;\r\n            }\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Rotates the set of vertices in-place.\r\n     * @method rotate\r\n     * @param {vertices} vertices\r\n     * @param {number} angle\r\n     * @param {vector} point\r\n     */\r\n    Vertices.rotate = function(vertices, angle, point) {\r\n        if (angle === 0)\r\n            return;\r\n\r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle);\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                dx = vertice.x - point.x,\r\n                dy = vertice.y - point.y;\r\n                \r\n            vertice.x = point.x + (dx * cos - dy * sin);\r\n            vertice.y = point.y + (dx * sin + dy * cos);\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `point` is inside the set of `vertices`.\r\n     * @method contains\r\n     * @param {vertices} vertices\r\n     * @param {vector} point\r\n     * @return {boolean} True if the vertices contains point, otherwise false\r\n     */\r\n    Vertices.contains = function(vertices, point) {\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var vertice = vertices[i],\r\n                nextVertice = vertices[(i + 1) % vertices.length];\r\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Scales the vertices from a point (default is centre) in-place.\r\n     * @method scale\r\n     * @param {vertices} vertices\r\n     * @param {number} scaleX\r\n     * @param {number} scaleY\r\n     * @param {vector} point\r\n     */\r\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\r\n        if (scaleX === 1 && scaleY === 1)\r\n            return vertices;\r\n\r\n        point = point || Vertices.centre(vertices);\r\n\r\n        var vertex,\r\n            delta;\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            vertex = vertices[i];\r\n            delta = Vector.sub(vertex, point);\r\n            vertices[i].x = point.x + delta.x * scaleX;\r\n            vertices[i].y = point.y + delta.y * scaleY;\r\n        }\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\r\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\r\n     * @method chamfer\r\n     * @param {vertices} vertices\r\n     * @param {number[]} radius\r\n     * @param {number} quality\r\n     * @param {number} qualityMin\r\n     * @param {number} qualityMax\r\n     */\r\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\r\n        if (typeof radius === 'number') {\r\n            radius = [radius];\r\n        } else {\r\n            radius = radius || [8];\r\n        }\r\n\r\n        // quality defaults to -1, which is auto\r\n        quality = (typeof quality !== 'undefined') ? quality : -1;\r\n        qualityMin = qualityMin || 2;\r\n        qualityMax = qualityMax || 14;\r\n\r\n        var newVertices = [];\r\n\r\n        for (var i = 0; i < vertices.length; i++) {\r\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\r\n                vertex = vertices[i],\r\n                nextVertex = vertices[(i + 1) % vertices.length],\r\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\r\n\r\n            if (currentRadius === 0) {\r\n                newVertices.push(vertex);\r\n                continue;\r\n            }\r\n\r\n            var prevNormal = Vector.normalise({ \r\n                x: vertex.y - prevVertex.y, \r\n                y: prevVertex.x - vertex.x\r\n            });\r\n\r\n            var nextNormal = Vector.normalise({ \r\n                x: nextVertex.y - vertex.y, \r\n                y: vertex.x - nextVertex.x\r\n            });\r\n\r\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\r\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\r\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\r\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\r\n\r\n            var precision = quality;\r\n\r\n            if (quality === -1) {\r\n                // automatically decide precision\r\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\r\n            }\r\n\r\n            precision = Common.clamp(precision, qualityMin, qualityMax);\r\n\r\n            // use an even value for precision, more likely to reduce axes by using symmetry\r\n            if (precision % 2 === 1)\r\n                precision += 1;\r\n\r\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\r\n                theta = alpha / precision;\r\n\r\n            for (var j = 0; j < precision; j++) {\r\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\r\n            }\r\n        }\r\n\r\n        return newVertices;\r\n    };\r\n\r\n    /**\r\n     * Sorts the input vertices into clockwise order in place.\r\n     * @method clockwiseSort\r\n     * @param {vertices} vertices\r\n     * @return {vertices} vertices\r\n     */\r\n    Vertices.clockwiseSort = function(vertices) {\r\n        var centre = Vertices.mean(vertices);\r\n\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\r\n        });\r\n\r\n        return vertices;\r\n    };\r\n\r\n    /**\r\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\r\n     * @method isConvex\r\n     * @param {vertices} vertices\r\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\r\n     */\r\n    Vertices.isConvex = function(vertices) {\r\n        // http://paulbourke.net/geometry/polygonmesh/\r\n        // Copyright (c) Paul Bourke (use permitted)\r\n\r\n        var flag = 0,\r\n            n = vertices.length,\r\n            i,\r\n            j,\r\n            k,\r\n            z;\r\n\r\n        if (n < 3)\r\n            return null;\r\n\r\n        for (i = 0; i < n; i++) {\r\n            j = (i + 1) % n;\r\n            k = (i + 2) % n;\r\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\r\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\r\n\r\n            if (z < 0) {\r\n                flag |= 1;\r\n            } else if (z > 0) {\r\n                flag |= 2;\r\n            }\r\n\r\n            if (flag === 3) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (flag !== 0){\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the convex hull of the input vertices as a new array of points.\r\n     * @method hull\r\n     * @param {vertices} vertices\r\n     * @return [vertex] vertices\r\n     */\r\n    Vertices.hull = function(vertices) {\r\n        // http://geomalgorithms.com/a10-_hull-1.html\r\n\r\n        var upper = [],\r\n            lower = [], \r\n            vertex,\r\n            i;\r\n\r\n        // sort vertices on x-axis (y-axis for ties)\r\n        vertices = vertices.slice(0);\r\n        vertices.sort(function(vertexA, vertexB) {\r\n            var dx = vertexA.x - vertexB.x;\r\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\r\n        });\r\n\r\n        // build lower hull\r\n        for (i = 0; i < vertices.length; i += 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (lower.length >= 2 \r\n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\r\n                lower.pop();\r\n            }\r\n\r\n            lower.push(vertex);\r\n        }\r\n\r\n        // build upper hull\r\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\r\n            vertex = vertices[i];\r\n\r\n            while (upper.length >= 2 \r\n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\r\n                upper.pop();\r\n            }\r\n\r\n            upper.push(vertex);\r\n        }\r\n\r\n        // concatenation of the lower and upper hulls gives the convex hull\r\n        // omit last points because they are repeated at the beginning of the other list\r\n        upper.pop();\r\n        lower.pop();\r\n\r\n        return upper.concat(lower);\r\n    };\r\n\r\n})();\r\n","var Matter = require('../../CustomMain');\n\n/**\n * An attractors plugin for matter.js.\n * See the readme for usage and examples.\n * @module MatterAttractors\n */\nvar MatterAttractors =\n{\n    name: 'matter-attractors',\n    version: '0.1.7',\n    for: 'matter-js@^0.14.2',\n    silent: true,\n\n    // installs the plugin where `base` is `Matter`\n    // you should not need to call this directly.\n    install: function (base)\n    {\n        base.after('Body.create', function ()\n        {\n            MatterAttractors.Body.init(this);\n        });\n\n        base.before('Engine.update', function (engine)\n        {\n            MatterAttractors.Engine.update(engine);\n        });\n    },\n\n    Body:\n    {\n        /**\n         * Initialises the `body` to support attractors.\n         * This is called automatically by the plugin.\n         * @function MatterAttractors.Body.init\n         * @param {Matter.Body} body The body to init.\n         * @returns {void} No return value.\n         */\n        init: function (body)\n        {\n            body.plugin.attractors = body.plugin.attractors || [];\n        }\n    },\n\n    Engine:\n    {\n        /**\n         * Applies all attractors for all bodies in the `engine`.\n         * This is called automatically by the plugin.\n         * @function MatterAttractors.Engine.update\n         * @param {Matter.Engine} engine The engine to update.\n         * @returns {void} No return value.\n         */\n        update: function (engine)\n        {\n            var bodies = Matter.Composite.allBodies(engine.world);\n\n            for (var i = 0; i < bodies.length; i++)\n            {\n                var bodyA = bodies[i];\n                var attractors = bodyA.plugin.attractors;\n\n                if (attractors && attractors.length > 0)\n                {\n                    for (var j = 0; j < bodies.length; j++)\n                    {\n                        var bodyB = bodies[j];\n\n                        if (i !== j)\n                        {\n                            for (var k = 0; k < attractors.length; k++)\n                            {\n                                var attractor = attractors[k];\n                                var forceVector = attractor;\n\n                                if (Matter.Common.isFunction(attractor))\n                                {\n                                    forceVector = attractor(bodyA, bodyB);\n                                }\n\n                                if (forceVector)\n                                {\n                                    Matter.Body.applyForce(bodyB, bodyB.position, forceVector);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    /**\n     * Defines some useful common attractor functions that can be used\n     * by pushing them to your body's `body.plugin.attractors` array.\n     * @namespace MatterAttractors.Attractors\n     * @property {number} gravityConstant The gravitational constant used by the gravity attractor.\n     */\n    Attractors:\n    {\n        gravityConstant: 0.001,\n\n        /**\n         * An attractor function that applies Newton's law of gravitation.\n         * Use this by pushing `MatterAttractors.Attractors.gravity` to your body's `body.plugin.attractors` array.\n         * The gravitational constant defaults to `0.001` which you can change\n         * at `MatterAttractors.Attractors.gravityConstant`.\n         * @function MatterAttractors.Attractors.gravity\n         * @param {Matter.Body} bodyA The first body.\n         * @param {Matter.Body} bodyB The second body.\n         * @returns {void} No return value.\n         */\n        gravity: function (bodyA, bodyB)\n        {\n            // use Newton's law of gravitation\n            var bToA = Matter.Vector.sub(bodyB.position, bodyA.position);\n            var distanceSq = Matter.Vector.magnitudeSquared(bToA) || 0.0001;\n            var normal = Matter.Vector.normalise(bToA);\n            var magnitude = -MatterAttractors.Attractors.gravityConstant * (bodyA.mass * bodyB.mass / distanceSq);\n            var force = Matter.Vector.mult(normal, magnitude);\n\n            // to apply forces to both bodies\n            Matter.Body.applyForce(bodyA, bodyA.position, Matter.Vector.neg(force));\n            Matter.Body.applyForce(bodyB, bodyB.position, force);\n        }\n    }\n};\n\nmodule.exports = MatterAttractors;\n\n/**\n * @namespace Matter.Body\n * @see http://brm.io/matter-js/docs/classes/Body.html\n */\n\n/**\n * This plugin adds a new property `body.plugin.attractors` to instances of `Matter.Body`.\n * This is an array of callback functions that will be called automatically\n * for every pair of bodies, on every engine update.\n * @property {Function[]} body.plugin.attractors\n * @memberof Matter.Body\n */\n\n/**\n * An attractor function calculates the force to be applied\n * to `bodyB`, it should either:\n * - return the force vector to be applied to `bodyB`\n * - or apply the force to the body(s) itself\n * @callback AttractorFunction\n * @param {Matter.Body} bodyA\n * @param {Matter.Body} bodyB\n * @returns {(Vector|undefined)} a force vector (optional)\n */\n","/**\r\n * @author       @dxu https://github.com/dxu/matter-collision-events\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MatterCollisionEvents = {\r\n\r\n    name: 'matter-collision-events',\r\n    version: '0.1.6',\r\n    for: 'matter-js@^0.14.2',\r\n    silent: true,\r\n\r\n    install: function (matter)\r\n    {\r\n        matter.after('Engine.create', function ()\r\n        {\r\n            matter.Events.on(this, 'collisionStart', function (event)\r\n            {\r\n                event.pairs.map(function (pair)\r\n                {\r\n                    var bodyA = pair.bodyA;\r\n                    var bodyB = pair.bodyB;\r\n\r\n                    if (bodyA.gameObject)\r\n                    {\r\n                        bodyA.gameObject.emit('collide', bodyA, bodyB, pair);\r\n                    }\r\n\r\n                    if (bodyB.gameObject)\r\n                    {\r\n                        bodyB.gameObject.emit('collide', bodyB, bodyA, pair);\r\n                    }\r\n\r\n                    matter.Events.trigger(bodyA, 'onCollide', { pair: pair });\r\n                    matter.Events.trigger(bodyB, 'onCollide', { pair: pair });\r\n\r\n                    if (bodyA.onCollideCallback)\r\n                    {\r\n                        bodyA.onCollideCallback(pair);\r\n                    }\r\n\r\n                    if (bodyB.onCollideCallback)\r\n                    {\r\n                        bodyB.onCollideCallback(pair);\r\n                    }\r\n\r\n                    if (bodyA.onCollideWith[bodyB.id])\r\n                    {\r\n                        bodyA.onCollideWith[bodyB.id](bodyB, pair);\r\n                    }\r\n\r\n                    if (bodyB.onCollideWith[bodyA.id])\r\n                    {\r\n                        bodyB.onCollideWith[bodyA.id](bodyA, pair);\r\n                    }\r\n                });\r\n            });\r\n\r\n            matter.Events.on(this, 'collisionActive', function (event)\r\n            {\r\n                event.pairs.map(function (pair)\r\n                {\r\n                    var bodyA = pair.bodyA;\r\n                    var bodyB = pair.bodyB;\r\n\r\n                    if (bodyA.gameObject)\r\n                    {\r\n                        bodyA.gameObject.emit('collideActive', bodyA, bodyB, pair);\r\n                    }\r\n\r\n                    if (bodyB.gameObject)\r\n                    {\r\n                        bodyB.gameObject.emit('collideActive', bodyB, bodyA, pair);\r\n                    }\r\n\r\n                    matter.Events.trigger(bodyA, 'onCollideActive', { pair: pair });\r\n                    matter.Events.trigger(bodyB, 'onCollideActive', { pair: pair });\r\n\r\n                    if (bodyA.onCollideActiveCallback)\r\n                    {\r\n                        bodyA.onCollideActiveCallback(pair);\r\n                    }\r\n\r\n                    if (bodyB.onCollideActiveCallback)\r\n                    {\r\n                        bodyB.onCollideActiveCallback(pair);\r\n                    }\r\n                });\r\n            });\r\n\r\n            matter.Events.on(this, 'collisionEnd', function (event)\r\n            {\r\n                event.pairs.map(function (pair)\r\n                {\r\n                    var bodyA = pair.bodyA;\r\n                    var bodyB = pair.bodyB;\r\n\r\n                    if (bodyA.gameObject)\r\n                    {\r\n                        bodyA.gameObject.emit('collideEnd', bodyA, bodyB, pair);\r\n                    }\r\n\r\n                    if (bodyB.gameObject)\r\n                    {\r\n                        bodyB.gameObject.emit('collideEnd', bodyB, bodyA, pair);\r\n                    }\r\n\r\n                    matter.Events.trigger(bodyA, 'onCollideEnd', { pair: pair });\r\n                    matter.Events.trigger(bodyB, 'onCollideEnd', { pair: pair });\r\n\r\n                    if (bodyA.onCollideEndCallback)\r\n                    {\r\n                        bodyA.onCollideEndCallback(pair);\r\n                    }\r\n\r\n                    if (bodyB.onCollideEndCallback)\r\n                    {\r\n                        bodyB.onCollideEndCallback(pair);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nmodule.exports = MatterCollisionEvents;\r\n","var Matter = require('../../CustomMain');\r\n\r\n/**\r\n * A coordinate wrapping plugin for matter.js.\r\n * See the readme for usage and examples.\r\n * @module MatterWrap\r\n */\r\nvar MatterWrap = {\r\n  // plugin meta\r\n  name: 'matter-wrap', // PLUGIN_NAME\r\n  version: '0.1.4', // PLUGIN_VERSION\r\n  for: 'matter-js@^0.14.2',\r\n  silent: true, // no console log please\r\n\r\n  // installs the plugin where `base` is `Matter`\r\n  // you should not need to call this directly.\r\n  install: function(base) {\r\n    base.after('Engine.update', function() {\r\n      MatterWrap.Engine.update(this);\r\n    });\r\n  },\r\n\r\n  Engine: {\r\n    /**\r\n     * Updates the engine by wrapping bodies and composites inside `engine.world`.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Engine.update\r\n     * @param {Matter.Engine} engine The engine to update.\r\n     * @returns {void} No return value.\r\n     */\r\n    update: function(engine) {\r\n      var world = engine.world,\r\n        bodies = Matter.Composite.allBodies(world),\r\n        composites = Matter.Composite.allComposites(world);\r\n\r\n      for (var i = 0; i < bodies.length; i += 1) {\r\n        var body = bodies[i];\r\n\r\n        if (body.plugin.wrap) {\r\n          MatterWrap.Body.wrap(body, body.plugin.wrap);\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < composites.length; i += 1) {\r\n        var composite = composites[i];\r\n\r\n        if (composite.plugin.wrap) {\r\n          MatterWrap.Composite.wrap(composite, composite.plugin.wrap);\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  Bounds: {\r\n    /**\r\n     * Returns a translation vector that wraps the `objectBounds` inside the `bounds`.\r\n     * @function MatterWrap.Bounds.wrap\r\n     * @param {Matter.Bounds} objectBounds The bounds of the object to wrap inside the bounds.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.\r\n     * @returns {?Matter.Vector} A translation vector (only if wrapping is required).\r\n     */\r\n    wrap: function(objectBounds, bounds) {\r\n      var x = null,\r\n        y = null;\r\n\r\n      if (typeof bounds.min.x !== 'undefined' && typeof bounds.max.x !== 'undefined') {\r\n        if (objectBounds.min.x > bounds.max.x) {\r\n          x = bounds.min.x - objectBounds.max.x;\r\n        } else if (objectBounds.max.x < bounds.min.x) {\r\n          x = bounds.max.x - objectBounds.min.x;\r\n        }\r\n      }\r\n\r\n      if (typeof bounds.min.y !== 'undefined' && typeof bounds.max.y !== 'undefined') {\r\n        if (objectBounds.min.y > bounds.max.y) {\r\n          y = bounds.min.y - objectBounds.max.y;\r\n        } else if (objectBounds.max.y < bounds.min.y) {\r\n          y = bounds.max.y - objectBounds.min.y;\r\n        }\r\n      }\r\n\r\n      if (x !== null || y !== null) {\r\n        return {\r\n          x: x || 0,\r\n          y: y || 0\r\n        };\r\n      }\r\n    }\r\n  },\r\n\r\n  Body: {\r\n    /**\r\n     * Wraps the `body` position such that it always stays within the given bounds. \r\n     * Upon crossing a boundary the body will appear on the opposite side of the bounds, \r\n     * while maintaining its velocity.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Body.wrap\r\n     * @param {Matter.Body} body The body to wrap.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the body inside.\r\n     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).\r\n     */\r\n    wrap: function(body, bounds) {\r\n      var translation = MatterWrap.Bounds.wrap(body.bounds, bounds);\r\n\r\n      if (translation) {\r\n        Matter.Body.translate(body, translation);\r\n      }\r\n\r\n      return translation;\r\n    }\r\n  },\r\n\r\n  Composite: {\r\n    /**\r\n     * Returns the union of the bounds of all of the composite's bodies\r\n     * (not accounting for constraints).\r\n     * @function MatterWrap.Composite.bounds\r\n     * @param {Matter.Composite} composite The composite.\r\n     * @returns {Matter.Bounds} The composite bounds.\r\n     */\r\n    bounds: function(composite) {\r\n      var bodies = Matter.Composite.allBodies(composite),\r\n        vertices = [];\r\n      \r\n      for (var i = 0; i < bodies.length; i += 1) {\r\n        var body = bodies[i];\r\n        vertices.push(body.bounds.min, body.bounds.max);\r\n      }\r\n\r\n      return Matter.Bounds.create(vertices);\r\n    },\r\n\r\n    /**\r\n     * Wraps the `composite` position such that it always stays within the given bounds. \r\n     * Upon crossing a boundary the composite will appear on the opposite side of the bounds, \r\n     * while maintaining its velocity.\r\n     * This is called automatically by the plugin.\r\n     * @function MatterWrap.Composite.wrap\r\n     * @param {Matter.Composite} composite The composite to wrap.\r\n     * @param {Matter.Bounds} bounds The bounds to wrap the composite inside.\r\n     * @returns {?Matter.Vector} The translation vector that was applied (only if wrapping was required).\r\n     */\r\n    wrap: function(composite, bounds) {\r\n      var translation = MatterWrap.Bounds.wrap(\r\n        MatterWrap.Composite.bounds(composite), \r\n        bounds\r\n      );\r\n\r\n      if (translation) {\r\n        Matter.Composite.translate(composite, translation);\r\n      }\r\n\r\n      return translation;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = MatterWrap;\r\n\r\n/**\r\n * @namespace Matter.Body\r\n * @see http://brm.io/matter-js/docs/classes/Body.html\r\n */\r\n\r\n/**\r\n * This plugin adds a new property `body.plugin.wrap` to instances of `Matter.Body`.  \r\n * This is a `Matter.Bounds` instance that specifies the wrapping region.\r\n * @property {Matter.Bounds} body.plugin.wrap\r\n * @memberof Matter.Body\r\n */\r\n\r\n/**\r\n * This plugin adds a new property `composite.plugin.wrap` to instances of `Matter.Composite`.  \r\n * This is a `Matter.Bounds` instance that specifies the wrapping region.\r\n * @property {Matter.Bounds} composite.plugin.wrap\r\n * @memberof Matter.Composite\r\n */","/**\r\n * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  v0.3.0\r\n\r\nmodule.exports = {\r\n    decomp: polygonDecomp,\r\n    quickDecomp: polygonQuickDecomp,\r\n    isSimple: polygonIsSimple,\r\n    removeCollinearPoints: polygonRemoveCollinearPoints,\r\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\r\n    makeCCW: polygonMakeCCW\r\n};\r\n\r\n/**\r\n * Compute the intersection between two lines.\r\n * @static\r\n * @method lineInt\r\n * @param  {Array}  l1          Line vector 1\r\n * @param  {Array}  l2          Line vector 2\r\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\r\n * @return {Array}              The intersection point.\r\n */\r\nfunction lineInt(l1,l2,precision){\r\n    precision = precision || 0;\r\n    var i = [0,0]; // point\r\n    var a1, b1, c1, a2, b2, c2, det; // scalars\r\n    a1 = l1[1][1] - l1[0][1];\r\n    b1 = l1[0][0] - l1[1][0];\r\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\r\n    a2 = l2[1][1] - l2[0][1];\r\n    b2 = l2[0][0] - l2[1][0];\r\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\r\n    det = a1 * b2 - a2*b1;\r\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\r\n        i[0] = (b2 * c1 - b1 * c2) / det;\r\n        i[1] = (a1 * c2 - a2 * c1) / det;\r\n    }\r\n    return i;\r\n}\r\n\r\n/**\r\n * Checks if two line segments intersects.\r\n * @method segmentsIntersect\r\n * @param {Array} p1 The start vertex of the first line segment.\r\n * @param {Array} p2 The end vertex of the first line segment.\r\n * @param {Array} q1 The start vertex of the second line segment.\r\n * @param {Array} q2 The end vertex of the second line segment.\r\n * @return {Boolean} True if the two line segments intersect\r\n */\r\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\r\n\tvar dx = p2[0] - p1[0];\r\n\tvar dy = p2[1] - p1[1];\r\n\tvar da = q2[0] - q1[0];\r\n\tvar db = q2[1] - q1[1];\r\n\r\n\t// segments are parallel\r\n\tif((da*dy - db*dx) === 0){\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\r\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\r\n\r\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\r\n}\r\n\r\n/**\r\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\r\n * @static\r\n * @method area\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @return {Number}\r\n */\r\nfunction triangleArea(a,b,c){\r\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\r\n}\r\n\r\nfunction isLeft(a,b,c){\r\n    return triangleArea(a,b,c) > 0;\r\n}\r\n\r\nfunction isLeftOn(a,b,c) {\r\n    return triangleArea(a, b, c) >= 0;\r\n}\r\n\r\nfunction isRight(a,b,c) {\r\n    return triangleArea(a, b, c) < 0;\r\n}\r\n\r\nfunction isRightOn(a,b,c) {\r\n    return triangleArea(a, b, c) <= 0;\r\n}\r\n\r\nvar tmpPoint1 = [],\r\n    tmpPoint2 = [];\r\n\r\n/**\r\n * Check if three points are collinear\r\n * @method collinear\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Array} c\r\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\r\n * @return {Boolean}\r\n */\r\nfunction collinear(a,b,c,thresholdAngle) {\r\n    if(!thresholdAngle){\r\n        return triangleArea(a, b, c) === 0;\r\n    } else {\r\n        var ab = tmpPoint1,\r\n            bc = tmpPoint2;\r\n\r\n        ab[0] = b[0]-a[0];\r\n        ab[1] = b[1]-a[1];\r\n        bc[0] = c[0]-b[0];\r\n        bc[1] = c[1]-b[1];\r\n\r\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\r\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\r\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\r\n            angle = Math.acos(dot/(magA*magB));\r\n        return angle < thresholdAngle;\r\n    }\r\n}\r\n\r\nfunction sqdist(a,b){\r\n    var dx = b[0] - a[0];\r\n    var dy = b[1] - a[1];\r\n    return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\r\n * @method at\r\n * @param  {Number} i\r\n * @return {Array}\r\n */\r\nfunction polygonAt(polygon, i){\r\n    var s = polygon.length;\r\n    return polygon[i < 0 ? i % s + s : i % s];\r\n}\r\n\r\n/**\r\n * Clear the polygon data\r\n * @method clear\r\n * @return {Array}\r\n */\r\nfunction polygonClear(polygon){\r\n    polygon.length = 0;\r\n}\r\n\r\n/**\r\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\r\n * @method append\r\n * @param {Polygon} poly The polygon to get points from.\r\n * @param {Number}  from The vertex index in \"poly\".\r\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\r\n * @return {Array}\r\n */\r\nfunction polygonAppend(polygon, poly, from, to){\r\n    for(var i=from; i<to; i++){\r\n        polygon.push(poly[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Make sure that the polygon vertices are ordered counter-clockwise.\r\n * @method makeCCW\r\n */\r\nfunction polygonMakeCCW(polygon){\r\n    var br = 0,\r\n        v = polygon;\r\n\r\n    // find bottom right point\r\n    for (var i = 1; i < polygon.length; ++i) {\r\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\r\n            br = i;\r\n        }\r\n    }\r\n\r\n    // reverse poly if clockwise\r\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\r\n        polygonReverse(polygon);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Reverse the vertices in the polygon\r\n * @method reverse\r\n */\r\nfunction polygonReverse(polygon){\r\n    var tmp = [];\r\n    var N = polygon.length;\r\n    for(var i=0; i!==N; i++){\r\n        tmp.push(polygon.pop());\r\n    }\r\n    for(var i=0; i!==N; i++){\r\n\t\tpolygon[i] = tmp[i];\r\n    }\r\n}\r\n\r\n/**\r\n * Check if a point in the polygon is a reflex point\r\n * @method isReflex\r\n * @param  {Number}  i\r\n * @return {Boolean}\r\n */\r\nfunction polygonIsReflex(polygon, i){\r\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\r\n}\r\n\r\nvar tmpLine1=[],\r\n    tmpLine2=[];\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee(polygon, a,b) {\r\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\r\n\r\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\r\n        return false;\r\n    }\r\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\r\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\r\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\r\n            continue;\r\n        }\r\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\r\n            l1[0] = polygonAt(polygon, a);\r\n            l1[1] = polygonAt(polygon, b);\r\n            l2[0] = polygonAt(polygon, i);\r\n            l2[1] = polygonAt(polygon, i + 1);\r\n            p = lineInt(l1,l2);\r\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if two vertices in the polygon can see each other\r\n * @method canSee2\r\n * @param  {Number} a Vertex index 1\r\n * @param  {Number} b Vertex index 2\r\n * @return {Boolean}\r\n */\r\nfunction polygonCanSee2(polygon, a,b) {\r\n    // for each edge\r\n    for (var i = 0; i !== polygon.length; ++i) {\r\n        // ignore incident edges\r\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\r\n            continue;\r\n        }\r\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Copy the polygon from vertex i to vertex j.\r\n * @method copy\r\n * @param  {Number} i\r\n * @param  {Number} j\r\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\r\n * @return {Polygon}                The resulting copy.\r\n */\r\nfunction polygonCopy(polygon, i,j,targetPoly){\r\n    var p = targetPoly || [];\r\n    polygonClear(p);\r\n    if (i < j) {\r\n        // Insert all vertices from i to j\r\n        for(var k=i; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n    } else {\r\n\r\n        // Insert vertices 0 to j\r\n        for(var k=0; k<=j; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n\r\n        // Insert vertices i to end\r\n        for(var k=i; k<polygon.length; k++){\r\n            p.push(polygon[k]);\r\n        }\r\n    }\r\n\r\n    return p;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\r\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\r\n * @method getCutEdges\r\n * @return {Array}\r\n */\r\nfunction polygonGetCutEdges(polygon) {\r\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\r\n    var nDiags = Number.MAX_VALUE;\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(polygon, i)) {\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (polygonCanSee(polygon, i, j)) {\r\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\r\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\r\n\r\n                    for(var k=0; k<tmp2.length; k++){\r\n                        tmp1.push(tmp2[k]);\r\n                    }\r\n\r\n                    if (tmp1.length < nDiags) {\r\n                        min = tmp1;\r\n                        nDiags = tmp1.length;\r\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return min;\r\n}\r\n\r\n/**\r\n * Decomposes the polygon into one or more convex sub-Polygons.\r\n * @method decomp\r\n * @return {Array} An array or Polygon objects.\r\n */\r\nfunction polygonDecomp(polygon){\r\n    var edges = polygonGetCutEdges(polygon);\r\n    if(edges.length > 0){\r\n        return polygonSlice(polygon, edges);\r\n    } else {\r\n        return [polygon];\r\n    }\r\n}\r\n\r\n/**\r\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\r\n * @method slice\r\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\r\n * @return {Array}\r\n */\r\nfunction polygonSlice(polygon, cutEdges){\r\n    if(cutEdges.length === 0){\r\n\t\treturn [polygon];\r\n    }\r\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\r\n\r\n        var polys = [polygon];\r\n\r\n        for(var i=0; i<cutEdges.length; i++){\r\n            var cutEdge = cutEdges[i];\r\n            // Cut all polys\r\n            for(var j=0; j<polys.length; j++){\r\n                var poly = polys[j];\r\n                var result = polygonSlice(poly, cutEdge);\r\n                if(result){\r\n                    // Found poly! Cut and quit\r\n                    polys.splice(j,1);\r\n                    polys.push(result[0],result[1]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return polys;\r\n    } else {\r\n\r\n        // Was given one edge\r\n        var cutEdge = cutEdges;\r\n        var i = polygon.indexOf(cutEdge[0]);\r\n        var j = polygon.indexOf(cutEdge[1]);\r\n\r\n        if(i !== -1 && j !== -1){\r\n            return [polygonCopy(polygon, i,j),\r\n                    polygonCopy(polygon, j,i)];\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks that the line segments of this polygon do not intersect each other.\r\n * @method isSimple\r\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\r\n * @return {Boolean}\r\n * @todo Should it check all segments with all others?\r\n */\r\nfunction polygonIsSimple(polygon){\r\n    var path = polygon, i;\r\n    // Check\r\n    for(i=0; i<path.length-1; i++){\r\n        for(var j=0; j<i-1; j++){\r\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check the segment between the last and the first point to all others\r\n    for(i=1; i<path.length-2; i++){\r\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\r\n\tdelta = delta || 0;\r\n\tvar a1 = p2[1] - p1[1];\r\n\tvar b1 = p1[0] - p2[0];\r\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\r\n\tvar a2 = q2[1] - q1[1];\r\n\tvar b2 = q1[0] - q2[0];\r\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\r\n\tvar det = (a1 * b2) - (a2 * b1);\r\n\r\n\tif(!scalar_eq(det,0,delta)){\r\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\r\n\t} else {\r\n\t\treturn [0,0];\r\n    }\r\n}\r\n\r\n/**\r\n * Quickly decompose the Polygon into convex sub-polygons.\r\n * @method quickDecomp\r\n * @param  {Array} result\r\n * @param  {Array} [reflexVertices]\r\n * @param  {Array} [steinerPoints]\r\n * @param  {Number} [delta]\r\n * @param  {Number} [maxlevel]\r\n * @param  {Number} [level]\r\n * @return {Array}\r\n */\r\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\r\n    maxlevel = maxlevel || 100;\r\n    level = level || 0;\r\n    delta = delta || 25;\r\n    result = typeof(result)!==\"undefined\" ? result : [];\r\n    reflexVertices = reflexVertices || [];\r\n    steinerPoints = steinerPoints || [];\r\n\r\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\r\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\r\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\r\n    var lowerPoly=[], upperPoly=[]; // polygons\r\n    var poly = polygon,\r\n        v = polygon;\r\n\r\n    if(v.length < 3){\r\n\t\treturn result;\r\n    }\r\n\r\n    level++;\r\n    if(level > maxlevel){\r\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\r\n        return result;\r\n    }\r\n\r\n    for (var i = 0; i < polygon.length; ++i) {\r\n        if (polygonIsReflex(poly, i)) {\r\n            reflexVertices.push(poly[i]);\r\n            upperDist = lowerDist = Number.MAX_VALUE;\r\n\r\n\r\n            for (var j = 0; j < polygon.length; ++j) {\r\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\r\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\r\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < lowerDist) { // keep only the closest intersection\r\n                            lowerDist = d;\r\n                            lowerInt = p;\r\n                            lowerIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\r\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\r\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\r\n                        d = sqdist(poly[i], p);\r\n                        if (d < upperDist) {\r\n                            upperDist = d;\r\n                            upperInt = p;\r\n                            upperIndex = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if there are no vertices to connect to, choose a point in the middle\r\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\r\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\r\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\r\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\r\n                steinerPoints.push(p);\r\n\r\n                if (i < upperIndex) {\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    if (lowerIndex !== 0){\r\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\r\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\r\n                    }\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\r\n                        polygonAppend(lowerPoly, poly,i,poly.length);\r\n                    }\r\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\r\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\r\n                    lowerPoly.push(p);\r\n                    upperPoly.push(p);\r\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\r\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\r\n                }\r\n            } else {\r\n                // connect to the closest point within the triangle\r\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\r\n\r\n                if (lowerIndex > upperIndex) {\r\n                    upperIndex += polygon.length;\r\n                }\r\n                closestDist = Number.MAX_VALUE;\r\n\r\n                if(upperIndex < lowerIndex){\r\n                    return result;\r\n                }\r\n\r\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\r\n                    if (\r\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\r\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\r\n                    ) {\r\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\r\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\r\n                            closestDist = d;\r\n                            closestIndex = j % polygon.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (i < closestIndex) {\r\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\r\n                    if (closestIndex !== 0){\r\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\r\n                    }\r\n                    polygonAppend(upperPoly, poly,0,i+1);\r\n                } else {\r\n                    if (i !== 0){\r\n                        polygonAppend(lowerPoly, poly,i,v.length);\r\n                    }\r\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\r\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\r\n                }\r\n            }\r\n\r\n            // solve smallest poly first\r\n            if (lowerPoly.length < upperPoly.length) {\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            } else {\r\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    result.push(polygon);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Remove collinear points in the polygon.\r\n * @method removeCollinearPoints\r\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\r\n * @return {Number}           The number of points removed\r\n */\r\nfunction polygonRemoveCollinearPoints(polygon, precision){\r\n    var num = 0;\r\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\r\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\r\n            // Remove the middle point\r\n            polygon.splice(i%polygon.length,1);\r\n            num++;\r\n        }\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * Remove duplicate points in the polygon.\r\n * @method removeDuplicatePoints\r\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\r\n */\r\nfunction polygonRemoveDuplicatePoints(polygon, precision){\r\n    for(var i=polygon.length-1; i>=1; --i){\r\n        var pi = polygon[i];\r\n        for(var j=i-1; j>=0; --j){\r\n            if(points_eq(pi, polygon[j], precision)){\r\n                polygon.splice(i,1);\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two scalars are equal\r\n * @static\r\n * @method eq\r\n * @param  {Number} a\r\n * @param  {Number} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction scalar_eq(a,b,precision){\r\n    precision = precision || 0;\r\n    return Math.abs(a-b) <= precision;\r\n}\r\n\r\n/**\r\n * Check if two points are equal\r\n * @static\r\n * @method points_eq\r\n * @param  {Array} a\r\n * @param  {Array} b\r\n * @param  {Number} [precision]\r\n * @return {Boolean}\r\n */\r\nfunction points_eq(a,b,precision){\r\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\r\n}\r\n","/**\r\n * @author       Vladimir Agafonkin\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar quickselect = require('../utils/array/QuickSelect');\r\n\r\n/**\r\n * @classdesc\r\n * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.\r\n * It's based on an optimized R-tree data structure with bulk insertion support.\r\n *\r\n * Spatial index is a special data structure for points and rectangles that allows you to perform queries like\r\n * \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items).\r\n *\r\n * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.\r\n * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.\r\n * \r\n * rbush is forked from https://github.com/mourner/rbush by Vladimir Agafonkin\r\n *\r\n * @class RTree\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n */\r\n\r\nfunction rbush (maxEntries)\r\n{\r\n    var format = [ '.left', '.top', '.right', '.bottom' ];\r\n\r\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\r\n\r\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\r\n    this._maxEntries = Math.max(4, maxEntries || 9);\r\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\r\n\r\n    this.clear();\r\n}\r\n\r\nrbush.prototype = {\r\n\r\n    all: function ()\r\n    {\r\n        return this._all(this.data, []);\r\n    },\r\n\r\n    search: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            result = [],\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return result;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf) result.push(child);\r\n                    else if (contains(bbox, childBBox)) this._all(child, result);\r\n                    else nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    collides: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return false;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf || contains(bbox, childBBox)) return true;\r\n                    nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    load: function (data)\r\n    {\r\n        if (!(data && data.length)) return this;\r\n\r\n        if (data.length < this._minEntries) {\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                this.insert(data[i]);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // recursively build the tree with the given data from scratch using OMT algorithm\r\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\r\n\r\n        if (!this.data.children.length) {\r\n            // save as is if tree is empty\r\n            this.data = node;\r\n\r\n        } else if (this.data.height === node.height) {\r\n            // split root if trees have the same height\r\n            this._splitRoot(this.data, node);\r\n\r\n        } else {\r\n            if (this.data.height < node.height) {\r\n                // swap trees if inserted one is bigger\r\n                var tmpNode = this.data;\r\n                this.data = node;\r\n                node = tmpNode;\r\n            }\r\n\r\n            // insert the small tree into the large tree at appropriate level\r\n            this._insert(node, this.data.height - node.height - 1, true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    insert: function (item)\r\n    {\r\n        if (item) this._insert(item, this.data.height - 1);\r\n        return this;\r\n    },\r\n\r\n    clear: function ()\r\n    {\r\n        this.data = createNode([]);\r\n        return this;\r\n    },\r\n\r\n    remove: function (item, equalsFn)\r\n    {\r\n        if (!item) return this;\r\n\r\n        var node = this.data,\r\n            bbox = this.toBBox(item),\r\n            path = [],\r\n            indexes = [],\r\n            i, parent, index, goingUp;\r\n\r\n        // depth-first iterative tree traversal\r\n        while (node || path.length) {\r\n\r\n            if (!node) { // go up\r\n                node = path.pop();\r\n                parent = path[path.length - 1];\r\n                i = indexes.pop();\r\n                goingUp = true;\r\n            }\r\n\r\n            if (node.leaf) { // check current node\r\n                index = findItem(item, node.children, equalsFn);\r\n\r\n                if (index !== -1) {\r\n                    // item found, remove the item and condense tree upwards\r\n                    node.children.splice(index, 1);\r\n                    path.push(node);\r\n                    this._condense(path);\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\r\n                path.push(node);\r\n                indexes.push(i);\r\n                i = 0;\r\n                parent = node;\r\n                node = node.children[0];\r\n\r\n            } else if (parent) { // go right\r\n                i++;\r\n                node = parent.children[i];\r\n                goingUp = false;\r\n\r\n            } else node = null; // nothing found\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toBBox: function (item) { return item; },\r\n\r\n    compareMinX: compareNodeMinX,\r\n    compareMinY: compareNodeMinY,\r\n\r\n    toJSON: function () { return this.data; },\r\n\r\n    fromJSON: function (data)\r\n    {\r\n        this.data = data;\r\n        return this;\r\n    },\r\n\r\n    _all: function (node, result)\r\n    {\r\n        var nodesToSearch = [];\r\n        while (node) {\r\n            if (node.leaf) result.push.apply(result, node.children);\r\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\r\n\r\n            node = nodesToSearch.pop();\r\n        }\r\n        return result;\r\n    },\r\n\r\n    _build: function (items, left, right, height)\r\n    {\r\n        var N = right - left + 1,\r\n            M = this._maxEntries,\r\n            node;\r\n\r\n        if (N <= M) {\r\n            // reached leaf level; return leaf\r\n            node = createNode(items.slice(left, right + 1));\r\n            calcBBox(node, this.toBBox);\r\n            return node;\r\n        }\r\n\r\n        if (!height) {\r\n            // target height of the bulk-loaded tree\r\n            height = Math.ceil(Math.log(N) / Math.log(M));\r\n\r\n            // target number of root entries to maximize storage utilization\r\n            M = Math.ceil(N / Math.pow(M, height - 1));\r\n        }\r\n\r\n        node = createNode([]);\r\n        node.leaf = false;\r\n        node.height = height;\r\n\r\n        // split the items into M mostly square tiles\r\n\r\n        var N2 = Math.ceil(N / M),\r\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\r\n            i, j, right2, right3;\r\n\r\n        multiSelect(items, left, right, N1, this.compareMinX);\r\n\r\n        for (i = left; i <= right; i += N1) {\r\n\r\n            right2 = Math.min(i + N1 - 1, right);\r\n\r\n            multiSelect(items, i, right2, N2, this.compareMinY);\r\n\r\n            for (j = i; j <= right2; j += N2) {\r\n\r\n                right3 = Math.min(j + N2 - 1, right2);\r\n\r\n                // pack each entry recursively\r\n                node.children.push(this._build(items, j, right3, height - 1));\r\n            }\r\n        }\r\n\r\n        calcBBox(node, this.toBBox);\r\n\r\n        return node;\r\n    },\r\n\r\n    _chooseSubtree: function (bbox, node, level, path)\r\n    {\r\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\r\n\r\n        while (true) {\r\n            path.push(node);\r\n\r\n            if (node.leaf || path.length - 1 === level) break;\r\n\r\n            minArea = minEnlargement = Infinity;\r\n\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n                child = node.children[i];\r\n                area = bboxArea(child);\r\n                enlargement = enlargedArea(bbox, child) - area;\r\n\r\n                // choose entry with the least area enlargement\r\n                if (enlargement < minEnlargement) {\r\n                    minEnlargement = enlargement;\r\n                    minArea = area < minArea ? area : minArea;\r\n                    targetNode = child;\r\n\r\n                } else if (enlargement === minEnlargement) {\r\n                    // otherwise choose one with the smallest area\r\n                    if (area < minArea) {\r\n                        minArea = area;\r\n                        targetNode = child;\r\n                    }\r\n                }\r\n            }\r\n\r\n            node = targetNode || node.children[0];\r\n        }\r\n\r\n        return node;\r\n    },\r\n\r\n    _insert: function (item, level, isNode)\r\n    {\r\n        var toBBox = this.toBBox,\r\n            bbox = isNode ? item : toBBox(item),\r\n            insertPath = [];\r\n\r\n        // find the best node for accommodating the item, saving all nodes along the path too\r\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\r\n\r\n        // put the item into the node\r\n        node.children.push(item);\r\n        extend(node, bbox);\r\n\r\n        // split on node overflow; propagate upwards if necessary\r\n        while (level >= 0) {\r\n            if (insertPath[level].children.length > this._maxEntries) {\r\n                this._split(insertPath, level);\r\n                level--;\r\n            } else break;\r\n        }\r\n\r\n        // adjust bboxes along the insertion path\r\n        this._adjustParentBBoxes(bbox, insertPath, level);\r\n    },\r\n\r\n    // split overflowed node into two\r\n    _split: function (insertPath, level)\r\n    {\r\n        var node = insertPath[level],\r\n            M = node.children.length,\r\n            m = this._minEntries;\r\n\r\n        this._chooseSplitAxis(node, m, M);\r\n\r\n        var splitIndex = this._chooseSplitIndex(node, m, M);\r\n\r\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\r\n        newNode.height = node.height;\r\n        newNode.leaf = node.leaf;\r\n\r\n        calcBBox(node, this.toBBox);\r\n        calcBBox(newNode, this.toBBox);\r\n\r\n        if (level) insertPath[level - 1].children.push(newNode);\r\n        else this._splitRoot(node, newNode);\r\n    },\r\n\r\n    _splitRoot: function (node, newNode)\r\n    {\r\n        // split root node\r\n        this.data = createNode([node, newNode]);\r\n        this.data.height = node.height + 1;\r\n        this.data.leaf = false;\r\n        calcBBox(this.data, this.toBBox);\r\n    },\r\n\r\n    _chooseSplitIndex: function (node, m, M)\r\n    {\r\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\r\n\r\n        minOverlap = minArea = Infinity;\r\n\r\n        for (i = m; i <= M - m; i++) {\r\n            bbox1 = distBBox(node, 0, i, this.toBBox);\r\n            bbox2 = distBBox(node, i, M, this.toBBox);\r\n\r\n            overlap = intersectionArea(bbox1, bbox2);\r\n            area = bboxArea(bbox1) + bboxArea(bbox2);\r\n\r\n            // choose distribution with minimum overlap\r\n            if (overlap < minOverlap) {\r\n                minOverlap = overlap;\r\n                index = i;\r\n\r\n                minArea = area < minArea ? area : minArea;\r\n\r\n            } else if (overlap === minOverlap) {\r\n                // otherwise choose distribution with minimum area\r\n                if (area < minArea) {\r\n                    minArea = area;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    },\r\n\r\n    // sorts node children by the best axis for split\r\n    _chooseSplitAxis: function (node, m, M)\r\n    {\r\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\r\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\r\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\r\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\r\n\r\n        // if total distributions margin value is minimal for x, sort by minX,\r\n        // otherwise it's already sorted by minY\r\n        if (xMargin < yMargin) node.children.sort(compareMinX);\r\n    },\r\n\r\n    // total margin of all possible split distributions where each node is at least m full\r\n    _allDistMargin: function (node, m, M, compare)\r\n    {\r\n        node.children.sort(compare);\r\n\r\n        var toBBox = this.toBBox,\r\n            leftBBox = distBBox(node, 0, m, toBBox),\r\n            rightBBox = distBBox(node, M - m, M, toBBox),\r\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\r\n            i, child;\r\n\r\n        for (i = m; i < M - m; i++) {\r\n            child = node.children[i];\r\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(leftBBox);\r\n        }\r\n\r\n        for (i = M - m - 1; i >= m; i--) {\r\n            child = node.children[i];\r\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(rightBBox);\r\n        }\r\n\r\n        return margin;\r\n    },\r\n\r\n    _adjustParentBBoxes: function (bbox, path, level)\r\n    {\r\n        // adjust bboxes along the given tree path\r\n        for (var i = level; i >= 0; i--) {\r\n            extend(path[i], bbox);\r\n        }\r\n    },\r\n\r\n    _condense: function (path)\r\n    {\r\n        // go through the path, removing empty nodes and updating bboxes\r\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\r\n            if (path[i].children.length === 0) {\r\n                if (i > 0) {\r\n                    siblings = path[i - 1].children;\r\n                    siblings.splice(siblings.indexOf(path[i]), 1);\r\n\r\n                } else this.clear();\r\n\r\n            } else calcBBox(path[i], this.toBBox);\r\n        }\r\n    },\r\n\r\n    compareMinX: function (a, b)\r\n    {\r\n        return a.left - b.left;\r\n    },\r\n\r\n    compareMinY: function (a, b)\r\n    {\r\n        return a.top - b.top;\r\n    },\r\n\r\n    toBBox: function (a)\r\n    {\r\n        return {\r\n            minX: a.left,\r\n            minY: a.top,\r\n            maxX: a.right,\r\n            maxY: a.bottom\r\n        };\r\n    }\r\n};\r\n\r\nfunction findItem (item, items, equalsFn)\r\n{\r\n    if (!equalsFn) return items.indexOf(item);\r\n\r\n    for (var i = 0; i < items.length; i++) {\r\n        if (equalsFn(item, items[i])) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n// calculate node's bbox from bboxes of its children\r\nfunction calcBBox (node, toBBox)\r\n{\r\n    distBBox(node, 0, node.children.length, toBBox, node);\r\n}\r\n\r\n// min bounding rectangle of node children from k to p-1\r\nfunction distBBox (node, k, p, toBBox, destNode)\r\n{\r\n    if (!destNode) destNode = createNode(null);\r\n    destNode.minX = Infinity;\r\n    destNode.minY = Infinity;\r\n    destNode.maxX = -Infinity;\r\n    destNode.maxY = -Infinity;\r\n\r\n    for (var i = k, child; i < p; i++) {\r\n        child = node.children[i];\r\n        extend(destNode, node.leaf ? toBBox(child) : child);\r\n    }\r\n\r\n    return destNode;\r\n}\r\n\r\nfunction extend (a, b)\r\n{\r\n    a.minX = Math.min(a.minX, b.minX);\r\n    a.minY = Math.min(a.minY, b.minY);\r\n    a.maxX = Math.max(a.maxX, b.maxX);\r\n    a.maxY = Math.max(a.maxY, b.maxY);\r\n    return a;\r\n}\r\n\r\nfunction compareNodeMinX (a, b) { return a.minX - b.minX; }\r\nfunction compareNodeMinY (a, b) { return a.minY - b.minY; }\r\n\r\nfunction bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }\r\nfunction bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\r\n\r\nfunction enlargedArea (a, b)\r\n{\r\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\r\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\r\n}\r\n\r\nfunction intersectionArea (a, b)\r\n{\r\n    var minX = Math.max(a.minX, b.minX),\r\n        minY = Math.max(a.minY, b.minY),\r\n        maxX = Math.min(a.maxX, b.maxX),\r\n        maxY = Math.min(a.maxY, b.maxY);\r\n\r\n    return Math.max(0, maxX - minX) *\r\n           Math.max(0, maxY - minY);\r\n}\r\n\r\nfunction contains (a, b)\r\n{\r\n    return a.minX <= b.minX &&\r\n           a.minY <= b.minY &&\r\n           b.maxX <= a.maxX &&\r\n           b.maxY <= a.maxY;\r\n}\r\n\r\nfunction intersects (a, b)\r\n{\r\n    return b.minX <= a.maxX &&\r\n           b.minY <= a.maxY &&\r\n           b.maxX >= a.minX &&\r\n           b.maxY >= a.minY;\r\n}\r\n\r\nfunction createNode (children)\r\n{\r\n    return {\r\n        children: children,\r\n        height: 1,\r\n        leaf: true,\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity\r\n    };\r\n}\r\n\r\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\r\n// combines selection algorithm with binary divide & conquer approach\r\n\r\nfunction multiSelect (arr, left, right, n, compare)\r\n{\r\n    var stack = [left, right],\r\n        mid;\r\n\r\n    while (stack.length)\r\n    {\r\n        right = stack.pop();\r\n        left = stack.pop();\r\n\r\n        if (right - left <= n) continue;\r\n\r\n        mid = left + Math.ceil((right - left) / n / 2) * n;\r\n        quickselect(arr, mid, left, right, compare);\r\n\r\n        stack.push(left, mid, mid, right);\r\n    }\r\n}\r\n\r\nmodule.exports = rbush;","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n    if (!filteringOptions) { filteringOptions = {}; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (isColliding && !tile.collides)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (hasInterestingFace && !tile.hasInterestingFace)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n * @param {number} width - The width of the area.\r\n * @param {number} height - The height of the area.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n{\r\n    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;\r\n\r\n    //  Top left corner of the rect, rounded down to include partial tiles\r\n    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    //  Bottom right corner of the rect, rounded up to include partial tiles\r\n    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);\r\n};\r\n\r\nmodule.exports = GetTilesWithinWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SafeRange = require('./SafeRange');\r\n\r\n/**\r\n * Returns all elements in the array.\r\n *\r\n * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n *\r\n * For example: `getAll('visible', true)` would return only elements that have their visible property set.\r\n *\r\n * Optionally you can specify a start and end index. For example if the array had 100 elements,\r\n * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n * the first 50 elements.\r\n *\r\n * @function Phaser.Utils.Array.GetAll\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to search.\r\n * @param {string} [property] - The property to test on each array element.\r\n * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n * @param {number} [startIndex] - An optional start index to search from.\r\n * @param {number} [endIndex] - An optional end index to search to.\r\n *\r\n * @return {array} All matching elements from the array.\r\n */\r\nvar GetAll = function (array, property, value, startIndex, endIndex)\r\n{\r\n    if (startIndex === undefined) { startIndex = 0; }\r\n    if (endIndex === undefined) { endIndex = array.length; }\r\n\r\n    var output = [];\r\n\r\n    if (SafeRange(array, startIndex, endIndex))\r\n    {\r\n        for (var i = startIndex; i < endIndex; i++)\r\n        {\r\n            var child = array[i];\r\n\r\n            if (!property ||\r\n                (property && value === undefined && child.hasOwnProperty(property)) ||\r\n                (property && value !== undefined && child[property] === value))\r\n            {\r\n                output.push(child);\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = GetAll;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction swap (arr, i, j)\r\n{\r\n    var tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp;\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction defaultCompare (a, b)\r\n{\r\n    return a < b ? -1 : a > b ? 1 : 0;\r\n}\r\n\r\n/**\r\n * A [Floyd-Rivest](https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm) quick selection algorithm.\r\n *\r\n * Rearranges the array items so that all items in the [left, k] range are smaller than all items in [k, right];\r\n * The k-th element will have the (k - left + 1)th smallest value in [left, right].\r\n *\r\n * The array is modified in-place.\r\n *\r\n * Based on code by [Vladimir Agafonkin](https://www.npmjs.com/~mourner)\r\n *\r\n * @function Phaser.Utils.Array.QuickSelect\r\n * @since 3.0.0\r\n *\r\n * @param {array} arr - The array to sort.\r\n * @param {number} k - The k-th element index.\r\n * @param {number} [left=0] - The index of the left part of the range.\r\n * @param {number} [right] - The index of the right part of the range.\r\n * @param {function} [compare] - An optional comparison function. Is passed two elements and should return 0, 1 or -1.\r\n */\r\nvar QuickSelect = function (arr, k, left, right, compare)\r\n{\r\n    if (left === undefined) { left = 0; }\r\n    if (right === undefined) { right = arr.length - 1; }\r\n    if (compare === undefined) { compare = defaultCompare; }\r\n\r\n    while (right > left)\r\n    {\r\n        if (right - left > 600)\r\n        {\r\n            var n = right - left + 1;\r\n            var m = k - left + 1;\r\n            var z = Math.log(n);\r\n            var s = 0.5 * Math.exp(2 * z / 3);\r\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\r\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\r\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\r\n\r\n            QuickSelect(arr, k, newLeft, newRight, compare);\r\n        }\r\n\r\n        var t = arr[k];\r\n        var i = left;\r\n        var j = right;\r\n\r\n        swap(arr, left, k);\r\n\r\n        if (compare(arr[right], t) > 0)\r\n        {\r\n            swap(arr, left, right);\r\n        }\r\n\r\n        while (i < j)\r\n        {\r\n            swap(arr, i, j);\r\n\r\n            i++;\r\n            j--;\r\n\r\n            while (compare(arr[i], t) < 0)\r\n            {\r\n                i++;\r\n            }\r\n\r\n            while (compare(arr[j], t) > 0)\r\n            {\r\n                j--;\r\n            }\r\n        }\r\n\r\n        if (compare(arr[left], t) === 0)\r\n        {\r\n            swap(arr, left, j);\r\n        }\r\n        else\r\n        {\r\n            j++;\r\n            swap(arr, j, right);\r\n        }\r\n\r\n        if (j <= k)\r\n        {\r\n            left = j + 1;\r\n        }\r\n\r\n        if (k <= j)\r\n        {\r\n            right = j - 1;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = QuickSelect;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../object/GetValue');\r\nvar Shuffle = require('./Shuffle');\r\n\r\nvar BuildChunk = function (a, b, qty)\r\n{\r\n    var out = [];\r\n\r\n    for (var aIndex = 0; aIndex < a.length; aIndex++)\r\n    {\r\n        for (var bIndex = 0; bIndex < b.length; bIndex++)\r\n        {\r\n            for (var i = 0; i < qty; i++)\r\n            {\r\n                out.push({ a: a[aIndex], b: b[bIndex] });\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\n/**\r\n * Creates an array populated with a range of values, based on the given arguments and configuration object.\r\n *\r\n * Range ([a,b,c], [1,2,3]) =\r\n * a1, a2, a3, b1, b2, b3, c1, c2, c3\r\n * \r\n * Range ([a,b], [1,2,3], qty = 3) =\r\n * a1, a1, a1, a2, a2, a2, a3, a3, a3, b1, b1, b1, b2, b2, b2, b3, b3, b3\r\n * \r\n * Range ([a,b,c], [1,2,3], repeat x1) =\r\n * a1, a2, a3, b1, b2, b3, c1, c2, c3, a1, a2, a3, b1, b2, b3, c1, c2, c3\r\n * \r\n * Range ([a,b], [1,2], repeat -1 = endless, max = 14) =\r\n * Maybe if max is set then repeat goes to -1 automatically?\r\n * a1, a2, b1, b2, a1, a2, b1, b2, a1, a2, b1, b2, a1, a2 (capped at 14 elements)\r\n * \r\n * Range ([a], [1,2,3,4,5], random = true) =\r\n * a4, a1, a5, a2, a3\r\n * \r\n * Range ([a, b], [1,2,3], random = true) =\r\n * b3, a2, a1, b1, a3, b2\r\n * \r\n * Range ([a, b, c], [1,2,3], randomB = true) =\r\n * a3, a1, a2, b2, b3, b1, c1, c3, c2\r\n * \r\n * Range ([a], [1,2,3,4,5], yoyo = true) =\r\n * a1, a2, a3, a4, a5, a5, a4, a3, a2, a1\r\n * \r\n * Range ([a, b], [1,2,3], yoyo = true) =\r\n * a1, a2, a3, b1, b2, b3, b3, b2, b1, a3, a2, a1\r\n *\r\n * @function Phaser.Utils.Array.Range\r\n * @since 3.0.0\r\n *\r\n * @param {array} a - The first array of range elements.\r\n * @param {array} b - The second array of range elements.\r\n * @param {object} [options] - A range configuration object. Can contain: repeat, random, randomB, yoyo, max, qty.\r\n *\r\n * @return {array} An array of arranged elements.\r\n */\r\nvar Range = function (a, b, options)\r\n{\r\n    var max = GetValue(options, 'max', 0);\r\n    var qty = GetValue(options, 'qty', 1);\r\n    var random = GetValue(options, 'random', false);\r\n    var randomB = GetValue(options, 'randomB', false);\r\n    var repeat = GetValue(options, 'repeat', 0);\r\n    var yoyo = GetValue(options, 'yoyo', false);\r\n\r\n    var out = [];\r\n\r\n    if (randomB)\r\n    {\r\n        Shuffle(b);\r\n    }\r\n\r\n    //  Endless repeat, so limit by max\r\n    if (repeat === -1)\r\n    {\r\n        if (max === 0)\r\n        {\r\n            repeat = 0;\r\n        }\r\n        else\r\n        {\r\n            //  Work out how many repeats we need\r\n            var total = (a.length * b.length) * qty;\r\n\r\n            if (yoyo)\r\n            {\r\n                total *= 2;\r\n            }\r\n\r\n            repeat = Math.ceil(max / total);\r\n        }\r\n    }\r\n\r\n    for (var i = 0; i <= repeat; i++)\r\n    {\r\n        var chunk = BuildChunk(a, b, qty);\r\n\r\n        if (random)\r\n        {\r\n            Shuffle(chunk);\r\n        }\r\n\r\n        out = out.concat(chunk);\r\n\r\n        if (yoyo)\r\n        {\r\n            chunk.reverse();\r\n\r\n            out = out.concat(chunk);\r\n        }\r\n    }\r\n\r\n    if (max)\r\n    {\r\n        out.splice(max);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Range;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tests if the start and end indexes are a safe range for the given array.\r\n * \r\n * @function Phaser.Utils.Array.SafeRange\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to check.\r\n * @param {number} startIndex - The start index.\r\n * @param {number} endIndex - The end index.\r\n * @param {boolean} [throwError=true] - Throw an error if the range is out of bounds.\r\n *\r\n * @return {boolean} True if the range is safe, otherwise false.\r\n */\r\nvar SafeRange = function (array, startIndex, endIndex, throwError)\r\n{\r\n    var len = array.length;\r\n\r\n    if (startIndex < 0 ||\r\n        startIndex > len ||\r\n        startIndex >= endIndex ||\r\n        endIndex > len ||\r\n        startIndex + endIndex > len)\r\n    {\r\n        if (throwError)\r\n        {\r\n            throw new Error('Range Error: Values outside acceptable range');\r\n        }\r\n\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        return true;\r\n    }\r\n};\r\n\r\nmodule.exports = SafeRange;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Shallow Object Clone. Will not clone nested objects.\r\n *\r\n * @function Phaser.Utils.Objects.Clone\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj - The object to clone.\r\n *\r\n * @return {object} A new object with the same properties as the input object.\r\n */\r\nvar Clone = function (obj)\r\n{\r\n    var clone = {};\r\n\r\n    for (var key in obj)\r\n    {\r\n        if (Array.isArray(obj[key]))\r\n        {\r\n            clone[key] = obj[key].slice(0);\r\n        }\r\n        else\r\n        {\r\n            clone[key] = obj[key];\r\n        }\r\n    }\r\n\r\n    return clone;\r\n};\r\n\r\nmodule.exports = Clone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clone = require('./Clone');\r\n\r\n/**\r\n * Creates a new Object using all values from obj1 and obj2.\r\n * If a value exists in both obj1 and obj2, the value in obj1 is used.\r\n * \r\n * This is only a shallow copy. Deeply nested objects are not cloned, so be sure to only use this\r\n * function on shallow objects.\r\n *\r\n * @function Phaser.Utils.Objects.Merge\r\n * @since 3.0.0\r\n *\r\n * @param {object} obj1 - The first object.\r\n * @param {object} obj2 - The second object.\r\n *\r\n * @return {object} A new object containing the union of obj1's and obj2's properties.\r\n */\r\nvar Merge = function (obj1, obj2)\r\n{\r\n    var clone = Clone(obj1);\r\n\r\n    for (var key in obj2)\r\n    {\r\n        if (!clone.hasOwnProperty(key))\r\n        {\r\n            clone[key] = obj2[key];\r\n        }\r\n    }\r\n\r\n    return clone;\r\n};\r\n\r\nmodule.exports = Merge;\r\n"],"names":["DistanceBetween","module","exports","circleA","circleB","x","y","radius","circle","rect","halfWidth","width","halfHeight","height","cx","Math","abs","cy","xDist","yDist","xCornerDist","yCornerDist","value","min","max","CONST","degrees","DEG_TO_RAD","Clamp","percent","radians","RAD_TO_DEG","point","angle","distance","t","atan2","cos","sin","range","point1","point2","x1","y1","x2","y2","dx","dy","sqrt","a","b","epsilon","undefined","Class","Components","Image","ArcadeImage","Extends","Mixins","Acceleration","Angular","Bounce","Debug","Drag","Enable","Friction","Gravity","Immovable","Mass","Pushable","Size","Velocity","initialize","scene","texture","frame","call","this","body","DegToRad","DistanceSquared","Factory","GetFastValue","Merge","OverlapCirc","OverlapRect","PluginCache","SceneEvents","Vector2","World","ArcadePhysics","systems","sys","config","getConfig","world","add","events","once","BOOT","boot","on","START","start","DESTROY","destroy","eventEmitter","UPDATE","update","POST_UPDATE","postUpdate","SHUTDOWN","shutdown","enableUpdate","disableUpdate","off","gameConfig","game","physics","sceneConfig","settings","overlap","object1","object2","overlapCallback","processCallback","callbackContext","collideObjects","collide","collideCallback","collideTiles","sprite","tiles","overlapTiles","pause","resume","accelerateTo","gameObject","speed","xSpeedMax","ySpeedMax","acceleration","setToPolar","maxVelocity","set","accelerateToObject","destination","closest","source","targets","bodies","entries","Number","MAX_VALUE","len","length","i","target","center","furthest","farthest","moveTo","maxTime","velocity","moveToObject","velocityFromAngle","vec2","velocityFromRotation","rotation","overlapRect","includeDynamic","includeStatic","overlapCirc","register","Sprite","ArcadeSprite","Events","RadToDeg","Rectangle","RectangleContains","Body","displayWidth","displayHeight","transform","scaleX","scaleY","displayOriginX","displayOriginY","debugShowBody","defaults","debugShowVelocity","debugBodyColor","bodyDebugColor","enable","isCircle","offset","position","prev","clone","prevFrame","allowRotation","preRotation","sourceWidth","sourceHeight","realWidth","realHeight","newVelocity","deltaMax","allowDrag","drag","allowGravity","gravity","bounce","worldBounce","customBoundsRectangle","bounds","onWorldBounds","onCollide","onOverlap","maxSpeed","friction","useDamping","angularVelocity","angularAcceleration","angularDrag","maxAngular","mass","facing","FACING_NONE","immovable","pushable","moves","customSeparateX","customSeparateY","overlapX","overlapY","overlapR","embedded","collideWorldBounds","checkCollision","none","up","down","left","right","touching","wasTouching","blocked","syncBounds","physicsType","DYNAMIC_BODY","_sx","_sy","_dx","_dy","_tx","_ty","_bounds","updateBounds","parentContainer","matrix","getWorldTransformMatrix","_tempMatrix","_tempMatrix2","tx","ty","recalc","getBounds","asx","asy","floor","updateCenter","updateFromGameObject","resetFlags","clear","preUpdate","willStep","delta","updateMotion","vx","vy","checkWorldBounds","emit","WORLD_BOUNDS","mx","my","FACING_LEFT","FACING_RIGHT","FACING_UP","FACING_DOWN","deltaZ","setBoundsRectangle","pos","check","bx","by","wasSet","bottom","setOffset","setSize","getCenter","ox","oy","setCircle","offsetX","offsetY","reset","stop","setPosition","getTopLeft","copy","obj","hitTest","top","onFloor","onCeiling","onWall","deltaAbsX","deltaAbsY","deltaX","deltaY","deltaXFinal","deltaYFinal","pendingDestroy","drawDebug","graphic","lineStyle","defaultStrokeWidth","strokeCircle","lineBetween","velocityDebugColor","willDrawDebug","setCollideWorldBounds","bounceX","bounceY","setBounceX","setBounceY","setVelocity","setVelocityX","setVelocityY","setMaxVelocity","setMaxVelocityX","setMaxVelocityY","setMaxSpeed","setBounce","setAcceleration","setAccelerationX","setAccelerationY","setAllowDrag","setAllowGravity","setAllowRotation","setDrag","setDamping","setDragX","setDragY","setGravity","setGravityX","setGravityY","setFriction","setFrictionX","setFrictionY","setAngularVelocity","setAngularAcceleration","setAngularDrag","setMass","setImmovable","setEnable","processX","processY","get","Collider","overlapOnly","name","active","setName","removeCollider","PhysicsGroup","StaticPhysicsGroup","collider","addCollider","addOverlap","existing","isStatic","type","STATIC_BODY","enableBody","staticImage","key","image","displayList","staticSprite","updateList","staticGroup","children","group","body1","body2","bias","maxOverlap","Group","IsPlainObject","internalCreateCallback","createCallbackHandler","internalRemoveCallback","removeCallbackHandler","Array","isArray","_this","forEach","singleConfig","classType","child","disableBody","step","items","getChildren","body1Pushable","body2Pushable","body1MassImpact","body2MassImpact","body1FullImpact","body2FullImpact","body1MovingLeft","body1MovingRight","body1Stationary","body2MovingLeft","body2MovingRight","body2Stationary","body1OnLeft","body2OnLeft","BlockCheck","Run","side","halfOverlap","Check","v1","v2","nv1","nv2","avg","Set","b1","b2","ov","RunImmovableBody1","blockedState","RunImmovableBody2","body1MovingUp","body1MovingDown","body2MovingUp","body2MovingDown","body1OnTop","body2OnTop","GetOverlapX","ProcessX","body1Immovable","body2Immovable","GetOverlapY","ProcessY","CircleContains","StaticBody","debugShowStaticBody","staticBodyDebugColor","originX","originY","ZERO","setGameObject","staticTree","remove","insert","strokeRect","createMultipleCallback","createMultipleCallbackHandler","refresh","AngleBetweenPoints","EventEmitter","FuzzyEqual","FuzzyGreaterThan","FuzzyLessThan","GetTilesWithinWorldXY","GetValue","MATH_CONST","ProcessQueue","ProcessTileCallbacks","RTree","SeparateTile","SeparateX","SeparateY","TileIntersectsBody","TransformMatrix","Wrap","staticBodies","colliders","scale","fps","fixedStep","_elapsed","_frameTime","_frameTimeMS","stepsLastFrame","timeScale","OVERLAP_BIAS","TILE_BIAS","forceX","isPaused","_total","debugGraphic","maxEntries","useTree","tree","treeMinMax","minX","minY","maxX","maxY","createDebugGraphic","object","bodyType","entry","isParent","c","disable","delete","graphics","setDepth","setBounds","checkLeft","checkRight","checkUp","checkDown","setTo","setBoundsCollision","PAUSE","RESUME","setFPS","framerate","time","size","fixedDelta","msPerFrame","load","WORLD_STEP","dynamic","pending","dynamicTree","computeAngularVelocity","computeVelocity","velocityDelta","velocityX","accelerationX","dragX","velocityY","accelerationY","dragY","pow","normalize","separate","intersects","separateCircle","bodyRect","bodyCircle","resultX","resultY","result","OVERLAP","COLLIDE","d","nx","ny","p","EPSILON","circleBodyIntersects","j","object1isArray","object2isArray","collideHandler","collideGroupVsGroup","collideSpriteVsSprite","collideSpriteVsGroup","isTilemap","collideSpriteVsTilemapLayer","collideGroupVsTilemapLayer","sprite1","sprite2","bodyB","bodyA","minMax","results","search","contains","skipIndex","indexOf","tilemapLayer","didCollide","collideSpriteVsTilesHandler","w","h","layerData","layer","tileWidth","baseTileWidth","xDiff","tileHeight","baseTileHeight","mapData","cameras","main","isLayer","tile","tileWorldRect","collision","tileToWorldXY","baseHeight","TILE_OVERLAP","TILE_COLLIDE","group1","group2","wrap","padding","wrapObject","wrapArray","objects","removeAllListeners","setDebug","showBody","showVelocity","bodyColor","setDebugBodyColor","enableGameObject","showGameObject","visible","disableGameObject","hideGameObject","refreshBody","Circle","CircleToCircle","CircleToRectangle","bodiesInRect","area","circFromBody","bodiesInArea","push","dynamicBodies","fakeBody","iterate","concat","setPushable","setBodySize","GROUP","TILEMAPLAYER","Extend","Arcade","StaticGroup","Tilemap","collisionCallback","collisionCallbackContext","callbacks","index","callback","TileCheckX","TileCheckY","tileBias","tileLeft","tileTop","tileRight","tileBottom","faceHorizontal","faceLeft","faceRight","faceVertical","faceTop","faceBottom","ProcessTileSeparationX","collideLeft","collideRight","ProcessTileSeparationY","collideUp","collideDown","Matter","BodyBounds","boundsCenter","centerDiff","parseBody","hasOwnProperty","boundsWidth","boundsHeight","bodyCenterX","centerOfMass","bodyCenterY","diff","getTopCenter","getTopRight","getLeftCenter","getRightCenter","getBottomLeft","getBottomCenter","getBottomRight","Composite","Detector","Grid","Pairs","Pair","Query","Resolver","SAT","Constraint","Common","Engine","Sleeping","Plugin","Bodies","Composites","Axes","Bounds","Svg","Vector","Vertices","addComposite","addBody","addConstraint","MatterGameObject","MatterImage","MatterSprite","MatterTileBody","PhysicsEditorParser","PhysicsJSONParser","PointerConstraint","rectangle","options","trapezoid","slope","maxSides","polygon","sides","fromVertices","vertexSets","flagInternal","removeCollinear","minimumArea","fromPath","fromPhysicsEditor","addToWorld","has","fromSVG","xml","path","getElementsByTagName","points","pathToVertices","fromJSON","imageStack","columns","rows","columnGap","rowGap","stack","pyramid","chain","composite","xOffsetA","yOffsetA","xOffsetB","yOffsetB","mesh","crossBrace","newtonsCradle","number","car","wheelSize","softBody","particleRadius","particleOptions","constraintOptions","joint","stiffness","constraint","spring","isNaN","create","worldConstraint","mouseSpring","pointerConstraint","render","tileBody","temp","Collision","Force","Sensor","SetBody","Sleep","Static","Transform","mixin","def","Object","defineProperty","_tempVec2","setExistingBody","shape","setBody","GameObject","Pipeline","_crop","resetCropObject","setTexture","setSizeToFrame","setOrigin","setRectangle","initPipeline","ALIGN_CONST","MatterAttractors","MatterCollisionEvents","MatterLib","MatterWrap","MatterPhysics","bodyBounds","detector","grid","pair","pairs","query","resolver","sat","composites","axes","svg","vector","vertices","verts","enableCollisionEventsPlugin","enableAttractorPlugin","enableWrapPlugin","_restingThresh","_restingThreshTangent","_positionDampen","_positionWarming","_frictionNormalMultiplier","use","set60Hz","getDelta","update60Hz","autoUpdate","set30Hz","update30Hz","correction","containsPoint","getMatterBodies","intersectPoint","output","intersectRect","outside","region","intersectRay","rayWidth","collisions","ray","intersectBody","collides","match","info","id","setCollisionCategory","collisionFilter","category","setCollisionGroup","setCollidesWith","categories","flags","mask","getAllBodies","applyForce","force","applyForceFromPosition","applyForceFromAngle","getConstraintLength","aX","pointA","aY","bX","pointB","bY","alignBody","align","TOP_LEFT","LEFT_TOP","TOP_CENTER","TOP_RIGHT","RIGHT_TOP","LEFT_CENTER","CENTER","RIGHT_CENTER","LEFT_BOTTOM","BOTTOM_LEFT","BOTTOM_CENTER","BOTTOM_RIGHT","RIGHT_BOTTOM","AnimationState","anims","HasValue","matterBody","collisionGroup","getCollisionGroup","setFromTileCollision","setFromTileRectangle","sx","sy","tileX","getLeft","tileY","getTop","collisionObjects","parts","ow","oh","ellipse","polyline","map","centre","removeBody","fixtureConfigs","fixtures","fc","fixtureParts","parseFixture","matterConfig","extend","setParts","fixtureConfig","r","parseVertices","v","clockwiseSort","flagCoincidentParts","part","label","InputEvents","camera","pointer","angularStiffness","BEFORE_UPDATE","input","POINTER_DOWN","onDown","POINTER_UP","onUp","getBody","getWorldPoint","allBodies","localWorld","ignorePointer","canCollide","hitTestBody","DRAG_START","partsLength","angleB","isDown","DRAG","stopDrag","DRAG_END","removeConstraint","MatterBody","MatterEvents","MatterWorld","engine","walls","enabled","runnerConfig","hasFPS","deltaMin","runner","deltaSampleSize","counterTimestamp","frameCounter","deltaHistory","timePrev","timeScalePrev","frameRequestId","isFixed","debugConfig","showAxes","showAngleIndicator","angleColor","showBroadphase","broadphaseColor","showBounds","boundsColor","velocityColor","showCollisions","collisionColor","showSeparations","separationColor","showStaticBody","showInternalEdges","renderFill","renderLine","fillColor","fillOpacity","lineColor","lineOpacity","lineThickness","staticFillColor","staticLineColor","showSleeping","staticBodySleepOpacity","sleepFillColor","sleepLineColor","showSensors","sensorFillColor","sensorLineColor","showPositions","positionSize","positionColor","showJoint","jointColor","jointLineOpacity","jointLineThickness","pinSize","pinColor","springColor","anchorColor","anchorSize","showConvexHulls","hullColor","setEventsProxy","boundsConfig","thickness","setCompositeRenderStyle","constraints","setBodyRenderStyle","setConstraintRenderStyle","event","BEFORE_ADD","AFTER_ADD","BEFORE_REMOVE","AFTER_REMOVE","AFTER_UPDATE","COLLISION_START","COLLISION_ACTIVE","COLLISION_END","updateWall","wall","frictionStatic","disableGravity","deep","entity","convertTilemapLayer","getTilesWithin","isColliding","convertTiles","nextGroup","isNonColliding","nextCategory","timing","slice","apply","src","getAllConstraints","allConstraints","getAllComposites","allComposites","broadphase","controller","renderGrid","renderBodyBounds","renderBodies","renderJoints","renderBodyAxes","renderBodyVelocity","renderSeparations","list","renderCollisions","bucketKeys","keys","buckets","bucketId","split","parseInt","bucketWidth","bucketHeight","isActive","posA","posB","penetration","k","fillStyle","activeContacts","vertex","fillRect","contacts","normalPosX","normalPosY","supports","normal","axis","positionPrev","isSleeping","renderBody","renderConvexHull","opacity","isSensor","circleRadius","beginPath","arc","PI","vertLength","vert","isInternal","lineTo","nextIndex","closePath","fillPath","strokePath","px","py","hs","ceil","renderConstraint","end","sub","perp","normalise","coils","clamp","anchors","fillCircle","resetCollisionIDs","_nextCollidingGroupId","_nextNonCollidingGroupId","_nextCategory","restitution","setOnCollide","onCollideCallback","setOnCollideEnd","onCollideEndCallback","setOnCollideActive","onCollideActiveCallback","setOnCollideWith","applyForceFrom","thrust","thrustLeft","thrustRight","thrustBack","air","fstatic","frictionAir","setFrictionAir","setFrictionStatic","setIgnoreGravity","ignoreGravity","setDensity","setSensor","FuzzyEquals","setPolygon","setTrapezoid","_originComponent","rx","xOffset","ry","yOffset","comx","comy","centerOffset","shapeType","bodyX","bodyY","bodyWidth","bodyHeight","pRadius","setVertices","setToSleep","setAwake","setSleepThreshold","sleepThreshold","setSleepEvents","setSleepStartEvent","setSleepEndEvent","SLEEP_START","SLEEP_END","setStatic","WrapAngle","WrapAngleDegrees","_scaleX","factorX","factorY","_scaleY","renderFlags","_rotation","setAngle","setRotation","setFixedRotation","setInertia","Infinity","setScale","PolyDecomp","TileBody","_inertiaScale","nextId","plugin","torque","positionImpulse","previousPositionImpulse","constraintImpulse","totalContacts","angularSpeed","motion","density","slop","chamfer","anglePrev","parent","inverseMass","inertia","inverseInertia","_original","gravityScale","onCollideWith","_initProperties","rotate","property","prototype","setCentre","moment","translate","autoHull","hull","hullCentre","total","_totalProperties","relative","rotateAbout","magnitude","translation","totalArea","totalInertia","deltaTime","deltaTimeSquared","velocityPrevX","velocityPrevY","properties","mult","div","isModified","setModified","updateParents","updateChildren","trigger","childComposite","warn","removeComposite","compositeA","compositeB","removeCompositeAt","splice","removeBodyAt","removeConstraintAt","keepStatic","filter","toString","move","rebase","recursive","broadphasePairs","pairsTable","table","metrics","midphaseTests","overlaps","partA","partB","previousCollision","narrowphaseTests","reused","narrowReuseCount","collided","narrowDetections","filterA","filterB","pairsList","forceUpdate","col","row","bucket","gridChanged","broadphaseTests","newRegion","_getRegion","union","_regionUnion","startCol","endCol","startRow","endRow","_getBucketId","isInsideNewRegion","isInsideOldRegion","_bucketRemoveBody","_createBucket","_bucketAddBody","_createActivePairsList","regionA","regionB","_createRegion","column","pairId","pairKeys","timestamp","separation","confirmedActive","timeCreated","timeUpdated","parentA","parentB","contact","supportCount","depth","setActive","_pairMaxIdleLife","collisionStart","collisionActive","collisionEnd","removeOld","pairIndex","indexesToRemove","startPoint","endPoint","rayAngle","rayLength","rayX","rayY","preSolvePosition","activeCount","solvePosition","normalX","normalY","positionImpulseA","positionImpulseB","contactShare","bodyBtoAX","bodyBtoAY","impulseCoefficient","postSolvePosition","dot","preSolveVelocity","tangent","contactVertex","normalImpulse","tangentImpulse","impulse","_temp","tempA","cross","solveVelocity","timeScaleSquared","tempB","tempC","tempD","tempE","offsetA","offsetB","velocityPointA","velocityPointB","relativeVelocity","normalVelocity","tangentVelocity","tangentSpeed","tangentVelocityDirection","sign","normalForce","maxFriction","oAcN","oBcN","share","contactNormalImpulse","contactTangentImpulse","overlapAB","overlapBA","minOverlap","canReusePrevCol","axisBodyA","axisBody","axisBodyB","axisNumber","_overlapAxes","verticesB","_findSupports","verticesA","neg","projectionA","projectionB","_projectToAxis","projection","vertexA","vertexB","nearestDistance","vertexToBody","bodyAPosition","_warming","_torqueDampen","_minLength","initialPointA","initialPointB","damping","angleA","preSolveAll","solveAll","fixedA","fixedB","solve","pointAWorld","pointBWorld","currentLength","difference","massTotal","resistanceTotal","zero","postSolveAll","_nextId","_seed","_nowStartTime","Date","argsStart","deepClone","arguments","prop","constructor","values","begin","val","shuffle","array","random","choose","choices","isElement","HTMLElement","nodeType","nodeName","isFunction","isPlainObject","isString","now","window","performance","webkitNow","_seededRandom","colorToNumber","colorString","replace","charAt","logLevel","log","console","haystack","needle","func","mapped","topologicalSort","graph","visited","node","_topologicalSort","neighbors","neighbor","funcs","_chained","lastResult","args","l","chainPathBefore","base","chainPathAfter","Metrics","element","positionIterations","velocityIterations","constraintIterations","enableSleeping","extended","_bodiesApplyGravity","_bodiesUpdate","afterCollisions","_bodiesClearForces","merge","engineA","engineB","worldBounds","eventNames","names","join","newCallbacks","eventClone","version","uses","used","before","after","narrowReuse","narrowEff","midEff","broadEff","toFixed","_registry","isPlugin","registered","pluginVersion","versionParse","registeredVersion","resolve","dependency","dependencyParse","install","isUsed","isFor","parsed","for","versionSatisfies","plugins","dependencies","sortedDependencies","status","_warned","silent","tracked","parsedBase","resolved","test","identifiers","isRange","substr","operator","prerelease","rangeParsed","rangeParts","versionParsed","versionParts","_motionWakeThreshold","_motionSleepThreshold","_minBias","timeFactor","minMotion","maxMotion","sleepCounter","sleepingBody","movingBody","wasSleeping","decomp","quality","qualityMin","qualityMax","verticesPath","x3","theta","xx","yy","isConvex","concave","makeCCW","removeCollinearPoints","decomposed","quickDecomp","chunkVertices","maxDistance","pav","pbv","z","da","magnitudeSquared","db","lastBody","maxHeight","bodyAHeight","bodyAWidth","bodyBHeight","bodyC","actualRows","lastBodyWidth","wheelAOffset","wheelBOffset","wheelA","wheelB","axelA","axelB","gradient","boundsA","boundsB","shift","sampleLength","il","segment","segments","segmentsQueue","lastSegment","lastPoint","lx","ly","addPoint","pathSegType","isRelative","addSegmentPoint","segType","pathSegTypeAsLetter","toUpperCase","_svgPathToAbsolute","getTotalLength","pathSegList","numberOfItems","getItem","getPathSegAtLength","getPointAtLength","x0","y0","segs","seg","replaceItem","createSVGPathSegMovetoAbs","createSVGPathSegLinetoAbs","createSVGPathSegLinetoHorizontalAbs","createSVGPathSegLinetoVerticalAbs","createSVGPathSegCurvetoCubicAbs","createSVGPathSegCurvetoCubicSmoothAbs","createSVGPathSegCurvetoQuadraticAbs","createSVGPathSegCurvetoQuadraticSmoothAbs","createSVGPathSegArcAbs","r1","r2","largeArcFlag","sweepFlag","vectorA","vectorB","cross3","vectorC","scalar","negate","parseFloat","mean","average","signed","numerator","denominator","n","vertice","nextVertice","newVertices","prevVertex","nextVertex","currentRadius","prevNormal","nextNormal","diagonalRadius","radiusVector","midNormal","scaledVertex","precision","acos","sort","flag","upper","lower","pop","init","attractors","attractor","forceVector","Attractors","gravityConstant","bToA","distanceSq","matter","objectBounds","lineInt","l1","l2","a1","c1","a2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","s","triangleArea","isLeft","isLeftOn","isRight","isRightOn","edges","polygonGetCutEdges","polygonSlice","polygonQuickDecomp","reflexVertices","steinerPoints","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","poly","polygonIsReflex","polygonAt","getIntersectionPoint","sqdist","polygonAppend","polygonCanSee2","isSimple","num","collinear","removeDuplicatePoints","pi","points_eq","br","tmp","N","polygonReverse","tmpPoint1","tmpPoint2","thresholdAngle","ab","bc","magA","magB","from","to","tmpLine1","tmpLine2","polygonCanSee","dist","polygonCopy","targetPoly","polygonClear","tmp1","tmp2","tmpPoly","nDiags","cutEdges","polys","cutEdge","quickselect","rbush","_maxEntries","_minEntries","findItem","item","equalsFn","calcBBox","toBBox","distBBox","destNode","createNode","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","multiSelect","arr","compare","mid","all","_all","data","bbox","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","goingUp","indexes","_condense","compareMinX","compareMinY","toJSON","M","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","_allDistMargin","leftBBox","rightBBox","margin","siblings","filteringOptions","isNotEmpty","hasInterestingFace","GetTilesWithin","pointStart","pointEnd","worldX","worldY","worldToTileXY","tilemap","_convert","WorldToTileXY","xStart","yStart","xEnd","yEnd","SafeRange","startIndex","endIndex","swap","defaultCompare","QuickSelect","exp","sd","newLeft","newRight","Shuffle","BuildChunk","qty","out","aIndex","bIndex","randomB","repeat","yoyo","chunk","reverse","throwError","Error","Clone","obj1","obj2"],"sourceRoot":""}