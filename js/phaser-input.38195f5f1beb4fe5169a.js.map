{"version":3,"file":"js/phaser-input.38195f5f1beb4fe5169a.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/canvas/CanvasPool.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/display/canvas/Smoothing.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Circle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Circumference.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/CircumferencePoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Contains.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/GetPoint.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/GetPoints.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/circle/Random.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/ellipse/Random.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/geom/triangle/Random.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/CreateInteractiveObject.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/CreatePixelPerfectHandler.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/InputPlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/InputPluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/Axis.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/Button.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/Gamepad.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/GamepadPlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/configs/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/gamepad/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/KeyboardPlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/combo/KeyCombo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/UP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/DownDuration.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/JustDown.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/JustUp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/Key.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/KeyMap.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/keyboard/keys/UpDuration.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/mouse/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/input/touch/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/FromPercent.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/SmoothStep.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/angle/Between.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/distance/DistanceBetween.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/interpolation/SmoothStepInterpolation.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/SnapFloor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Remove.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetValue.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../../const');\r\nvar Smoothing = require('./Smoothing');\r\n\r\n// The pool into which the canvas elements are placed.\r\nvar pool = [];\r\n\r\n//  Automatically apply smoothing(false) to created Canvas elements\r\nvar _disableContextSmoothing = false;\r\n\r\n/**\r\n * The CanvasPool is a global static object, that allows Phaser to recycle and pool 2D Context Canvas DOM elements.\r\n * It does not pool WebGL Contexts, because once the context options are set they cannot be modified again, \r\n * which is useless for some of the Phaser pipelines / renderer.\r\n *\r\n * This singleton is instantiated as soon as Phaser loads, before a Phaser.Game instance has even been created.\r\n * Which means all instances of Phaser Games on the same page can share the one single pool.\r\n *\r\n * @namespace Phaser.Display.Canvas.CanvasPool\r\n * @since 3.0.0\r\n */\r\nvar CanvasPool = function ()\r\n{\r\n    /**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {number} [width=1] - The width of the Canvas.\r\n     * @param {number} [height=1] - The height of the Canvas.\r\n     * @param {number} [canvasType=Phaser.CANVAS] - The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`.\r\n     * @param {boolean} [selfParent=false] - Use the generated Canvas element as the parent?\r\n     *\r\n     * @return {HTMLCanvasElement} The canvas element that was created or pulled from the pool\r\n     */\r\n    var create = function (parent, width, height, canvasType, selfParent)\r\n    {\r\n        if (width === undefined) { width = 1; }\r\n        if (height === undefined) { height = 1; }\r\n        if (canvasType === undefined) { canvasType = CONST.CANVAS; }\r\n        if (selfParent === undefined) { selfParent = false; }\r\n\r\n        var canvas;\r\n        var container = first(canvasType);\r\n\r\n        if (container === null)\r\n        {\r\n            container = {\r\n                parent: parent,\r\n                canvas: document.createElement('canvas'),\r\n                type: canvasType\r\n            };\r\n\r\n            if (canvasType === CONST.CANVAS)\r\n            {\r\n                pool.push(container);\r\n            }\r\n\r\n            canvas = container.canvas;\r\n        }\r\n        else\r\n        {\r\n            container.parent = parent;\r\n\r\n            canvas = container.canvas;\r\n        }\r\n\r\n        if (selfParent)\r\n        {\r\n            container.parent = canvas;\r\n        }\r\n\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        if (_disableContextSmoothing && canvasType === CONST.CANVAS)\r\n        {\r\n            Smoothing.disable(canvas.getContext('2d'));\r\n        }\r\n\r\n        return canvas;\r\n    };\r\n\r\n    /**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.create2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {number} [width=1] - The width of the Canvas.\r\n     * @param {number} [height=1] - The height of the Canvas.\r\n     *\r\n     * @return {HTMLCanvasElement} The created canvas.\r\n     */\r\n    var create2D = function (parent, width, height)\r\n    {\r\n        return create(parent, width, height, CONST.CANVAS);\r\n    };\r\n\r\n    /**\r\n     * Creates a new Canvas DOM element, or pulls one from the pool if free.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.createWebGL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The parent of the Canvas object.\r\n     * @param {number} [width=1] - The width of the Canvas.\r\n     * @param {number} [height=1] - The height of the Canvas.\r\n     *\r\n     * @return {HTMLCanvasElement} The created WebGL canvas.\r\n     */\r\n    var createWebGL = function (parent, width, height)\r\n    {\r\n        return create(parent, width, height, CONST.WEBGL);\r\n    };\r\n\r\n    /**\r\n     * Gets the first free canvas index from the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.first\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [canvasType=Phaser.CANVAS] - The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`.\r\n     *\r\n     * @return {HTMLCanvasElement} The first free canvas, or `null` if a WebGL canvas was requested or if the pool doesn't have free canvases.\r\n     */\r\n    var first = function (canvasType)\r\n    {\r\n        if (canvasType === undefined) { canvasType = CONST.CANVAS; }\r\n\r\n        if (canvasType === CONST.WEBGL)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        for (var i = 0; i < pool.length; i++)\r\n        {\r\n            var container = pool[i];\r\n\r\n            if (!container.parent && container.type === canvasType)\r\n            {\r\n                return container;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.\r\n     * The canvas has its width and height set to 1, and its parent attribute nulled.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} parent - The canvas or the parent of the canvas to free.\r\n     */\r\n    var remove = function (parent)\r\n    {\r\n        //  Check to see if the parent is a canvas object\r\n        var isCanvas = parent instanceof HTMLCanvasElement;\r\n\r\n        pool.forEach(function (container)\r\n        {\r\n            if ((isCanvas && container.canvas === parent) || (!isCanvas && container.parent === parent))\r\n            {\r\n                container.parent = null;\r\n                container.canvas.width = 1;\r\n                container.canvas.height = 1;\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Gets the total number of used canvas elements in the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.total\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of used canvases.\r\n     */\r\n    var total = function ()\r\n    {\r\n        var c = 0;\r\n\r\n        pool.forEach(function (container)\r\n        {\r\n            if (container.parent)\r\n            {\r\n                c++;\r\n            }\r\n        });\r\n\r\n        return c;\r\n    };\r\n\r\n    /**\r\n     * Gets the total number of free canvas elements in the pool.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.free\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of free canvases.\r\n     */\r\n    var free = function ()\r\n    {\r\n        return pool.length - total();\r\n    };\r\n\r\n    /**\r\n     * Disable context smoothing on any new Canvas element created.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.disableSmoothing\r\n     * @since 3.0.0\r\n     */\r\n    var disableSmoothing = function ()\r\n    {\r\n        _disableContextSmoothing = true;\r\n    };\r\n\r\n    /**\r\n     * Enable context smoothing on any new Canvas element created.\r\n     *\r\n     * @function Phaser.Display.Canvas.CanvasPool.enableSmoothing\r\n     * @since 3.0.0\r\n     */\r\n    var enableSmoothing = function ()\r\n    {\r\n        _disableContextSmoothing = false;\r\n    };\r\n\r\n    return {\r\n        create2D: create2D,\r\n        create: create,\r\n        createWebGL: createWebGL,\r\n        disableSmoothing: disableSmoothing,\r\n        enableSmoothing: enableSmoothing,\r\n        first: first,\r\n        free: free,\r\n        pool: pool,\r\n        remove: remove,\r\n        total: total\r\n    };\r\n};\r\n\r\n//  If we export the called function here, it'll only be invoked once (not every time it's required).\r\nmodule.exports = CanvasPool();\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Browser specific prefix, so not going to change between contexts, only between browsers\r\nvar prefix = '';\r\n\r\n/**\r\n * @namespace Phaser.Display.Canvas.Smoothing\r\n * @since 3.0.0\r\n */\r\nvar Smoothing = function ()\r\n{\r\n    /**\r\n     * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.getPrefix\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - The canvas context to check.\r\n     *\r\n     * @return {string} The name of the property on the context which controls image smoothing (either `imageSmoothingEnabled` or a vendor-prefixed version thereof), or `null` if not supported.\r\n     */\r\n    var getPrefix = function (context)\r\n    {\r\n        var vendors = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ];\r\n\r\n        for (var i = 0; i < vendors.length; i++)\r\n        {\r\n            var s = vendors[i] + 'mageSmoothingEnabled';\r\n\r\n            if (s in context)\r\n            {\r\n                return s;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\r\n     * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\r\n     * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\r\n     * drawn to the context will be affected. This sets the property across all current browsers but support is\r\n     * patchy on earlier browsers, especially on mobile.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - The context on which to enable smoothing.\r\n     *\r\n     * @return {(CanvasRenderingContext2D|WebGLRenderingContext)} The provided context.\r\n     */\r\n    var enable = function (context)\r\n    {\r\n        if (prefix === '')\r\n        {\r\n            prefix = getPrefix(context);\r\n        }\r\n\r\n        if (prefix)\r\n        {\r\n            context[prefix] = true;\r\n        }\r\n\r\n        return context;\r\n    };\r\n\r\n    /**\r\n     * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\r\n     * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\r\n     * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\r\n     * drawn to the context will be affected. This sets the property across all current browsers but support is\r\n     * patchy on earlier browsers, especially on mobile.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - The context on which to disable smoothing.\r\n     *\r\n     * @return {(CanvasRenderingContext2D|WebGLRenderingContext)} The provided context.\r\n     */\r\n    var disable = function (context)\r\n    {\r\n        if (prefix === '')\r\n        {\r\n            prefix = getPrefix(context);\r\n        }\r\n\r\n        if (prefix)\r\n        {\r\n            context[prefix] = false;\r\n        }\r\n\r\n        return context;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.\r\n     * Returns null if no smoothing prefix is available.\r\n     *\r\n     * @function Phaser.Display.Canvas.Smoothing.isEnabled\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(CanvasRenderingContext2D|WebGLRenderingContext)} context - The context to check.\r\n     *\r\n     * @return {?boolean} `true` if smoothing is enabled on the context, otherwise `false`. `null` if not supported.\r\n     */\r\n    var isEnabled = function (context)\r\n    {\r\n        return (prefix !== null) ? context[prefix] : null;\r\n    };\r\n\r\n    return {\r\n        disable: disable,\r\n        enable: enable,\r\n        getPrefix: getPrefix,\r\n        isEnabled: isEnabled\r\n    };\r\n\r\n};\r\n\r\nmodule.exports = Smoothing();\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Contains = require('./Contains');\r\nvar GetPoint = require('./GetPoint');\r\nvar GetPoints = require('./GetPoints');\r\nvar GEOM_CONST = require('../const');\r\nvar Random = require('./Random');\r\n\r\n/**\r\n * @classdesc\r\n * A Circle object.\r\n *\r\n * This is a geometry object, containing numerical values and related methods to inspect and modify them.\r\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\r\n * To render a Circle you should look at the capabilities of the Graphics class.\r\n *\r\n * @class Circle\r\n * @memberof Phaser.Geom\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {number} [x=0] - The x position of the center of the circle.\r\n * @param {number} [y=0] - The y position of the center of the circle.\r\n * @param {number} [radius=0] - The radius of the circle.\r\n */\r\nvar Circle = new Class({\r\n\r\n    initialize:\r\n\r\n    function Circle (x, y, radius)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 0; }\r\n\r\n        /**\r\n         * The geometry constant type of this object: `GEOM_CONST.CIRCLE`.\r\n         * Used for fast type comparisons.\r\n         *\r\n         * @name Phaser.Geom.Circle#type\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.type = GEOM_CONST.CIRCLE;\r\n\r\n        /**\r\n         * The x position of the center of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y position of the center of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The internal radius of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#_radius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._radius = radius;\r\n\r\n        /**\r\n         * The internal diameter of the circle.\r\n         *\r\n         * @name Phaser.Geom.Circle#_diameter\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._diameter = radius * 2;\r\n    },\r\n\r\n    /**\r\n     * Check to see if the Circle contains the given x / y coordinates.\r\n     *\r\n     * @method Phaser.Geom.Circle#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to check within the circle.\r\n     * @param {number} y - The y coordinate to check within the circle.\r\n     *\r\n     * @return {boolean} True if the coordinates are within the circle, otherwise false.\r\n     */\r\n    contains: function (x, y)\r\n    {\r\n        return Contains(this, x, y);\r\n    },\r\n\r\n    /**\r\n     * Returns a Point object containing the coordinates of a point on the circumference of the Circle\r\n     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n     * at 180 degrees around the circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [out,$return]\r\n     *\r\n     * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\r\n     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\r\n     */\r\n    getPoint: function (position, point)\r\n    {\r\n        return GetPoint(this, position, point);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\r\n     * based on the given quantity or stepRate values.\r\n     *\r\n     * @method Phaser.Geom.Circle#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\r\n     *\r\n     * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\r\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n     *\r\n     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the circle.\r\n     */\r\n    getPoints: function (quantity, stepRate, output)\r\n    {\r\n        return GetPoints(this, quantity, stepRate, output);\r\n    },\r\n\r\n    /**\r\n     * Returns a uniformly distributed random point from anywhere within the Circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Geom.Point} O - [point,$return]\r\n     *\r\n     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.\r\n     *\r\n     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n     */\r\n    getRandomPoint: function (point)\r\n    {\r\n        return Random(this, point);\r\n    },\r\n\r\n    /**\r\n     * Sets the x, y and radius of this circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#setTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the center of the circle.\r\n     * @param {number} [y=0] - The y position of the center of the circle.\r\n     * @param {number} [radius=0] - The radius of the circle.\r\n     *\r\n     * @return {this} This Circle object.\r\n     */\r\n    setTo: function (x, y, radius)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this._radius = radius;\r\n        this._diameter = radius * 2;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this Circle to be empty with a radius of zero.\r\n     * Does not change its position.\r\n     *\r\n     * @method Phaser.Geom.Circle#setEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Circle object.\r\n     */\r\n    setEmpty: function ()\r\n    {\r\n        this._radius = 0;\r\n        this._diameter = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of this Circle.\r\n     *\r\n     * @method Phaser.Geom.Circle#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The x position of the center of the circle.\r\n     * @param {number} [y=0] - The y position of the center of the circle.\r\n     *\r\n     * @return {this} This Circle object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if the Circle is empty: has a radius of zero.\r\n     *\r\n     * @method Phaser.Geom.Circle#isEmpty\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the Circle is empty, otherwise false.\r\n     */\r\n    isEmpty: function ()\r\n    {\r\n        return (this._radius <= 0);\r\n    },\r\n\r\n    /**\r\n     * The radius of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#radius\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._radius = value;\r\n            this._diameter = value * 2;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The diameter of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#diameter\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    diameter: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._diameter;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._diameter = value;\r\n            this._radius = value * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The left position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#left\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.x - this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.x = value + this._radius;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The right position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#right\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.x + this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.x = value - this._radius;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The top position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#top\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    top: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.y - this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.y = value + this._radius;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The bottom position of the Circle.\r\n     *\r\n     * @name Phaser.Geom.Circle#bottom\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    bottom: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.y + this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.y = value - this._radius;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Circle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the circumference of the given Circle.\r\n *\r\n * @function Phaser.Geom.Circle.Circumference\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference of.\r\n *\r\n * @return {number} The circumference of the Circle.\r\n */\r\nvar Circumference = function (circle)\r\n{\r\n    return 2 * (Math.PI * circle.radius);\r\n};\r\n\r\nmodule.exports = Circumference;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\r\n *\r\n * @function Phaser.Geom.Circle.CircumferencePoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\r\n * @param {number} angle - The angle from the center of the Circle to the circumference to return the point from. Given in radians.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point, or point-like object, to store the results in. If not given a Point will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object where the `x` and `y` properties are the point on the circumference.\r\n */\r\nvar CircumferencePoint = function (circle, angle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    out.x = circle.x + (circle.radius * Math.cos(angle));\r\n    out.y = circle.y + (circle.radius * Math.sin(angle));\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = CircumferencePoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Check to see if the Circle contains the given x / y coordinates.\r\n *\r\n * @function Phaser.Geom.Circle.Contains\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\r\n * @param {number} x - The x coordinate to check within the circle.\r\n * @param {number} y - The y coordinate to check within the circle.\r\n *\r\n * @return {boolean} True if the coordinates are within the circle, otherwise false.\r\n */\r\nvar Contains = function (circle, x, y)\r\n{\r\n    //  Check if x/y are within the bounds first\r\n    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom)\r\n    {\r\n        var dx = (circle.x - x) * (circle.x - x);\r\n        var dy = (circle.y - y) * (circle.y - y);\r\n\r\n        return (dx + dy) <= (circle.radius * circle.radius);\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = Contains;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CircumferencePoint = require('./CircumferencePoint');\r\nvar FromPercent = require('../../math/FromPercent');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle\r\n * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\r\n * at 180 degrees around the circle.\r\n *\r\n * @function Phaser.Geom.Circle.GetPoint\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\r\n * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\r\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\r\n */\r\nvar GetPoint = function (circle, position, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var angle = FromPercent(position, 0, MATH_CONST.PI2);\r\n\r\n    return CircumferencePoint(circle, angle, out);\r\n};\r\n\r\nmodule.exports = GetPoint;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circumference = require('./Circumference');\r\nvar CircumferencePoint = require('./CircumferencePoint');\r\nvar FromPercent = require('../../math/FromPercent');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\r\n * based on the given quantity or stepRate values.\r\n *\r\n * @function Phaser.Geom.Circle.GetPoints\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get the points from.\r\n * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\r\n * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\r\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\r\n *\r\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the circumference of the circle.\r\n */\r\nvar GetPoints = function (circle, quantity, stepRate, out)\r\n{\r\n    if (out === undefined) { out = []; }\r\n\r\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\r\n    if (!quantity && stepRate > 0)\r\n    {\r\n        quantity = Circumference(circle) / stepRate;\r\n    }\r\n\r\n    for (var i = 0; i < quantity; i++)\r\n    {\r\n        var angle = FromPercent(i / quantity, 0, MATH_CONST.PI2);\r\n\r\n        out.push(CircumferencePoint(circle, angle));\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetPoints;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a uniformly distributed random point from anywhere within the given Circle.\r\n *\r\n * @function Phaser.Geom.Circle.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Circle} circle - The Circle to get a random point from.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point or point-like object to set the random `x` and `y` values in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n */\r\nvar Random = function (circle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var t = 2 * Math.PI * Math.random();\r\n    var u = Math.random() + Math.random();\r\n    var r = (u > 1) ? 2 - u : u;\r\n    var x = r * Math.cos(t);\r\n    var y = r * Math.sin(t);\r\n\r\n    out.x = circle.x + (x * circle.radius);\r\n    out.y = circle.y + (y * circle.radius);\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Random;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a uniformly distributed random point from anywhere within the given Ellipse.\r\n *\r\n * @function Phaser.Geom.Ellipse.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Ellipse} ellipse - The Ellipse to get a random point from.\r\n * @param {(Phaser.Geom.Point|object)} [out] - A Point or point-like object to set the random `x` and `y` values in.\r\n *\r\n * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\r\n */\r\nvar Random = function (ellipse, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    var p = Math.random() * Math.PI * 2;\r\n    var s = Math.sqrt(Math.random());\r\n\r\n    out.x = ellipse.x + ((s * Math.cos(p)) * ellipse.width / 2);\r\n    out.y = ellipse.y + ((s * Math.sin(p)) * ellipse.height / 2);\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Random;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Point = require('../point/Point');\r\n\r\n/**\r\n * Returns a random Point from within the area of the given Triangle.\r\n *\r\n * @function Phaser.Geom.Triangle.Random\r\n * @since 3.0.0\r\n *\r\n * @generic {Phaser.Geom.Point} O - [out,$return]\r\n *\r\n * @param {Phaser.Geom.Triangle} triangle - The Triangle to get a random point from.\r\n * @param {Phaser.Geom.Point} [out] - The Point object to store the position in. If not given, a new Point instance is created.\r\n *\r\n * @return {Phaser.Geom.Point} A Point object holding the coordinates of a random position within the Triangle.\r\n */\r\nvar Random = function (triangle, out)\r\n{\r\n    if (out === undefined) { out = new Point(); }\r\n\r\n    //  Basis vectors\r\n    var ux = triangle.x2 - triangle.x1;\r\n    var uy = triangle.y2 - triangle.y1;\r\n\r\n    var vx = triangle.x3 - triangle.x1;\r\n    var vy = triangle.y3 - triangle.y1;\r\n\r\n    //  Random point within the unit square\r\n    var r = Math.random();\r\n    var s = Math.random();\r\n\r\n    //  Point outside the triangle? Remap it.\r\n    if (r + s >= 1)\r\n    {\r\n        r = 1 - r;\r\n        s = 1 - s;\r\n    }\r\n\r\n    out.x = triangle.x1 + ((ux * r) + (vx * s));\r\n    out.y = triangle.y1 + ((uy * r) + (vy * s));\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = Random;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Interactive Object.\r\n * \r\n * This is called automatically by the Input Manager when you enable a Game Object for input.\r\n *\r\n * The resulting Interactive Object is mapped to the Game Object's `input` property.\r\n *\r\n * @function Phaser.Input.CreateInteractiveObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to which this Interactive Object is bound.\r\n * @param {any} hitArea - The hit area for this Interactive Object. Typically a geometry shape, like a Rectangle or Circle.\r\n * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - The 'contains' check callback that the hit area shape will use for all hit tests.\r\n *\r\n * @return {Phaser.Types.Input.InteractiveObject} The new Interactive Object.\r\n */\r\nvar CreateInteractiveObject = function (gameObject, hitArea, hitAreaCallback)\r\n{\r\n    return {\r\n\r\n        gameObject: gameObject,\r\n\r\n        enabled: true,\r\n        alwaysEnabled: false,\r\n        draggable: false,\r\n        dropZone: false,\r\n        cursor: false,\r\n\r\n        target: null,\r\n\r\n        camera: null,\r\n\r\n        hitArea: hitArea,\r\n        hitAreaCallback: hitAreaCallback,\r\n        hitAreaDebug: null,\r\n\r\n        //  Has the dev specified their own shape, or is this bound to the texture size?\r\n        customHitArea: false,\r\n\r\n        localX: 0,\r\n        localY: 0,\r\n\r\n        //  0 = Not being dragged\r\n        //  1 = Being checked for dragging\r\n        //  2 = Being dragged\r\n        dragState: 0,\r\n\r\n        dragStartX: 0,\r\n        dragStartY: 0,\r\n        dragStartXGlobal: 0,\r\n        dragStartYGlobal: 0,\r\n\r\n        dragX: 0,\r\n        dragY: 0\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = CreateInteractiveObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Pixel Perfect Handler function.\r\n *\r\n * Access via `InputPlugin.makePixelPerfect` rather than calling it directly.\r\n *\r\n * @function Phaser.Input.CreatePixelPerfectHandler\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} textureManager - A reference to the Texture Manager.\r\n * @param {number} alphaTolerance - The alpha level that the pixel should be above to be included as a successful interaction.\r\n *\r\n * @return {function} The new Pixel Perfect Handler function.\r\n */\r\nvar CreatePixelPerfectHandler = function (textureManager, alphaTolerance)\r\n{\r\n    return function (hitArea, x, y, gameObject)\r\n    {\r\n        var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);\r\n\r\n        return (alpha && alpha >= alphaTolerance);\r\n    };\r\n};\r\n\r\nmodule.exports = CreatePixelPerfectHandler;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('../geom/circle/Circle');\r\nvar CircleContains = require('../geom/circle/Contains');\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\r\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\nvar Ellipse = require('../geom/ellipse/Ellipse');\r\nvar EllipseContains = require('../geom/ellipse/Contains');\r\nvar Events = require('./events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GEOM_CONST = require('../geom/const');\r\nvar InputPluginCache = require('./InputPluginCache');\r\nvar IsPlainObject = require('../utils/object/IsPlainObject');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../geom/rectangle/Contains');\r\nvar SceneEvents = require('../scene/events');\r\nvar Triangle = require('../geom/triangle/Triangle');\r\nvar TriangleContains = require('../geom/triangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * There are lots of game configuration options available relating to input.\r\n * See the [Input Config object]{@linkcode Phaser.Types.Core.InputConfig} for more details, including how to deal with Phaser\r\n * listening for input events outside of the canvas, how to set a default number of pointers, input\r\n * capture settings and more.\r\n *\r\n * Please also see the Input examples and tutorials for further information.\r\n *\r\n * **Incorrect input coordinates with Angular**\r\n *\r\n * If you are using Phaser within Angular, and use nglf or the router, to make the component in which the Phaser game resides\r\n * change state (i.e. appear or disappear) then you'll need to notify the Scale Manager about this, as Angular will mess with\r\n * the DOM in a way in which Phaser can't detect directly. Call `this.scale.updateBounds()` as part of your game init in order\r\n * to refresh the canvas DOM bounds values, which Phaser uses for input point position calculations.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\r\nvar InputPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function InputPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems class.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.5.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Game Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.input;\r\n\r\n        /**\r\n         * Internal event queue used for plugins only.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pluginEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.pluginEvents = new EventEmitter();\r\n\r\n        /**\r\n         * If `true` this Input Plugin will process DOM input events.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.5.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * A reference to the Scene Display List. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        //  Inject the available input plugins into this class\r\n        InputPluginCache.install(this);\r\n\r\n        /**\r\n         * A reference to the Mouse Manager.\r\n         *\r\n         * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n         *\r\n         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = this.manager.mouse;\r\n\r\n        /**\r\n         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n         * the top-most Game Objects in the Display List.\r\n         *\r\n         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.topOnly = true;\r\n\r\n        /**\r\n         * How often should the Pointers be checked?\r\n         *\r\n         * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n         * Objects are currently below it, or being interacted with it.\r\n         *\r\n         * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n         *\r\n         * This property only controls how often they will be polled if they have not been updated.\r\n         * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n         * if the pointer didn't itself move.\r\n         *\r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.pollRate = -1;\r\n\r\n        /**\r\n         * Internal poll timer value.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pollTimer = 0;\r\n\r\n        var _eventData = { cancelled: false };\r\n\r\n        /**\r\n         * Internal event propagation callback container.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventContainer\r\n         * @type {Phaser.Types.Input.EventData}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventContainer = {\r\n            stopPropagation: function ()\r\n            {\r\n                _eventData.cancelled = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Internal event propagation data object.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventData\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventData = _eventData;\r\n\r\n        /**\r\n         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragDistanceThreshold = 0;\r\n\r\n        /**\r\n         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * The default polling rate is to poll only on move so once the time threshold is reached the\r\n         * drag event will not start until you move the mouse. If you want it to start immediately\r\n         * when the time threshold is reached, you must increase the polling rate by calling\r\n         * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or\r\n         * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragTimeThreshold = 0;\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._temp = [];\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempZones = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._list = [];\r\n\r\n        /**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._draggable = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_dragState\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._dragState = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of valid DOM event types.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];\r\n\r\n        /**\r\n         * Internal property that tracks frame event state.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_updatedThisFrame\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this._updatedThisFrame = false;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @fires Phaser.Input.Events#BOOT\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.cameras = this.systems.cameras;\r\n\r\n        this.displayList = this.systems.displayList;\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.BOOT);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#start\r\n     * @fires Phaser.Input.Events#START\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\r\n        this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        this.enabled = true;\r\n\r\n        //  Populate the pointer drag states\r\n        this._dragState = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.START);\r\n    },\r\n\r\n    /**\r\n     * Game Over handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOver\r\n     * @fires Phaser.Input.Events#GAME_OVER\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOver: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OVER, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game Out handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOut\r\n     * @fires Phaser.Input.Events#GAME_OUT\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOut: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OUT, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n     * deleting old Game Objects.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @private\r\n     * @fires Phaser.Input.Events#PRE_UPDATE\r\n     * @since 3.0.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.PRE_UPDATE);\r\n\r\n        var removeList = this._pendingRemoval;\r\n        var insertList = this._pendingInsertion;\r\n\r\n        var toRemove = removeList.length;\r\n        var toInsert = insertList.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var current = this._list;\r\n\r\n        //  Delete old gameObjects\r\n        for (var i = 0; i < toRemove; i++)\r\n        {\r\n            var gameObject = removeList[i];\r\n\r\n            var index = current.indexOf(gameObject);\r\n\r\n            if (index > -1)\r\n            {\r\n                current.splice(index, 1);\r\n\r\n                this.clear(gameObject, true);\r\n            }\r\n        }\r\n\r\n        //  Clear the removal list\r\n        removeList.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n\r\n        //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\r\n        this._list = current.concat(insertList.splice(0));\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * This is called automatically by the Input Manager.\r\n     * It emits events for plugins to listen to and also handles polling updates, if enabled.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#updatePoll\r\n     * @since 3.18.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    updatePoll: function (time, delta)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  The plugins should update every frame, regardless if there has been\r\n        //  any DOM input events or not (such as the Gamepad and Keyboard)\r\n        this.pluginEvents.emit(Events.UPDATE, time, delta);\r\n\r\n        //  We can leave now if we've already updated once this frame via the immediate DOM event handlers\r\n        if (this._updatedThisFrame)\r\n        {\r\n            this._updatedThisFrame = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        var i;\r\n        var manager = this.manager;\r\n\r\n        var pointers = manager.pointers;\r\n        var pointersTotal = manager.pointersTotal;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            pointers[i].updateMotion();\r\n        }\r\n\r\n        //  No point going any further if there aren't any interactive objects\r\n        if (this._list.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var rate = this.pollRate;\r\n\r\n        if (rate === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else if (rate > 0)\r\n        {\r\n            this._pollTimer -= delta;\r\n\r\n            if (this._pollTimer < 0)\r\n            {\r\n                //  Discard timer diff, we're ready to poll again\r\n                this._pollTimer = this.pollRate;\r\n            }\r\n            else\r\n            {\r\n                //  Not enough time has elapsed since the last poll, so abort now\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //  We got this far? Then we should poll for movement\r\n        var captured = false;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            total += this.processOverOutEvents(pointer);\r\n\r\n            if (this.getDragState(pointer) === 2)\r\n            {\r\n                this.processDragThresholdEvent(pointer, time);\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events\r\n     * to relevant input enabled Game Objects in this scene.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Events#UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} type - The type of event to process.\r\n     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n     *\r\n     * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.\r\n     */\r\n    update: function (type, pointers)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pointersTotal = pointers.length;\r\n        var captured = false;\r\n\r\n        for (var i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            switch (type)\r\n            {\r\n                case CONST.MOUSE_DOWN:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_UP:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_START:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_END:\r\n                case CONST.TOUCH_CANCEL:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_MOVE:\r\n                case CONST.TOUCH_MOVE:\r\n                    total += this.processDragMoveEvent(pointer);\r\n                    total += this.processMoveEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_WHEEL:\r\n                    total += this.processWheelEvent(pointer);\r\n                    break;\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        this._updatedThisFrame = true;\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n     * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n     * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n     */\r\n    clear: function (gameObject, skipQueue)\r\n    {\r\n        if (skipQueue === undefined) { skipQueue = false; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        // If GameObject.input already cleared from higher class\r\n        if (!input)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!skipQueue)\r\n        {\r\n            this.queueForRemoval(gameObject);\r\n        }\r\n\r\n        input.gameObject = undefined;\r\n        input.target = undefined;\r\n        input.hitArea = undefined;\r\n        input.hitAreaCallback = undefined;\r\n        input.callbackContext = undefined;\r\n\r\n        gameObject.input = null;\r\n\r\n        //  Clear from _draggable, _drag and _over\r\n        var index = this._draggable.indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._draggable.splice(index, 1);\r\n        }\r\n\r\n        index = this._drag[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._drag[0].splice(index, 1);\r\n        }\r\n\r\n        index = this._over[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._over[0].splice(index, 1);\r\n\r\n            this.manager.resetCursor(input);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Disables Input on a single Game Object.\r\n     *\r\n     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n     * at any time, by passing it to `InputPlugin.enable`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n     */\r\n    disable: function (gameObject)\r\n    {\r\n        gameObject.input.enabled = false;\r\n    },\r\n\r\n    /**\r\n     * Enable a Game Object for interaction.\r\n     *\r\n     * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n     *\r\n     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enable: function (gameObject, hitArea, hitAreaCallback, dropZone)\r\n    {\r\n        if (dropZone === undefined) { dropZone = false; }\r\n\r\n        if (gameObject.input)\r\n        {\r\n            //  If it is already has an InteractiveObject then just enable it and return\r\n            gameObject.input.enabled = true;\r\n        }\r\n        else\r\n        {\r\n            //  Create an InteractiveObject and enable it\r\n            this.setHitArea(gameObject, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        if (gameObject.input && dropZone && !gameObject.input.dropZone)\r\n        {\r\n            gameObject.input.dropZone = dropZone;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n     * it is currently above.\r\n     *\r\n     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n     */\r\n    hitTestPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras.getCamerasBelowPointer(pointer);\r\n\r\n        for (var c = 0; c < cameras.length; c++)\r\n        {\r\n            var camera = cameras[c];\r\n\r\n            //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\r\n            //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\r\n            var over = this.manager.hitTest(pointer, this._list, camera);\r\n\r\n            //  Filter out the drop zones\r\n            for (var i = 0; i < over.length; i++)\r\n            {\r\n                var obj = over[i];\r\n\r\n                if (obj.input.dropZone)\r\n                {\r\n                    this._tempZones.push(obj);\r\n                }\r\n            }\r\n\r\n            if (over.length > 0)\r\n            {\r\n                pointer.camera = camera;\r\n\r\n                return over;\r\n            }\r\n        }\r\n\r\n        //  If we got this far then there were no Game Objects below the pointer, but it was still over\r\n        //  a camera, so set that the top-most one into the pointer\r\n\r\n        pointer.camera = cameras[0];\r\n\r\n        return [];\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer down event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processDownEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.downElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Returns the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state will be one of the following:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#getDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n     *\r\n     * @return {number} The drag state of the given Pointer.\r\n     */\r\n    getDragState: function (pointer)\r\n    {\r\n        return this._dragState[pointer.id];\r\n    },\r\n\r\n    /**\r\n     * Sets the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state must be one of the following values:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n     * @param {number} state - The drag state value. An integer between 0 and 5.\r\n     */\r\n    setDragState: function (pointer, state)\r\n    {\r\n        this._dragState[pointer.id] = state;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance\r\n     * or time threshold.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragThresholdEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.\r\n     * @param {number} time - The current time.\r\n     */\r\n    processDragThresholdEvent: function (pointer, time)\r\n    {\r\n        var passed = false;\r\n        var timeThreshold = this.dragTimeThreshold;\r\n        var distanceThreshold = this.dragDistanceThreshold;\r\n\r\n        if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold)\r\n        {\r\n            //  It has moved far enough to be considered a drag\r\n            passed = true;\r\n        }\r\n        else if (timeThreshold > 0 && (time >= pointer.downTime + timeThreshold))\r\n        {\r\n            //  It has been held down long enough to be considered a drag\r\n            passed = true;\r\n        }\r\n\r\n        if (passed)\r\n        {\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the drag list for the given pointer and dispatches the start events for each object on it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragStartList\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_START\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that DRAG_START was called on.\r\n     */\r\n    processDragStartList: function (pointer)\r\n    {\r\n        //  3 = Pointer meets criteria and is freshly down, notify the draglist\r\n        if (this.getDragState(pointer) !== 3)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            input.dragState = 2;\r\n\r\n            input.dragStartX = gameObject.x;\r\n            input.dragStartY = gameObject.y;\r\n\r\n            input.dragStartXGlobal = pointer.worldX;\r\n            input.dragStartYGlobal = pointer.worldY;\r\n\r\n            input.dragX = input.dragStartXGlobal - input.dragStartX;\r\n            input.dragY = input.dragStartYGlobal - input.dragStartY;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\r\n\r\n            this.emit(Events.DRAG_START, pointer, gameObject);\r\n        }\r\n\r\n        this.setDragState(pointer, 4);\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragDownEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were collected on the drag list.\r\n     */\r\n    processDragDownEvent: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0)\r\n        {\r\n            //  There are no draggable items, no over items or the pointer isn't down, so let's not even bother going further\r\n            return 0;\r\n        }\r\n\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        this.setDragState(pointer, 1);\r\n\r\n        //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\r\n        var draglist = [];\r\n\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (gameObject.input.draggable && (gameObject.input.dragState === 0))\r\n            {\r\n                draglist.push(gameObject);\r\n            }\r\n        }\r\n\r\n        if (draglist.length === 0)\r\n        {\r\n            this.setDragState(pointer, 0);\r\n\r\n            return 0;\r\n        }\r\n        else if (draglist.length > 1)\r\n        {\r\n            this.sortGameObjects(draglist, pointer);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                draglist.splice(1);\r\n            }\r\n        }\r\n\r\n        //  draglist now contains all potential candidates for dragging\r\n        this._drag[pointer.id] = draglist;\r\n\r\n        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)\r\n        {\r\n            //  No drag criteria, so snap immediately to mode 3\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n        else\r\n        {\r\n            //  Check the distance / time on the next event\r\n            this.setDragState(pointer, 2);\r\n\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag move' event for the given pointer.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragMoveEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_ENTER\r\n     * @fires Phaser.Input.Events#DRAG\r\n     * @fires Phaser.Input.Events#DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#DRAG_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragMoveEvent: function (pointer)\r\n    {\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        if (this.getDragState(pointer) === 2)\r\n        {\r\n            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);\r\n        }\r\n\r\n        if (this.getDragState(pointer) !== 4)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        var dropZones = this._tempZones;\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            var target = input.target;\r\n\r\n            //  If this GO has a target then let's check it\r\n            if (target)\r\n            {\r\n                var index = dropZones.indexOf(target);\r\n\r\n                //  Got a target, are we still over it?\r\n                if (index === 0)\r\n                {\r\n                    //  We're still over it, and it's still the top of the display list, phew ...\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);\r\n                }\r\n                else if (index > 0)\r\n                {\r\n                    //  Still over it but it's no longer top of the display list (targets must always be at the top)\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    input.target = dropZones[0];\r\n\r\n                    target = input.target;\r\n\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                }\r\n                else\r\n                {\r\n                    //  Nope, we've moved on (or the target has!), leave the old target\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    //  Anything new to replace it?\r\n                    //  Yup!\r\n                    if (dropZones[0])\r\n                    {\r\n                        input.target = dropZones[0];\r\n\r\n                        target = input.target;\r\n\r\n                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                    }\r\n                    else\r\n                    {\r\n                        //  Nope\r\n                        input.target = null;\r\n                    }\r\n                }\r\n            }\r\n            else if (!target && dropZones[0])\r\n            {\r\n                input.target = dropZones[0];\r\n\r\n                target = input.target;\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n            }\r\n\r\n            var dragX;\r\n            var dragY;\r\n\r\n            if (!gameObject.parentContainer)\r\n            {\r\n                dragX = pointer.worldX - input.dragX;\r\n                dragY = pointer.worldY - input.dragY;\r\n            }\r\n            else\r\n            {\r\n                var dx = pointer.worldX - input.dragStartXGlobal;\r\n                var dy = pointer.worldY - input.dragStartYGlobal;\r\n\r\n                var rotation = gameObject.getParentRotation();\r\n\r\n                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);\r\n                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);\r\n\r\n                dxRotated *= (1 / gameObject.parentContainer.scaleX);\r\n                dyRotated *= (1 / gameObject.parentContainer.scaleY);\r\n\r\n                dragX = dxRotated + input.dragStartX;\r\n                dragY = dyRotated + input.dragStartY;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\r\n\r\n            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\r\n        }\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragUpEvent\r\n     * @fires Phaser.Input.Events#DRAG_END\r\n     * @fires Phaser.Input.Events#DROP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragUpEvent: function (pointer)\r\n    {\r\n        //  5 = Pointer was actively dragging but has been released, notify draglist\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            if (input && input.dragState === 2)\r\n            {\r\n                input.dragState = 0;\r\n\r\n                input.dragX = input.localX - gameObject.displayOriginX;\r\n                input.dragY = input.localY - gameObject.displayOriginY;\r\n\r\n                var dropped = false;\r\n\r\n                var target = input.target;\r\n\r\n                if (target)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);\r\n\r\n                    this.emit(Events.DROP, pointer, gameObject, target);\r\n\r\n                    input.target = null;\r\n\r\n                    dropped = true;\r\n                }\r\n\r\n                //  And finally the dragend event\r\n\r\n                if (gameObject.input)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\r\n\r\n                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setDragState(pointer, 0);\r\n\r\n        list.splice(0);\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer movement event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n     * @fires Phaser.Input.Events#POINTER_MOVE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processMoveEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            if (this.topOnly)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles a mouse wheel event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processWheelEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL\r\n     * @fires Phaser.Input.Events#POINTER_WHEEL\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processWheelEvent: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        var dx = pointer.deltaX;\r\n        var dy = pointer.deltaY;\r\n        var dz = pointer.deltaZ;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over events.\r\n     * This is called when a touch input hits the canvas, having previously been off of it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = currentlyOver.length;\r\n\r\n        var justOver = [];\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = currentlyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                justOver.push(gameObject);\r\n\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = justOver;\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer out events.\r\n     * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOutEvents: function (pointer)\r\n    {\r\n        var previouslyOver = this._over[pointer.id];\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = previouslyOver.length;\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            this.sortGameObjects(previouslyOver, pointer);\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = previouslyOver[i];\r\n\r\n                //  Call onOut for everything in the previouslyOver array\r\n                gameObject = previouslyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                if (!aborted)\r\n                {\r\n                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);\r\n                }\r\n            }\r\n\r\n            this._over[pointer.id] = [];\r\n        }\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over and out events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverOutEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var i;\r\n        var gameObject;\r\n        var justOut = [];\r\n        var justOver = [];\r\n        var stillOver = [];\r\n        var previouslyOver = this._over[pointer.id];\r\n        var currentlyDragging = this._drag[pointer.id];\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Go through all objects the pointer was previously over, and see if it still is.\r\n        //  Splits the previouslyOver array into two parts: justOut and stillOver\r\n\r\n        for (i = 0; i < previouslyOver.length; i++)\r\n        {\r\n            gameObject = previouslyOver[i];\r\n\r\n            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)\r\n            {\r\n                //  Not in the currentlyOver array, so must be outside of this object now\r\n                justOut.push(gameObject);\r\n            }\r\n            else\r\n            {\r\n                //  In the currentlyOver array\r\n                stillOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Go through all objects the pointer is currently over (the hit test results)\r\n        //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\r\n        for (i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            gameObject = currentlyOver[i];\r\n\r\n            //  Is this newly over?\r\n\r\n            if (previouslyOver.indexOf(gameObject) === -1)\r\n            {\r\n                justOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  By this point the arrays are filled, so now we can process what happened...\r\n\r\n        //  Process the Just Out objects\r\n        var total = justOut.length;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOut, pointer);\r\n\r\n            //  Call onOut for everything in the justOut array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOut[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Reset cursor before we emit the event, in case they want to change it during the event\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OUT, pointer, justOut);\r\n            }\r\n        }\r\n\r\n        //  Process the Just Over objects\r\n        total = justOver.length;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOver, pointer);\r\n\r\n            //  Call onOver for everything in the justOver array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Set cursor before we emit the event, in case they want to change it during the event\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Add the contents of justOver to the previously over array\r\n        previouslyOver = stillOver.concat(justOver);\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer up events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processUpEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.upElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_UP, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_UP_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return currentlyOver.length;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForInsertion: function (child)\r\n    {\r\n        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)\r\n        {\r\n            this._pendingInsertion.push(child);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for removal from this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForRemoval: function (child)\r\n    {\r\n        this._pendingRemoval.push(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the draggable state of the given array of Game Objects.\r\n     *\r\n     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n     *\r\n     * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setDraggable: function (gameObjects, value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            gameObject.input.draggable = value;\r\n\r\n            var index = this._draggable.indexOf(gameObject);\r\n\r\n            if (value && index === -1)\r\n            {\r\n                this._draggable.push(gameObject);\r\n            }\r\n            else if (!value && index > -1)\r\n            {\r\n                this._draggable.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n     * ```\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n     * ```\r\n     *\r\n     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n     * dragstart, drag, etc.\r\n     *\r\n     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n     * Game Objects that really need it.\r\n     *\r\n     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n     * Render Textures, Text, Tilemaps, Containers or Particles.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n     *\r\n     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n     */\r\n    makePixelPerfect: function (alphaTolerance)\r\n    {\r\n        if (alphaTolerance === undefined) { alphaTolerance = 1; }\r\n\r\n        var textureManager = this.systems.textures;\r\n\r\n        return CreatePixelPerfectHandler(textureManager, alphaTolerance);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for the given array of Game Objects.\r\n     *\r\n     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n     *\r\n     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n     * to calculate.\r\n     *\r\n     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n     * such as `Phaser.Geom.Rectangle.Contains`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitArea: function (gameObjects, hitArea, hitAreaCallback)\r\n    {\r\n        if (hitArea === undefined)\r\n        {\r\n            return this.setHitAreaFromTexture(gameObjects);\r\n        }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        var draggable = false;\r\n        var dropZone = false;\r\n        var cursor = false;\r\n        var useHandCursor = false;\r\n        var pixelPerfect = false;\r\n        var customHitArea = true;\r\n\r\n        //  Config object?\r\n        if (IsPlainObject(hitArea))\r\n        {\r\n            var config = hitArea;\r\n\r\n            hitArea = GetFastValue(config, 'hitArea', null);\r\n            hitAreaCallback = GetFastValue(config, 'hitAreaCallback', null);\r\n            draggable = GetFastValue(config, 'draggable', false);\r\n            dropZone = GetFastValue(config, 'dropZone', false);\r\n            cursor = GetFastValue(config, 'cursor', false);\r\n            useHandCursor = GetFastValue(config, 'useHandCursor', false);\r\n\r\n            pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\r\n            var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\r\n\r\n            if (pixelPerfect)\r\n            {\r\n                hitArea = {};\r\n                hitAreaCallback = this.makePixelPerfect(alphaTolerance);\r\n            }\r\n\r\n            //  Still no hitArea or callback?\r\n            if (!hitArea || !hitAreaCallback)\r\n            {\r\n                this.setHitAreaFromTexture(gameObjects);\r\n                customHitArea = false;\r\n            }\r\n        }\r\n        else if (typeof hitArea === 'function' && !hitAreaCallback)\r\n        {\r\n            hitAreaCallback = hitArea;\r\n            hitArea = {};\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            if (pixelPerfect && gameObject.type === 'Container')\r\n            {\r\n                console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');\r\n                continue;\r\n            }\r\n\r\n            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;\r\n\r\n            io.customHitArea = customHitArea;\r\n            io.dropZone = dropZone;\r\n            io.cursor = (useHandCursor) ? 'pointer' : cursor;\r\n\r\n            gameObject.input = io;\r\n\r\n            if (draggable)\r\n            {\r\n                this.setDraggable(gameObject);\r\n            }\r\n\r\n            this.queueForInsertion(gameObject);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n     * the given coordinates and radius to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaCircle: function (gameObjects, x, y, radius, callback)\r\n    {\r\n        if (callback === undefined) { callback = CircleContains; }\r\n\r\n        var shape = new Circle(x, y, radius);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = EllipseContains; }\r\n\r\n        var shape = new Ellipse(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the Game Objects texture frame to define the position and size of the hit area.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaFromTexture: function (gameObjects, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var frame = gameObject.frame;\r\n\r\n            var width = 0;\r\n            var height = 0;\r\n\r\n            if (gameObject.width)\r\n            {\r\n                width = gameObject.width;\r\n                height = gameObject.height;\r\n            }\r\n            else if (frame)\r\n            {\r\n                width = frame.realWidth;\r\n                height = frame.realHeight;\r\n            }\r\n\r\n            if (gameObject.type === 'Container' && (width === 0 || height === 0))\r\n            {\r\n                console.warn('Container.setInteractive must specify a Shape or call setSize() first');\r\n                continue;\r\n            }\r\n\r\n            if (width !== 0 && height !== 0)\r\n            {\r\n                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\r\n\r\n                this.queueForInsertion(gameObject);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        var shape = new Rectangle(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n     * the given coordinates to control the position of its points.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)\r\n    {\r\n        if (callback === undefined) { callback = TriangleContains; }\r\n\r\n        var shape = new Triangle(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Creates an Input Debug Shape for the given Game Object.\r\n     *\r\n     * The Game Object must have _already_ been enabled for input prior to calling this method.\r\n     *\r\n     * This is intended to assist you during development and debugging.\r\n     *\r\n     * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,\r\n     * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.\r\n     *\r\n     * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.\r\n     *\r\n     * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object\r\n     * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via\r\n     * the Game Object property: `GameObject.input.hitAreaDebug`.\r\n     *\r\n     * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,\r\n     * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the\r\n     * method `InputPlugin.removeDebug`.\r\n     *\r\n     * Note that the debug shape will only show the outline of the input area. If the input test is using a\r\n     * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that\r\n     * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not\r\n     * work.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enableDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.\r\n     * @param {number} [color=0x00ff00] - The outline color of the debug shape.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enableDebug: function (gameObject, color)\r\n    {\r\n        if (color === undefined) { color = 0x00ff00; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.hitArea)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var shape = input.hitArea;\r\n        var shapeType = shape.type;\r\n        var debug = input.hitAreaDebug;\r\n        var factory = this.systems.add;\r\n        var updateList = this.systems.updateList;\r\n\r\n        if (debug)\r\n        {\r\n            updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            debug = null;\r\n        }\r\n\r\n        var offsetx = 0;\r\n        var offsety = 0;\r\n        switch (shapeType)\r\n        {\r\n            case GEOM_CONST.CIRCLE:\r\n                debug = factory.arc(0, 0, shape.radius);\r\n                offsetx = shape.x - shape.radius;\r\n                offsety = shape.y - shape.radius;\r\n                break;\r\n\r\n            case GEOM_CONST.ELLIPSE:\r\n                debug = factory.ellipse(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x - shape.width / 2;\r\n                offsety = shape.y - shape.height / 2;\r\n                break;\r\n\r\n            case GEOM_CONST.LINE:\r\n                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);\r\n                break;\r\n\r\n            case GEOM_CONST.POLYGON:\r\n                debug = factory.polygon(0, 0, shape.points);\r\n                break;\r\n\r\n            case GEOM_CONST.RECTANGLE:\r\n                debug = factory.rectangle(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x;\r\n                offsety = shape.y;\r\n                break;\r\n\r\n            case GEOM_CONST.TRIANGLE:\r\n                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);\r\n                break;\r\n        }\r\n\r\n        if (debug)\r\n        {\r\n            debug.isFilled = false;\r\n\r\n            debug.preUpdate = function ()\r\n            {\r\n                debug.setStrokeStyle(1 / gameObject.scale, color);\r\n\r\n                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);\r\n\r\n                var x = gameObject.x;\r\n                var y = gameObject.y;\r\n                var rotation = gameObject.rotation;\r\n                var scaleX = gameObject.scaleX;\r\n                var scaleY = gameObject.scaleY;\r\n\r\n                if (gameObject.parentContainer)\r\n                {\r\n                    var matrix = gameObject.getWorldTransformMatrix();\r\n\r\n                    x = matrix.tx;\r\n                    y = matrix.ty;\r\n                    rotation = matrix.rotation;\r\n                    scaleX = matrix.scaleX;\r\n                    scaleY = matrix.scaleY;\r\n                }\r\n\r\n                debug.setRotation(rotation);\r\n                debug.setScale(scaleX, scaleY);\r\n                debug.setPosition(x + offsetx, y + offsety);\r\n                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);\r\n                debug.setDepth(gameObject.depth);\r\n            };\r\n\r\n            updateList.add(debug);\r\n\r\n            input.hitAreaDebug = debug;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Input Debug Shape from the given Game Object.\r\n     *\r\n     * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#removeDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    removeDebug: function (gameObject)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaDebug)\r\n        {\r\n            var debug = input.hitAreaDebug;\r\n\r\n            this.systems.updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            input.hitAreaDebug = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to always poll.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n     *\r\n     * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n     * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n     * costs, especially if there are a large number of interactive objects in your game.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollAlways: function ()\r\n    {\r\n        return this.setPollRate(0);\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to only poll when they are moved or updated.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollOnMove: function ()\r\n    {\r\n        return this.setPollRate(-1);\r\n    },\r\n\r\n    /**\r\n     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollRate: function (value)\r\n    {\r\n        this.pollRate = value;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n     * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event\r\n     * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setGlobalTopOnly: function (value)\r\n    {\r\n        this.manager.globalTopOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setTopOnly: function (value)\r\n    {\r\n        this.topOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Given an array of Game Objects and a Pointer, sort the array and return it,\r\n     * so that the objects are in render order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortGameObjects: function (gameObjects, pointer)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        var list = pointer.camera.renderList;\r\n\r\n        return gameObjects.sort(function (childA, childB)\r\n        {\r\n            return list.indexOf(childB) - list.indexOf(childA);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Given an array of Drop Zone Game Objects, sort the array and return it,\r\n     * so that the objects are in depth index order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZones\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortDropZones: function (gameObjects)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        this.scene.sys.depthSort();\r\n\r\n        return gameObjects.sort(this.sortDropZoneHandler.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * Prior to version 3.52.0 this method was called `sortHandlerGO`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZoneHandler\r\n     * @private\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {number} Returns either a negative or positive integer, or zero if they match.\r\n     */\r\n    sortDropZoneHandler: function (childA, childB)\r\n    {\r\n        if (!childA.parentContainer && !childB.parentContainer)\r\n        {\r\n            //  Quick bail out when neither child has a container\r\n            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB.parentContainer)\r\n        {\r\n            //  Quick bail out when both children have the same container\r\n            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return -1;\r\n        }\r\n        else if (childB.parentContainer === childA)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            //  Container index check\r\n            var listA = childA.getIndexList();\r\n            var listB = childB.getIndexList();\r\n            var len = Math.min(listA.length, listB.length);\r\n\r\n            for (var i = 0; i < len; i++)\r\n            {\r\n                var indexA = listA[i];\r\n                var indexB = listB[i];\r\n\r\n                if (indexA === indexB)\r\n                {\r\n                    //  Go to the next level down\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    //  Non-matching parents, so return\r\n                    return indexB - indexA;\r\n                }\r\n            }\r\n\r\n            return listB.length - listA.length;\r\n        }\r\n\r\n        //  Technically this shouldn't happen, but ...\r\n        // eslint-disable-next-line no-unreachable\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * This method should be called from within an input event handler, such as `pointerdown`.\r\n     *\r\n     * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene\r\n     * not yet handled in the scene list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    stopPropagation: function ()\r\n    {\r\n        this.manager._tempSkip = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        return this.manager.addPointer(quantity);\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     *\r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     *\r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     *\r\n     * @return {this} This Input instance.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.manager.setDefaultCursor(cursor);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionIn\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionIn: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin has finished transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        if (!this.settings.transitionAllowInput)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning out.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionOut\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionOut: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @fires Phaser.Input.Events#SHUTDOWN\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.SHUTDOWN);\r\n\r\n        this._temp.length = 0;\r\n        this._list.length = 0;\r\n        this._draggable.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n        this._dragState.length = 0;\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            this._drag[i] = [];\r\n            this._over[i] = [];\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        var manager = this.manager;\r\n\r\n        manager.canvas.style.cursor = manager.defaultCursor;\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n\r\n        manager.events.off(Events.GAME_OUT, this.onGameOut, this);\r\n        manager.events.off(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @fires Phaser.Input.Events#DESTROY\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.DESTROY);\r\n\r\n        this.pluginEvents.removeAllListeners();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.cameras = null;\r\n        this.manager = null;\r\n        this.events = null;\r\n        this.mouse = null;\r\n    },\r\n\r\n    /**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     *\r\n     * @name Phaser.Input.InputPlugin#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isOver: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.isOver;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mousePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    mousePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.mousePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    activePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer1\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[1];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer2\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[2];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer3\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[3];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer4\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[4];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer5\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer5: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[5];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer6\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer6: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[6];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer7\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer7: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[7];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer8\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer8: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[8];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer9\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer9: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[9];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer10\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer10: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[10];\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('InputPlugin', InputPlugin, 'input');\r\n\r\nmodule.exports = InputPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../utils/object/GetValue');\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar inputPlugins = {};\r\n\r\n/**\r\n * @namespace Phaser.Input.InputPluginCache\r\n */\r\n\r\nvar InputPluginCache = {};\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @function Phaser.Input.InputPluginCache.register\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Input Plugin, this is the property key used.\r\n * @param {string} settingsKey - The key in the Scene Settings to check to see if this plugin should install or not.\r\n * @param {string} configKey - The key in the Game Config to check to see if this plugin should install or not.\r\n */\r\nInputPluginCache.register = function (key, plugin, mapping, settingsKey, configKey)\r\n{\r\n    inputPlugins[key] = { plugin: plugin, mapping: mapping, settingsKey: settingsKey, configKey: configKey };\r\n};\r\n\r\n/**\r\n * Returns the input plugin object from the cache based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.getPlugin\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to get.\r\n *\r\n * @return {Phaser.Types.Input.InputPluginContainer} The input plugin object.\r\n */\r\nInputPluginCache.getPlugin = function (key)\r\n{\r\n    return inputPlugins[key];\r\n};\r\n\r\n/**\r\n * Installs all of the registered Input Plugins into the given target.\r\n *\r\n * @function Phaser.Input.InputPluginCache.install\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} target - The target InputPlugin to install the plugins into.\r\n */\r\nInputPluginCache.install = function (target)\r\n{\r\n    var sys = target.scene.sys;\r\n    var settings = sys.settings.input;\r\n    var config = sys.game.config;\r\n\r\n    for (var key in inputPlugins)\r\n    {\r\n        var source = inputPlugins[key].plugin;\r\n        var mapping = inputPlugins[key].mapping;\r\n        var settingsKey = inputPlugins[key].settingsKey;\r\n        var configKey = inputPlugins[key].configKey;\r\n\r\n        if (GetValue(settings, settingsKey, config[configKey]))\r\n        {\r\n            target[mapping] = new source(target);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes an input plugin based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.remove\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to remove.\r\n */\r\nInputPluginCache.remove = function (key)\r\n{\r\n    if (inputPlugins.hasOwnProperty(key))\r\n    {\r\n        delete inputPlugins[key];\r\n    }\r\n};\r\n\r\nmodule.exports = InputPluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific Gamepad Axis.\r\n * Axis objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Axis\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Axis belongs to.\r\n * @param {number} index - The index of this Axis.\r\n */\r\nvar Axis = new Class({\r\n\r\n    initialize:\r\n\r\n    function Axis (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Axis belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the axis events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.events;\r\n\r\n        /**\r\n         * The index of this Axis.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The raw axis value, between -1 and 1 with 0 being dead center.\r\n         * Use the method `getValue` to get a normalized value with the threshold applied.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Movement tolerance threshold below which axis values are ignored in `getValue`.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#threshold\r\n         * @type {number}\r\n         * @default 0.1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 0.1;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Axis.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#update\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the axis movement.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n    },\r\n\r\n    /**\r\n     * Applies the `threshold` value to the axis and returns it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The axis value, adjusted for the movement threshold.\r\n     */\r\n    getValue: function ()\r\n    {\r\n        return (Math.abs(this.value) < this.threshold) ? 0 : this.value;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Axis instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Axis;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific button on a Gamepad.\r\n * Button objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Button\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Button belongs to.\r\n * @param {number} index - The index of this Button.\r\n */\r\nvar Button = new Class({\r\n\r\n    initialize:\r\n\r\n    function Button (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Button belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the button events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.manager;\r\n\r\n        /**\r\n         * The index of this Button.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * Between 0 and 1.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Can be set for analogue buttons to enable a 'pressure' threshold,\r\n         * before a button is considered as being 'pressed'.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#threshold\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 1;\r\n\r\n        /**\r\n         * Is the Button being pressed down or not?\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pressed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.pressed = false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Button.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#update\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_UP\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the button. Between 0 and 1.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n\r\n        var pad = this.pad;\r\n        var index = this.index;\r\n\r\n        if (value >= this.threshold)\r\n        {\r\n            if (!this.pressed)\r\n            {\r\n                this.pressed = true;\r\n                this.events.emit(Events.BUTTON_DOWN, pad, this, value);\r\n                this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);\r\n            }\r\n        }\r\n        else if (this.pressed)\r\n        {\r\n            this.pressed = false;\r\n            this.events.emit(Events.BUTTON_UP, pad, this, value);\r\n            this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Button instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Button;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Axis = require('./Axis');\r\nvar Button = require('./Button');\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A single Gamepad.\r\n *\r\n * These are created, updated and managed by the Gamepad Plugin.\r\n *\r\n * @class Gamepad\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.GamepadPlugin} manager - A reference to the Gamepad Plugin.\r\n * @param {Phaser.Types.Input.Gamepad.Pad} pad - The Gamepad object, as extracted from GamepadEvent.\r\n */\r\nvar Gamepad = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Gamepad (manager, pad)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Gamepad Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#manager\r\n         * @type {Phaser.Input.Gamepad.GamepadPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * A reference to the native Gamepad object that is connected to the browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#pad\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * A string containing some information about the controller.\r\n         *\r\n         * This is not strictly specified, but in Firefox it will contain three pieces of information\r\n         * separated by dashes (-): two 4-digit hexadecimal strings containing the USB vendor and\r\n         * product id of the controller, and the name of the controller as provided by the driver.\r\n         * In Chrome it will contain the name of the controller as provided by the driver,\r\n         * followed by vendor and product 4-digit hexadecimal strings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#id\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.id = pad.id;\r\n\r\n        /**\r\n         * An integer that is unique for each Gamepad currently connected to the system.\r\n         * This can be used to distinguish multiple controllers.\r\n         * Note that disconnecting a device and then connecting a new device may reuse the previous index.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = pad.index;\r\n\r\n        var buttons = [];\r\n\r\n        for (var i = 0; i < pad.buttons.length; i++)\r\n        {\r\n            buttons.push(new Button(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Button objects, corresponding to the different buttons available on the Gamepad.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#buttons\r\n         * @type {Phaser.Input.Gamepad.Button[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.buttons = buttons;\r\n\r\n        var axes = [];\r\n\r\n        for (i = 0; i < pad.axes.length; i++)\r\n        {\r\n            axes.push(new Axis(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Axis objects, corresponding to the different axes available on the Gamepad, if any.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#axes\r\n         * @type {Phaser.Input.Gamepad.Axis[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.axes = axes;\r\n\r\n        /**\r\n         * The Gamepad's Haptic Actuator (Vibration / Rumble support).\r\n         * This is highly experimental and only set if both present on the device,\r\n         * and exposed by both the hardware and browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#vibration\r\n         * @type {GamepadHapticActuator}\r\n         * @since 3.10.0\r\n         */\r\n        this.vibration = pad.vibrationActuator;\r\n\r\n        // https://w3c.github.io/gamepad/#remapping\r\n\r\n        var _noButton = { value: 0, pressed: false };\r\n\r\n        /**\r\n         * A reference to the Left Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCLeft = (buttons[14]) ? buttons[14] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCRight = (buttons[15]) ? buttons[15] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCTop = (buttons[12]) ? buttons[12] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCBottom = (buttons[13]) ? buttons[13] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Left Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCLeft = (buttons[2]) ? buttons[2] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCRight = (buttons[1]) ? buttons[1] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCTop = (buttons[3]) ? buttons[3] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCBottom = (buttons[0]) ? buttons[0] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Left Front Button (L1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftTop = (buttons[4]) ? buttons[4] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Left Front Button (L2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftBottom = (buttons[6]) ? buttons[6] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Right Front Button (R1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightTop = (buttons[5]) ? buttons[5] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Right Front Button (R2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightBottom = (buttons[7]) ? buttons[7] : _noButton;\r\n\r\n        var _noAxis = { value: 0 };\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisLeft = (axes[0]) ? axes[0] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisLeft = (axes[1]) ? axes[1] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisRight = (axes[2]) ? axes[2] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisRight = (axes[3]) ? axes[3] : _noAxis;\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's left axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a left axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#leftStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.leftStick = new Vector2();\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's right axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a right axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#rightStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.rightStick = new Vector2();\r\n\r\n        /**\r\n         * When was this Gamepad created? Used to avoid duplicate event spamming in the update loop.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_created\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._created = performance.now();\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of axis this Gamepad claims to support.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of axes this Gamepad claims to support.\r\n     */\r\n    getAxisTotal: function ()\r\n    {\r\n        return this.axes.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of an axis based on the given index.\r\n     * The index must be valid within the range of axes supported by this Gamepad.\r\n     * The return value will be a float between 0 and 1.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the axes to get the value for.\r\n     *\r\n     * @return {number} The value of the axis, between 0 and 1.\r\n     */\r\n    getAxisValue: function (index)\r\n    {\r\n        return this.axes[index].getValue();\r\n    },\r\n\r\n    /**\r\n     * Sets the threshold value of all axis on this Gamepad.\r\n     * The value is a float between 0 and 1 and is the amount below which the axis is considered as not having been moved.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#setAxisThreshold\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} value - A value between 0 and 1.\r\n     */\r\n    setAxisThreshold: function (value)\r\n    {\r\n        for (var i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].threshold = value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of buttons this Gamepad claims to have.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of buttons this Gamepad claims to have.\r\n     */\r\n    getButtonTotal: function ()\r\n    {\r\n        return this.buttons.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of a button based on the given index.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * The return value will be either 0 or 1 for an analogue button, or a float between 0 and 1\r\n     * for a pressure-sensitive digital button, such as the shoulder buttons on a Dual Shock.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {number} The value of the button, between 0 and 1.\r\n     */\r\n    getButtonValue: function (index)\r\n    {\r\n        return this.buttons[index].value;\r\n    },\r\n\r\n    /**\r\n     * Returns if the button is pressed down or not.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#isButtonDown\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {boolean} `true` if the button is considered as being pressed down, otherwise `false`.\r\n     */\r\n    isButtonDown: function (index)\r\n    {\r\n        return this.buttons[index].pressed;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Gamepad.\r\n     * Called automatically by the Gamepad Manager as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#update\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    update: function (pad)\r\n    {\r\n        if (pad.timestamp < this._created)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n\r\n        //  Sync the button values\r\n\r\n        var localButtons = this.buttons;\r\n        var gamepadButtons = pad.buttons;\r\n\r\n        var len = localButtons.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localButtons[i].update(gamepadButtons[i].value);\r\n        }\r\n\r\n        //  Sync the axis values\r\n\r\n        var localAxes = this.axes;\r\n        var gamepadAxes = pad.axes;\r\n\r\n        len = localAxes.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localAxes[i].update(gamepadAxes[i]);\r\n        }\r\n\r\n        if (len >= 2)\r\n        {\r\n            this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());\r\n\r\n            if (len >= 4)\r\n            {\r\n                this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad instance, its buttons and axes, and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.manager = null;\r\n        this.pad = null;\r\n\r\n        var i;\r\n\r\n        for (i = 0; i < this.buttons.length; i++)\r\n        {\r\n            this.buttons[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].destroy();\r\n        }\r\n\r\n        this.buttons = [];\r\n        this.axes = [];\r\n    },\r\n\r\n    /**\r\n     * Is this Gamepad currently connected or not?\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#connected\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    connected: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.connected;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A timestamp containing the most recent time this Gamepad was updated.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#timestamp\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    timestamp: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.timestamp;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Left button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad left button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#left\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Right button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad right button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#right\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Up button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad up button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#up\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    up: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Down button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad down button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#down\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    down: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's bottom button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the X button.\r\n     * On an XBox controller it's the A button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#A\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    A: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's top button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Triangle button.\r\n     * On an XBox controller it's the Y button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#Y\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    Y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's left button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Square button.\r\n     * On an XBox controller it's the X button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#X\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    X: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's right button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Circle button.\r\n     * On an XBox controller it's the B button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#B\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    B: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L1 button.\r\n     * On an XBox controller it's the LB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L2 button.\r\n     * On an XBox controller it's the LT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftBottom.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R1 button.\r\n     * On an XBox controller it's the RB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R2 button.\r\n     * On an XBox controller it's the RT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightBottom.value;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Gamepad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar Gamepad = require('./Gamepad');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar InputEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * The Gamepad Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Gamepad Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.gamepad`.\r\n *\r\n * To listen for a gamepad being connected:\r\n *\r\n * ```javascript\r\n * this.input.gamepad.once('connected', function (pad) {\r\n *     //   'pad' is a reference to the gamepad that was just connected\r\n * });\r\n * ```\r\n *\r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * Once you have received the connected event, or polled the gamepads and found them enabled, you can access\r\n * them via the built-in properties `GamepadPlugin.pad1` to `pad4`, for up to 4 game pads. With a reference\r\n * to the gamepads you can poll its buttons and axis sticks. See the properties and methods available on\r\n * the `Gamepad` class for more details.\r\n *\r\n * As of September 2020 Chrome, and likely other browsers, will soon start to require that games requesting\r\n * access to the Gamepad API are running under SSL. They will actively block API access if they are not.\r\n *\r\n * For more information about Gamepad support in browsers see the following resources:\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\r\n * https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/\r\n * http://html5gamepad.com/\r\n *\r\n * @class GamepadPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar GamepadPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GamepadPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A boolean that controls if the Gamepad Manager is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The Gamepad Event target, as defined in the Game Config.\r\n         * Typically the browser window, but can be any interactive DOM element.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#target\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.target;\r\n\r\n        /**\r\n         * An array of the connected Gamepads.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#gamepads\r\n         * @type {Phaser.Input.Gamepad.Gamepad[]}\r\n         * @default []\r\n         * @since 3.10.0\r\n         */\r\n        this.gamepads = [];\r\n\r\n        /**\r\n         * An internal event queue.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#queue\r\n         * @type {GamepadEvent[]}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.queue = [];\r\n\r\n        /**\r\n         * Internal event handler.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#onGamepadHandler\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.onGamepadHandler;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad1\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad1;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad2\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad2;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad3\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad3;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad4\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad4;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.scene.sys.game;\r\n        var settings = this.settings.input;\r\n        var config = game.config;\r\n\r\n        this.enabled = GetValue(settings, 'gamepad', config.inputGamepad) && game.device.input.gamepads;\r\n        this.target = GetValue(settings, 'gamepad.target', config.inputGamepadEventTarget);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (this.enabled)\r\n        {\r\n            this.startListeners();\r\n\r\n            this.refreshPads();\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * Starts the Gamepad Event listeners running.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#startListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var target = this.target;\r\n\r\n        var handler = function (event)\r\n        {\r\n            if (event.defaultPrevented || !_this.isActive())\r\n            {\r\n                // Do nothing if event already handled\r\n                return;\r\n            }\r\n\r\n            _this.refreshPads();\r\n\r\n            _this.queue.push(event);\r\n        };\r\n\r\n        this.onGamepadHandler = handler;\r\n\r\n        target.addEventListener('gamepadconnected', handler, false);\r\n        target.addEventListener('gamepaddisconnected', handler, false);\r\n\r\n        //  FF also supports gamepadbuttondown, gamepadbuttonup and gamepadaxismove but\r\n        //  nothing else does, and we can get those values via the gamepads anyway, so we will\r\n        //  until more browsers support this\r\n\r\n        //  Finally, listen for an update event from the Input Plugin\r\n        this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);\r\n    },\r\n\r\n    /**\r\n     * Stops the Gamepad Event listeners.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#stopListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        this.target.removeEventListener('gamepadconnected', this.onGamepadHandler);\r\n        this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler);\r\n\r\n        this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].removeAllListeners();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disconnects all current Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#disconnectAll\r\n     * @since 3.10.0\r\n     */\r\n    disconnectAll: function ()\r\n    {\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].pad.connected = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Refreshes the list of connected Gamepads.\r\n     *\r\n     * This is called automatically when a gamepad is connected or disconnected,\r\n     * and during the update loop.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#refreshPads\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    refreshPads: function ()\r\n    {\r\n        var connectedPads = navigator.getGamepads();\r\n\r\n        if (!connectedPads)\r\n        {\r\n            this.disconnectAll();\r\n        }\r\n        else\r\n        {\r\n            var currentPads = this.gamepads;\r\n\r\n            for (var i = 0; i < connectedPads.length; i++)\r\n            {\r\n                var livePad = connectedPads[i];\r\n\r\n                //  Because sometimes they're null (yes, really)\r\n                if (!livePad)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var id = livePad.id;\r\n                var index = livePad.index;\r\n                var currentPad = currentPads[index];\r\n\r\n                if (!currentPad)\r\n                {\r\n                    //  A new Gamepad, not currently stored locally\r\n                    var newPad = new Gamepad(this, livePad);\r\n\r\n                    currentPads[index] = newPad;\r\n\r\n                    if (!this._pad1)\r\n                    {\r\n                        this._pad1 = newPad;\r\n                    }\r\n                    else if (!this._pad2)\r\n                    {\r\n                        this._pad2 = newPad;\r\n                    }\r\n                    else if (!this._pad3)\r\n                    {\r\n                        this._pad3 = newPad;\r\n                    }\r\n                    else if (!this._pad4)\r\n                    {\r\n                        this._pad4 = newPad;\r\n                    }\r\n                }\r\n                else if (currentPad.id !== id)\r\n                {\r\n                    //  A new Gamepad with a different vendor string, but it has got the same index as an old one\r\n                    currentPad.destroy();\r\n\r\n                    currentPads[index] = new Gamepad(this, livePad);\r\n                }\r\n                else\r\n                {\r\n                    //  If neither of these, it's a pad we've already got, so update it\r\n                    currentPad.update(livePad);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all currently connected Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getAll\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad[]} An array of all currently connected Gamepads.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var out = [];\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i])\r\n            {\r\n                out.push(pads[i]);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Looks-up a single Gamepad based on the given index value.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getPad\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the Gamepad to get.\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad} The Gamepad matching the given index, or undefined if none were found.\r\n     */\r\n    getPad: function (index)\r\n    {\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i] && pads[i].index === index)\r\n            {\r\n                return pads[i];\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update loop. Refreshes all connected gamepads and processes their events.\r\n     *\r\n     * Called automatically by the Input Manager, invoked from the Game step.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Gamepad.Events#CONNECTED\r\n     * @fires Phaser.Input.Gamepad.Events#DISCONNECTED\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.refreshPads();\r\n\r\n        var len = this.queue.length;\r\n\r\n        if (len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var queue = this.queue.splice(0, len);\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var pad = this.getPad(event.gamepad.index);\r\n\r\n            if (event.type === 'gamepadconnected')\r\n            {\r\n                this.emit(Events.CONNECTED, pad, event);\r\n            }\r\n            else if (event.type === 'gamepaddisconnected')\r\n            {\r\n                this.emit(Events.DISCONNECTED, pad, event);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Shuts the Gamepad Plugin down.\r\n     * All this does is remove any listeners bound to it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.stopListeners();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad Plugin, disconnecting all Gamepads and releasing internal references.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            if (this.gamepads[i])\r\n            {\r\n                this.gamepads[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.gamepads = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.target = null;\r\n    },\r\n\r\n    /**\r\n     * The total number of connected game pads.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#total\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    total: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gamepads.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the first connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad1\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad1;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the second connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad2\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad2;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the third connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad3\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad3;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the fourth connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad4\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad4;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Gamepad Plugin class, if enabled via the `input.gamepad` Scene or Game Config property.\r\n * Use this to create access Gamepads connected to the browser and respond to gamepad buttons.\r\n *\r\n * @name Phaser.Input.InputPlugin#gamepad\r\n * @type {?Phaser.Input.Gamepad.GamepadPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('GamepadPlugin', GamepadPlugin, 'gamepad', 'gamepad', 'inputGamepad');\r\n\r\nmodule.exports = GamepadPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tatar SNES USB Controller Gamepad Configuration.\r\n * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.SNES_USB\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SELECT: 8,\r\n    START: 9,\r\n\r\n    B: 0,\r\n    A: 1,\r\n    Y: 2,\r\n    X: 3,\r\n\r\n    LEFT_SHOULDER: 4,\r\n    RIGHT_SHOULDER: 5\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * PlayStation DualShock 4 Gamepad Configuration.\r\n * Sony PlayStation DualShock 4 (v2) wireless controller\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.DUALSHOCK_4\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SHARE: 8,\r\n    OPTIONS: 9,\r\n    PS: 16,\r\n    TOUCHBAR: 17,\r\n\r\n    X: 0,\r\n    CIRCLE: 1,\r\n    SQUARE: 2,\r\n    TRIANGLE: 3,\r\n\r\n    L1: 4,\r\n    R1: 5,\r\n    L2: 6,\r\n    R2: 7,\r\n    L3: 10,\r\n    R3: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * XBox 360 Gamepad Configuration.\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.XBOX_360\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    MENU: 16,\r\n\r\n    A: 0,\r\n    B: 1,\r\n    X: 2,\r\n    Y: 3,\r\n\r\n    LB: 4,\r\n    RB: 5,\r\n\r\n    LT: 6,\r\n    RT: 7,\r\n\r\n    BACK: 8,\r\n    START: 9,\r\n\r\n    LS: 10,\r\n    RS: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Configs\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DUALSHOCK_4: require('./Sony_PlayStation_DualShock_4'),\r\n    SNES_USB: require('./SNES_USB_Controller'),\r\n    XBOX_360: require('./XBox360_Controller')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.\r\n * \r\n * You can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was pressed.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.\r\n * \r\n * You can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was released.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Connected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been connected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.\r\n * \r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#CONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was connected.\r\n * @param {Event} event - The native DOM Event that triggered the connection.\r\n */\r\nmodule.exports = 'connected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Disconnected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#DISCONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was disconnected.\r\n * @param {Event} event - The native DOM Event that triggered the disconnection.\r\n */\r\nmodule.exports = 'disconnected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been pressed on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('down', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been released on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('up', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BUTTON_DOWN: require('./BUTTON_DOWN_EVENT'),\r\n    BUTTON_UP: require('./BUTTON_UP_EVENT'),\r\n    CONNECTED: require('./CONNECTED_EVENT'),\r\n    DISCONNECTED: require('./DISCONNECTED_EVENT'),\r\n    GAMEPAD_BUTTON_DOWN: require('./GAMEPAD_BUTTON_DOWN_EVENT'),\r\n    GAMEPAD_BUTTON_UP: require('./GAMEPAD_BUTTON_UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Axis: require('./Axis'),\r\n    Button: require('./Button'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./Gamepad'),\r\n    GamepadPlugin: require('./GamepadPlugin'),\r\n    \r\n    Configs: require('./configs/')\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Input\r\n */\r\n\r\nvar Input = {\r\n\r\n    CreatePixelPerfectHandler: require('./CreatePixelPerfectHandler'),\r\n    CreateInteractiveObject: require('./CreateInteractiveObject'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./gamepad'),\r\n    InputManager: require('./InputManager'),\r\n    InputPlugin: require('./InputPlugin'),\r\n    InputPluginCache: require('./InputPluginCache'),\r\n    Keyboard: require('./keyboard'),\r\n    Mouse: require('./mouse'),\r\n    Pointer: require('./Pointer'),\r\n    Touch: require('./touch')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nInput = Extend(false, Input, CONST);\r\n\r\nmodule.exports = Input;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../../core/events');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputEvents = require('../events');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar Key = require('./keys/Key');\r\nvar KeyCodes = require('./keys/KeyCodes');\r\nvar KeyCombo = require('./combo/KeyCombo');\r\nvar KeyMap = require('./keys/KeyMap');\r\nvar SceneEvents = require('../../scene/events');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * @classdesc\r\n * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Keyboard Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown', callback, context);\r\n * ```\r\n *\r\n * Or, to listen for a specific key:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown-A', callback, context);\r\n * ```\r\n *\r\n * You can also create Key objects, which you can then poll in your game loop:\r\n *\r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * ```\r\n *\r\n * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from\r\n * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the\r\n * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.\r\n *\r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.\r\n *\r\n * @class KeyboardPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar KeyboardPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function KeyboardPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the core game, so we can listen for visibility events.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.16.0\r\n         */\r\n        this.game = sceneInputPlugin.systems.game;\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A reference to the global Keyboard Manager.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.manager = sceneInputPlugin.manager.keyboard;\r\n\r\n        /**\r\n         * A boolean that controls if this Keyboard Plugin is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of Key objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#keys\r\n         * @type {Phaser.Input.Keyboard.Key[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.keys = [];\r\n\r\n        /**\r\n         * An array of KeyCombo objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#combos\r\n         * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.combos = [];\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevCode\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevCode = null;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevTime\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevTime = 0;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevType\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.1\r\n         */\r\n        this.prevType = null;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var settings = this.settings.input;\r\n\r\n        this.enabled = GetValue(settings, 'keyboard', true);\r\n\r\n        var captures = GetValue(settings, 'keyboard.capture', null);\r\n\r\n        if (captures)\r\n        {\r\n            this.addCaptures(captures);\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.game.events.on(GameEvents.BLUR, this.resetKeys, this);\r\n\r\n        this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\r\n     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\r\n     *\r\n     * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser\r\n     * and cause the default behaviors.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent\r\n     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to enable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    addCapture: function (keycode)\r\n    {\r\n        this.manager.addCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing key capture.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove\r\n     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to disable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeCapture: function (keycode)\r\n    {\r\n        this.manager.removeCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns an array that contains all of the keyboard captures currently enabled.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {number[]} An array of all the currently capturing key codes.\r\n     */\r\n    getCaptures: function ()\r\n    {\r\n        return this.manager.captures;\r\n    },\r\n\r\n    /**\r\n     * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.\r\n     * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    enableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disables Phaser from preventing any key captures you may have defined, without actually removing them.\r\n     * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    disableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all keyboard captures.\r\n     *\r\n     * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    clearCaptures: function ()\r\n    {\r\n        this.manager.clearCaptures();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.\r\n     */\r\n    createCursorKeys: function ()\r\n    {\r\n        return this.addKeys({\r\n            up: KeyCodes.UP,\r\n            down: KeyCodes.DOWN,\r\n            left: KeyCodes.LEFT,\r\n            right: KeyCodes.RIGHT,\r\n            space: KeyCodes.SPACE,\r\n            shift: KeyCodes.SHIFT\r\n        });\r\n    },\r\n\r\n    /**\r\n     * A practical way to create an object containing user selected hotkeys.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n     * ```\r\n     *\r\n     * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.\r\n     *\r\n     * You can also pass in a comma-separated string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys('W,S,A,D');\r\n     * ```\r\n     *\r\n     * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {object} An object containing Key objects mapped to the input properties.\r\n     */\r\n    addKeys: function (keys, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var output = {};\r\n\r\n        if (typeof keys === 'string')\r\n        {\r\n            keys = keys.split(',');\r\n\r\n            for (var i = 0; i < keys.length; i++)\r\n            {\r\n                var currentKey = keys[i].trim();\r\n\r\n                if (currentKey)\r\n                {\r\n                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var key in keys)\r\n            {\r\n                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Adds a Key object to this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n     */\r\n    addKey: function (key, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var keys = this.keys;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                keys[idx] = key;\r\n            }\r\n            else\r\n            {\r\n                keys[key.keyCode] = key;\r\n            }\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key.keyCode);\r\n            }\r\n\r\n            key.setEmitOnRepeat(emitOnRepeat);\r\n\r\n            return key;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (!keys[key])\r\n        {\r\n            keys[key] = new Key(this, key);\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key);\r\n            }\r\n\r\n            keys[key].setEmitOnRepeat(emitOnRepeat);\r\n        }\r\n\r\n        return keys[key];\r\n    },\r\n\r\n    /**\r\n     * Removes a Key object from this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeKey: function (key, destroy)\r\n    {\r\n        if (destroy === undefined) { destroy = false; }\r\n\r\n        var keys = this.keys;\r\n        var ref;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                ref = this.keys[idx];\r\n\r\n                this.keys[idx] = undefined;\r\n            }\r\n        }\r\n        else if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (keys[key])\r\n        {\r\n            ref = keys[key];\r\n\r\n            keys[key] = undefined;\r\n        }\r\n\r\n        if (ref)\r\n        {\r\n            ref.plugin = null;\r\n\r\n            if (destroy)\r\n            {\r\n                ref.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Key objects created by _this_ Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeAllKeys\r\n     * @since 3.24.0\r\n     *\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on each removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeAllKeys: function (destroy)\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var key = keys[i];\r\n\r\n            if (key)\r\n            {\r\n                keys[i] = undefined;\r\n\r\n                if (destroy)\r\n                {\r\n                    key.destroy();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new KeyCombo.\r\n     *\r\n     * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n     * it will emit a `keycombomatch` event from this Keyboard Plugin.\r\n     *\r\n     * The keys to be listened for can be defined as:\r\n     *\r\n     * A string (i.e. 'ATARI')\r\n     * An array of either integers (key codes) or strings, or a mixture of both\r\n     * An array of objects (such as Key objects) with a public 'keyCode' property\r\n     *\r\n     * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n     * you could pass the following array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n     *\r\n     * this.input.keyboard.on('keycombomatch', function (event) {\r\n     *     console.log('Konami Code entered!');\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to listen for the user entering the word PHASER:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo('PHASER');\r\n     * ```\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.\r\n     */\r\n    createCombo: function (keys, config)\r\n    {\r\n        return new KeyCombo(this, keys, config);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Key object is currently being held down.\r\n     *\r\n     * The difference between this method and checking the `Key.isDown` property directly is that you can provide\r\n     * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted\r\n     * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it\r\n     * will only return `true` every 100ms.\r\n     *\r\n     * If the Keyboard Plugin has been disabled, this method will always return `false`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.Input.Keyboard.Key} key - A Key object.\r\n     * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.\r\n     *\r\n     * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.\r\n     */\r\n    checkDown: function (key, duration)\r\n    {\r\n        if (duration === undefined) { duration = 0; }\r\n\r\n        if (this.enabled && key.isDown)\r\n        {\r\n            var t = SnapFloor(this.time - key.timeDown, duration);\r\n\r\n            if (t > key._tick)\r\n            {\r\n                key._tick = t;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#update\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var queue = this.manager.queue;\r\n        var len = queue.length;\r\n\r\n        if (!this.isActive() || len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var keys = this.keys;\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var code = event.keyCode;\r\n            var key = keys[code];\r\n            var repeat = false;\r\n\r\n            //  Override the default functions (it's too late for the browser to use them anyway, so we may as well)\r\n            if (event.cancelled === undefined)\r\n            {\r\n                //  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list\r\n                event.cancelled = 0;\r\n\r\n                //  Won't reach any more local (Scene level) handlers\r\n                event.stopImmediatePropagation = function ()\r\n                {\r\n                    event.cancelled = 1;\r\n                };\r\n\r\n                //  Won't reach any more handlers in any Scene further down the Scene list\r\n                event.stopPropagation = function ()\r\n                {\r\n                    event.cancelled = -1;\r\n                };\r\n            }\r\n\r\n            if (event.cancelled === -1)\r\n            {\r\n                //  This event has been stopped from broadcasting to any other Scene, so abort.\r\n                continue;\r\n            }\r\n\r\n            //  Duplicate event bailout\r\n            if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType)\r\n            {\r\n                //  On some systems, the exact same event will fire multiple times. This prevents it.\r\n                continue;\r\n            }\r\n\r\n            this.prevCode = code;\r\n            this.prevTime = event.timeStamp;\r\n            this.prevType = event.type;\r\n\r\n            if (event.type === 'keydown')\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    repeat = key.isDown;\r\n\r\n                    key.onDown(event);\r\n                }\r\n\r\n                if (!event.cancelled && (!key || !repeat))\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_DOWN + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_DOWN, event);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    key.onUp(event);\r\n                }\r\n\r\n                if (!event.cancelled)\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_UP + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_UP, event);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //  Reset the cancel state for other Scenes to use\r\n            if (event.cancelled === 1)\r\n            {\r\n                event.cancelled = 0;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.\r\n     * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.\r\n     * If you have created a Key object directly you'll need to reset it yourself.\r\n     *\r\n     * This method is called automatically when the Keyboard Plugin shuts down, but can be\r\n     * invoked directly at any time you require.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys\r\n     * @since 3.15.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    resetKeys: function ()\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].reset();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuts this Keyboard Plugin down. This performs the following tasks:\r\n     *\r\n     * 1 - Removes all keys created by this Keyboard plugin.\r\n     * 2 - Stops and removes the keyboard event listeners.\r\n     * 3 - Clears out any pending requests in the queue, without processing them.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAllKeys(true);\r\n        this.removeAllListeners();\r\n\r\n        this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.game.events.off(GameEvents.BLUR, this.resetKeys);\r\n\r\n        this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);\r\n\r\n        this.queue = [];\r\n    },\r\n\r\n    /**\r\n     * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.keys = [];\r\n        this.combos = [];\r\n        this.queue = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.manager = null;\r\n    },\r\n\r\n    /**\r\n     * Internal time value.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#time\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    time: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.sceneInputPlugin.manager.time;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.\r\n * Use this to create Key objects and listen for keyboard specific events.\r\n *\r\n * @name Phaser.Input.InputPlugin#keyboard\r\n * @type {?Phaser.Input.Keyboard.KeyboardPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');\r\n\r\nmodule.exports = KeyboardPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n * Return `true` if it reached the end of the combo, `false` if not.\r\n *\r\n * @function Phaser.Input.Keyboard.AdvanceKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to advance.\r\n *\r\n * @return {boolean} `true` if it reached the end of the combo, `false` if not.\r\n */\r\nvar AdvanceKeyCombo = function (event, combo)\r\n{\r\n    combo.timeLastMatched = event.timeStamp;\r\n    combo.index++;\r\n\r\n    if (combo.index === combo.size)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        combo.current = combo.keyCodes[combo.index];\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = AdvanceKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ProcessKeyCombo = require('./ProcessKeyCombo');\r\nvar ResetKeyCombo = require('./ResetKeyCombo');\r\n\r\n/**\r\n * @classdesc\r\n * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n * it will emit a `keycombomatch` event from the Keyboard Manager.\r\n *\r\n * The keys to be listened for can be defined as:\r\n *\r\n * A string (i.e. 'ATARI')\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n * you could pass the following array of key codes:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * Or, to listen for the user entering the word PHASER:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo('PHASER');\r\n * ```\r\n *\r\n * @class KeyCombo\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @listens Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} keyboardPlugin - A reference to the Keyboard Plugin.\r\n * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n */\r\nvar KeyCombo = new Class({\r\n\r\n    initialize:\r\n\r\n    function KeyCombo (keyboardPlugin, keys, config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        //  Can't have a zero or single length combo (string or array based)\r\n        if (keys.length < 2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Keyboard Manager\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = keyboardPlugin;\r\n\r\n        /**\r\n         * A flag that controls if this Key Combo is actively processing keys or not.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of the keycodes that comprise this combo.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCodes = [];\r\n\r\n        //  if 'keys' is a string we need to get the keycode of each character in it\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var char = keys[i];\r\n\r\n            if (typeof char === 'string')\r\n            {\r\n                this.keyCodes.push(char.toUpperCase().charCodeAt(0));\r\n            }\r\n            else if (typeof char === 'number')\r\n            {\r\n                this.keyCodes.push(char);\r\n            }\r\n            else if (char.hasOwnProperty('keyCode'))\r\n            {\r\n                this.keyCodes.push(char.keyCode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The current keyCode the combo is waiting for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#current\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.current = this.keyCodes[0];\r\n\r\n        /**\r\n         * The current index of the key being waited for in the 'keys' string.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#index\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.index = 0;\r\n\r\n        /**\r\n         * The length of this combo (in keycodes)\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#size\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.size = this.keyCodes.length;\r\n\r\n        /**\r\n         * The time the previous key in the combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeLastMatched = 0;\r\n\r\n        /**\r\n         * Has this Key Combo been matched yet?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.matched = false;\r\n\r\n        /**\r\n         * The time the entire combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeMatched = 0;\r\n\r\n        /**\r\n         * If they press the wrong key do we reset the combo?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n         * @type {boolean}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);\r\n\r\n        /**\r\n         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);\r\n\r\n        /**\r\n         * If previously matched and they press the first key of the combo again, will it reset?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);\r\n\r\n        /**\r\n         * If the combo matches, will it delete itself?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);\r\n\r\n        var _this = this;\r\n\r\n        var onKeyDownHandler = function (event)\r\n        {\r\n            if (_this.matched || !_this.enabled)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var matched = ProcessKeyCombo(event, _this);\r\n\r\n            if (matched)\r\n            {\r\n                _this.manager.emit(Events.COMBO_MATCH, _this, event);\r\n\r\n                if (_this.resetOnMatch)\r\n                {\r\n                    ResetKeyCombo(_this);\r\n                }\r\n                else if (_this.deleteOnMatch)\r\n                {\r\n                    _this.destroy();\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * The internal Key Down handler.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n         * @private\r\n         * @type {KeyboardKeydownCallback}\r\n         * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n         * @since 3.0.0\r\n         */\r\n        this.onKeyDown = onKeyDownHandler;\r\n\r\n        this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n    },\r\n\r\n    /**\r\n     * How far complete is this combo? A value between 0 and 1.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    progress: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.index / this.size;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Combo and all of its references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enabled = false;\r\n        this.keyCodes = [];\r\n\r\n        this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = KeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AdvanceKeyCombo = require('./AdvanceKeyCombo');\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ProcessKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to be processed.\r\n *\r\n * @return {boolean} `true` if the combo was matched, otherwise `false`.\r\n */\r\nvar ProcessKeyCombo = function (event, combo)\r\n{\r\n    if (combo.matched)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    var comboMatched = false;\r\n    var keyMatched = false;\r\n\r\n    if (event.keyCode === combo.current)\r\n    {\r\n        //  Key was correct\r\n\r\n        if (combo.index > 0 && combo.maxKeyDelay > 0)\r\n        {\r\n            //  We have to check to see if the delay between\r\n            //  the new key and the old one was too long (if enabled)\r\n\r\n            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;\r\n\r\n            //  Check if they pressed it in time or not\r\n            if (event.timeStamp <= timeLimit)\r\n            {\r\n                keyMatched = true;\r\n                comboMatched = AdvanceKeyCombo(event, combo);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            keyMatched = true;\r\n\r\n            //  We don't check the time for the first key pressed, so just advance it\r\n            comboMatched = AdvanceKeyCombo(event, combo);\r\n        }\r\n    }\r\n\r\n    if (!keyMatched && combo.resetOnWrongKey)\r\n    {\r\n        //  Wrong key was pressed\r\n        combo.index = 0;\r\n        combo.current = combo.keyCodes[0];\r\n    }\r\n\r\n    if (comboMatched)\r\n    {\r\n        combo.timeLastMatched = event.timeStamp;\r\n        combo.matched = true;\r\n        combo.timeMatched = event.timeStamp;\r\n    }\r\n\r\n    return comboMatched;\r\n};\r\n\r\nmodule.exports = ProcessKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ResetKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo to reset.\r\n *\r\n * @return {Phaser.Input.Keyboard.KeyCombo} The KeyCombo.\r\n */\r\nvar ResetKeyCombo = function (combo)\r\n{\r\n    combo.current = combo.keyCodes[0];\r\n    combo.index = 0;\r\n    combo.timeLastMatched = 0;\r\n    combo.matched = false;\r\n    combo.timeMatched = 0;\r\n\r\n    return combo;\r\n};\r\n\r\nmodule.exports = ResetKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.\r\n * \r\n * You can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.\r\n * \r\n * You can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Combo Match Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.\r\n * \r\n * Listen for this event from the Key Plugin after a combo has been created:\r\n * \r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * @event Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.KeyCombo} keycombo - The Key Combo object that was matched.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event of the final key in the combo. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'keycombomatch';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('down', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was pressed.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Unlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed\r\n * use the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keydown-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Unlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released\r\n * use the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keyup-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('up', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#UP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was released.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ANY_KEY_DOWN: require('./ANY_KEY_DOWN_EVENT'),\r\n    ANY_KEY_UP: require('./ANY_KEY_UP_EVENT'),\r\n    COMBO_MATCH: require('./COMBO_MATCH_EVENT'),\r\n    DOWN: require('./DOWN_EVENT'),\r\n    KEY_DOWN: require('./KEY_DOWN_EVENT'),\r\n    KEY_UP: require('./KEY_UP_EVENT'),\r\n    UP: require('./UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Events: require('./events'),\r\n\r\n    KeyboardManager: require('./KeyboardManager'),\r\n    KeyboardPlugin: require('./KeyboardPlugin'),\r\n\r\n    Key: require('./keys/Key'),\r\n    KeyCodes: require('./keys/KeyCodes'),\r\n\r\n    KeyCombo: require('./combo/KeyCombo'),\r\n\r\n    AdvanceKeyCombo: require('./combo/AdvanceKeyCombo'),\r\n    ProcessKeyCombo: require('./combo/ProcessKeyCombo'),\r\n    ResetKeyCombo: require('./combo/ResetKeyCombo'),\r\n\r\n    JustDown: require('./keys/JustDown'),\r\n    JustUp: require('./keys/JustUp'),\r\n    DownDuration: require('./keys/DownDuration'),\r\n    UpDuration: require('./keys/UpDuration')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was pressed down within the `duration` value given, based on the current\r\n * game clock time. Or `false` if it either isn't down, or was pressed down longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.DownDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been pressed down.\r\n *\r\n * @return {boolean} `true` if the Key was pressed down within `duration` ms ago, otherwise `false`.\r\n */\r\nvar DownDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeDown;\r\n\r\n    return (key.isDown && current < duration);\r\n};\r\n\r\nmodule.exports = DownDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justDown value allows you to test if this Key has just been pressed down or not.\r\n * \r\n * When you check this value it will return `true` if the Key is down, otherwise `false`.\r\n * \r\n * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.\r\n * This allows you to use it in situations where you want to check if this key is down without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustDown\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just down or not.\r\n *\r\n * @return {boolean} `true` if the Key was just pressed, otherwise `false`.\r\n */\r\nvar JustDown = function (key)\r\n{\r\n    if (key._justDown)\r\n    {\r\n        key._justDown = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustDown;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justUp value allows you to test if this Key has just been released or not.\r\n * \r\n * When you check this value it will return `true` if the Key is up, otherwise `false`.\r\n * \r\n * You can only call JustUp once per key release. It will only return `true` once, until the Key is pressed down and released again.\r\n * This allows you to use it in situations where you want to check if this key is up without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustUp\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just up or not.\r\n *\r\n * @return {boolean} `true` if the Key was just released, otherwise `false`.\r\n */\r\nvar JustUp = function (key)\r\n{\r\n    if (key._justUp)\r\n    {\r\n        key._justUp = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustUp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A generic Key object which can be passed to the Process functions (and so on)\r\n * keycode must be an integer\r\n *\r\n * @class Key\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} plugin - The Keyboard Plugin instance that owns this Key object.\r\n * @param {number} keyCode - The keycode of this key.\r\n */\r\nvar Key = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Key (plugin, keyCode)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Keyboard Plugin instance that owns this Key object.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#plugin\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.17.0\r\n         */\r\n        this.plugin = plugin;\r\n\r\n        /**\r\n         * The keycode of this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#keyCode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCode = keyCode;\r\n\r\n        /**\r\n         * The original DOM event.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#originalEvent\r\n         * @type {KeyboardEvent}\r\n         * @since 3.0.0\r\n         */\r\n        this.originalEvent = undefined;\r\n\r\n        /**\r\n         * Can this Key be processed?\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The \"down\" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isDown = false;\r\n\r\n        /**\r\n         * The \"up\" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isUp\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isUp = true;\r\n\r\n        /**\r\n         * The down state of the ALT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#altKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.altKey = false;\r\n\r\n        /**\r\n         * The down state of the CTRL key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#ctrlKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.ctrlKey = false;\r\n\r\n        /**\r\n         * The down state of the SHIFT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#shiftKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.shiftKey = false;\r\n\r\n        /**\r\n         * The down state of the Meta key, if pressed at the same time as this key.\r\n         * On a Mac the Meta Key is the Command key. On Windows keyboards, it's the Windows key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#metaKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.metaKey = false;\r\n\r\n        /**\r\n         * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#location\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.location = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last pressed down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeDown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeDown = 0;\r\n\r\n        /**\r\n         * The number of milliseconds this key was held down for in the previous down - up sequence.\r\n         * This value isn't updated every game step, only when the Key changes state.\r\n         * To get the current duration use the `getDuration` method.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last released.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeUp\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeUp = 0;\r\n\r\n        /**\r\n         * When a key is held down should it continuously fire the `down` event each time it repeats?\r\n         * \r\n         * By default it will emit the `down` event just once, but if you wish to receive the event\r\n         * for each repeat as well, enable this property.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#emitOnRepeat\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.emitOnRepeat = false;\r\n\r\n        /**\r\n         * If a key is held down this holds down the number of times the key has 'repeated'.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#repeats\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeats = 0;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justDown\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justDown = false;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justUp\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justUp = false;\r\n\r\n        /**\r\n         * Internal tick counter.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_tick\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._tick = -1;\r\n    },\r\n\r\n    /**\r\n     * Controls if this Key will continuously emit a `down` event while being held down (true),\r\n     * or emit the event just once, on first press, and then skip future events (false).\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#setEmitOnRepeat\r\n     * @since 3.16.0\r\n     * \r\n     * @param {boolean} value - Emit `down` events on repeated key down actions, or just once?\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    setEmitOnRepeat: function (value)\r\n    {\r\n        this.emitOnRepeat = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Down action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onDown\r\n     * @fires Phaser.Input.Keyboard.Events#DOWN\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onDown: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.altKey = event.altKey;\r\n        this.ctrlKey = event.ctrlKey;\r\n        this.shiftKey = event.shiftKey;\r\n        this.metaKey = event.metaKey;\r\n        this.location = event.location;\r\n    \r\n        this.repeats++;\r\n\r\n        if (!this.isDown)\r\n        {\r\n            this.isDown = true;\r\n            this.isUp = false;\r\n            this.timeDown = event.timeStamp;\r\n            this.duration = 0;\r\n            this._justDown = true;\r\n            this._justUp = false;\r\n\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n        else if (this.emitOnRepeat)\r\n        {\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Up action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onUp\r\n     * @fires Phaser.Input.Keyboard.Events#UP\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onUp: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n    \r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.timeUp = event.timeStamp;\r\n        this.duration = this.timeUp - this.timeDown;\r\n        this.repeats = 0;\r\n    \r\n        this._justDown = false;\r\n        this._justUp = true;\r\n        this._tick = -1;\r\n        \r\n        this.emit(Events.UP, this, event);\r\n    },\r\n\r\n    /**\r\n     * Resets this Key object back to its default un-pressed state.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#reset\r\n     * @since 3.6.0\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.preventDefault = true;\r\n        this.enabled = true;\r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.altKey = false;\r\n        this.ctrlKey = false;\r\n        this.shiftKey = false;\r\n        this.metaKey = false;\r\n        this.timeDown = 0;\r\n        this.duration = 0;\r\n        this.timeUp = 0;\r\n        this.repeats = 0;\r\n        this._justDown = false;\r\n        this._justUp = false;\r\n        this._tick = -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the duration, in ms, that the Key has been held down for.\r\n     * \r\n     * If the key is not currently down it will return zero.\r\n     * \r\n     * The get the duration the Key was held down for in the previous up-down cycle,\r\n     * use the `Key.duration` property value instead.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#getDuration\r\n     * @since 3.17.0\r\n     * \r\n     * @return {number} The duration, in ms, that the Key has been held down for if currently down.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        if (this.isDown)\r\n        {\r\n            return (this.plugin.game.loop.time - this.timeDown);\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes any bound event handlers and removes local references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.originalEvent = null;\r\n\r\n        this.plugin = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Key;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar KeyCodes = require('./KeyCodes');\r\n\r\nvar KeyMap = {};\r\n\r\nfor (var key in KeyCodes)\r\n{\r\n    KeyMap[KeyCodes[key]] = key;\r\n}\r\n\r\nmodule.exports = KeyMap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was released within the `duration` value given, based on the current\r\n * game clock time. Or returns `false` if it either isn't up, or was released longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.UpDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been released.\r\n *\r\n * @return {boolean} `true` if the Key was released within `duration` ms ago, otherwise `false`.\r\n */\r\nvar UpDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeUp;\r\n\r\n    return (key.isUp && current < duration);\r\n};\r\n\r\nmodule.exports = UpDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Mouse\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    MouseManager: require('./MouseManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Touch\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    TouchManager: require('./TouchManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('./Clamp');\r\n\r\n/**\r\n * Return a value based on the range between `min` and `max` and the percentage given.\r\n *\r\n * @function Phaser.Math.FromPercent\r\n * @since 3.0.0\r\n *\r\n * @param {number} percent - A value between 0 and 1 representing the percentage.\r\n * @param {number} min - The minimum value.\r\n * @param {number} [max] - The maximum value.\r\n *\r\n * @return {number} The value that is `percent` percent between `min` and `max`.\r\n */\r\nvar FromPercent = function (percent, min, max)\r\n{\r\n    percent = Clamp(percent, 0, 1);\r\n\r\n    return (max - min) * percent + min;\r\n};\r\n\r\nmodule.exports = FromPercent;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\r\n *\r\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\r\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\r\n * between 0 and 1 otherwise.\r\n *\r\n * @function Phaser.Math.SmoothStep\r\n * @since 3.0.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} x - The input value.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The percentage of interpolation, between 0 and 1.\r\n */\r\nvar SmoothStep = function (x, min, max)\r\n{\r\n    if (x <= min)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    if (x >= max)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    x = (x - min) / (max - min);\r\n\r\n    return x * x * (3 - 2 * x);\r\n};\r\n\r\nmodule.exports = SmoothStep;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\r\n *\r\n * @function Phaser.Math.Angle.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The angle in radians.\r\n */\r\nvar Between = function (x1, y1, x2, y2)\r\n{\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n};\r\n\r\nmodule.exports = Between;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the distance between two sets of coordinates (points).\r\n *\r\n * @function Phaser.Math.Distance.Between\r\n * @since 3.0.0\r\n *\r\n * @param {number} x1 - The x coordinate of the first point.\r\n * @param {number} y1 - The y coordinate of the first point.\r\n * @param {number} x2 - The x coordinate of the second point.\r\n * @param {number} y2 - The y coordinate of the second point.\r\n *\r\n * @return {number} The distance between each point.\r\n */\r\nvar DistanceBetween = function (x1, y1, x2, y2)\r\n{\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\nmodule.exports = DistanceBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SmoothStep = require('../SmoothStep');\r\n\r\n/**\r\n * A Smooth Step interpolation method.\r\n *\r\n * @function Phaser.Math.Interpolation.SmoothStep\r\n * @since 3.9.0\r\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\r\n *\r\n * @param {number} t - The percentage of interpolation, between 0 and 1.\r\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\r\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\r\n *\r\n * @return {number} The interpolated value.\r\n */\r\nvar SmoothStepInterpolation = function (t, min, max)\r\n{\r\n    return min + (max - min) * SmoothStep(t, 0, 1);\r\n};\r\n\r\nmodule.exports = SmoothStepInterpolation;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using floor.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\r\n * As will `14` snap to `10`... but `16` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapFloor = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapFloor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SpliceOne = require('./SpliceOne');\r\n\r\n/**\r\n * Removes the given item, or array of items, from the array.\r\n *\r\n * The array is modified in-place.\r\n *\r\n * You can optionally specify a callback to be invoked for each item successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.Remove\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.\r\n */\r\nvar Remove = function (array, item, callback, context)\r\n{\r\n    if (context === undefined) { context = array; }\r\n\r\n    var index;\r\n\r\n    //  Fast path to avoid array mutation and iteration\r\n    if (!Array.isArray(item))\r\n    {\r\n        index = array.indexOf(item);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, item);\r\n            }\r\n\r\n            return item;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    //  If we got this far, we have an array of items to remove\r\n\r\n    var itemLength = item.length - 1;\r\n    var removed = [];\r\n\r\n    while (itemLength >= 0)\r\n    {\r\n        var entry = item[itemLength];\r\n\r\n        index = array.indexOf(entry);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            removed.push(entry);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, entry);\r\n            }\r\n        }\r\n\r\n        itemLength--;\r\n    }\r\n\r\n    return removed;\r\n};\r\n\r\nmodule.exports = Remove;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n"],"names":["create","first","total","CONST","Smoothing","pool","_disableContextSmoothing","module","exports","c","forEach","container","parent","create2D","width","height","CANVAS","canvasType","selfParent","canvas","undefined","document","createElement","type","push","disable","getContext","createWebGL","WEBGL","disableSmoothing","enableSmoothing","i","length","free","remove","isCanvas","HTMLCanvasElement","getPrefix","prefix","context","enable","vendors","s","isEnabled","Class","Contains","GetPoint","GetPoints","GEOM_CONST","Random","Circle","initialize","x","y","radius","this","CIRCLE","_radius","_diameter","contains","getPoint","position","point","getPoints","quantity","stepRate","output","getRandomPoint","setTo","setEmpty","setPosition","isEmpty","get","set","value","diameter","left","right","top","bottom","circle","Math","PI","Point","angle","out","cos","sin","CircumferencePoint","FromPercent","MATH_CONST","PI2","Circumference","t","random","u","r","ellipse","p","sqrt","triangle","ux","x2","x1","uy","y2","y1","vx","x3","vy","y3","gameObject","hitArea","hitAreaCallback","enabled","alwaysEnabled","draggable","dropZone","cursor","target","camera","hitAreaDebug","customHitArea","localX","localY","dragState","dragStartX","dragStartY","dragStartXGlobal","dragStartYGlobal","dragX","dragY","textureManager","alphaTolerance","alpha","getPixelAlpha","texture","key","frame","name","CircleContains","CreateInteractiveObject","CreatePixelPerfectHandler","DistanceBetween","Ellipse","EllipseContains","Events","EventEmitter","GetFastValue","InputPluginCache","IsPlainObject","PluginCache","Rectangle","RectangleContains","SceneEvents","Triangle","TriangleContains","InputPlugin","Extends","scene","call","systems","sys","settings","manager","game","input","pluginEvents","displayList","cameras","install","mouse","topOnly","pollRate","_pollTimer","_eventData","cancelled","_eventContainer","stopPropagation","dragDistanceThreshold","dragTimeThreshold","_temp","_tempZones","_list","_pendingInsertion","_pendingRemoval","_draggable","_drag","_dragState","_over","_validTypes","_updatedThisFrame","events","once","BOOT","boot","on","START","start","DESTROY","destroy","emit","eventEmitter","TRANSITION_START","transitionIn","TRANSITION_OUT","transitionOut","TRANSITION_COMPLETE","transitionComplete","PRE_UPDATE","preUpdate","SHUTDOWN","shutdown","GAME_OUT","onGameOut","GAME_OVER","onGameOver","event","isActive","timeStamp","removeList","insertList","toRemove","toInsert","current","index","indexOf","splice","clear","concat","updatePoll","time","delta","UPDATE","pointers","pointersTotal","updateMotion","rate","captured","pointer","hitTestPointer","sortGameObjects","sortDropZones","processOverOutEvents","getDragState","processDragThresholdEvent","update","MOUSE_DOWN","processDragDownEvent","processDownEvents","MOUSE_UP","processDragUpEvent","processUpEvents","TOUCH_START","processOverEvents","TOUCH_END","TOUCH_CANCEL","processOutEvents","MOUSE_MOVE","TOUCH_MOVE","processDragMoveEvent","processMoveEvents","MOUSE_WHEEL","processWheelEvent","skipQueue","queueForRemoval","callbackContext","resetCursor","setHitArea","getCamerasBelowPointer","over","hitTest","obj","currentlyOver","aborted","GAMEOBJECT_POINTER_DOWN","GAMEOBJECT_DOWN","downElement","POINTER_DOWN","POINTER_DOWN_OUTSIDE","id","setDragState","state","passed","timeThreshold","distanceThreshold","downX","downY","downTime","processDragStartList","list","worldX","worldY","GAMEOBJECT_DRAG_START","DRAG_START","primaryDown","draglist","loop","now","dropZones","GAMEOBJECT_DRAG_OVER","DRAG_OVER","GAMEOBJECT_DRAG_LEAVE","DRAG_LEAVE","GAMEOBJECT_DRAG_ENTER","DRAG_ENTER","parentContainer","dx","dy","rotation","getParentRotation","dxRotated","dyRotated","scaleX","scaleY","GAMEOBJECT_DRAG","DRAG","displayOriginX","displayOriginY","dropped","GAMEOBJECT_DROP","DROP","GAMEOBJECT_DRAG_END","DRAG_END","GAMEOBJECT_POINTER_MOVE","GAMEOBJECT_MOVE","POINTER_MOVE","deltaX","deltaY","dz","deltaZ","GAMEOBJECT_POINTER_WHEEL","GAMEOBJECT_WHEEL","POINTER_WHEEL","totalInteracted","justOver","setCursor","GAMEOBJECT_POINTER_OVER","GAMEOBJECT_OVER","POINTER_OVER","previouslyOver","GAMEOBJECT_POINTER_OUT","GAMEOBJECT_OUT","POINTER_OUT","justOut","stillOver","currentlyDragging","GAMEOBJECT_POINTER_UP","GAMEOBJECT_UP","upElement","POINTER_UP","POINTER_UP_OUTSIDE","queueForInsertion","child","setDraggable","gameObjects","Array","isArray","makePixelPerfect","textures","setHitAreaFromTexture","useHandCursor","pixelPerfect","config","console","warn","io","setHitAreaCircle","callback","shape","setHitAreaEllipse","realWidth","realHeight","setHitAreaRectangle","setHitAreaTriangle","enableDebug","color","shapeType","debug","factory","add","updateList","offsetx","offsety","arc","ELLIPSE","LINE","line","POLYGON","polygon","points","RECTANGLE","rectangle","TRIANGLE","isFilled","setStrokeStyle","scale","setDisplayOrigin","matrix","getWorldTransformMatrix","tx","ty","setRotation","setScale","setScrollFactor","scrollFactorX","scrollFactorY","setDepth","depth","removeDebug","setPollAlways","setPollRate","setPollOnMove","setGlobalTopOnly","globalTopOnly","setTopOnly","renderList","sort","childA","childB","depthSort","sortDropZoneHandler","bind","getIndex","listA","getIndexList","listB","len","min","indexA","indexB","_tempSkip","addPointer","setDefaultCursor","transitionAllowInput","removeAllListeners","style","defaultCursor","off","activePointer","isOver","mousePointer","pointer1","pointer2","pointer3","pointer4","pointer5","pointer6","pointer7","pointer8","pointer9","pointer10","register","GetValue","inputPlugins","plugin","mapping","settingsKey","configKey","source","hasOwnProperty","Axis","pad","threshold","getValue","abs","Button","pressed","BUTTON_DOWN","GAMEPAD_BUTTON_DOWN","BUTTON_UP","GAMEPAD_BUTTON_UP","Vector2","Gamepad","buttons","axes","vibration","vibrationActuator","_noButton","_LCLeft","_LCRight","_LCTop","_LCBottom","_RCLeft","_RCRight","_RCTop","_RCBottom","_FBLeftTop","_FBLeftBottom","_FBRightTop","_FBRightBottom","_noAxis","_HAxisLeft","_VAxisLeft","_HAxisRight","_VAxisRight","leftStick","rightStick","_created","performance","getAxisTotal","getAxisValue","setAxisThreshold","getButtonTotal","getButtonValue","isButtonDown","timestamp","localButtons","gamepadButtons","localAxes","gamepadAxes","connected","up","down","A","Y","X","B","L1","L2","R1","R2","InputEvents","GamepadPlugin","sceneInputPlugin","gamepads","queue","onGamepadHandler","_pad1","_pad2","_pad3","_pad4","inputGamepad","device","inputGamepadEventTarget","startListeners","refreshPads","_this","handler","defaultPrevented","addEventListener","stopListeners","removeEventListener","disconnectAll","connectedPads","navigator","getGamepads","currentPads","livePad","currentPad","newPad","getAll","pads","getPad","gamepad","CONNECTED","DISCONNECTED","pad1","pad2","pad3","pad4","UP","DOWN","LEFT","RIGHT","SELECT","LEFT_SHOULDER","RIGHT_SHOULDER","SHARE","OPTIONS","PS","TOUCHBAR","SQUARE","L3","R3","LEFT_STICK_H","LEFT_STICK_V","RIGHT_STICK_H","RIGHT_STICK_V","MENU","LB","RB","LT","RT","BACK","LS","RS","DUALSHOCK_4","SNES_USB","XBOX_360","Configs","Extend","Input","InputManager","Keyboard","Mouse","Pointer","Touch","GameEvents","Key","KeyCodes","KeyCombo","KeyMap","SnapFloor","KeyboardPlugin","keyboard","keys","combos","prevCode","prevTime","prevType","captures","addCaptures","MANAGER_PROCESS","BLUR","resetKeys","PAUSE","SLEEP","addCapture","keycode","removeCapture","getCaptures","enableGlobalCapture","preventDefault","disableGlobalCapture","clearCaptures","createCursorKeys","addKeys","space","SPACE","shift","SHIFT","enableCapture","emitOnRepeat","split","currentKey","trim","addKey","idx","keyCode","setEmitOnRepeat","toUpperCase","removeKey","ref","removeAllKeys","createCombo","checkDown","duration","isDown","timeDown","_tick","code","repeat","stopImmediatePropagation","onDown","KEY_DOWN","ANY_KEY_DOWN","onUp","KEY_UP","ANY_KEY_UP","reset","combo","timeLastMatched","size","keyCodes","ProcessKeyCombo","ResetKeyCombo","keyboardPlugin","char","charCodeAt","matched","timeMatched","resetOnWrongKey","maxKeyDelay","resetOnMatch","deleteOnMatch","onKeyDown","COMBO_MATCH","progress","AdvanceKeyCombo","comboMatched","keyMatched","timeLimit","KeyboardManager","JustDown","JustUp","DownDuration","UpDuration","_justDown","_justUp","originalEvent","isUp","altKey","ctrlKey","shiftKey","metaKey","location","timeUp","repeats","getDuration","MouseManager","TouchManager","max","Clamp","percent","atan2","SmoothStep","gap","divide","floor","SpliceOne","array","item","itemLength","removed","entry","defaultValue"],"sourceRoot":""}