{"version":3,"file":"js/phaser-structs.c2e5997f061fd81967a3.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/eventemitter3/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/RoundAwayFromZero.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/snap/SnapFloor.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/List.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/Map.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/RTree.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/structs/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/FindClosestInSorted.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Remove.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/RotateLeft.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/RotateRight.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/Shuffle.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/SortByDigits.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/array/SpliceOne.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetValue.js"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.\r\n *\r\n * @function Phaser.Math.RoundAwayFromZero\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The number to round.\r\n *\r\n * @return {number} The rounded number, rounded away from zero.\r\n */\r\nvar RoundAwayFromZero = function (value)\r\n{\r\n    // \"Opposite\" of truncate.\r\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\r\n};\r\n\r\nmodule.exports = RoundAwayFromZero;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Snap a value to nearest grid slice, using floor.\r\n *\r\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\r\n * As will `14` snap to `10`... but `16` will snap to `15`.\r\n *\r\n * @function Phaser.Math.Snap.Floor\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to snap.\r\n * @param {number} gap - The interval gap of the grid.\r\n * @param {number} [start=0] - Optional starting offset for gap.\r\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\r\n *\r\n * @return {number} The snapped value.\r\n */\r\nvar SnapFloor = function (value, gap, start, divide)\r\n{\r\n    if (start === undefined) { start = 0; }\r\n\r\n    if (gap === 0)\r\n    {\r\n        return value;\r\n    }\r\n\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n\r\n    return (divide) ? (start + value) / gap : start + value;\r\n};\r\n\r\nmodule.exports = SnapFloor;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArrayUtils = require('../utils/array');\r\nvar Class = require('../utils/Class');\r\nvar NOOP = require('../utils/NOOP');\r\nvar StableSort = require('../utils/array/StableSort');\r\n\r\n/**\r\n * @callback EachListCallback<I>\r\n *\r\n * @param {I} item - The item which is currently being processed.\r\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * List is a generic implementation of an ordered list which contains utility methods for retrieving, manipulating, and iterating items.\r\n *\r\n * @class List\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n *\r\n * @param {*} parent - The parent of this list.\r\n */\r\nvar List = new Class({\r\n\r\n    initialize:\r\n\r\n    function List (parent)\r\n    {\r\n        /**\r\n         * The parent of this list.\r\n         *\r\n         * @name Phaser.Structs.List#parent\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * The objects that belong to this collection.\r\n         *\r\n         * @genericUse {T[]} - [$type]\r\n         *\r\n         * @name Phaser.Structs.List#list\r\n         * @type {Array.<*>}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.list = [];\r\n\r\n        /**\r\n         * The index of the current element.\r\n         *\r\n         * This is used internally when iterating through the list with the {@link #first}, {@link #last}, {@link #get}, and {@link #previous} properties.\r\n         *\r\n         * @name Phaser.Structs.List#position\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.position = 0;\r\n\r\n        /**\r\n         * A callback that is invoked every time a child is added to this list.\r\n         *\r\n         * @name Phaser.Structs.List#addCallback\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */\r\n        this.addCallback = NOOP;\r\n\r\n        /**\r\n         * A callback that is invoked every time a child is removed from this list.\r\n         *\r\n         * @name Phaser.Structs.List#removeCallback\r\n         * @type {function}\r\n         * @since 3.4.0\r\n         */\r\n        this.removeCallback = NOOP;\r\n\r\n        /**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.Structs.List#_sortKey\r\n         * @type {string}\r\n         * @since 3.4.0\r\n         */\r\n        this._sortKey = '';\r\n    },\r\n\r\n    /**\r\n     * Adds the given item to the end of the list. Each item must be unique.\r\n     *\r\n     * @method Phaser.Structs.List#add\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*|Array.<*>} child - The item, or array of items, to add to the list.\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.\r\n     *\r\n     * @return {*} The list's underlying array.\r\n     */\r\n    add: function (child, skipCallback)\r\n    {\r\n        if (skipCallback)\r\n        {\r\n            return ArrayUtils.Add(this.list, child);\r\n        }\r\n        else\r\n        {\r\n            return ArrayUtils.Add(this.list, child, 0, this.addCallback, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an item to list, starting at a specified index. Each item must be unique within the list.\r\n     *\r\n     * @method Phaser.Structs.List#addAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item, or array of items, to add to the list.\r\n     * @param {number} [index=0] - The index in the list at which the element(s) will be inserted.\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.addCallback if this child is added successfully.\r\n     *\r\n     * @return {*} The List's underlying array.\r\n     */\r\n    addAt: function (child, index, skipCallback)\r\n    {\r\n        if (skipCallback)\r\n        {\r\n            return ArrayUtils.AddAt(this.list, child, index);\r\n        }\r\n        else\r\n        {\r\n            return ArrayUtils.AddAt(this.list, child, index, 0, this.addCallback, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the item at a given position inside the List.\r\n     *\r\n     * @method Phaser.Structs.List#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {number} index - The index of the item.\r\n     *\r\n     * @return {*} The retrieved item, or `undefined` if it's outside the List's bounds.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.list[index];\r\n    },\r\n\r\n    /**\r\n     * Locates an item within the List and returns its index.\r\n     *\r\n     * @method Phaser.Structs.List#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child]\r\n     *\r\n     * @param {*} child - The item to locate.\r\n     *\r\n     * @return {number} The index of the item within the List, or -1 if it's not in the List.\r\n     */\r\n    getIndex: function (child)\r\n    {\r\n        //  Return -1 if given child isn't a child of this display list\r\n        return this.list.indexOf(child);\r\n    },\r\n\r\n    /**\r\n     * Sort the contents of this List so the items are in order based on the given property.\r\n     * For example, `sort('alpha')` would sort the List contents based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.Structs.List#sort\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [children,$return]\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */\r\n    sort: function (property, handler)\r\n    {\r\n        if (!property)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (handler === undefined)\r\n        {\r\n            handler = function (childA, childB)\r\n            {\r\n                return childA[property] - childB[property];\r\n            };\r\n        }\r\n\r\n        StableSort(this.list, handler);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Searches for the first instance of a child with its `name`\r\n     * property matching the given argument. Should more than one child have\r\n     * the same name only the first is returned.\r\n     *\r\n     * @method Phaser.Structs.List#getByName\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?*} The first child with a matching name, or null if none were found.\r\n     */\r\n    getByName: function (name)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, 'name', name);\r\n    },\r\n\r\n    /**\r\n     * Returns a random child from the group.\r\n     *\r\n     * @method Phaser.Structs.List#getRandom\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {number} [startIndex=0] - Offset from the front of the group (lowest child).\r\n     * @param {number} [length=(to top)] - Restriction on the number of values you want to randomly select from.\r\n     *\r\n     * @return {?*} A random child of this Group.\r\n     */\r\n    getRandom: function (startIndex, length)\r\n    {\r\n        return ArrayUtils.GetRandom(this.list, startIndex, length);\r\n    },\r\n\r\n    /**\r\n     * Returns the first element in a given part of the List which matches a specific criterion.\r\n     *\r\n     * @method Phaser.Structs.List#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T | null} - [$return]\r\n     *\r\n     * @param {string} property - The name of the property to test or a falsey value to have no criterion.\r\n     * @param {*} value - The value to test the `property` against, or `undefined` to allow any value and only check for existence.\r\n     * @param {number} [startIndex=0] - The position in the List to start the search at.\r\n     * @param {number} [endIndex] - The position in the List to optionally stop the search at. It won't be checked.\r\n     *\r\n     * @return {?*} The first item which matches the given criterion, or `null` if no such item exists.\r\n     */\r\n    getFirst: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns all children in this List.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('parent')` would return only children that have a property called `parent`.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     *\r\n     * `getAll('visible', true)` would return only children that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this List had 100 children,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 children in the List.\r\n     *\r\n     * @method Phaser.Structs.List#getAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @param {string} [property] - An optional property to test against the value argument.\r\n     * @param {*} [value] - If property is set then Child.property must strictly equal this value to be included in the results.\r\n     * @param {number} [startIndex] - The first child index to start the search from.\r\n     * @param {number} [endIndex] - The last child index to search up until.\r\n     *\r\n     * @return {Array.<*>} All items of the List which match the given criterion, if any.\r\n     */\r\n    getAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of items in the List which have a property matching the given value.\r\n     *\r\n     * @method Phaser.Structs.List#count\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {string} property - The property to test on each item.\r\n     * @param {*} value - The value to test the property against.\r\n     *\r\n     * @return {number} The total number of matching elements.\r\n     */\r\n    count: function (property, value)\r\n    {\r\n        return ArrayUtils.CountAllMatching(this.list, property, value);\r\n    },\r\n\r\n    /**\r\n     * Swaps the positions of two items in the list.\r\n     *\r\n     * @method Phaser.Structs.List#swap\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child1,child2]\r\n     *\r\n     * @param {*} child1 - The first item to swap.\r\n     * @param {*} child2 - The second item to swap.\r\n     */\r\n    swap: function (child1, child2)\r\n    {\r\n        ArrayUtils.Swap(this.list, child1, child2);\r\n    },\r\n\r\n    /**\r\n     * Moves an item in the List to a new position.\r\n     *\r\n     * @method Phaser.Structs.List#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item to move.\r\n     * @param {number} index - Moves an item in the List to a new position.\r\n     *\r\n     * @return {*} The item that was moved.\r\n     */\r\n    moveTo: function (child, index)\r\n    {\r\n        return ArrayUtils.MoveTo(this.list, child, index);\r\n    },\r\n\r\n    /**\r\n     * Moves the given array element above another one in the array.\r\n     *\r\n     * @method Phaser.Structs.List#moveAbove\r\n     * @since 3.55.0\r\n     *\r\n     * @genericUse {T} - [child1,child2]\r\n     *\r\n     * @param {*} child1 - The element to move above base element.\r\n     * @param {*} child2 - The base element.\r\n     */\r\n    moveAbove: function (child1, child2)\r\n    {\r\n        return ArrayUtils.MoveAbove(this.list, child1, child2);\r\n    },\r\n\r\n    /**\r\n     * Moves the given array element below another one in the array.\r\n     *\r\n     * @method Phaser.Structs.List#moveBelow\r\n     * @since 3.55.0\r\n     *\r\n     * @genericUse {T} - [child1,child2]\r\n     *\r\n     * @param {*} child1 - The element to move below base element.\r\n     * @param {*} child2 - The base element.\r\n     */\r\n    moveBelow: function (child1, child2)\r\n    {\r\n        return ArrayUtils.MoveBelow(this.list, child1, child2);\r\n    },\r\n\r\n    /**\r\n     * Removes one or many items from the List.\r\n     *\r\n     * @method Phaser.Structs.List#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item, or array of items, to remove.\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {*} The item, or array of items, which were successfully removed from the List.\r\n     */\r\n    remove: function (child, skipCallback)\r\n    {\r\n        if (skipCallback)\r\n        {\r\n            return ArrayUtils.Remove(this.list, child);\r\n        }\r\n        else\r\n        {\r\n            return ArrayUtils.Remove(this.list, child, this.removeCallback, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes the item at the given position in the List.\r\n     *\r\n     * @method Phaser.Structs.List#removeAt\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [$return]\r\n     *\r\n     * @param {number} index - The position to remove the item from.\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {*} The item that was removed.\r\n     */\r\n    removeAt: function (index, skipCallback)\r\n    {\r\n        if (skipCallback)\r\n        {\r\n            return ArrayUtils.RemoveAt(this.list, index);\r\n        }\r\n        else\r\n        {\r\n            return ArrayUtils.RemoveAt(this.list, index, this.removeCallback, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes the items within the given range in the List.\r\n     *\r\n     * @method Phaser.Structs.List#removeBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T[]} - [$return]\r\n     *\r\n     * @param {number} [startIndex=0] - The index to start removing from.\r\n     * @param {number} [endIndex] - The position to stop removing at. The item at this position won't be removed.\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {Array.<*>} An array of the items which were removed.\r\n     */\r\n    removeBetween: function (startIndex, endIndex, skipCallback)\r\n    {\r\n        if (skipCallback)\r\n        {\r\n            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex);\r\n        }\r\n        else\r\n        {\r\n            return ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeCallback, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes all the items.\r\n     *\r\n     * @method Phaser.Structs.List#removeAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     *\r\n     * @param {boolean} [skipCallback=false] - Skip calling the List.removeCallback.\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */\r\n    removeAll: function (skipCallback)\r\n    {\r\n        var i = this.list.length;\r\n\r\n        while (i--)\r\n        {\r\n            this.remove(this.list[i], skipCallback);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings the given child to the top of this List.\r\n     *\r\n     * @method Phaser.Structs.List#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item to bring to the top of the List.\r\n     *\r\n     * @return {*} The item which was moved.\r\n     */\r\n    bringToTop: function (child)\r\n    {\r\n        return ArrayUtils.BringToTop(this.list, child);\r\n    },\r\n\r\n    /**\r\n     * Sends the given child to the bottom of this List.\r\n     *\r\n     * @method Phaser.Structs.List#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item to send to the back of the list.\r\n     *\r\n     * @return {*} The item which was moved.\r\n     */\r\n    sendToBack: function (child)\r\n    {\r\n        return ArrayUtils.SendToBack(this.list, child);\r\n    },\r\n\r\n    /**\r\n     * Moves the given child up one place in this group unless it's already at the top.\r\n     *\r\n     * @method Phaser.Structs.List#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item to move up.\r\n     *\r\n     * @return {*} The item which was moved.\r\n     */\r\n    moveUp: function (child)\r\n    {\r\n        ArrayUtils.MoveUp(this.list, child);\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * Moves the given child down one place in this group unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.Structs.List#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child,$return]\r\n     *\r\n     * @param {*} child - The item to move down.\r\n     *\r\n     * @return {*} The item which was moved.\r\n     */\r\n    moveDown: function (child)\r\n    {\r\n        ArrayUtils.MoveDown(this.list, child);\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * Reverses the order of all children in this List.\r\n     *\r\n     * @method Phaser.Structs.List#reverse\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */\r\n    reverse: function ()\r\n    {\r\n        this.list.reverse();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the items in the list.\r\n     *\r\n     * @method Phaser.Structs.List#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.List.<T>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.List} This List object.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        ArrayUtils.Shuffle(this.list);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Replaces a child of this List with the given newChild. The newChild cannot be a member of this List.\r\n     *\r\n     * @method Phaser.Structs.List#replace\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [oldChild,newChild,$return]\r\n     *\r\n     * @param {*} oldChild - The child in this List that will be replaced.\r\n     * @param {*} newChild - The child to be inserted into this List.\r\n     *\r\n     * @return {*} Returns the oldChild that was replaced within this group.\r\n     */\r\n    replace: function (oldChild, newChild)\r\n    {\r\n        return ArrayUtils.Replace(this.list, oldChild, newChild);\r\n    },\r\n\r\n    /**\r\n     * Checks if an item exists within the List.\r\n     *\r\n     * @method Phaser.Structs.List#exists\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [child]\r\n     *\r\n     * @param {*} child - The item to check for the existence of.\r\n     *\r\n     * @return {boolean} `true` if the item is found in the list, otherwise `false`.\r\n     */\r\n    exists: function (child)\r\n    {\r\n        return (this.list.indexOf(child) > -1);\r\n    },\r\n\r\n    /**\r\n     * Sets the property `key` to the given value on all members of this List.\r\n     *\r\n     * @method Phaser.Structs.List#setAll\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {T} - [value]\r\n     *\r\n     * @param {string} property - The name of the property to set.\r\n     * @param {*} value - The value to set the property to.\r\n     * @param {number} [startIndex] - The first child index to start the search from.\r\n     * @param {number} [endIndex] - The last child index to search up until.\r\n     */\r\n    setAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all children to the given callback.\r\n     *\r\n     * @method Phaser.Structs.List#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachListCallback.<T>} - [callback]\r\n     *\r\n     * @param {EachListCallback} callback - The function to call.\r\n     * @param {*} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n\r\n        for (var i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < this.list.length; i++)\r\n        {\r\n            args[0] = this.list[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears the List and recreates its internal array.\r\n     *\r\n     * @method Phaser.Structs.List#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAll();\r\n\r\n        this.list = [];\r\n    },\r\n\r\n    /**\r\n     * Destroys this List.\r\n     *\r\n     * @method Phaser.Structs.List#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAll();\r\n\r\n        this.parent = null;\r\n        this.addCallback = null;\r\n        this.removeCallback = null;\r\n    },\r\n\r\n    /**\r\n     * The number of items inside the List.\r\n     *\r\n     * @name Phaser.Structs.List#length\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    length: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.list.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The first item in the List or `null` for an empty List.\r\n     *\r\n     * @name Phaser.Structs.List#first\r\n     * @genericUse {T} - [$type]\r\n     * @type {*}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    first: {\r\n\r\n        get: function ()\r\n        {\r\n            this.position = 0;\r\n\r\n            if (this.list.length > 0)\r\n            {\r\n                return this.list[0];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The last item in the List, or `null` for an empty List.\r\n     *\r\n     * @name Phaser.Structs.List#last\r\n     * @genericUse {T} - [$type]\r\n     * @type {*}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    last: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.list.length > 0)\r\n            {\r\n                this.position = this.list.length - 1;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The next item in the List, or `null` if the entire List has been traversed.\r\n     *\r\n     * This property can be read successively after reading {@link #first} or manually setting the {@link #position} to iterate the List.\r\n     *\r\n     * @name Phaser.Structs.List#next\r\n     * @genericUse {T} - [$type]\r\n     * @type {*}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    next: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position < this.list.length)\r\n            {\r\n                this.position++;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The previous item in the List, or `null` if the entire List has been traversed.\r\n     *\r\n     * This property can be read successively after reading {@link #last} or manually setting the {@link #position} to iterate the List backwards.\r\n     *\r\n     * @name Phaser.Structs.List#previous\r\n     * @genericUse {T} - [$type]\r\n     * @type {*}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    previous: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position > 0)\r\n            {\r\n                this.position--;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = List;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @callback EachMapCallback<E>\r\n *\r\n * @param {string} key - The key of the Map entry.\r\n * @param {E} entry - The value of the Map entry.\r\n *\r\n * @return {?boolean} The callback result.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * The keys of a Map can be arbitrary values.\r\n *\r\n * ```javascript\r\n * var map = new Map([\r\n *    [ 1, 'one' ],\r\n *    [ 2, 'two' ],\r\n *    [ 3, 'three' ]\r\n * ]);\r\n * ```\r\n *\r\n * @class Map\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @generic K\r\n * @generic V\r\n * @genericUse {V[]} - [elements]\r\n *\r\n * @param {Array.<*>} elements - An optional array of key-value pairs to populate this Map with.\r\n */\r\nvar Map = new Class({\r\n\r\n    initialize:\r\n\r\n    function Map (elements)\r\n    {\r\n        /**\r\n         * The entries in this Map.\r\n         *\r\n         * @genericUse {Object.<string, V>} - [$type]\r\n         *\r\n         * @name Phaser.Structs.Map#entries\r\n         * @type {Object.<string, *>}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.entries = {};\r\n\r\n        /**\r\n         * The number of key / value pairs in this Map.\r\n         *\r\n         * @name Phaser.Structs.Map#size\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.size = 0;\r\n\r\n        if (Array.isArray(elements))\r\n        {\r\n            for (var i = 0; i < elements.length; i++)\r\n            {\r\n                this.set(elements[i][0], elements[i][1]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds an element with a specified `key` and `value` to this Map.\r\n     * If the `key` already exists, the value will be replaced.\r\n     *\r\n     * @method Phaser.Structs.Map#set\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [value]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to be added to this Map.\r\n     * @param {*} value - The value of the element to be added to this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    set: function (key, value)\r\n    {\r\n        if (!this.has(key))\r\n        {\r\n            this.size++;\r\n        }\r\n\r\n        this.entries[key] = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the value associated to the `key`, or `undefined` if there is none.\r\n     *\r\n     * @method Phaser.Structs.Map#get\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {V} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to return from the `Map` object.\r\n     *\r\n     * @return {*} The element associated with the specified key or `undefined` if the key can't be found in this Map object.\r\n     */\r\n    get: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            return this.entries[key];\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all the values stored in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#getArray\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An array of the values stored in this Map.\r\n     */\r\n    getArray: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating whether an element with the specified key exists or not.\r\n     *\r\n     * @method Phaser.Structs.Map#has\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     *\r\n     * @param {string} key - The key of the element to test for presence of in this Map.\r\n     *\r\n     * @return {boolean} Returns `true` if an element with the specified key exists in this Map, otherwise `false`.\r\n     */\r\n    has: function (key)\r\n    {\r\n        return (this.entries.hasOwnProperty(key));\r\n    },\r\n\r\n    /**\r\n     * Delete the specified element from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#delete\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K} - [key]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {string} key - The key of the element to delete from this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    delete: function (key)\r\n    {\r\n        if (this.has(key))\r\n        {\r\n            delete this.entries[key];\r\n            this.size--;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delete all entries from this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        Object.keys(this.entries).forEach(function (prop)\r\n        {\r\n            delete this.entries[prop];\r\n\r\n        }, this);\r\n\r\n        this.size = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns all entries keys in this Map.\r\n     *\r\n     * @method Phaser.Structs.Map#keys\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {K[]} - [$return]\r\n     *\r\n     * @return {string[]} Array containing entries' keys.\r\n     */\r\n    keys: function ()\r\n    {\r\n        return Object.keys(this.entries);\r\n    },\r\n\r\n    /**\r\n     * Returns an `Array` of all entries.\r\n     *\r\n     * @method Phaser.Structs.Map#values\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V[]} - [$return]\r\n     *\r\n     * @return {Array.<*>} An `Array` of entries.\r\n     */\r\n    values: function ()\r\n    {\r\n        var output = [];\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            output.push(entries[key]);\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Dumps the contents of this Map to the console via `console.group`.\r\n     *\r\n     * @method Phaser.Structs.Map#dump\r\n     * @since 3.0.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var entries = this.entries;\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.group('Map');\r\n\r\n        for (var key in entries)\r\n        {\r\n            console.log(key, entries[key]);\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.groupEnd();\r\n    },\r\n\r\n    /**\r\n     * Iterates through all entries in this Map, passing each one to the given callback.\r\n     *\r\n     * If the callback returns `false`, the iteration will break.\r\n     *\r\n     * @method Phaser.Structs.Map#each\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {EachMapCallback.<V>} - [callback]\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [$return]\r\n     *\r\n     * @param {EachMapCallback} callback - The callback which will receive the keys and entries held in this Map.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    each: function (callback)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (callback(key, entries[key]) === false)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the value exists within this Map. Otherwise, returns `false`.\r\n     *\r\n     * @method Phaser.Structs.Map#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {V} - [value]\r\n     *\r\n     * @param {*} value - The value to search for.\r\n     *\r\n     * @return {boolean} `true` if the value is found, otherwise `false`.\r\n     */\r\n    contains: function (value)\r\n    {\r\n        var entries = this.entries;\r\n\r\n        for (var key in entries)\r\n        {\r\n            if (entries[key] === value)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Merges all new keys from the given Map into this one.\r\n     * If it encounters a key that already exists it will be skipped unless override is set to `true`.\r\n     *\r\n     * @method Phaser.Structs.Map#merge\r\n     * @since 3.0.0\r\n     *\r\n     * @genericUse {Phaser.Structs.Map.<K, V>} - [map,$return]\r\n     *\r\n     * @param {Phaser.Structs.Map} map - The Map to merge in to this Map.\r\n     * @param {boolean} [override=false] - Set to `true` to replace values in this Map with those from the source map, or `false` to skip them.\r\n     *\r\n     * @return {Phaser.Structs.Map} This Map object.\r\n     */\r\n    merge: function (map, override)\r\n    {\r\n        if (override === undefined) { override = false; }\r\n\r\n        var local = this.entries;\r\n        var source = map.entries;\r\n\r\n        for (var key in source)\r\n        {\r\n            if (local.hasOwnProperty(key) && override)\r\n            {\r\n                local[key] = source[key];\r\n            }\r\n            else\r\n            {\r\n                this.set(key, source[key]);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Map;\r\n","/**\r\n * @author       Vladimir Agafonkin\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar quickselect = require('../utils/array/QuickSelect');\r\n\r\n/**\r\n * @classdesc\r\n * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.\r\n * It's based on an optimized R-tree data structure with bulk insertion support.\r\n *\r\n * Spatial index is a special data structure for points and rectangles that allows you to perform queries like\r\n * \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items).\r\n *\r\n * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.\r\n * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.\r\n * \r\n * rbush is forked from https://github.com/mourner/rbush by Vladimir Agafonkin\r\n *\r\n * @class RTree\r\n * @memberof Phaser.Structs\r\n * @constructor\r\n * @since 3.0.0\r\n */\r\n\r\nfunction rbush (maxEntries)\r\n{\r\n    var format = [ '.left', '.top', '.right', '.bottom' ];\r\n\r\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\r\n\r\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\r\n    this._maxEntries = Math.max(4, maxEntries || 9);\r\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\r\n\r\n    this.clear();\r\n}\r\n\r\nrbush.prototype = {\r\n\r\n    all: function ()\r\n    {\r\n        return this._all(this.data, []);\r\n    },\r\n\r\n    search: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            result = [],\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return result;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf) result.push(child);\r\n                    else if (contains(bbox, childBBox)) this._all(child, result);\r\n                    else nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    collides: function (bbox)\r\n    {\r\n        var node = this.data,\r\n            toBBox = this.toBBox;\r\n\r\n        if (!intersects(bbox, node)) return false;\r\n\r\n        var nodesToSearch = [],\r\n            i, len, child, childBBox;\r\n\r\n        while (node) {\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n\r\n                child = node.children[i];\r\n                childBBox = node.leaf ? toBBox(child) : child;\r\n\r\n                if (intersects(bbox, childBBox)) {\r\n                    if (node.leaf || contains(bbox, childBBox)) return true;\r\n                    nodesToSearch.push(child);\r\n                }\r\n            }\r\n            node = nodesToSearch.pop();\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    load: function (data)\r\n    {\r\n        if (!(data && data.length)) return this;\r\n\r\n        if (data.length < this._minEntries) {\r\n            for (var i = 0, len = data.length; i < len; i++) {\r\n                this.insert(data[i]);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        // recursively build the tree with the given data from scratch using OMT algorithm\r\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\r\n\r\n        if (!this.data.children.length) {\r\n            // save as is if tree is empty\r\n            this.data = node;\r\n\r\n        } else if (this.data.height === node.height) {\r\n            // split root if trees have the same height\r\n            this._splitRoot(this.data, node);\r\n\r\n        } else {\r\n            if (this.data.height < node.height) {\r\n                // swap trees if inserted one is bigger\r\n                var tmpNode = this.data;\r\n                this.data = node;\r\n                node = tmpNode;\r\n            }\r\n\r\n            // insert the small tree into the large tree at appropriate level\r\n            this._insert(node, this.data.height - node.height - 1, true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    insert: function (item)\r\n    {\r\n        if (item) this._insert(item, this.data.height - 1);\r\n        return this;\r\n    },\r\n\r\n    clear: function ()\r\n    {\r\n        this.data = createNode([]);\r\n        return this;\r\n    },\r\n\r\n    remove: function (item, equalsFn)\r\n    {\r\n        if (!item) return this;\r\n\r\n        var node = this.data,\r\n            bbox = this.toBBox(item),\r\n            path = [],\r\n            indexes = [],\r\n            i, parent, index, goingUp;\r\n\r\n        // depth-first iterative tree traversal\r\n        while (node || path.length) {\r\n\r\n            if (!node) { // go up\r\n                node = path.pop();\r\n                parent = path[path.length - 1];\r\n                i = indexes.pop();\r\n                goingUp = true;\r\n            }\r\n\r\n            if (node.leaf) { // check current node\r\n                index = findItem(item, node.children, equalsFn);\r\n\r\n                if (index !== -1) {\r\n                    // item found, remove the item and condense tree upwards\r\n                    node.children.splice(index, 1);\r\n                    path.push(node);\r\n                    this._condense(path);\r\n                    return this;\r\n                }\r\n            }\r\n\r\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\r\n                path.push(node);\r\n                indexes.push(i);\r\n                i = 0;\r\n                parent = node;\r\n                node = node.children[0];\r\n\r\n            } else if (parent) { // go right\r\n                i++;\r\n                node = parent.children[i];\r\n                goingUp = false;\r\n\r\n            } else node = null; // nothing found\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    toBBox: function (item) { return item; },\r\n\r\n    compareMinX: compareNodeMinX,\r\n    compareMinY: compareNodeMinY,\r\n\r\n    toJSON: function () { return this.data; },\r\n\r\n    fromJSON: function (data)\r\n    {\r\n        this.data = data;\r\n        return this;\r\n    },\r\n\r\n    _all: function (node, result)\r\n    {\r\n        var nodesToSearch = [];\r\n        while (node) {\r\n            if (node.leaf) result.push.apply(result, node.children);\r\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\r\n\r\n            node = nodesToSearch.pop();\r\n        }\r\n        return result;\r\n    },\r\n\r\n    _build: function (items, left, right, height)\r\n    {\r\n        var N = right - left + 1,\r\n            M = this._maxEntries,\r\n            node;\r\n\r\n        if (N <= M) {\r\n            // reached leaf level; return leaf\r\n            node = createNode(items.slice(left, right + 1));\r\n            calcBBox(node, this.toBBox);\r\n            return node;\r\n        }\r\n\r\n        if (!height) {\r\n            // target height of the bulk-loaded tree\r\n            height = Math.ceil(Math.log(N) / Math.log(M));\r\n\r\n            // target number of root entries to maximize storage utilization\r\n            M = Math.ceil(N / Math.pow(M, height - 1));\r\n        }\r\n\r\n        node = createNode([]);\r\n        node.leaf = false;\r\n        node.height = height;\r\n\r\n        // split the items into M mostly square tiles\r\n\r\n        var N2 = Math.ceil(N / M),\r\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\r\n            i, j, right2, right3;\r\n\r\n        multiSelect(items, left, right, N1, this.compareMinX);\r\n\r\n        for (i = left; i <= right; i += N1) {\r\n\r\n            right2 = Math.min(i + N1 - 1, right);\r\n\r\n            multiSelect(items, i, right2, N2, this.compareMinY);\r\n\r\n            for (j = i; j <= right2; j += N2) {\r\n\r\n                right3 = Math.min(j + N2 - 1, right2);\r\n\r\n                // pack each entry recursively\r\n                node.children.push(this._build(items, j, right3, height - 1));\r\n            }\r\n        }\r\n\r\n        calcBBox(node, this.toBBox);\r\n\r\n        return node;\r\n    },\r\n\r\n    _chooseSubtree: function (bbox, node, level, path)\r\n    {\r\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\r\n\r\n        while (true) {\r\n            path.push(node);\r\n\r\n            if (node.leaf || path.length - 1 === level) break;\r\n\r\n            minArea = minEnlargement = Infinity;\r\n\r\n            for (i = 0, len = node.children.length; i < len; i++) {\r\n                child = node.children[i];\r\n                area = bboxArea(child);\r\n                enlargement = enlargedArea(bbox, child) - area;\r\n\r\n                // choose entry with the least area enlargement\r\n                if (enlargement < minEnlargement) {\r\n                    minEnlargement = enlargement;\r\n                    minArea = area < minArea ? area : minArea;\r\n                    targetNode = child;\r\n\r\n                } else if (enlargement === minEnlargement) {\r\n                    // otherwise choose one with the smallest area\r\n                    if (area < minArea) {\r\n                        minArea = area;\r\n                        targetNode = child;\r\n                    }\r\n                }\r\n            }\r\n\r\n            node = targetNode || node.children[0];\r\n        }\r\n\r\n        return node;\r\n    },\r\n\r\n    _insert: function (item, level, isNode)\r\n    {\r\n        var toBBox = this.toBBox,\r\n            bbox = isNode ? item : toBBox(item),\r\n            insertPath = [];\r\n\r\n        // find the best node for accommodating the item, saving all nodes along the path too\r\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\r\n\r\n        // put the item into the node\r\n        node.children.push(item);\r\n        extend(node, bbox);\r\n\r\n        // split on node overflow; propagate upwards if necessary\r\n        while (level >= 0) {\r\n            if (insertPath[level].children.length > this._maxEntries) {\r\n                this._split(insertPath, level);\r\n                level--;\r\n            } else break;\r\n        }\r\n\r\n        // adjust bboxes along the insertion path\r\n        this._adjustParentBBoxes(bbox, insertPath, level);\r\n    },\r\n\r\n    // split overflowed node into two\r\n    _split: function (insertPath, level)\r\n    {\r\n        var node = insertPath[level],\r\n            M = node.children.length,\r\n            m = this._minEntries;\r\n\r\n        this._chooseSplitAxis(node, m, M);\r\n\r\n        var splitIndex = this._chooseSplitIndex(node, m, M);\r\n\r\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\r\n        newNode.height = node.height;\r\n        newNode.leaf = node.leaf;\r\n\r\n        calcBBox(node, this.toBBox);\r\n        calcBBox(newNode, this.toBBox);\r\n\r\n        if (level) insertPath[level - 1].children.push(newNode);\r\n        else this._splitRoot(node, newNode);\r\n    },\r\n\r\n    _splitRoot: function (node, newNode)\r\n    {\r\n        // split root node\r\n        this.data = createNode([node, newNode]);\r\n        this.data.height = node.height + 1;\r\n        this.data.leaf = false;\r\n        calcBBox(this.data, this.toBBox);\r\n    },\r\n\r\n    _chooseSplitIndex: function (node, m, M)\r\n    {\r\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\r\n\r\n        minOverlap = minArea = Infinity;\r\n\r\n        for (i = m; i <= M - m; i++) {\r\n            bbox1 = distBBox(node, 0, i, this.toBBox);\r\n            bbox2 = distBBox(node, i, M, this.toBBox);\r\n\r\n            overlap = intersectionArea(bbox1, bbox2);\r\n            area = bboxArea(bbox1) + bboxArea(bbox2);\r\n\r\n            // choose distribution with minimum overlap\r\n            if (overlap < minOverlap) {\r\n                minOverlap = overlap;\r\n                index = i;\r\n\r\n                minArea = area < minArea ? area : minArea;\r\n\r\n            } else if (overlap === minOverlap) {\r\n                // otherwise choose distribution with minimum area\r\n                if (area < minArea) {\r\n                    minArea = area;\r\n                    index = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    },\r\n\r\n    // sorts node children by the best axis for split\r\n    _chooseSplitAxis: function (node, m, M)\r\n    {\r\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\r\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\r\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\r\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\r\n\r\n        // if total distributions margin value is minimal for x, sort by minX,\r\n        // otherwise it's already sorted by minY\r\n        if (xMargin < yMargin) node.children.sort(compareMinX);\r\n    },\r\n\r\n    // total margin of all possible split distributions where each node is at least m full\r\n    _allDistMargin: function (node, m, M, compare)\r\n    {\r\n        node.children.sort(compare);\r\n\r\n        var toBBox = this.toBBox,\r\n            leftBBox = distBBox(node, 0, m, toBBox),\r\n            rightBBox = distBBox(node, M - m, M, toBBox),\r\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\r\n            i, child;\r\n\r\n        for (i = m; i < M - m; i++) {\r\n            child = node.children[i];\r\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(leftBBox);\r\n        }\r\n\r\n        for (i = M - m - 1; i >= m; i--) {\r\n            child = node.children[i];\r\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\r\n            margin += bboxMargin(rightBBox);\r\n        }\r\n\r\n        return margin;\r\n    },\r\n\r\n    _adjustParentBBoxes: function (bbox, path, level)\r\n    {\r\n        // adjust bboxes along the given tree path\r\n        for (var i = level; i >= 0; i--) {\r\n            extend(path[i], bbox);\r\n        }\r\n    },\r\n\r\n    _condense: function (path)\r\n    {\r\n        // go through the path, removing empty nodes and updating bboxes\r\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\r\n            if (path[i].children.length === 0) {\r\n                if (i > 0) {\r\n                    siblings = path[i - 1].children;\r\n                    siblings.splice(siblings.indexOf(path[i]), 1);\r\n\r\n                } else this.clear();\r\n\r\n            } else calcBBox(path[i], this.toBBox);\r\n        }\r\n    },\r\n\r\n    compareMinX: function (a, b)\r\n    {\r\n        return a.left - b.left;\r\n    },\r\n\r\n    compareMinY: function (a, b)\r\n    {\r\n        return a.top - b.top;\r\n    },\r\n\r\n    toBBox: function (a)\r\n    {\r\n        return {\r\n            minX: a.left,\r\n            minY: a.top,\r\n            maxX: a.right,\r\n            maxY: a.bottom\r\n        };\r\n    }\r\n};\r\n\r\nfunction findItem (item, items, equalsFn)\r\n{\r\n    if (!equalsFn) return items.indexOf(item);\r\n\r\n    for (var i = 0; i < items.length; i++) {\r\n        if (equalsFn(item, items[i])) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n// calculate node's bbox from bboxes of its children\r\nfunction calcBBox (node, toBBox)\r\n{\r\n    distBBox(node, 0, node.children.length, toBBox, node);\r\n}\r\n\r\n// min bounding rectangle of node children from k to p-1\r\nfunction distBBox (node, k, p, toBBox, destNode)\r\n{\r\n    if (!destNode) destNode = createNode(null);\r\n    destNode.minX = Infinity;\r\n    destNode.minY = Infinity;\r\n    destNode.maxX = -Infinity;\r\n    destNode.maxY = -Infinity;\r\n\r\n    for (var i = k, child; i < p; i++) {\r\n        child = node.children[i];\r\n        extend(destNode, node.leaf ? toBBox(child) : child);\r\n    }\r\n\r\n    return destNode;\r\n}\r\n\r\nfunction extend (a, b)\r\n{\r\n    a.minX = Math.min(a.minX, b.minX);\r\n    a.minY = Math.min(a.minY, b.minY);\r\n    a.maxX = Math.max(a.maxX, b.maxX);\r\n    a.maxY = Math.max(a.maxY, b.maxY);\r\n    return a;\r\n}\r\n\r\nfunction compareNodeMinX (a, b) { return a.minX - b.minX; }\r\nfunction compareNodeMinY (a, b) { return a.minY - b.minY; }\r\n\r\nfunction bboxArea (a) { return (a.maxX - a.minX) * (a.maxY - a.minY); }\r\nfunction bboxMargin (a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\r\n\r\nfunction enlargedArea (a, b)\r\n{\r\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\r\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\r\n}\r\n\r\nfunction intersectionArea (a, b)\r\n{\r\n    var minX = Math.max(a.minX, b.minX),\r\n        minY = Math.max(a.minY, b.minY),\r\n        maxX = Math.min(a.maxX, b.maxX),\r\n        maxY = Math.min(a.maxY, b.maxY);\r\n\r\n    return Math.max(0, maxX - minX) *\r\n           Math.max(0, maxY - minY);\r\n}\r\n\r\nfunction contains (a, b)\r\n{\r\n    return a.minX <= b.minX &&\r\n           a.minY <= b.minY &&\r\n           b.maxX <= a.maxX &&\r\n           b.maxY <= a.maxY;\r\n}\r\n\r\nfunction intersects (a, b)\r\n{\r\n    return b.minX <= a.maxX &&\r\n           b.minY <= a.maxY &&\r\n           b.maxX >= a.minX &&\r\n           b.maxY >= a.minY;\r\n}\r\n\r\nfunction createNode (children)\r\n{\r\n    return {\r\n        children: children,\r\n        height: 1,\r\n        leaf: true,\r\n        minX: Infinity,\r\n        minY: Infinity,\r\n        maxX: -Infinity,\r\n        maxY: -Infinity\r\n    };\r\n}\r\n\r\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\r\n// combines selection algorithm with binary divide & conquer approach\r\n\r\nfunction multiSelect (arr, left, right, n, compare)\r\n{\r\n    var stack = [left, right],\r\n        mid;\r\n\r\n    while (stack.length)\r\n    {\r\n        right = stack.pop();\r\n        left = stack.pop();\r\n\r\n        if (right - left <= n) continue;\r\n\r\n        mid = left + Math.ceil((right - left) / n / 2) * n;\r\n        quickselect(arr, mid, left, right, compare);\r\n\r\n        stack.push(left, mid, mid, right);\r\n    }\r\n}\r\n\r\nmodule.exports = rbush;","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Structs\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Events: require('./events'),\r\n    List: require('./List'),\r\n    Map: require('./Map'),\r\n    ProcessQueue: require('./ProcessQueue'),\r\n    RTree: require('./RTree'),\r\n    Set: require('./Set'),\r\n    Size: require('./Size')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Searches a pre-sorted array for the closet value to the given number.\r\n *\r\n * If the `key` argument is given it will assume the array contains objects that all have the required `key` property name,\r\n * and will check for the closest value of those to the given number.\r\n *\r\n * @function Phaser.Utils.Array.FindClosestInSorted\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to search for in the array.\r\n * @param {array} array - The array to search, which must be sorted.\r\n * @param {string} [key] - An optional property key. If specified the array elements property will be checked against value.\r\n *\r\n * @return {(number|any)} The nearest value found in the array, or if a `key` was given, the nearest object with the matching property value.\r\n */\r\nvar FindClosestInSorted = function (value, array, key)\r\n{\r\n    if (!array.length)\r\n    {\r\n        return NaN;\r\n    }\r\n    else if (array.length === 1)\r\n    {\r\n        return array[0];\r\n    }\r\n\r\n    var i = 1;\r\n    var low;\r\n    var high;\r\n\r\n    if (key)\r\n    {\r\n        if (value < array[0][key])\r\n        {\r\n            return array[0];\r\n        }\r\n\r\n        while (array[i][key] < value)\r\n        {\r\n            i++;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        while (array[i] < value)\r\n        {\r\n            i++;\r\n        }\r\n    }\r\n\r\n    if (i > array.length)\r\n    {\r\n        i = array.length;\r\n    }\r\n\r\n    if (key)\r\n    {\r\n        low = array[i - 1][key];\r\n        high = array[i][key];\r\n\r\n        return ((high - value) <= (value - low)) ? array[i] : array[i - 1];\r\n    }\r\n    else\r\n    {\r\n        low = array[i - 1];\r\n        high = array[i];\r\n\r\n        return ((high - value) <= (value - low)) ? high : low;\r\n    }\r\n};\r\n\r\nmodule.exports = FindClosestInSorted;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SpliceOne = require('./SpliceOne');\r\n\r\n/**\r\n * Removes the given item, or array of items, from the array.\r\n *\r\n * The array is modified in-place.\r\n *\r\n * You can optionally specify a callback to be invoked for each item successfully removed from the array.\r\n *\r\n * @function Phaser.Utils.Array.Remove\r\n * @since 3.4.0\r\n *\r\n * @param {array} array - The array to be modified.\r\n * @param {*|Array.<*>} item - The item, or array of items, to be removed from the array.\r\n * @param {function} [callback] - A callback to be invoked for each item successfully removed from the array.\r\n * @param {object} [context] - The context in which the callback is invoked.\r\n *\r\n * @return {*|Array.<*>} The item, or array of items, that were successfully removed from the array.\r\n */\r\nvar Remove = function (array, item, callback, context)\r\n{\r\n    if (context === undefined) { context = array; }\r\n\r\n    var index;\r\n\r\n    //  Fast path to avoid array mutation and iteration\r\n    if (!Array.isArray(item))\r\n    {\r\n        index = array.indexOf(item);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, item);\r\n            }\r\n\r\n            return item;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    //  If we got this far, we have an array of items to remove\r\n\r\n    var itemLength = item.length - 1;\r\n    var removed = [];\r\n\r\n    while (itemLength >= 0)\r\n    {\r\n        var entry = item[itemLength];\r\n\r\n        index = array.indexOf(entry);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(array, index);\r\n\r\n            removed.push(entry);\r\n\r\n            if (callback)\r\n            {\r\n                callback.call(context, entry);\r\n            }\r\n        }\r\n\r\n        itemLength--;\r\n    }\r\n\r\n    return removed;\r\n};\r\n\r\nmodule.exports = Remove;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Moves the element at the start of the array to the end, shifting all items in the process.\r\n * The \"rotation\" happens to the left.\r\n *\r\n * @function Phaser.Utils.Array.RotateLeft\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the left. This array is modified in place.\r\n * @param {number} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */\r\nvar RotateLeft = function (array, total)\r\n{\r\n    if (total === undefined) { total = 1; }\r\n\r\n    var element = null;\r\n\r\n    for (var i = 0; i < total; i++)\r\n    {\r\n        element = array.shift();\r\n        array.push(element);\r\n    }\r\n\r\n    return element;\r\n};\r\n\r\nmodule.exports = RotateLeft;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Moves the element at the end of the array to the start, shifting all items in the process.\r\n * The \"rotation\" happens to the right.\r\n *\r\n * @function Phaser.Utils.Array.RotateRight\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to shift to the right. This array is modified in place.\r\n * @param {number} [total=1] - The number of times to shift the array.\r\n *\r\n * @return {*} The most recently shifted element.\r\n */\r\nvar RotateRight = function (array, total)\r\n{\r\n    if (total === undefined) { total = 1; }\r\n\r\n    var element = null;\r\n\r\n    for (var i = 0; i < total; i++)\r\n    {\r\n        element = array.pop();\r\n        array.unshift(element);\r\n    }\r\n\r\n    return element;\r\n};\r\n\r\nmodule.exports = RotateRight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Shuffles the contents of the given array using the Fisher-Yates implementation.\r\n *\r\n * The original array is modified directly and returned.\r\n *\r\n * @function Phaser.Utils.Array.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @generic T\r\n * @genericUse {T[]} - [array,$return]\r\n *\r\n * @param {T[]} array - The array to shuffle. This array is modified in place.\r\n *\r\n * @return {T[]} The shuffled array.\r\n */\r\nvar Shuffle = function (array)\r\n{\r\n    for (var i = array.length - 1; i > 0; i--)\r\n    {\r\n        var j = Math.floor(Math.random() * (i + 1));\r\n        var temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n\r\n    return array;\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Takes the given array and runs a numeric sort on it, ignoring any non-digits that\n * may be in the entries.\n *\n * You should only run this on arrays containing strings.\n *\n * @function Phaser.Utils.Array.SortByDigits\n * @since 3.50.0\n *\n * @param {string[]} array - The input array of strings.\n *\n * @return {string[]} The sorted input array.\n */\nvar SortByDigits = function (array)\n{\n    var re = /\\D/g;\n\n    array.sort(function (a, b)\n    {\n        return (parseInt(a.replace(re, ''), 10) - parseInt(b.replace(re, ''), 10));\n    });\n\n    return array;\n};\n\nmodule.exports = SortByDigits;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Removes a single item from an array and returns it without creating gc, like the native splice does.\r\n * Based on code by Mike Reinstein.\r\n *\r\n * @function Phaser.Utils.Array.SpliceOne\r\n * @since 3.0.0\r\n *\r\n * @param {array} array - The array to splice from.\r\n * @param {number} index - The index of the item which should be spliced.\r\n *\r\n * @return {*} The item which was spliced (removed).\r\n */\r\nvar SpliceOne = function (array, index)\r\n{\r\n    if (index >= array.length)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var len = array.length - 1;\r\n\r\n    var item = array[index];\r\n\r\n    for (var i = index; i < len; i++)\r\n    {\r\n        array[i] = array[i + 1];\r\n    }\r\n\r\n    array.length = len;\r\n\r\n    return item;\r\n};\r\n\r\nmodule.exports = SpliceOne;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Source object\r\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\r\n//  The default value to use if the key doesn't exist\r\n\r\n/**\r\n * Retrieves a value from an object.\r\n *\r\n * @function Phaser.Utils.Objects.GetValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to retrieve the value from.\r\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\r\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\r\n *\r\n * @return {*} The value of the requested key.\r\n */\r\nvar GetValue = function (source, key, defaultValue)\r\n{\r\n    if (!source || typeof source === 'number')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key))\r\n    {\r\n        return source[key];\r\n    }\r\n    else if (key.indexOf('.') !== -1)\r\n    {\r\n        var keys = key.split('.');\r\n        var parent = source;\r\n        var value = defaultValue;\r\n\r\n        //  Use for loop here so we can break early\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            if (parent.hasOwnProperty(keys[i]))\r\n            {\r\n                //  Yes it has a key property, let's carry on down\r\n                value = parent[keys[i]];\r\n\r\n                parent = parent[keys[i]];\r\n            }\r\n            else\r\n            {\r\n                //  Can't go any further, so reset to default\r\n                value = defaultValue;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetValue;\r\n"],"names":["has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","event","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","concat","listeners","handlers","i","l","length","ee","Array","listenerCount","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","module","exports","value","min","max","Math","ceil","floor","gap","start","divide","ArrayUtils","Class","NOOP","StableSort","List","initialize","parent","list","position","addCallback","removeCallback","_sortKey","add","child","skipCallback","Add","addAt","index","AddAt","getAt","getIndex","indexOf","sort","property","handler","childA","childB","getByName","GetFirst","getRandom","startIndex","GetRandom","getFirst","endIndex","getAll","GetAll","count","CountAllMatching","swap","child1","child2","Swap","moveTo","MoveTo","moveAbove","MoveAbove","moveBelow","MoveBelow","remove","Remove","removeAt","RemoveAt","removeBetween","RemoveBetween","removeAll","bringToTop","BringToTop","sendToBack","SendToBack","moveUp","MoveUp","moveDown","MoveDown","reverse","shuffle","Shuffle","replace","oldChild","newChild","Replace","exists","setAll","SetAll","each","callback","shutdown","destroy","get","first","last","next","previous","Map","elements","entries","size","isArray","set","key","getArray","output","delete","clear","keys","forEach","prop","values","dump","console","group","log","groupEnd","contains","merge","map","override","local","source","quickselect","rbush","maxEntries","_maxEntries","_minEntries","findItem","item","items","equalsFn","calcBBox","node","toBBox","distBBox","children","k","p","destNode","createNode","minX","Infinity","minY","maxX","maxY","extend","leaf","a","b","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","height","multiSelect","arr","left","right","n","compare","mid","stack","pop","all","_all","data","search","bbox","result","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","N","M","pow","right2","right3","N2","N1","sqrt","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","top","bottom","ProcessQueue","RTree","Set","Size","array","NaN","low","high","SpliceOne","itemLength","removed","entry","total","element","shift","unshift","random","temp","re","parseInt","defaultValue","split"],"sourceRoot":""}