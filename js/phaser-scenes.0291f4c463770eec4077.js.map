{"version":3,"file":"js/phaser-scenes.0291f4c463770eec4077.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/BLUR_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/BOOT_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/CONTEXT_LOST_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/CONTEXT_RESTORED_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/DESTROY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/FOCUS_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/HIDDEN_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/PAUSE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/POST_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/POST_STEP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/PRE_RENDER_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/PRE_STEP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/READY_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/RESUME_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/STEP_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/VISIBLE_EVENT.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/core/events/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/math/Clamp.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/plugins/PluginCache.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/ScenePlugin.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/scene/index.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/Class.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/NOOP.js","webpack://@agogpixel/phaser3-demo/./node_modules/phaser/src/utils/object/GetFastValue.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Blur Event.\r\n * \r\n * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\r\n * enters a blurred state. The blur event is raised when the window loses focus. This can happen if a user swaps\r\n * tab, or if they simply remove focus from the browser to another app.\r\n *\r\n * @event Phaser.Core.Events#BLUR\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'blur';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Boot Event.\r\n * \r\n * This event is dispatched when the Phaser Game instance has finished booting, but before it is ready to start running.\r\n * The global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.\r\n *\r\n * @event Phaser.Core.Events#BOOT\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'boot';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Context Lost Event.\r\n * \r\n * This event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Lost event from the browser.\r\n * \r\n * The partner event is `CONTEXT_RESTORED`.\r\n *\r\n * @event Phaser.Core.Events#CONTEXT_LOST\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'contextlost';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Context Restored Event.\r\n * \r\n * This event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Restored event from the browser.\r\n * \r\n * The partner event is `CONTEXT_LOST`.\r\n *\r\n * @event Phaser.Core.Events#CONTEXT_RESTORED\r\n * @since 3.19.0\r\n */\r\nmodule.exports = 'contextrestored';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Destroy Event.\r\n * \r\n * This event is dispatched when the game instance has been told to destroy itself.\r\n * Lots of internal systems listen to this event in order to clear themselves out.\r\n * Custom plugins and game code should also do the same.\r\n *\r\n * @event Phaser.Core.Events#DESTROY\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'destroy';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Focus Event.\r\n * \r\n * This event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\r\n * enters a focused state. The focus event is raised when the window re-gains focus, having previously lost it.\r\n *\r\n * @event Phaser.Core.Events#FOCUS\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'focus';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Hidden Event.\r\n * \r\n * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\r\n * enters a hidden state. Only browsers that support the Visibility API will cause this event to be emitted.\r\n * \r\n * In most modern browsers, when the document enters a hidden state, the Request Animation Frame and setTimeout, which\r\n * control the main game loop, will automatically pause. There is no way to stop this from happening. It is something\r\n * your game should account for in its own code, should the pause be an issue (i.e. for multiplayer games)\r\n *\r\n * @event Phaser.Core.Events#HIDDEN\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'hidden';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Pause Event.\r\n * \r\n * This event is dispatched when the Game loop enters a paused state, usually as a result of the Visibility Handler.\r\n *\r\n * @event Phaser.Core.Events#PAUSE\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'pause';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Post-Render Event.\r\n * \r\n * This event is dispatched right at the end of the render process.\r\n * \r\n * Every Scene will have rendered and been drawn to the canvas by the time this event is fired.\r\n * Use it for any last minute post-processing before the next game step begins.\r\n *\r\n * @event Phaser.Core.Events#POST_RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer being used by the Game instance.\r\n */\r\nmodule.exports = 'postrender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Post-Step Event.\r\n * \r\n * This event is dispatched after the Scene Manager has updated.\r\n * Hook into it from plugins or systems that need to do things before the render starts.\r\n *\r\n * @event Phaser.Core.Events#POST_STEP\r\n * @since 3.0.0\r\n * \r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'poststep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Pre-Render Event.\r\n * \r\n * This event is dispatched immediately before any of the Scenes have started to render.\r\n * \r\n * The renderer will already have been initialized this frame, clearing itself and preparing to receive the Scenes for rendering, but it won't have actually drawn anything yet.\r\n *\r\n * @event Phaser.Core.Events#PRE_RENDER\r\n * @since 3.0.0\r\n * \r\n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - A reference to the current renderer being used by the Game instance.\r\n */\r\nmodule.exports = 'prerender';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Pre-Step Event.\r\n * \r\n * This event is dispatched before the main Game Step starts. By this point in the game cycle none of the Scene updates have yet happened.\r\n * Hook into it from plugins or systems that need to update before the Scene Manager does.\r\n *\r\n * @event Phaser.Core.Events#PRE_STEP\r\n * @since 3.0.0\r\n * \r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'prestep';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Ready Event.\r\n * \r\n * This event is dispatched when the Phaser Game instance has finished booting, the Texture Manager is fully ready,\r\n * and all local systems are now able to start.\r\n *\r\n * @event Phaser.Core.Events#READY\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'ready';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Resume Event.\r\n * \r\n * This event is dispatched when the game loop leaves a paused state and resumes running.\r\n *\r\n * @event Phaser.Core.Events#RESUME\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'resume';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Step Event.\r\n * \r\n * This event is dispatched after the Game Pre-Step and before the Scene Manager steps.\r\n * Hook into it from plugins or systems that need to update before the Scene Manager does, but after the core Systems have.\r\n *\r\n * @event Phaser.Core.Events#STEP\r\n * @since 3.0.0\r\n * \r\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n */\r\nmodule.exports = 'step';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Game Visible Event.\r\n * \r\n * This event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\r\n * enters a visible state, previously having been hidden.\r\n * \r\n * Only browsers that support the Visibility API will cause this event to be emitted.\r\n *\r\n * @event Phaser.Core.Events#VISIBLE\r\n * @since 3.0.0\r\n */\r\nmodule.exports = 'visible';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Core.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BLUR: require('./BLUR_EVENT'),\r\n    BOOT: require('./BOOT_EVENT'),\r\n    CONTEXT_LOST: require('./CONTEXT_LOST_EVENT'),\r\n    CONTEXT_RESTORED: require('./CONTEXT_RESTORED_EVENT'),\r\n    DESTROY: require('./DESTROY_EVENT'),\r\n    FOCUS: require('./FOCUS_EVENT'),\r\n    HIDDEN: require('./HIDDEN_EVENT'),\r\n    PAUSE: require('./PAUSE_EVENT'),\r\n    POST_RENDER: require('./POST_RENDER_EVENT'),\r\n    POST_STEP: require('./POST_STEP_EVENT'),\r\n    PRE_RENDER: require('./PRE_RENDER_EVENT'),\r\n    PRE_STEP: require('./PRE_STEP_EVENT'),\r\n    READY: require('./READY_EVENT'),\r\n    RESUME: require('./RESUME_EVENT'),\r\n    STEP: require('./STEP_EVENT'),\r\n    VISIBLE: require('./VISIBLE_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\r\n *\r\n * @function Phaser.Math.Clamp\r\n * @since 3.0.0\r\n *\r\n * @param {number} value - The value to be clamped.\r\n * @param {number} min - The minimum bounds.\r\n * @param {number} max - The maximum bounds.\r\n *\r\n * @return {number} The clamped value.\r\n */\r\nvar Clamp = function (value, min, max)\r\n{\r\n    return Math.max(min, Math.min(max, value));\r\n};\r\n\r\nmodule.exports = Clamp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar corePlugins = {};\r\n\r\n//  Contains the plugins that the dev has loaded into their game\r\n//  These are the source objects, not instantiated.\r\nvar customPlugins = {};\r\n\r\nvar PluginCache = {};\r\n\r\n/**\r\n * @namespace Phaser.Plugins.PluginCache\r\n */\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @method Phaser.Plugins.PluginCache.register\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {boolean} [custom=false] - Core Scene plugin or a Custom Scene plugin?\r\n */\r\nPluginCache.register = function (key, plugin, mapping, custom)\r\n{\r\n    if (custom === undefined) { custom = false; }\r\n\r\n    corePlugins[key] = { plugin: plugin, mapping: mapping, custom: custom };\r\n};\r\n\r\n/**\r\n * Stores a custom plugin in the global plugin cache.\r\n * The key must be unique, within the scope of the cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.registerCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Scene Systems, this is the property key map used.\r\n * @param {?any} data - A value to be passed to the plugin's `init` method.\r\n */\r\nPluginCache.registerCustom = function (key, plugin, mapping, data)\r\n{\r\n    customPlugins[key] = { plugin: plugin, mapping: mapping, data: data };\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the core plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the core cache, otherwise `false`.\r\n */\r\nPluginCache.hasCore = function (key)\r\n{\r\n    return corePlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Checks if the given key is already being used in the custom plugin cache.\r\n *\r\n * @method Phaser.Plugins.PluginCache.hasCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key to check for.\r\n *\r\n * @return {boolean} `true` if the key is already in use in the custom cache, otherwise `false`.\r\n */\r\nPluginCache.hasCustom = function (key)\r\n{\r\n    return customPlugins.hasOwnProperty(key);\r\n};\r\n\r\n/**\r\n * Returns the core plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCore\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CorePluginContainer} The core plugin object.\r\n */\r\nPluginCache.getCore = function (key)\r\n{\r\n    return corePlugins[key];\r\n};\r\n\r\n/**\r\n * Returns the custom plugin object from the cache based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {Phaser.Types.Plugins.CustomPluginContainer} The custom plugin object.\r\n */\r\nPluginCache.getCustom = function (key)\r\n{\r\n    return customPlugins[key];\r\n};\r\n\r\n/**\r\n * Returns an object from the custom cache based on the given key that can be instantiated.\r\n *\r\n * @method Phaser.Plugins.PluginCache.getCustomClass\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to get.\r\n *\r\n * @return {function} The custom plugin object.\r\n */\r\nPluginCache.getCustomClass = function (key)\r\n{\r\n    return (customPlugins.hasOwnProperty(key)) ? customPlugins[key].plugin : null;\r\n};\r\n\r\n/**\r\n * Removes a core plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.remove\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the core plugin to remove.\r\n */\r\nPluginCache.remove = function (key)\r\n{\r\n    if (corePlugins.hasOwnProperty(key))\r\n    {\r\n        delete corePlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes a custom plugin based on the given key.\r\n *\r\n * @method Phaser.Plugins.PluginCache.removeCustom\r\n * @since 3.8.0\r\n * \r\n * @param {string} key - The key of the custom plugin to remove.\r\n */\r\nPluginCache.removeCustom = function (key)\r\n{\r\n    if (customPlugins.hasOwnProperty(key))\r\n    {\r\n        delete customPlugins[key];\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Core Plugins.\r\n * \r\n * This includes all of the internal system plugins that Phaser needs, like the Input Plugin and Loader Plugin.\r\n * So be sure you only call this if you do not wish to run Phaser again.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCorePlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCorePlugins = function ()\r\n{\r\n    for (var key in corePlugins)\r\n    {\r\n        if (corePlugins.hasOwnProperty(key))\r\n        {\r\n            delete corePlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes all Custom Plugins.\r\n *\r\n * @method Phaser.Plugins.PluginCache.destroyCustomPlugins\r\n * @since 3.12.0\r\n */\r\nPluginCache.destroyCustomPlugins = function ()\r\n{\r\n    for (var key in customPlugins)\r\n    {\r\n        if (customPlugins.hasOwnProperty(key))\r\n        {\r\n            delete customPlugins[key];\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = PluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Clamp = require('../math/Clamp');\r\nvar Class = require('../utils/Class');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Plugin is the main interface to the Scene Manager and allows you to control\r\n * any Scene running in your game. You should always use this plugin. By default, it is\r\n * mapped to the Scene property `this.scene`. Meaning, from within a Scene, you can call\r\n * methods such as `this.scene.start()`.\r\n *\r\n * Note that nearly all methods in this class are run on a queue-basis and not\r\n * immediately. For example, calling `this.scene.launch('SceneB')` will try to\r\n * launch SceneB when the Scene Manager next updates, which is at the start of the game\r\n * step. All operations are queued and run in the order in which they are invoked here.\r\n *\r\n * @class ScenePlugin\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this ScenePlugin belongs to.\r\n */\r\nvar ScenePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function ScenePlugin (scene)\r\n    {\r\n        /**\r\n         * The Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene Systems instance of the Scene that this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The settings of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * The key of the Scene this ScenePlugin belongs to.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = scene.sys.settings.key;\r\n\r\n        /**\r\n         * The Game's SceneManager.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#manager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.scene;\r\n\r\n        /**\r\n         * If this Scene is currently transitioning to another, this holds\r\n         * the current percentage of the transition progress, between 0 and 1.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#transitionProgress\r\n         * @type {number}\r\n         * @since 3.5.0\r\n         */\r\n        this.transitionProgress = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_elapsed\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._elapsed = 0;\r\n\r\n        /**\r\n         * Transition elapsed timer.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_target\r\n         * @type {?Phaser.Scenes.Scene}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._target = null;\r\n\r\n        /**\r\n         * Transition duration.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_duration\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._duration = 0;\r\n\r\n        /**\r\n         * Transition callback.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdate\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdate;\r\n\r\n        /**\r\n         * Transition callback scope.\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_onUpdateScope\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._onUpdateScope;\r\n\r\n        /**\r\n         * Will this Scene sleep (true) after the transition, or stop (false)\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willSleep\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willSleep = false;\r\n\r\n        /**\r\n         * Will this Scene be removed from the Scene Manager after the transition completes?\r\n         *\r\n         * @name Phaser.Scenes.ScenePlugin#_willRemove\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.5.0\r\n         */\r\n        this._willRemove = false;\r\n\r\n        scene.sys.events.once(Events.BOOT, this.boot, this);\r\n        scene.sys.events.on(Events.START, this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#boot\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(Events.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this._target = null;\r\n\r\n        this.systems.events.once(Events.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Shutdown this Scene and run the given one.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to start.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', this.key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restarts this Scene.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#restart\r\n     * @since 3.4.0\r\n     *\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    restart: function (data)\r\n    {\r\n        var key = this.key;\r\n\r\n        this.manager.queueOp('stop', key);\r\n        this.manager.queueOp('start', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This will start a transition from the current Scene to the target Scene given.\r\n     *\r\n     * The transition will last for the duration specified in milliseconds.\r\n     *\r\n     * You can have the target Scene moved above or below this one in the display list.\r\n     *\r\n     * You can specify an update callback. This callback will be invoked _every frame_ for the duration\r\n     * of the transition.\r\n     *\r\n     * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.\r\n     *\r\n     * There are also 5 transition related events: This scene will emit the event `transitionout` when\r\n     * the transition begins, which is typically the frame after calling this method.\r\n     *\r\n     * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.\r\n     * It will then emit the event `transitionstart` when its `create` method is called.\r\n     * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,\r\n     * as the Scenes `init` and `create` methods are not invoked when a Scene wakes up.\r\n     *\r\n     * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.\r\n     * These events are cleared of all listeners when the Scene shuts down, but not if it is sent to sleep.\r\n     *\r\n     * It's important to understand that the duration of the transition begins the moment you call this method.\r\n     * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the\r\n     * time still counts down even while that is happening. If the game itself pauses, or something else causes\r\n     * this Scenes update loop to stop, then the transition will also pause for that duration. There are\r\n     * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to\r\n     * override this understand that until the target Scene completes it might never be unlocked for input events.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#transition\r\n     * @fires Phaser.Scenes.Events#TRANSITION_OUT\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Types.Scenes.SceneTransitionConfig} config - The transition configuration object.\r\n     *\r\n     * @return {boolean} `true` is the transition was started, otherwise `false`.\r\n     */\r\n    transition: function (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        var key = GetFastValue(config, 'target', false);\r\n\r\n        var target = this.manager.getScene(key);\r\n\r\n        if (!key || !this.checkValidTransition(target))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var duration = GetFastValue(config, 'duration', 1000);\r\n\r\n        this._elapsed = 0;\r\n        this._target = target;\r\n        this._duration = duration;\r\n        this._willSleep = GetFastValue(config, 'sleep', false);\r\n        this._willRemove = GetFastValue(config, 'remove', false);\r\n\r\n        var callback = GetFastValue(config, 'onUpdate', null);\r\n\r\n        if (callback)\r\n        {\r\n            this._onUpdate = callback;\r\n            this._onUpdateScope = GetFastValue(config, 'onUpdateScope', this.scene);\r\n        }\r\n\r\n        var allowInput = GetFastValue(config, 'allowInput', false);\r\n\r\n        this.settings.transitionAllowInput = allowInput;\r\n\r\n        var targetSettings = target.sys.settings;\r\n\r\n        targetSettings.isTransition = true;\r\n        targetSettings.transitionFrom = this.scene;\r\n        targetSettings.transitionDuration = duration;\r\n        targetSettings.transitionAllowInput = allowInput;\r\n\r\n        if (GetFastValue(config, 'moveAbove', false))\r\n        {\r\n            this.manager.moveAbove(this.key, key);\r\n        }\r\n        else if (GetFastValue(config, 'moveBelow', false))\r\n        {\r\n            this.manager.moveBelow(this.key, key);\r\n        }\r\n\r\n        if (target.sys.isSleeping())\r\n        {\r\n            target.sys.wake(GetFastValue(config, 'data'));\r\n        }\r\n        else\r\n        {\r\n            this.manager.start(key, GetFastValue(config, 'data'));\r\n        }\r\n\r\n        this.systems.events.emit(Events.TRANSITION_OUT, target, duration);\r\n\r\n        this.systems.events.on(Events.UPDATE, this.step, this);\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if this Scene can transition to the target Scene or not.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#checkValidTransition\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {Phaser.Scene} target - The Scene to test against.\r\n     *\r\n     * @return {boolean} `true` if this Scene can transition, otherwise `false`.\r\n     */\r\n    checkValidTransition: function (target)\r\n    {\r\n        //  Not a valid target if it doesn't exist, isn't active or is already transitioning in or out\r\n        if (!target || target.sys.isActive() || target.sys.isTransitioning() || target === this.scene || this.systems.isTransitioning())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * A single game step. This is only called if the parent Scene is transitioning\r\n     * out to another Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#step\r\n     * @private\r\n     * @since 3.5.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        this._elapsed += delta;\r\n\r\n        this.transitionProgress = Clamp(this._elapsed / this._duration, 0, 1);\r\n\r\n        if (this._onUpdate)\r\n        {\r\n            this._onUpdate.call(this._onUpdateScope, this.transitionProgress);\r\n        }\r\n\r\n        if (this._elapsed >= this._duration)\r\n        {\r\n            this.transitionComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by `step` when the transition out of this scene to another is over.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#transitionComplete\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#TRANSITION_COMPLETE\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        var targetSys = this._target.sys;\r\n        var targetSettings = this._target.sys.settings;\r\n\r\n        //  Stop the step\r\n        this.systems.events.off(Events.UPDATE, this.step, this);\r\n\r\n        //  Notify target scene\r\n        targetSys.events.emit(Events.TRANSITION_COMPLETE, this.scene);\r\n\r\n        //  Clear target scene settings\r\n        targetSettings.isTransition = false;\r\n        targetSettings.transitionFrom = null;\r\n\r\n        //  Clear local settings\r\n        this._duration = 0;\r\n        this._target = null;\r\n        this._onUpdate = null;\r\n        this._onUpdateScope = null;\r\n\r\n        //  Now everything is clear we can handle what happens to this Scene\r\n        if (this._willRemove)\r\n        {\r\n            this.manager.remove(this.key);\r\n        }\r\n        else if (this._willSleep)\r\n        {\r\n            this.systems.sleep();\r\n        }\r\n        else\r\n        {\r\n            this.manager.stop(this.key);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as `Scene.settings.data` and passed to `Scene.init`, and `Scene.create`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        return this.manager.add(key, sceneConfig, autoStart, data);\r\n    },\r\n\r\n    /**\r\n     * Launch the given Scene and run it in parallel with this one.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#launch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to launch.\r\n     * @param {object} [data] - The Scene data.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    launch: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('start', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene, but does not change the state of this Scene.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene and emitted in its ready, wake, or resume events.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        if (key && key !== this.key)\r\n        {\r\n            this.manager.queueOp('run', key, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Pause the Scene - this stops the update step from happening but it still renders.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its pause event.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('pause', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resume the Scene - starts the update loop again.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its resume event.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('resume', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene sleep (no update, no render) but doesn't shutdown.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its sleep event.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('sleep', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes the Scene wake-up (starts update and render)\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted in its wake event.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('wake', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Makes this Scene sleep then starts the Scene given.\r\n     *\r\n     * This will happen at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to start.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    switch: function (key)\r\n    {\r\n        if (key !== this.key)\r\n        {\r\n            this.manager.queueOp('switch', this.key, key);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shutdown the Scene, clearing display list, timers, etc.\r\n     *\r\n     * This happens at the next Scene Manager update, not immediately.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to stop.\r\n     * @param {any} [data] - Optional data object to pass to Scene.Systems.shutdown.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    stop: function (key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.queueOp('stop', key, data);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the active state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - If `true` the Scene will be resumed. If `false` it will be paused.\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to set the active state of.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted with its events.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    setActive: function (value, key, data)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setActive(value, data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visible state of the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible value.\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to set the visible state for.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    setVisible: function (value, key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        var scene = this.manager.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.setVisible(value);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is sleeping or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping, or `null` if no matching Scene was found.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isSleeping(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is running or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is running, or `null` if no matching Scene was found.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isActive(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is paused or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isPaused\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is paused, or `null` if no matching Scene was found.\r\n     */\r\n    isPaused: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isPaused(key);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Scene is visible or not?\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible, or `null` if no matching Scene was found.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.isVisible(key);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#swapPosition\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} [keyB] - The second Scene to swap. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.swapPosition(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved to be above.\r\n     * @param {(string|Phaser.Scene)} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveAbove(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.\r\n     *\r\n     * This controls the order in which they are rendered and updated.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved to be below.\r\n     * @param {(string|Phaser.Scene)} [keyB] - The Scene to be moved. If none is given it defaults to this Scene.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyB === undefined) { keyB = this.key; }\r\n\r\n        if (keyA !== keyB)\r\n        {\r\n            this.manager.moveBelow(keyA, keyB);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to be removed.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.remove(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveUp(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.moveDown(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.bringToTop(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to move.\r\n     *\r\n     * @return {this} This Scene Plugin instance.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        this.manager.sendToBack(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieve a Scene.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to retrieve.\r\n     *\r\n     * @return {Phaser.Scene} The Scene.\r\n     */\r\n    get: function (key)\r\n    {\r\n        return this.manager.getScene(key);\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#getIndex\r\n     * @since 3.7.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} [key] - The Scene to get the index of.\r\n     *\r\n     * @return {number} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        if (key === undefined) { key = this.key; }\r\n\r\n        return this.manager.getIndex(key);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(Events.SHUTDOWN, this.shutdown, this);\r\n        eventEmitter.off(Events.POST_UPDATE, this.step, this);\r\n        eventEmitter.off(Events.TRANSITION_OUT);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     *\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Scenes.ScenePlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene.sys.events.off(Events.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.settings = null;\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('ScenePlugin', ScenePlugin, 'scenePlugin');\r\n\r\nmodule.exports = ScenePlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Scenes\r\n */\r\n\r\nvar Scene = {\r\n\r\n    Events: require('./events'),\r\n    GetPhysicsPlugins: require('./GetPhysicsPlugins'),\r\n    GetScenePlugins: require('./GetScenePlugins'),\r\n    SceneManager: require('./SceneManager'),\r\n    ScenePlugin: require('./ScenePlugin'),\r\n    Settings: require('./Settings'),\r\n    Systems: require('./Systems')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nScene = Extend(false, Scene, CONST);\r\n\r\nmodule.exports = Scene;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Extends the given `myClass` object's prototype with the properties of `definition`.\r\n *\r\n * @function extend\r\n * @ignore\r\n * @param {Object} ctor The constructor object to mix into.\r\n * @param {Object} definition A dictionary of functions for the class.\r\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\r\n * @param {Object} [extend] The parent constructor object.\r\n */\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Applies the given `mixins` to the prototype of `myClass`.\r\n *\r\n * @function mixin\r\n * @ignore\r\n * @param {Object} myClass The constructor object to mix into.\r\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\r\n */\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class Phaser.Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * A NOOP (No Operation) callback function.\r\n *\r\n * Used internally by Phaser when it's more expensive to determine if a callback exists\r\n * than it is to just invoke an empty function.\r\n *\r\n * @function Phaser.Utils.NOOP\r\n * @since 3.0.0\r\n */\r\nvar NOOP = function ()\r\n{\r\n    //  NOOP\r\n};\r\n\r\nmodule.exports = NOOP;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\r\n *\r\n * @function Phaser.Utils.Objects.GetFastValue\r\n * @since 3.0.0\r\n *\r\n * @param {object} source - The object to search\r\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\r\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\r\n *\r\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\r\n */\r\nvar GetFastValue = function (source, key, defaultValue)\r\n{\r\n    var t = typeof(source);\r\n\r\n    if (!source || t === 'number' || t === 'string')\r\n    {\r\n        return defaultValue;\r\n    }\r\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\r\n    {\r\n        return source[key];\r\n    }\r\n    else\r\n    {\r\n        return defaultValue;\r\n    }\r\n};\r\n\r\nmodule.exports = GetFastValue;\r\n"],"names":["module","exports","BLUR","BOOT","CONTEXT_LOST","CONTEXT_RESTORED","DESTROY","FOCUS","HIDDEN","PAUSE","POST_RENDER","POST_STEP","PRE_RENDER","PRE_STEP","READY","RESUME","STEP","VISIBLE","value","min","max","Math","corePlugins","customPlugins","PluginCache","key","plugin","mapping","custom","undefined","data","hasOwnProperty","Clamp","Class","Events","GetFastValue","ScenePlugin","initialize","scene","this","systems","sys","settings","manager","game","transitionProgress","_elapsed","_target","_duration","_onUpdate","_onUpdateScope","_willSleep","_willRemove","events","once","boot","on","START","pluginStart","destroy","SHUTDOWN","shutdown","start","queueOp","restart","transition","config","target","getScene","checkValidTransition","duration","callback","allowInput","transitionAllowInput","targetSettings","isTransition","transitionFrom","transitionDuration","moveAbove","moveBelow","isSleeping","wake","emit","TRANSITION_OUT","UPDATE","step","isActive","isTransitioning","time","delta","call","transitionComplete","targetSys","off","TRANSITION_COMPLETE","remove","sleep","stop","add","sceneConfig","autoStart","launch","run","pause","resume","switch","setActive","setVisible","isPaused","isVisible","swapPosition","keyA","keyB","moveUp","moveDown","bringToTop","sendToBack","get","getIndex","eventEmitter","POST_UPDATE","register","CONST","Extend","Scene","GetPhysicsPlugins","GetScenePlugins","SceneManager","Settings","Systems","getProperty","definition","k","isClassDescriptor","def","Object","getOwnPropertyDescriptor","set","hasGetterOrSetter","enumerable","configurable","hasNonConfigurable","obj","prop","extend","ctor","prototype","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","length","Extends","base","apply","arguments","create","constructor","Mixins","source","defaultValue","t"],"sourceRoot":""}